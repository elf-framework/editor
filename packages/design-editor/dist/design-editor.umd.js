var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@elf/sapa"), require("@elf/editor"), require("@elf/color")) : typeof define === "function" && define.amd ? define(["exports", "@elf/sapa", "@elf/editor", "@elf/color"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.elf = {}, global2.sapa, global2.editor, global2.color));
})(this, function(exports2, sapa, editor, Color) {
  var _modelManager, _json, _cachedValue, _timestamp, _lastChangedField, _collapsed, _id, _renderers;
  "use strict";
  function _interopNamespace(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var Color__namespace = /* @__PURE__ */ _interopNamespace(Color);
  var index = "";
  var layout$1 = "";
  class ClipboardManager {
    constructor(editor2) {
      this.editor = editor2;
      this.clipboard = [];
    }
    get length() {
      return this.clipboard.length;
    }
    clear() {
      this.clipboard = [];
    }
    get isEmpty() {
      return this.clipboard.length == 0;
    }
    get last() {
      return this.clipboard[this.clipboard.length - 1];
    }
    push(data) {
      this.clipboard.push(data);
    }
    pop() {
      return this.clipboard.pop();
    }
  }
  class HistoryManager {
    constructor(editor2) {
      this.$editor = editor2;
      this.$context = editor2.context;
      this.currentIndex = -1;
      this.undoHistories = [];
      this.redoHistories = [];
      this.selection = {};
    }
    get length() {
      return this.undoHistories.length;
    }
    get selectedIds() {
      return Object.keys(this.selection);
    }
    createCommand(commandString) {
      return this.$context.stateManager.isPointerUp ? `history.${commandString}` : commandString;
    }
    saveSelection(obj2 = {}) {
      this.selection = this.$editor.context.selection.toCloneObject();
    }
    getUndoValues(multiAttrs = {}) {
      let result = {};
      Object.keys(multiAttrs).forEach((id) => {
        result[id] = {};
        const selectedObject = this.selection[id] || this.$editor.context.selection.itemsByIds(id)[0];
        const attrs = multiAttrs[id];
        Object.keys(attrs).forEach((key) => {
          result[id][key] = selectedObject[key];
        });
      });
      return result;
    }
    add(message, command, data) {
      const time = window.performance.now();
      const lastUndoObject = this.undoHistories[this.undoHistories.length - 1];
      const historyObject = { message, command, data, time };
      if (lastUndoObject && lastUndoObject.message === message && time - lastUndoObject.time < this.$editor.context.config.get("history.delay.ms")) {
        this.undoHistories[this.undoHistories.length - 1] = historyObject;
      } else {
        this.undoHistories.push(historyObject);
        this.currentIndex++;
        this.undoHistories.length = this.currentIndex + 1;
      }
      this.$context.commands.emit("refreshHistory", command.command);
      this.$editor.emit("refreshHistoryList");
      return historyObject;
    }
    map(callback) {
      let results = [
        ...this.undoHistories.map(callback),
        "-",
        ...this.redoHistories.map(callback)
      ].reverse();
      return results;
    }
    undo() {
      if (this.currentIndex < -1)
        return;
      if (this.currentIndex === this.length) {
        this.currentIndex--;
      }
      const commandObject = this.undoHistories[this.currentIndex];
      if (commandObject && commandObject.command) {
        commandObject.command.undo(this.$editor, commandObject.data);
        this.currentIndex--;
        this.$editor.nextTick(() => {
          this.$context.commands.emit("refreshHistory", commandObject.command);
          this.$editor.emit("refreshHistoryList");
        });
      }
    }
    redo() {
      if (this.currentIndex > this.length)
        return;
      if (this.currentIndex < 0) {
        this.currentIndex++;
      }
      const commandObject = this.undoHistories[this.currentIndex];
      if (commandObject && commandObject.command) {
        this.currentIndex++;
        commandObject.command.redo(this.$editor, commandObject.data);
        this.$editor.debug(commandObject);
        this.$editor.nextTick(() => {
          this.$context.commands.emit("refreshHistory", commandObject.command);
          this.$editor.emit("refreshHistoryList");
        });
      }
    }
  }
  class LockManager {
    constructor(editor2) {
      this.editor = editor2;
      this.lockList = {};
    }
    get(key) {
      return this.lockList[key];
    }
    set(key, value) {
      this.lockList[key] = true;
    }
    toggle(key) {
      if (this.lockList[key]) {
        delete this.lockList[key];
      } else {
        this.lockList[key] = true;
      }
    }
  }
  const identity$3 = () => true;
  class ModelManager {
    constructor(editor2) {
      this.editor = editor2;
      this.context = this.editor.context;
      this.version = "0.0.0";
      this.name = "";
      this.description = "";
      this.items = /* @__PURE__ */ new Map();
      this.projects = [];
    }
    load(doc = void 0, context = { origin: "*" }) {
      var _a;
      const newDoc = doc || this.editor.loadItem("model");
      this.items.clear();
      this.version = newDoc == null ? void 0 : newDoc.version;
      this.name = newDoc == null ? void 0 : newDoc.name;
      this.description = newDoc == null ? void 0 : newDoc.description;
      (_a = newDoc == null ? void 0 : newDoc.projects) == null ? void 0 : _a.forEach((project2) => {
        this.createModel(project2);
      });
      if (this.projects.length === 0) {
        this.createProject();
      }
    }
    createProject() {
      this.createModel({
        itemType: "project",
        name: "New Project"
      });
    }
    getProjectByIndex(index2 = 0) {
      return this.get(this.projects[index2]);
    }
    get(id) {
      return this.items.get(id);
    }
    set(id, item) {
      this.items.set(id, item);
      this.setChanged("set", id, item);
    }
    remove(id) {
      const obj2 = this.items.get(id);
      const children = obj2.parent.children;
      const index2 = children.indexOf(id);
      obj2.reset({
        removed: true,
        removedIndex: index2,
        removedLeftSibling: index2 > 0 ? children[index2 - 1] : null,
        removedRightSibling: index2 < children.length - 1 ? children[index2 + 1] : null
      });
      this.setChanged("remove", id);
    }
    recover(id) {
      const obj2 = this.items.get(id);
      const parent = this.getParent(id);
      if (!obj2.get("removedLeftSibling") && obj2.get("removedRightSibling")) {
        parent.children.splice(parent.children.findIndex(() => obj2.get("removedRightSibling")) - 1, 0, id);
      } else if (obj2.get("removedLeftSibling") && !obj2.get("removedRightSibling")) {
        parent.children.splice(parent.children.findIndex(() => obj2.get("removedLeftSibling")) + 1, 0, id);
      } else {
        parent.children.splice(obj2.get("removedIndex"), 0, id);
      }
      obj2.removeField("removed");
      obj2.removeField("removedLeftSibling");
      obj2.removeField("removedRightSibling");
      obj2.removeField("removedIndex");
      this.setChanged("recover", id);
    }
    clear() {
      this.items.clear();
    }
    toJSON() {
      return {
        version: this.version,
        name: this.name,
        description: this.description,
        projects: this.projects.map((id) => {
          return this.get(id).toJSON();
        })
      };
    }
    setChanged(type, id, obj2) {
      this.editor.emit("changed", type, id, obj2);
    }
    removeChild(rootId, childId) {
      const obj2 = this.get(rootId);
      obj2.reset({
        children: obj2.children.filter((it) => it !== childId)
      });
      this.setChanged("removeChild", rootId, { childId });
    }
    get components() {
      return this.context.components;
    }
    searchItem(id) {
      return this.get(id);
    }
    searchLayers(rootId, childId) {
      const obj2 = this.get(rootId);
      return this.get(obj2.children.find((it) => it === childId));
    }
    searchItemsById(ids) {
      return ids.map((id) => this.get(id));
    }
    findGroupItem(rootId) {
      const obj2 = this.get(rootId);
      if (obj2.hasChildren()) {
        return obj2;
      }
      if (obj2.parent && (obj2.parent.is("project") || obj2.parent.is("artboard") || obj2.isBooleanItem)) {
        return obj2;
      }
      return obj2.parent && this.findGroupItem(obj2.parentId);
    }
    convertGroupItems(items) {
      const objectList = {};
      items.forEach((item) => {
        if (item.parent && item.isNot("project") && item.parent.hasLayout()) {
          const groupItem = item.parent;
          objectList[groupItem.id] = groupItem;
        } else {
          const groupItem = this.findGroupItem(item.id) || item;
          objectList[groupItem.id] = groupItem;
        }
      });
      return Object.values(objectList).filter((it) => it.isNot("project"));
    }
    searchLiveItemsById(ids) {
      return ids.map((id) => this.get(id)).filter((it) => !it.removed);
    }
    markRemove(ids = []) {
      ids.forEach((id) => {
        this.remove(id);
      });
      this.setChanged("markRemove", ids, { isLayer: true });
    }
    markRemoveProject(id) {
      const index2 = this.projects.findIndex((it) => it === id);
      this.projects.splice(index2, 1);
      this.get(id).removed = true;
      this.setChanged("markRemoveProject", [id], { isProject: true });
      return index2;
    }
    unmarkRemove(ids = []) {
      ids.forEach((id) => {
        this.recover(id);
      });
      this.setChanged("unmarkRemove", ids, { isLayer: true });
    }
    unmarkRemoveProject(id, index2) {
      this.projects.splice(index2, 0, id);
      this.get(id).removed = false;
      this.setChanged("unmarkRemoveProject", [id], {
        removed: true,
        isProject: true
      });
    }
    createModel(itemObject, isRegister = true, context = { origin: "*" }) {
      const layers = itemObject.layers;
      delete itemObject.layers;
      let item;
      if (this.get(itemObject.id)) {
        item = this.get(itemObject.id);
        item.reset(itemObject);
      } else {
        item = this.components.createComponent(itemObject.itemType, __spreadValues({}, itemObject));
        item.setModelManager(this);
      }
      if (isRegister) {
        this.set(item.id, item);
        if (item.is("project")) {
          this.projects = [.../* @__PURE__ */ new Set([...this.projects, item.id])];
        }
      }
      const children = (layers || []).map((it) => {
        return this.createModel(__spreadProps(__spreadValues({}, it), { parentId: item.id }), true, context);
      });
      if (children.length) {
        item.reset({
          children: children.map((it) => {
            return it.id;
          })
        }, context);
      }
      return item;
    }
    getAllLayers(rootId, filterCallback = identity$3) {
      var results = [];
      const obj2 = this.get(rootId);
      let len2 = obj2.children.length;
      for (let start = len2; start--; ) {
        let id = obj2.children[start];
        results.push(...this.getAllLayers(id, filterCallback));
      }
      if (sapa.isFunction(filterCallback) && filterCallback(obj2)) {
        results.push(obj2);
      }
      return results;
    }
    getLayers(rootId) {
      var _a;
      const obj2 = this.get(rootId);
      return ((_a = obj2 == null ? void 0 : obj2.children) == null ? void 0 : _a.map((childId) => this.get(childId))) || [];
    }
    eachLayers(rootId, callback) {
      const obj2 = this.get(rootId);
      let len2 = obj2.children.length;
      for (let start = len2; start--; ) {
        let id = obj2.children[start];
        callback(this.get(id));
      }
    }
    mapLayers(rootId, callback) {
      const obj2 = this.get(rootId);
      return obj2.children.map((childId) => {
        return callback(this.get(childId));
      });
    }
    getParent(rootId) {
      var _a;
      return this.get((_a = this.get(rootId)) == null ? void 0 : _a.parentId);
    }
    getDepth(rootId) {
      const parent = this.getParent(rootId);
      if (!parent)
        return 1;
      return this.getDepth(parent.id) + 1;
    }
    getPath(rootId, defaultRef = null) {
      const obj2 = this.get(rootId) || defaultRef;
      const parent = this.getParent(rootId);
      if (!parent)
        return [obj2];
      const list = this.getPath(parent.id);
      list.push(obj2);
      return list;
    }
    clone(rootId, isDeep = true) {
      const obj2 = this.get(rootId);
      const json = obj2.toCloneObject(isDeep);
      const item = this.createModel(json);
      item.setParentId(obj2.parentId);
      return item;
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var a = Object.defineProperty({}, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var pathkit = { exports: {} };
  var __viteBrowserExternal = {};
  var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  (function(module2, exports3) {
    var PathKitInit2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(PathKitInit3) {
        PathKitInit3 = PathKitInit3 || {};
        var d;
        d || (d = typeof PathKitInit3 !== "undefined" ? PathKitInit3 : {});
        var aa;
        d.ready = new Promise(function(a) {
          aa = a;
        });
        (function(a) {
          var b = {};
          a.loadCmdsTypedArray = function(h) {
            for (var k = 0, l = 0; l < h.length; l++)
              k += h[l].length;
            if (b[k])
              var n = b[k];
            else
              n = new Float32Array(k), b[k] = n;
            var p = 0;
            for (l = 0; l < h.length; l++)
              for (var q = 0; q < h[l].length; q++) {
                var t = h[l][q];
                typeof t === "string" && (t = a.SkBits2FloatUnsigned(parseInt(t)));
                n[p] = t;
                p++;
              }
            h = a._malloc(n.length * n.BYTES_PER_ELEMENT);
            a.HEAPF32.set(n, h / n.BYTES_PER_ELEMENT);
            return [h, k];
          };
          a.FromCmds = function(h) {
            h = a.loadCmdsTypedArray(h);
            var k = a._FromCmds(h[0], h[1]);
            a._free(h[0]);
            return k;
          };
          var c, e, f, g, m;
          a.cubicYFromX = function(h, k, l, n, p) {
            c && e === h && f === k && g === l && m === n || (c && c.delete(), c = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
            return c.computeYFromX(p);
          };
          a.cubicPtFromT = function(h, k, l, n, p) {
            c && e === h && f === k && g === l && m === n || (c && c.delete(), c = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
            return c.computePtFromT(p);
          };
        })(d);
        (function(a) {
          a.onRuntimeInitialized = function() {
            a.SkPath.prototype.addPath = function() {
              var b = arguments[0];
              if (arguments.length === 1)
                this._addPath(b, 1, 0, 0, 0, 1, 0, 0, 0, 1);
              else if (arguments.length === 2) {
                var c = arguments[1];
                this._addPath(b, c.a, c.c, c.e, c.b, c.d, c.f, 0, 0, 1);
              } else if (arguments.length === 7)
                c = arguments, this._addPath(b, c[1], c[3], c[5], c[2], c[4], c[6], 0, 0, 1);
              else if (arguments.length === 10)
                c = arguments, this._addPath(b, c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9]);
              else
                return console.Fb("addPath expected to take 1, 2, 7, or 10 args. Got " + arguments.length), null;
              return this;
            };
            a.SkPath.prototype.arc = function(b, c, e, f, g, m) {
              this._arc(b, c, e, f, g, !!m);
              return this;
            };
            a.SkPath.prototype.arcTo = function(b, c, e, f, g) {
              this._arcTo(b, c, e, f, g);
              return this;
            };
            a.SkPath.prototype.bezierCurveTo = function(b, c, e, f, g, m) {
              this._cubicTo(b, c, e, f, g, m);
              return this;
            };
            a.SkPath.prototype.close = function() {
              this._close();
              return this;
            };
            a.SkPath.prototype.closePath = function() {
              this._close();
              return this;
            };
            a.SkPath.prototype.conicTo = function(b, c, e, f, g) {
              this._conicTo(b, c, e, f, g);
              return this;
            };
            a.SkPath.prototype.cubicTo = function(b, c, e, f, g, m) {
              this._cubicTo(b, c, e, f, g, m);
              return this;
            };
            a.SkPath.prototype.dash = function(b, c, e) {
              return this._dash(b, c, e) ? this : null;
            };
            a.SkPath.prototype.ellipse = function(b, c, e, f, g, m, h, k) {
              this._ellipse(b, c, e, f, g, m, h, !!k);
              return this;
            };
            a.SkPath.prototype.lineTo = function(b, c) {
              this._lineTo(b, c);
              return this;
            };
            a.SkPath.prototype.moveTo = function(b, c) {
              this._moveTo(b, c);
              return this;
            };
            a.SkPath.prototype.op = function(b, c) {
              return this._op(b, c) ? this : null;
            };
            a.SkPath.prototype.quadraticCurveTo = function(b, c, e, f) {
              this._quadTo(b, c, e, f);
              return this;
            };
            a.SkPath.prototype.quadTo = function(b, c, e, f) {
              this._quadTo(b, c, e, f);
              return this;
            };
            a.SkPath.prototype.rect = function(b, c, e, f) {
              this._rect(b, c, e, f);
              return this;
            };
            a.SkPath.prototype.simplify = function() {
              return this._simplify() ? this : null;
            };
            a.SkPath.prototype.stroke = function(b) {
              b = b || {};
              b.width = b.width || 1;
              b.miter_limit = b.miter_limit || 4;
              b.cap = b.cap || a.StrokeCap.BUTT;
              b.join = b.join || a.StrokeJoin.MITER;
              return this._stroke(b) ? this : null;
            };
            a.SkPath.prototype.transform = function() {
              if (arguments.length === 1)
                this._transform(arguments[0]);
              else if (arguments.length === 9) {
                var b = arguments;
                this._transform(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
              } else
                return console.Fb("transform expected to take 1 or 9 arguments. Got " + arguments.length), null;
              return this;
            };
            a.SkPath.prototype.trim = function(b, c, e) {
              return this._trim(b, c, !!e) ? this : null;
            };
          };
        })(d);
        var r = {}, v;
        for (v in d)
          d.hasOwnProperty(v) && (r[v] = d[v]);
        var ba = false, w = false, ca = false, da = false;
        ba = typeof window === "object";
        w = typeof importScripts === "function";
        ca = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        da = !ba && !ca && !w;
        var x = "", ea, fa, ha, ia;
        if (ca)
          x = w ? require$$0.dirname(x) + "/" : __dirname + "/", ea = function(a, b) {
            ha || (ha = require$$0);
            ia || (ia = require$$0);
            a = ia.normalize(a);
            return ha.readFileSync(a, b ? null : "utf8");
          }, fa = function(a) {
            a = ea(a, true);
            a.buffer || (a = new Uint8Array(a));
            assert(a.buffer);
            return a;
          }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
            throw a;
          }), process.on("unhandledRejection", y), d.inspect = function() {
            return "[Emscripten Module object]";
          };
        else if (da)
          typeof read != "undefined" && (ea = function(a) {
            return read(a);
          }), fa = function(a) {
            if (typeof readbuffer === "function")
              return new Uint8Array(readbuffer(a));
            a = read(a, "binary");
            assert(typeof a === "object");
            return a;
          }, typeof print !== "undefined" && (typeof console === "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr !== "undefined" ? printErr : print);
        else if (ba || w)
          w ? x = self.location.href : document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), x.indexOf("blob:") !== 0 ? x = x.substr(0, x.lastIndexOf("/") + 1) : x = "", ea = function(a) {
            var b = new XMLHttpRequest();
            b.open("GET", a, false);
            b.send(null);
            return b.responseText;
          }, w && (fa = function(a) {
            var b = new XMLHttpRequest();
            b.open("GET", a, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          });
        var ja = d.print || console.log.bind(console), z = d.printErr || console.warn.bind(console);
        for (v in r)
          r.hasOwnProperty(v) && (d[v] = r[v]);
        r = null;
        var ka;
        d.wasmBinary && (ka = d.wasmBinary);
        d.noExitRuntime && d.noExitRuntime;
        typeof WebAssembly !== "object" && z("no native wasm support detected");
        var la, ma = new WebAssembly.Table({ initial: 309, maximum: 309, element: "anyfunc" }), na = false;
        function assert(a, b) {
          a || y("Assertion failed: " + b);
        }
        var oa = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function pa(a, b, c) {
          var e = b + c;
          for (c = b; a[c] && !(c >= e); )
            ++c;
          if (16 < c - b && a.subarray && oa)
            return oa.decode(a.subarray(b, c));
          for (e = ""; b < c; ) {
            var f = a[b++];
            if (f & 128) {
              var g = a[b++] & 63;
              if ((f & 224) == 192)
                e += String.fromCharCode((f & 31) << 6 | g);
              else {
                var m = a[b++] & 63;
                f = (f & 240) == 224 ? (f & 15) << 12 | g << 6 | m : (f & 7) << 18 | g << 12 | m << 6 | a[b++] & 63;
                65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
              }
            } else
              e += String.fromCharCode(f);
          }
          return e;
        }
        function qa(a, b, c) {
          var e = B;
          if (0 < c) {
            c = b + c - 1;
            for (var f = 0; f < a.length; ++f) {
              var g = a.charCodeAt(f);
              if (55296 <= g && 57343 >= g) {
                var m = a.charCodeAt(++f);
                g = 65536 + ((g & 1023) << 10) | m & 1023;
              }
              if (127 >= g) {
                if (b >= c)
                  break;
                e[b++] = g;
              } else {
                if (2047 >= g) {
                  if (b + 1 >= c)
                    break;
                  e[b++] = 192 | g >> 6;
                } else {
                  if (65535 >= g) {
                    if (b + 2 >= c)
                      break;
                    e[b++] = 224 | g >> 12;
                  } else {
                    if (b + 3 >= c)
                      break;
                    e[b++] = 240 | g >> 18;
                    e[b++] = 128 | g >> 12 & 63;
                  }
                  e[b++] = 128 | g >> 6 & 63;
                }
                e[b++] = 128 | g & 63;
              }
            }
            e[b] = 0;
          }
        }
        var ra = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
        function sa(a, b) {
          var c = a >> 1;
          for (var e = c + b / 2; !(c >= e) && ta[c]; )
            ++c;
          c <<= 1;
          if (32 < c - a && ra)
            return ra.decode(B.subarray(a, c));
          c = 0;
          for (e = ""; ; ) {
            var f = D[a + 2 * c >> 1];
            if (f == 0 || c == b / 2)
              return e;
            ++c;
            e += String.fromCharCode(f);
          }
        }
        function ua(a, b, c) {
          c === void 0 && (c = 2147483647);
          if (2 > c)
            return 0;
          c -= 2;
          var e = b;
          c = c < 2 * a.length ? c / 2 : a.length;
          for (var f = 0; f < c; ++f)
            D[b >> 1] = a.charCodeAt(f), b += 2;
          D[b >> 1] = 0;
          return b - e;
        }
        function va(a) {
          return 2 * a.length;
        }
        function wa(a, b) {
          for (var c = 0, e = ""; !(c >= b / 4); ) {
            var f = E[a + 4 * c >> 2];
            if (f == 0)
              break;
            ++c;
            65536 <= f ? (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023)) : e += String.fromCharCode(f);
          }
          return e;
        }
        function xa(a, b, c) {
          c === void 0 && (c = 2147483647);
          if (4 > c)
            return 0;
          var e = b;
          c = e + c - 4;
          for (var f = 0; f < a.length; ++f) {
            var g = a.charCodeAt(f);
            if (55296 <= g && 57343 >= g) {
              var m = a.charCodeAt(++f);
              g = 65536 + ((g & 1023) << 10) | m & 1023;
            }
            E[b >> 2] = g;
            b += 4;
            if (b + 4 > c)
              break;
          }
          E[b >> 2] = 0;
          return b - e;
        }
        function ya(a) {
          for (var b = 0, c = 0; c < a.length; ++c) {
            var e = a.charCodeAt(c);
            55296 <= e && 57343 >= e && ++c;
            b += 4;
          }
          return b;
        }
        var za, Aa, B, D, ta, E, F, Ba, Ca, Da = d.INITIAL_MEMORY || 16777216;
        d.wasmMemory ? la = d.wasmMemory : la = new WebAssembly.Memory({ initial: Da / 65536, maximum: Da / 65536 });
        la && (za = la.buffer);
        Da = za.byteLength;
        var G = za;
        za = G;
        d.HEAP8 = Aa = new Int8Array(G);
        d.HEAP16 = D = new Int16Array(G);
        d.HEAP32 = E = new Int32Array(G);
        d.HEAPU8 = B = new Uint8Array(G);
        d.HEAPU16 = ta = new Uint16Array(G);
        d.HEAPU32 = F = new Uint32Array(G);
        d.HEAPF32 = Ba = new Float32Array(G);
        d.HEAPF64 = Ca = new Float64Array(G);
        E[3e3] = 5255040;
        function Ea(a) {
          for (; 0 < a.length; ) {
            var b = a.shift();
            if (typeof b == "function")
              b(d);
            else {
              var c = b.Jb;
              typeof c === "number" ? b.tb === void 0 ? d.dynCall_v(c) : d.dynCall_vi(c, b.tb) : c(b.tb === void 0 ? null : b.tb);
            }
          }
        }
        var Fa = [], Ga = [], Ha = [], Ia = [];
        function Ja() {
          var a = d.preRun.shift();
          Fa.unshift(a);
        }
        var H = 0, La = null;
        d.preloadedImages = {};
        d.preloadedAudios = {};
        function y(a) {
          if (d.onAbort)
            d.onAbort(a);
          ja(a);
          z(a);
          na = true;
          throw new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
        }
        function Ma(a) {
          var b = I;
          return String.prototype.startsWith ? b.startsWith(a) : b.indexOf(a) === 0;
        }
        function Na() {
          return Ma("data:application/octet-stream;base64,");
        }
        var I = "pathkit.wasm";
        if (!Na()) {
          var Oa = I;
          I = d.locateFile ? d.locateFile(Oa, x) : x + Oa;
        }
        function Pa() {
          try {
            if (ka)
              return new Uint8Array(ka);
            if (fa)
              return fa(I);
            throw "both async and sync fetching of the wasm failed";
          } catch (a) {
            y(a);
          }
        }
        function Qa() {
          return ka || !ba && !w || typeof fetch !== "function" || Ma("file://") ? new Promise(function(a) {
            a(Pa());
          }) : fetch(I, { credentials: "same-origin" }).then(function(a) {
            if (!a.ok)
              throw "failed to load wasm binary file at '" + I + "'";
            return a.arrayBuffer();
          }).catch(function() {
            return Pa();
          });
        }
        Ga.push({ Jb: function() {
          Ra();
        } });
        var Sa = {};
        function Ta(a) {
          for (; a.length; ) {
            var b = a.pop();
            a.pop()(b);
          }
        }
        function J(a) {
          return this.fromWireType(F[a >> 2]);
        }
        var K = {}, L = {}, Ua = {};
        function Va(a) {
          if (a === void 0)
            return "_unknown";
          a = a.replace(/[^a-zA-Z0-9_]/g, "$");
          var b = a.charCodeAt(0);
          return 48 <= b && 57 >= b ? "_" + a : a;
        }
        function Wa(a, b) {
          a = Va(a);
          return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
        }
        function Xa(a) {
          var b = Error, c = Wa(a, function(e) {
            this.name = a;
            this.message = e;
            e = Error(e).stack;
            e !== void 0 && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c.prototype = Object.create(b.prototype);
          c.prototype.constructor = c;
          c.prototype.toString = function() {
            return this.message === void 0 ? this.name : this.name + ": " + this.message;
          };
          return c;
        }
        var Ya = void 0;
        function Za(a) {
          throw new Ya(a);
        }
        function N(a, b, c) {
          function e(h) {
            h = c(h);
            h.length !== a.length && Za("Mismatched type converter count");
            for (var k = 0; k < a.length; ++k)
              O(a[k], h[k]);
          }
          a.forEach(function(h) {
            Ua[h] = b;
          });
          var f = Array(b.length), g = [], m = 0;
          b.forEach(function(h, k) {
            L.hasOwnProperty(h) ? f[k] = L[h] : (g.push(h), K.hasOwnProperty(h) || (K[h] = []), K[h].push(function() {
              f[k] = L[h];
              ++m;
              m === g.length && e(f);
            }));
          });
          g.length === 0 && e(f);
        }
        var $a = {};
        function ab(a) {
          switch (a) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + a);
          }
        }
        var bb = void 0;
        function P(a) {
          for (var b = ""; B[a]; )
            b += bb[B[a++]];
          return b;
        }
        var Q = void 0;
        function R(a) {
          throw new Q(a);
        }
        function O(a, b, c) {
          c = c || {};
          if (!("argPackAdvance" in b))
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          var e = b.name;
          a || R('type "' + e + '" must have a positive integer typeid pointer');
          if (L.hasOwnProperty(a)) {
            if (c.Mb)
              return;
            R("Cannot register type '" + e + "' twice");
          }
          L[a] = b;
          delete Ua[a];
          K.hasOwnProperty(a) && (b = K[a], delete K[a], b.forEach(function(f) {
            f();
          }));
        }
        function cb(a) {
          return { count: a.count, lb: a.lb, nb: a.nb, bb: a.bb, cb: a.cb, gb: a.gb, ib: a.ib };
        }
        function db(a) {
          R(a.$a.cb.ab.name + " instance already deleted");
        }
        var eb = false;
        function fb() {
        }
        function gb(a) {
          --a.count.value;
          a.count.value === 0 && (a.gb ? a.ib.hb(a.gb) : a.cb.ab.hb(a.bb));
        }
        function hb(a) {
          if (typeof FinalizationGroup === "undefined")
            return hb = function(b) {
              return b;
            }, a;
          eb = new FinalizationGroup(function(b) {
            for (var c = b.next(); !c.done; c = b.next())
              c = c.value, c.bb ? gb(c) : console.warn("object already deleted: " + c.bb);
          });
          hb = function(b) {
            eb.register(b, b.$a, b.$a);
            return b;
          };
          fb = function(b) {
            eb.unregister(b.$a);
          };
          return hb(a);
        }
        var ib = void 0, jb = [];
        function kb() {
          for (; jb.length; ) {
            var a = jb.pop();
            a.$a.lb = false;
            a["delete"]();
          }
        }
        function S() {
        }
        var lb = {};
        function mb(a, b, c) {
          if (a[b].eb === void 0) {
            var e = a[b];
            a[b] = function() {
              a[b].eb.hasOwnProperty(arguments.length) || R("Function '" + c + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].eb + ")!");
              return a[b].eb[arguments.length].apply(this, arguments);
            };
            a[b].eb = [];
            a[b].eb[e.qb] = e;
          }
        }
        function nb(a, b, c) {
          d.hasOwnProperty(a) ? ((c === void 0 || d[a].eb !== void 0 && d[a].eb[c] !== void 0) && R("Cannot register public name '" + a + "' twice"), mb(d, a, a), d.hasOwnProperty(c) && R("Cannot register multiple overloads of a function with the same number of arguments (" + c + ")!"), d[a].eb[c] = b) : (d[a] = b, c !== void 0 && (d[a].Sb = c));
        }
        function ob(a, b, c, e, f, g, m, h) {
          this.name = a;
          this.constructor = b;
          this.mb = c;
          this.hb = e;
          this.jb = f;
          this.Kb = g;
          this.pb = m;
          this.Hb = h;
          this.Pb = [];
        }
        function pb(a, b, c) {
          for (; b !== c; )
            b.pb || R("Expected null or instance of " + c.name + ", got an instance of " + b.name), a = b.pb(a), b = b.jb;
          return a;
        }
        function qb(a, b) {
          if (b === null)
            return this.xb && R("null is not a valid " + this.name), 0;
          b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
          b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
          return pb(b.$a.bb, b.$a.cb.ab, this.ab);
        }
        function rb(a, b) {
          if (b === null) {
            this.xb && R("null is not a valid " + this.name);
            if (this.sb) {
              var c = this.ob();
              a !== null && a.push(this.hb, c);
              return c;
            }
            return 0;
          }
          b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
          b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
          !this.rb && b.$a.cb.rb && R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
          c = pb(b.$a.bb, b.$a.cb.ab, this.ab);
          if (this.sb)
            switch (b.$a.gb === void 0 && R("Passing raw pointer to smart pointer is illegal"), this.Rb) {
              case 0:
                b.$a.ib === this ? c = b.$a.gb : R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
                break;
              case 1:
                c = b.$a.gb;
                break;
              case 2:
                if (b.$a.ib === this)
                  c = b.$a.gb;
                else {
                  var e = b.clone();
                  c = this.Qb(c, V(function() {
                    e["delete"]();
                  }));
                  a !== null && a.push(this.hb, c);
                }
                break;
              default:
                R("Unsupporting sharing policy");
            }
          return c;
        }
        function sb(a, b) {
          if (b === null)
            return this.xb && R("null is not a valid " + this.name), 0;
          b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
          b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
          b.$a.cb.rb && R("Cannot convert argument of type " + b.$a.cb.name + " to parameter type " + this.name);
          return pb(b.$a.bb, b.$a.cb.ab, this.ab);
        }
        function tb(a, b, c) {
          if (b === c)
            return a;
          if (c.jb === void 0)
            return null;
          a = tb(a, b, c.jb);
          return a === null ? null : c.Hb(a);
        }
        var ub = {};
        function vb(a, b) {
          for (b === void 0 && R("ptr should not be undefined"); a.jb; )
            b = a.pb(b), a = a.jb;
          return ub[b];
        }
        function wb(a, b) {
          b.cb && b.bb || Za("makeClassHandle requires ptr and ptrType");
          !!b.ib !== !!b.gb && Za("Both smartPtrType and smartPtr must be specified");
          b.count = { value: 1 };
          return hb(Object.create(a, { $a: { value: b } }));
        }
        function W(a, b, c, e) {
          this.name = a;
          this.ab = b;
          this.xb = c;
          this.rb = e;
          this.sb = false;
          this.hb = this.Qb = this.ob = this.Eb = this.Rb = this.Ob = void 0;
          b.jb !== void 0 ? this.toWireType = rb : (this.toWireType = e ? qb : sb, this.fb = null);
        }
        function xb(a, b, c) {
          d.hasOwnProperty(a) || Za("Replacing nonexistant public symbol");
          d[a].eb !== void 0 && c !== void 0 ? d[a].eb[c] = b : (d[a] = b, d[a].qb = c);
        }
        function X(a, b) {
          a = P(a);
          var c = d["dynCall_" + a];
          for (var e = [], f = 1; f < a.length; ++f)
            e.push("a" + f);
          f = "return function dynCall_" + (a + "_" + b) + "(" + e.join(", ") + ") {\n";
          f += "    return dynCall(rawFunction" + (e.length ? ", " : "") + e.join(", ") + ");\n";
          c = new Function("dynCall", "rawFunction", f + "};\n")(c, b);
          typeof c !== "function" && R("unknown function pointer with signature " + a + ": " + b);
          return c;
        }
        var yb = void 0;
        function zb(a) {
          a = Ab(a);
          var b = P(a);
          Y(a);
          return b;
        }
        function Db(a, b) {
          function c(g) {
            f[g] || L[g] || (Ua[g] ? Ua[g].forEach(c) : (e.push(g), f[g] = true));
          }
          var e = [], f = {};
          b.forEach(c);
          throw new yb(a + ": " + e.map(zb).join([", "]));
        }
        function Eb(a, b) {
          for (var c = [], e = 0; e < a; e++)
            c.push(E[(b >> 2) + e]);
          return c;
        }
        function Fb(a) {
          var b = Function;
          if (!(b instanceof Function))
            throw new TypeError("new_ called with constructor type " + typeof b + " which is not a function");
          var c = Wa(b.name || "unknownFunctionName", function() {
          });
          c.prototype = b.prototype;
          c = new c();
          a = b.apply(c, a);
          return a instanceof Object ? a : c;
        }
        function Gb(a, b, c, e, f) {
          var g = b.length;
          2 > g && R("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var m = b[1] !== null && c !== null, h = false;
          for (c = 1; c < b.length; ++c)
            if (b[c] !== null && b[c].fb === void 0) {
              h = true;
              break;
            }
          var k = b[0].name !== "void", l = "", n = "";
          for (c = 0; c < g - 2; ++c)
            l += (c !== 0 ? ", " : "") + "arg" + c, n += (c !== 0 ? ", " : "") + "arg" + c + "Wired";
          a = "return function " + Va(a) + "(" + l + ") {\nif (arguments.length !== " + (g - 2) + ") {\nthrowBindingError('function " + a + " called with ' + arguments.length + ' arguments, expected " + (g - 2) + " args!');\n}\n";
          h && (a += "var destructors = [];\n");
          var p = h ? "destructors" : "null";
          l = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
          e = [R, e, f, Ta, b[0], b[1]];
          m && (a += "var thisWired = classParam.toWireType(" + p + ", this);\n");
          for (c = 0; c < g - 2; ++c)
            a += "var arg" + c + "Wired = argType" + c + ".toWireType(" + p + ", arg" + c + "); // " + b[c + 2].name + "\n", l.push("argType" + c), e.push(b[c + 2]);
          m && (n = "thisWired" + (0 < n.length ? ", " : "") + n);
          a += (k ? "var rv = " : "") + "invoker(fn" + (0 < n.length ? ", " : "") + n + ");\n";
          if (h)
            a += "runDestructors(destructors);\n";
          else
            for (c = m ? 1 : 2; c < b.length; ++c)
              g = c === 1 ? "thisWired" : "arg" + (c - 2) + "Wired", b[c].fb !== null && (a += g + "_dtor(" + g + "); // " + b[c].name + "\n", l.push(g + "_dtor"), e.push(b[c].fb));
          k && (a += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
          l.push(a + "}\n");
          return Fb(l).apply(null, e);
        }
        var Hb = [], Z = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function Ib(a) {
          4 < a && --Z[a].yb === 0 && (Z[a] = void 0, Hb.push(a));
        }
        function V(a) {
          switch (a) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              var b = Hb.length ? Hb.pop() : Z.length;
              Z[b] = { yb: 1, value: a };
              return b;
          }
        }
        function Jb(a, b, c) {
          switch (b) {
            case 0:
              return function(e) {
                return this.fromWireType((c ? Aa : B)[e]);
              };
            case 1:
              return function(e) {
                return this.fromWireType((c ? D : ta)[e >> 1]);
              };
            case 2:
              return function(e) {
                return this.fromWireType((c ? E : F)[e >> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + a);
          }
        }
        function Kb(a, b) {
          var c = L[a];
          c === void 0 && R(b + " has unknown type " + zb(a));
          return c;
        }
        function U(a) {
          if (a === null)
            return "null";
          var b = typeof a;
          return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
        }
        function Lb(a, b) {
          switch (b) {
            case 2:
              return function(c) {
                return this.fromWireType(Ba[c >> 2]);
              };
            case 3:
              return function(c) {
                return this.fromWireType(Ca[c >> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + a);
          }
        }
        function Mb(a, b, c) {
          switch (b) {
            case 0:
              return c ? function(e) {
                return Aa[e];
              } : function(e) {
                return B[e];
              };
            case 1:
              return c ? function(e) {
                return D[e >> 1];
              } : function(e) {
                return ta[e >> 1];
              };
            case 2:
              return c ? function(e) {
                return E[e >> 2];
              } : function(e) {
                return F[e >> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + a);
          }
        }
        var Nb = {};
        function Ob(a) {
          var b = Nb[a];
          return b === void 0 ? P(a) : b;
        }
        var Pb = [];
        function Qb(a) {
          a || R("Cannot use deleted val. handle = " + a);
          return Z[a].value;
        }
        function Rb() {
          return typeof globalThis === "object" ? globalThis : Function("return this")();
        }
        function Sb(a) {
          var b = Pb.length;
          Pb.push(a);
          return b;
        }
        function Tb(a, b) {
          for (var c = Array(a), e = 0; e < a; ++e)
            c[e] = Kb(E[(b >> 2) + e], "parameter " + e);
          return c;
        }
        var Ub = {}, Vb = [null, [], []];
        Ya = d.InternalError = Xa("InternalError");
        for (var Wb = Array(256), Xb = 0; 256 > Xb; ++Xb)
          Wb[Xb] = String.fromCharCode(Xb);
        bb = Wb;
        Q = d.BindingError = Xa("BindingError");
        S.prototype.isAliasOf = function(a) {
          if (!(this instanceof S && a instanceof S))
            return false;
          var b = this.$a.cb.ab, c = this.$a.bb, e = a.$a.cb.ab;
          for (a = a.$a.bb; b.jb; )
            c = b.pb(c), b = b.jb;
          for (; e.jb; )
            a = e.pb(a), e = e.jb;
          return b === e && c === a;
        };
        S.prototype.clone = function() {
          this.$a.bb || db(this);
          if (this.$a.nb)
            return this.$a.count.value += 1, this;
          var a = hb(Object.create(Object.getPrototypeOf(this), { $a: { value: cb(this.$a) } }));
          a.$a.count.value += 1;
          a.$a.lb = false;
          return a;
        };
        S.prototype["delete"] = function() {
          this.$a.bb || db(this);
          this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
          fb(this);
          gb(this.$a);
          this.$a.nb || (this.$a.gb = void 0, this.$a.bb = void 0);
        };
        S.prototype.isDeleted = function() {
          return !this.$a.bb;
        };
        S.prototype.deleteLater = function() {
          this.$a.bb || db(this);
          this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
          jb.push(this);
          jb.length === 1 && ib && ib(kb);
          this.$a.lb = true;
          return this;
        };
        W.prototype.Lb = function(a) {
          this.Eb && (a = this.Eb(a));
          return a;
        };
        W.prototype.Cb = function(a) {
          this.hb && this.hb(a);
        };
        W.prototype.argPackAdvance = 8;
        W.prototype.readValueFromPointer = J;
        W.prototype.deleteObject = function(a) {
          if (a !== null)
            a["delete"]();
        };
        W.prototype.fromWireType = function(a) {
          function b() {
            return this.sb ? wb(this.ab.mb, { cb: this.Ob, bb: c, ib: this, gb: a }) : wb(this.ab.mb, { cb: this, bb: a });
          }
          var c = this.Lb(a);
          if (!c)
            return this.Cb(a), null;
          var e = vb(this.ab, c);
          if (e !== void 0) {
            if (e.$a.count.value === 0)
              return e.$a.bb = c, e.$a.gb = a, e.clone();
            e = e.clone();
            this.Cb(a);
            return e;
          }
          e = this.ab.Kb(c);
          e = lb[e];
          if (!e)
            return b.call(this);
          e = this.rb ? e.Gb : e.pointerType;
          var f = tb(c, this.ab, e.ab);
          return f === null ? b.call(this) : this.sb ? wb(e.ab.mb, { cb: e, bb: f, ib: this, gb: a }) : wb(e.ab.mb, { cb: e, bb: f });
        };
        d.getInheritedInstanceCount = function() {
          return Object.keys(ub).length;
        };
        d.getLiveInheritedInstances = function() {
          var a = [], b;
          for (b in ub)
            ub.hasOwnProperty(b) && a.push(ub[b]);
          return a;
        };
        d.flushPendingDeletes = kb;
        d.setDelayFunction = function(a) {
          ib = a;
          jb.length && ib && ib(kb);
        };
        yb = d.UnboundTypeError = Xa("UnboundTypeError");
        d.count_emval_handles = function() {
          for (var a = 0, b = 5; b < Z.length; ++b)
            Z[b] !== void 0 && ++a;
          return a;
        };
        d.get_first_emval = function() {
          for (var a = 5; a < Z.length; ++a)
            if (Z[a] !== void 0)
              return Z[a];
          return null;
        };
        var Zb = {
          s: function(a) {
            var b = Sa[a];
            delete Sa[a];
            var c = b.elements, e = c.length, f = c.map(function(h) {
              return h.wb;
            }).concat(c.map(function(h) {
              return h.Ab;
            })), g = b.ob, m = b.hb;
            N([a], f, function(h) {
              c.forEach(function(k, l) {
                var n = h[l], p = k.ub, q = k.vb, t = h[l + e], u = k.zb, M = k.Bb;
                k.read = function(A) {
                  return n.fromWireType(p(q, A));
                };
                k.write = function(A, T) {
                  var C = [];
                  u(M, A, t.toWireType(C, T));
                  Ta(C);
                };
              });
              return [{ name: b.name, fromWireType: function(k) {
                for (var l = Array(e), n = 0; n < e; ++n)
                  l[n] = c[n].read(k);
                m(k);
                return l;
              }, toWireType: function(k, l) {
                if (e !== l.length)
                  throw new TypeError("Incorrect number of tuple elements for " + b.name + ": expected=" + e + ", actual=" + l.length);
                for (var n = g(), p = 0; p < e; ++p)
                  c[p].write(n, l[p]);
                k !== null && k.push(m, n);
                return n;
              }, argPackAdvance: 8, readValueFromPointer: J, fb: m }];
            });
          },
          v: function(a) {
            var b = $a[a];
            delete $a[a];
            var c = b.ob, e = b.hb, f = b.Db, g = f.map(function(m) {
              return m.wb;
            }).concat(f.map(function(m) {
              return m.Ab;
            }));
            N([a], g, function(m) {
              var h = {};
              f.forEach(function(k, l) {
                var n = m[l], p = k.ub, q = k.vb, t = m[l + f.length], u = k.zb, M = k.Bb;
                h[k.Ib] = { read: function(A) {
                  return n.fromWireType(p(q, A));
                }, write: function(A, T) {
                  var C = [];
                  u(M, A, t.toWireType(C, T));
                  Ta(C);
                } };
              });
              return [{ name: b.name, fromWireType: function(k) {
                var l = {}, n;
                for (n in h)
                  l[n] = h[n].read(k);
                e(k);
                return l;
              }, toWireType: function(k, l) {
                for (var n in h)
                  if (!(n in l))
                    throw new TypeError("Missing field");
                var p = c();
                for (n in h)
                  h[n].write(p, l[n]);
                k !== null && k.push(e, p);
                return p;
              }, argPackAdvance: 8, readValueFromPointer: J, fb: e }];
            });
          },
          G: function(a, b, c, e, f) {
            var g = ab(c);
            b = P(b);
            O(a, {
              name: b,
              fromWireType: function(m) {
                return !!m;
              },
              toWireType: function(m, h) {
                return h ? e : f;
              },
              argPackAdvance: 8,
              readValueFromPointer: function(m) {
                if (c === 1)
                  var h = Aa;
                else if (c === 2)
                  h = D;
                else if (c === 4)
                  h = E;
                else
                  throw new TypeError("Unknown boolean type size: " + b);
                return this.fromWireType(h[m >> g]);
              },
              fb: null
            });
          },
          k: function(a, b, c, e, f, g, m, h, k, l, n, p, q) {
            n = P(n);
            g = X(f, g);
            h && (h = X(m, h));
            l && (l = X(k, l));
            q = X(p, q);
            var t = Va(n);
            nb(t, function() {
              Db("Cannot construct " + n + " due to unbound types", [e]);
            });
            N([a, b, c], e ? [e] : [], function(u) {
              u = u[0];
              if (e) {
                var M = u.ab;
                var A = M.mb;
              } else
                A = S.prototype;
              u = Wa(t, function() {
                if (Object.getPrototypeOf(this) !== T)
                  throw new Q("Use 'new' to construct " + n);
                if (C.kb === void 0)
                  throw new Q(n + " has no accessible constructor");
                var Bb = C.kb[arguments.length];
                if (Bb === void 0)
                  throw new Q("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(C.kb).toString() + ") parameters instead!");
                return Bb.apply(this, arguments);
              });
              var T = Object.create(A, { constructor: { value: u } });
              u.prototype = T;
              var C = new ob(n, u, T, q, M, g, h, l);
              M = new W(n, C, true, false);
              A = new W(n + "*", C, false, false);
              var Cb = new W(n + " const*", C, false, true);
              lb[a] = { pointerType: A, Gb: Cb };
              xb(t, u);
              return [M, A, Cb];
            });
          },
          h: function(a, b, c, e, f, g) {
            assert(0 < b);
            var m = Eb(b, c);
            f = X(e, f);
            var h = [g], k = [];
            N([], [a], function(l) {
              l = l[0];
              var n = "constructor " + l.name;
              l.ab.kb === void 0 && (l.ab.kb = []);
              if (l.ab.kb[b - 1] !== void 0)
                throw new Q("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + l.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              l.ab.kb[b - 1] = function() {
                Db("Cannot construct " + l.name + " due to unbound types", m);
              };
              N([], m, function(p) {
                l.ab.kb[b - 1] = function() {
                  arguments.length !== b - 1 && R(n + " called with " + arguments.length + " arguments, expected " + (b - 1));
                  k.length = 0;
                  h.length = b;
                  for (var q = 1; q < b; ++q)
                    h[q] = p[q].toWireType(k, arguments[q - 1]);
                  q = f.apply(null, h);
                  Ta(k);
                  return p[0].fromWireType(q);
                };
                return [];
              });
              return [];
            });
          },
          a: function(a, b, c, e, f, g, m, h) {
            var k = Eb(c, e);
            b = P(b);
            g = X(f, g);
            N([], [a], function(l) {
              function n() {
                Db("Cannot call " + p + " due to unbound types", k);
              }
              l = l[0];
              var p = l.name + "." + b;
              h && l.ab.Pb.push(b);
              var q = l.ab.mb, t = q[b];
              t === void 0 || t.eb === void 0 && t.className !== l.name && t.qb === c - 2 ? (n.qb = c - 2, n.className = l.name, q[b] = n) : (mb(q, b, p), q[b].eb[c - 2] = n);
              N([], k, function(u) {
                u = Gb(p, u, l, g, m);
                q[b].eb === void 0 ? (u.qb = c - 2, q[b] = u) : q[b].eb[c - 2] = u;
                return [];
              });
              return [];
            });
          },
          M: function(a, b, c) {
            a = P(a);
            N([], [b], function(e) {
              e = e[0];
              d[a] = e.fromWireType(c);
              return [];
            });
          },
          E: function(a, b) {
            b = P(b);
            O(a, { name: b, fromWireType: function(c) {
              var e = Z[c].value;
              Ib(c);
              return e;
            }, toWireType: function(c, e) {
              return V(e);
            }, argPackAdvance: 8, readValueFromPointer: J, fb: null });
          },
          g: function(a, b, c, e) {
            function f() {
            }
            c = ab(c);
            b = P(b);
            f.values = {};
            O(a, { name: b, constructor: f, fromWireType: function(g) {
              return this.constructor.values[g];
            }, toWireType: function(g, m) {
              return m.value;
            }, argPackAdvance: 8, readValueFromPointer: Jb(b, c, e), fb: null });
            nb(b, f);
          },
          j: function(a, b, c) {
            var e = Kb(a, "enum");
            b = P(b);
            a = e.constructor;
            e = Object.create(e.constructor.prototype, { value: { value: c }, constructor: { value: Wa(e.name + "_" + b, function() {
            }) } });
            a.values[c] = e;
            a[b] = e;
          },
          p: function(a, b, c) {
            c = ab(c);
            b = P(b);
            O(a, { name: b, fromWireType: function(e) {
              return e;
            }, toWireType: function(e, f) {
              if (typeof f !== "number" && typeof f !== "boolean")
                throw new TypeError('Cannot convert "' + U(f) + '" to ' + this.name);
              return f;
            }, argPackAdvance: 8, readValueFromPointer: Lb(b, c), fb: null });
          },
          f: function(a, b, c, e, f, g) {
            var m = Eb(b, c);
            a = P(a);
            f = X(e, f);
            nb(a, function() {
              Db("Cannot call " + a + " due to unbound types", m);
            }, b - 1);
            N([], m, function(h) {
              h = [h[0], null].concat(h.slice(1));
              xb(a, Gb(a, h, null, f, g), b - 1);
              return [];
            });
          },
          e: function(a, b, c, e, f) {
            function g(l) {
              return l;
            }
            b = P(b);
            f === -1 && (f = 4294967295);
            var m = ab(c);
            if (e === 0) {
              var h = 32 - 8 * c;
              g = function(l) {
                return l << h >>> h;
              };
            }
            var k = b.indexOf("unsigned") != -1;
            O(a, { name: b, fromWireType: g, toWireType: function(l, n) {
              if (typeof n !== "number" && typeof n !== "boolean")
                throw new TypeError('Cannot convert "' + U(n) + '" to ' + this.name);
              if (n < e || n > f)
                throw new TypeError('Passing a number "' + U(n) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + e + ", " + f + "]!");
              return k ? n >>> 0 : n | 0;
            }, argPackAdvance: 8, readValueFromPointer: Mb(b, m, e !== 0), fb: null });
          },
          b: function(a, b, c) {
            function e(g) {
              g >>= 2;
              return new f(za, F[g + 1], F[g]);
            }
            var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
            c = P(c);
            O(a, { name: c, fromWireType: e, argPackAdvance: 8, readValueFromPointer: e }, { Mb: true });
          },
          q: function(a, b) {
            b = P(b);
            var c = b === "std::string";
            O(a, { name: b, fromWireType: function(e) {
              var f = F[e >> 2];
              if (c)
                for (var g = e + 4, m = 0; m <= f; ++m) {
                  var h = e + 4 + m;
                  if (B[h] == 0 || m == f) {
                    g = g ? pa(B, g, h - g) : "";
                    if (k === void 0)
                      var k = g;
                    else
                      k += String.fromCharCode(0), k += g;
                    g = h + 1;
                  }
                }
              else {
                k = Array(f);
                for (m = 0; m < f; ++m)
                  k[m] = String.fromCharCode(B[e + 4 + m]);
                k = k.join("");
              }
              Y(e);
              return k;
            }, toWireType: function(e, f) {
              f instanceof ArrayBuffer && (f = new Uint8Array(f));
              var g = typeof f === "string";
              g || f instanceof Uint8Array || f instanceof Uint8ClampedArray || f instanceof Int8Array || R("Cannot pass non-string to std::string");
              var m = (c && g ? function() {
                for (var l = 0, n = 0; n < f.length; ++n) {
                  var p = f.charCodeAt(n);
                  55296 <= p && 57343 >= p && (p = 65536 + ((p & 1023) << 10) | f.charCodeAt(++n) & 1023);
                  127 >= p ? ++l : l = 2047 >= p ? l + 2 : 65535 >= p ? l + 3 : l + 4;
                }
                return l;
              } : function() {
                return f.length;
              })(), h = Yb(4 + m + 1);
              F[h >> 2] = m;
              if (c && g)
                qa(f, h + 4, m + 1);
              else if (g)
                for (g = 0; g < m; ++g) {
                  var k = f.charCodeAt(g);
                  255 < k && (Y(h), R("String has UTF-16 code units that do not fit in 8 bits"));
                  B[h + 4 + g] = k;
                }
              else
                for (g = 0; g < m; ++g)
                  B[h + 4 + g] = f[g];
              e !== null && e.push(Y, h);
              return h;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: function(e) {
              Y(e);
            } });
          },
          l: function(a, b, c) {
            c = P(c);
            if (b === 2) {
              var e = sa;
              var f = ua;
              var g = va;
              var m = function() {
                return ta;
              };
              var h = 1;
            } else
              b === 4 && (e = wa, f = xa, g = ya, m = function() {
                return F;
              }, h = 2);
            O(a, { name: c, fromWireType: function(k) {
              for (var l = F[k >> 2], n = m(), p, q = k + 4, t = 0; t <= l; ++t) {
                var u = k + 4 + t * b;
                if (n[u >> h] == 0 || t == l)
                  q = e(q, u - q), p === void 0 ? p = q : (p += String.fromCharCode(0), p += q), q = u + b;
              }
              Y(k);
              return p;
            }, toWireType: function(k, l) {
              typeof l !== "string" && R("Cannot pass non-string to C++ string type " + c);
              var n = g(l), p = Yb(4 + n + b);
              F[p >> 2] = n >> h;
              f(l, p + 4, n + b);
              k !== null && k.push(Y, p);
              return p;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: function(k) {
              Y(k);
            } });
          },
          u: function(a, b, c, e, f, g) {
            Sa[a] = { name: P(b), ob: X(c, e), hb: X(f, g), elements: [] };
          },
          t: function(a, b, c, e, f, g, m, h, k) {
            Sa[a].elements.push({ wb: b, ub: X(c, e), vb: f, Ab: g, zb: X(m, h), Bb: k });
          },
          w: function(a, b, c, e, f, g) {
            $a[a] = { name: P(b), ob: X(c, e), hb: X(f, g), Db: [] };
          },
          i: function(a, b, c, e, f, g, m, h, k, l) {
            $a[a].Db.push({ Ib: P(b), wb: c, ub: X(e, f), vb: g, Ab: m, zb: X(h, k), Bb: l });
          },
          H: function(a, b) {
            b = P(b);
            O(a, { Nb: true, name: b, argPackAdvance: 0, fromWireType: function() {
            }, toWireType: function() {
            } });
          },
          d: function(a, b, c, e) {
            a = Pb[a];
            b = Qb(b);
            c = Ob(c);
            a(b, c, null, e);
          },
          N: Ib,
          z: function(a) {
            if (a === 0)
              return V(Rb());
            a = Ob(a);
            return V(Rb()[a]);
          },
          c: function(a, b) {
            b = Tb(a, b);
            for (var c = b[0], e = c.name + "_$" + b.slice(1).map(function(l) {
              return l.name;
            }).join("_") + "$", f = ["retType"], g = [c], m = "", h = 0; h < a - 1; ++h)
              m += (h !== 0 ? ", " : "") + "arg" + h, f.push("argType" + h), g.push(b[1 + h]);
            e = "return function " + Va("methodCaller_" + e) + "(handle, name, destructors, args) {\n";
            var k = 0;
            for (h = 0; h < a - 1; ++h)
              e += "    var arg" + h + " = argType" + h + ".readValueFromPointer(args" + (k ? "+" + k : "") + ");\n", k += b[h + 1].argPackAdvance;
            e += "    var rv = handle[name](" + m + ");\n";
            for (h = 0; h < a - 1; ++h)
              b[h + 1].deleteObject && (e += "    argType" + h + ".deleteObject(arg" + h + ");\n");
            c.Nb || (e += "    return retType.toWireType(destructors, rv);\n");
            f.push(e + "};\n");
            a = Fb(f).apply(null, g);
            return Sb(a);
          },
          n: function(a) {
            4 < a && (Z[a].yb += 1);
          },
          x: function(a, b, c, e) {
            a = Qb(a);
            var f = Ub[b];
            if (!f) {
              f = "";
              for (var g = 0; g < b; ++g)
                f += (g !== 0 ? ", " : "") + "arg" + g;
              var m = "return function emval_allocator_" + b + "(constructor, argTypes, args) {\n";
              for (g = 0; g < b; ++g)
                m += "var argType" + g + " = requireRegisteredType(Module['HEAP32'][(argTypes >>> 2) + " + g + '], "parameter ' + g + '");\nvar arg' + g + " = argType" + g + ".readValueFromPointer(args);\nargs += argType" + g + "['argPackAdvance'];\n";
              f = new Function("requireRegisteredType", "Module", "__emval_register", m + ("var obj = new constructor(" + f + ");\nreturn __emval_register(obj);\n}\n"))(Kb, d, V);
              Ub[b] = f;
            }
            return f(a, c, e);
          },
          O: function() {
            return V([]);
          },
          F: function(a) {
            return V(Ob(a));
          },
          L: function(a, b) {
            a = Kb(a, "_emval_take_value");
            a = a.readValueFromPointer(b);
            return V(a);
          },
          m: function() {
            y();
          },
          B: function(a, b, c) {
            B.copyWithin(a, b, b + c);
          },
          C: function() {
            y("OOM");
          },
          D: function() {
            return 0;
          },
          y: function() {
          },
          o: function(a, b, c, e) {
            for (var f = 0, g = 0; g < c; g++) {
              for (var m = E[b + 8 * g >> 2], h = E[b + (8 * g + 4) >> 2], k = 0; k < h; k++) {
                var l = B[m + k], n = Vb[a];
                l === 0 || l === 10 ? ((a === 1 ? ja : z)(pa(n, 0)), n.length = 0) : n.push(l);
              }
              f += h;
            }
            E[e >> 2] = f;
            return 0;
          },
          memory: la,
          K: function() {
          },
          r: function() {
          },
          J: function() {
          },
          I: function() {
          },
          A: function() {
          },
          table: ma
        }, $b = function() {
          function a(f) {
            d.asm = f.exports;
            H--;
            d.monitorRunDependencies && d.monitorRunDependencies(H);
            H == 0 && (La && (f = La, La = null, f()));
          }
          function b(f) {
            a(f.instance);
          }
          function c(f) {
            return Qa().then(function(g) {
              return WebAssembly.instantiate(g, e);
            }).then(f, function(g) {
              z("failed to asynchronously prepare wasm: " + g);
              y(g);
            });
          }
          var e = { a: Zb };
          H++;
          d.monitorRunDependencies && d.monitorRunDependencies(H);
          if (d.instantiateWasm)
            try {
              return d.instantiateWasm(e, a);
            } catch (f) {
              return z("Module.instantiateWasm callback failed with error: " + f), false;
            }
          (function() {
            if (ka || typeof WebAssembly.instantiateStreaming !== "function" || Na() || Ma("file://") || typeof fetch !== "function")
              return c(b);
            fetch(I, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(b, function(g) {
                z("wasm streaming compile failed: " + g);
                z("falling back to ArrayBuffer instantiation");
                c(b);
              });
            });
          })();
          return {};
        }();
        d.asm = $b;
        var Ra = d.___wasm_call_ctors = function() {
          return (Ra = d.___wasm_call_ctors = d.asm.P).apply(null, arguments);
        };
        d.__Z6ToCmdsRK6SkPath = function() {
          return (d.__Z6ToCmdsRK6SkPath = d.asm.Q).apply(null, arguments);
        };
        d.__Z8FromCmdsmi = function() {
          return (d.__Z8FromCmdsmi = d.asm.R).apply(null, arguments);
        };
        d.__Z7NewPathv = function() {
          return (d.__Z7NewPathv = d.asm.S).apply(null, arguments);
        };
        d.__Z8CopyPathRK6SkPath = function() {
          return (d.__Z8CopyPathRK6SkPath = d.asm.T).apply(null, arguments);
        };
        d.__Z6EqualsRK6SkPathS1_ = function() {
          return (d.__Z6EqualsRK6SkPathS1_ = d.asm.U).apply(null, arguments);
        };
        d.__Z11ToSVGStringRK6SkPath = function() {
          return (d.__Z11ToSVGStringRK6SkPath = d.asm.V).apply(null, arguments);
        };
        d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = function() {
          return (d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = d.asm.W).apply(null, arguments);
        };
        d.__Z13ApplySimplifyR6SkPath = function() {
          return (d.__Z13ApplySimplifyR6SkPath = d.asm.X).apply(null, arguments);
        };
        d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = function() {
          return (d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = d.asm.Y).apply(null, arguments);
        };
        d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = function() {
          return (d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = d.asm.Z).apply(null, arguments);
        };
        d.__Z14ResolveBuilderR11SkOpBuilder = function() {
          return (d.__Z14ResolveBuilderR11SkOpBuilder = d.asm._).apply(null, arguments);
        };
        d.__Z8ToCanvasRK6SkPathN10emscripten3valE = function() {
          return (d.__Z8ToCanvasRK6SkPathN10emscripten3valE = d.asm.$).apply(null, arguments);
        };
        d.__Z8ToPath2DRK6SkPath = function() {
          return (d.__Z8ToPath2DRK6SkPath = d.asm.aa).apply(null, arguments);
        };
        var Y = d._free = function() {
          return (Y = d._free = d.asm.ba).apply(null, arguments);
        }, Yb = d._malloc = function() {
          return (Yb = d._malloc = d.asm.ca).apply(null, arguments);
        }, Ab = d.___getTypeName = function() {
          return (Ab = d.___getTypeName = d.asm.da).apply(null, arguments);
        };
        d.___embind_register_native_and_builtin_types = function() {
          return (d.___embind_register_native_and_builtin_types = d.asm.ea).apply(null, arguments);
        };
        d.dynCall_vi = function() {
          return (d.dynCall_vi = d.asm.fa).apply(null, arguments);
        };
        d.dynCall_iiiii = function() {
          return (d.dynCall_iiiii = d.asm.ga).apply(null, arguments);
        };
        d.dynCall_ii = function() {
          return (d.dynCall_ii = d.asm.ha).apply(null, arguments);
        };
        d.dynCall_i = function() {
          return (d.dynCall_i = d.asm.ia).apply(null, arguments);
        };
        d.dynCall_viifffffffff = function() {
          return (d.dynCall_viifffffffff = d.asm.ja).apply(null, arguments);
        };
        d.dynCall_vifffffi = function() {
          return (d.dynCall_vifffffi = d.asm.ka).apply(null, arguments);
        };
        d.dynCall_vifffff = function() {
          return (d.dynCall_vifffff = d.asm.la).apply(null, arguments);
        };
        d.dynCall_viffffff = function() {
          return (d.dynCall_viffffff = d.asm.ma).apply(null, arguments);
        };
        d.dynCall_vifffffffi = function() {
          return (d.dynCall_vifffffffi = d.asm.na).apply(null, arguments);
        };
        d.dynCall_viff = function() {
          return (d.dynCall_viff = d.asm.oa).apply(null, arguments);
        };
        d.dynCall_viffff = function() {
          return (d.dynCall_viffff = d.asm.pa).apply(null, arguments);
        };
        d.dynCall_vii = function() {
          return (d.dynCall_vii = d.asm.qa).apply(null, arguments);
        };
        d.dynCall_iii = function() {
          return (d.dynCall_iii = d.asm.ra).apply(null, arguments);
        };
        d.dynCall_iifff = function() {
          return (d.dynCall_iifff = d.asm.sa).apply(null, arguments);
        };
        d.dynCall_iiffi = function() {
          return (d.dynCall_iiffi = d.asm.ta).apply(null, arguments);
        };
        d.dynCall_vifffffffff = function() {
          return (d.dynCall_vifffffffff = d.asm.ua).apply(null, arguments);
        };
        d.dynCall_iiii = function() {
          return (d.dynCall_iiii = d.asm.va).apply(null, arguments);
        };
        d.dynCall_viii = function() {
          return (d.dynCall_viii = d.asm.wa).apply(null, arguments);
        };
        d.dynCall_viiii = function() {
          return (d.dynCall_viiii = d.asm.xa).apply(null, arguments);
        };
        d.dynCall_fif = function() {
          return (d.dynCall_fif = d.asm.ya).apply(null, arguments);
        };
        d.dynCall_viif = function() {
          return (d.dynCall_viif = d.asm.za).apply(null, arguments);
        };
        d.dynCall_fi = function() {
          return (d.dynCall_fi = d.asm.Aa).apply(null, arguments);
        };
        d.dynCall_viiifffffffff = function() {
          return (d.dynCall_viiifffffffff = d.asm.Ba).apply(null, arguments);
        };
        d.dynCall_viifffffi = function() {
          return (d.dynCall_viifffffi = d.asm.Ca).apply(null, arguments);
        };
        d.dynCall_viifffff = function() {
          return (d.dynCall_viifffff = d.asm.Da).apply(null, arguments);
        };
        d.dynCall_viiffffff = function() {
          return (d.dynCall_viiffffff = d.asm.Ea).apply(null, arguments);
        };
        d.dynCall_viifffffffi = function() {
          return (d.dynCall_viifffffffi = d.asm.Fa).apply(null, arguments);
        };
        d.dynCall_viiff = function() {
          return (d.dynCall_viiff = d.asm.Ga).apply(null, arguments);
        };
        d.dynCall_viiffff = function() {
          return (d.dynCall_viiffff = d.asm.Ha).apply(null, arguments);
        };
        d.dynCall_iiifff = function() {
          return (d.dynCall_iiifff = d.asm.Ia).apply(null, arguments);
        };
        d.dynCall_iiiffi = function() {
          return (d.dynCall_iiiffi = d.asm.Ja).apply(null, arguments);
        };
        d.dynCall_fii = function() {
          return (d.dynCall_fii = d.asm.Ka).apply(null, arguments);
        };
        d.dynCall_iiffff = function() {
          return (d.dynCall_iiffff = d.asm.La).apply(null, arguments);
        };
        d.dynCall_fiif = function() {
          return (d.dynCall_fiif = d.asm.Ma).apply(null, arguments);
        };
        d.dynCall_iiif = function() {
          return (d.dynCall_iiif = d.asm.Na).apply(null, arguments);
        };
        d.dynCall_vifii = function() {
          return (d.dynCall_vifii = d.asm.Oa).apply(null, arguments);
        };
        d.dynCall_viifd = function() {
          return (d.dynCall_viifd = d.asm.Pa).apply(null, arguments);
        };
        d.dynCall_viid = function() {
          return (d.dynCall_viid = d.asm.Qa).apply(null, arguments);
        };
        d.dynCall_viddi = function() {
          return (d.dynCall_viddi = d.asm.Ra).apply(null, arguments);
        };
        d.dynCall_iidi = function() {
          return (d.dynCall_iidi = d.asm.Sa).apply(null, arguments);
        };
        d.dynCall_viffi = function() {
          return (d.dynCall_viffi = d.asm.Ta).apply(null, arguments);
        };
        d.dynCall_fffff = function() {
          return (d.dynCall_fffff = d.asm.Ua).apply(null, arguments);
        };
        d.dynCall_viiiii = function() {
          return (d.dynCall_viiiii = d.asm.Va).apply(null, arguments);
        };
        d.dynCall_viiiiiffii = function() {
          return (d.dynCall_viiiiiffii = d.asm.Wa).apply(null, arguments);
        };
        d.dynCall_iiiiii = function() {
          return (d.dynCall_iiiiii = d.asm.Xa).apply(null, arguments);
        };
        d.dynCall_iiiiiii = function() {
          return (d.dynCall_iiiiiii = d.asm.Ya).apply(null, arguments);
        };
        d.dynCall_iidiiii = function() {
          return (d.dynCall_iidiiii = d.asm.Za).apply(null, arguments);
        };
        d.dynCall_jiji = function() {
          return (d.dynCall_jiji = d.asm._a).apply(null, arguments);
        };
        d.asm = $b;
        var ac;
        La = function bc() {
          ac || cc();
          ac || (La = bc);
        };
        function cc() {
          function a() {
            if (!ac && (ac = true, d.calledRun = true, !na)) {
              Ea(Ga);
              Ea(Ha);
              aa(d);
              if (d.onRuntimeInitialized)
                d.onRuntimeInitialized();
              if (d.postRun)
                for (typeof d.postRun == "function" && (d.postRun = [d.postRun]); d.postRun.length; ) {
                  var b = d.postRun.shift();
                  Ia.unshift(b);
                }
              Ea(Ia);
            }
          }
          if (!(0 < H)) {
            if (d.preRun)
              for (typeof d.preRun == "function" && (d.preRun = [d.preRun]); d.preRun.length; )
                Ja();
            Ea(Fa);
            0 < H || (d.setStatus ? (d.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                d.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        d.run = cc;
        if (d.preInit)
          for (typeof d.preInit == "function" && (d.preInit = [d.preInit]); 0 < d.preInit.length; )
            d.preInit.pop()();
        cc();
        return PathKitInit3.ready;
      };
    }();
    module2.exports = PathKitInit2;
  })(pathkit);
  var PathKitInit = pathkit.exports;
  var fitCurve$1 = { exports: {} };
  (function(module2, exports3) {
    (function(global2, factory) {
      {
        factory(module2);
      }
    })(commonjsGlobal, function(module3) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       *  @preserve  JavaScript implementation of
       *  Algorithm for Automatically Fitting Digitized Curves
       *  by Philip J. Schneider
       *  "Graphics Gems", Academic Press, 1990
       *
       *  The MIT License (MIT)
       *
       *  https://github.com/soswow/fit-curves
       */
      function fitCurve2(points, maxError, progressCallback) {
        if (!Array.isArray(points)) {
          throw new TypeError("First argument should be an array");
        }
        points.forEach(function(point2) {
          if (!Array.isArray(point2) || point2.some(function(item) {
            return typeof item !== "number";
          }) || point2.length !== points[0].length) {
            throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
          }
        });
        points = points.filter(function(point2, i) {
          return i === 0 || !point2.every(function(val, j) {
            return val === points[i - 1][j];
          });
        });
        if (points.length < 2) {
          return [];
        }
        var len2 = points.length;
        var leftTangent = createTangent(points[1], points[0]);
        var rightTangent = createTangent(points[len2 - 2], points[len2 - 1]);
        return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
      }
      function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
        var MaxIterations = 20;
        var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist2, i;
        if (points.length === 2) {
          dist2 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
          bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist2)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist2)), points[1]];
          return [bezCurve];
        }
        u = chordLengthParameterize(points);
        var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
        bezCurve = _generateAndReport[0];
        maxError = _generateAndReport[1];
        splitPoint = _generateAndReport[2];
        if (maxError === 0 || maxError < error) {
          return [bezCurve];
        }
        if (maxError < error * error) {
          uPrime = u;
          prevErr = maxError;
          prevSplit = splitPoint;
          for (i = 0; i < MaxIterations; i++) {
            uPrime = reparameterize(bezCurve, points, uPrime);
            var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
            bezCurve = _generateAndReport2[0];
            maxError = _generateAndReport2[1];
            splitPoint = _generateAndReport2[2];
            if (maxError < error) {
              return [bezCurve];
            } else if (splitPoint === prevSplit) {
              var errChange = maxError / prevErr;
              if (errChange > 0.9999 && errChange < 1.0001) {
                break;
              }
            }
            prevErr = maxError;
            prevSplit = splitPoint;
          }
        }
        beziers = [];
        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
        if (centerVector.every(function(val) {
          return val === 0;
        })) {
          centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
          var _ref = [-centerVector[1], centerVector[0]];
          centerVector[0] = _ref[0];
          centerVector[1] = _ref[1];
        }
        toCenterTangent = maths.normalize(centerVector);
        fromCenterTangent = maths.mulItems(toCenterTangent, -1);
        beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
        beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
        return beziers;
      }
      function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
        var bezCurve, maxError, splitPoint;
        bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent);
        var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);
        maxError = _computeMaxError[0];
        splitPoint = _computeMaxError[1];
        if (progressCallback) {
          progressCallback({
            bez: bezCurve,
            points,
            params: paramsOrig,
            maxErr: maxError,
            maxPoint: splitPoint
          });
        }
        return [bezCurve, maxError, splitPoint];
      }
      function generateBezier(points, parameters, leftTangent, rightTangent) {
        var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len2, tmp2, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
        bezCurve = [firstPoint, null, null, lastPoint];
        A = maths.zeros_Xx2x2(parameters.length);
        for (i = 0, len2 = parameters.length; i < len2; i++) {
          u = parameters[i];
          ux = 1 - u;
          a = A[i];
          a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
          a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
        }
        C = [[0, 0], [0, 0]];
        X = [0, 0];
        for (i = 0, len2 = points.length; i < len2; i++) {
          u = parameters[i];
          a = A[i];
          C[0][0] += maths.dot(a[0], a[0]);
          C[0][1] += maths.dot(a[0], a[1]);
          C[1][0] += maths.dot(a[0], a[1]);
          C[1][1] += maths.dot(a[1], a[1]);
          tmp2 = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
          X[0] += maths.dot(a[0], tmp2);
          X[1] += maths.dot(a[1], tmp2);
        }
        det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
        det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
        det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
        alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
        alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
        segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
        epsilon = 1e-6 * segLength;
        if (alpha_l < epsilon || alpha_r < epsilon) {
          bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
          bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
        } else {
          bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
          bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
        }
        return bezCurve;
      }
      function reparameterize(bezier2, points, parameters) {
        return parameters.map(function(p, i) {
          return newtonRaphsonRootFind(bezier2, points[i], p);
        });
      }
      function newtonRaphsonRootFind(bez, point2, u) {
        var d = maths.subtract(bezier.q(bez, u), point2), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
        if (denominator === 0) {
          return u;
        } else {
          return u - numerator / denominator;
        }
      }
      function chordLengthParameterize(points) {
        var u = [], currU, prevU, prevP;
        points.forEach(function(p, i) {
          currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
          u.push(currU);
          prevU = currU;
          prevP = p;
        });
        u = u.map(function(x) {
          return x / prevU;
        });
        return u;
      }
      function computeMaxError(points, bez, parameters) {
        var dist2, maxDist, splitPoint, v, i, count, point2, t;
        maxDist = 0;
        splitPoint = Math.floor(points.length / 2);
        var t_distMap = mapTtoRelativeDistances(bez, 10);
        for (i = 0, count = points.length; i < count; i++) {
          point2 = points[i];
          t = find_t(bez, parameters[i], t_distMap, 10);
          v = maths.subtract(bezier.q(bez, t), point2);
          dist2 = v[0] * v[0] + v[1] * v[1];
          if (dist2 > maxDist) {
            maxDist = dist2;
            splitPoint = i;
          }
        }
        return [maxDist, splitPoint];
      }
      var mapTtoRelativeDistances = function mapTtoRelativeDistances2(bez, B_parts) {
        var B_t_curr;
        var B_t_dist = [0];
        var B_t_prev = bez[0];
        var sumLen = 0;
        for (var i = 1; i <= B_parts; i++) {
          B_t_curr = bezier.q(bez, i / B_parts);
          sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
          B_t_dist.push(sumLen);
          B_t_prev = B_t_curr;
        }
        B_t_dist = B_t_dist.map(function(x) {
          return x / sumLen;
        });
        return B_t_dist;
      };
      function find_t(bez, param, t_distMap, B_parts) {
        if (param < 0) {
          return 0;
        }
        if (param > 1) {
          return 1;
        }
        var lenMax, lenMin, tMax, tMin, t;
        for (var i = 1; i <= B_parts; i++) {
          if (param <= t_distMap[i]) {
            tMin = (i - 1) / B_parts;
            tMax = i / B_parts;
            lenMin = t_distMap[i - 1];
            lenMax = t_distMap[i];
            t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
            break;
          }
        }
        return t;
      }
      function createTangent(pointA, pointB) {
        return maths.normalize(maths.subtract(pointA, pointB));
      }
      var maths = function() {
        function maths2() {
          _classCallCheck(this, maths2);
        }
        maths2.zeros_Xx2x2 = function zeros_Xx2x2(x) {
          var zs = [];
          while (x--) {
            zs.push([0, 0]);
          }
          return zs;
        };
        maths2.mulItems = function mulItems(items, multiplier) {
          return items.map(function(x) {
            return x * multiplier;
          });
        };
        maths2.mulMatrix = function mulMatrix(m1, m2) {
          return m1.reduce(function(sum, x1, i) {
            return sum + x1 * m2[i];
          }, 0);
        };
        maths2.subtract = function subtract2(arr1, arr2) {
          return arr1.map(function(x1, i) {
            return x1 - arr2[i];
          });
        };
        maths2.addArrays = function addArrays(arr1, arr2) {
          return arr1.map(function(x1, i) {
            return x1 + arr2[i];
          });
        };
        maths2.addItems = function addItems(items, addition) {
          return items.map(function(x) {
            return x + addition;
          });
        };
        maths2.sum = function sum(items) {
          return items.reduce(function(sum2, x) {
            return sum2 + x;
          });
        };
        maths2.dot = function dot2(m1, m2) {
          return maths2.mulMatrix(m1, m2);
        };
        maths2.vectorLen = function vectorLen(v) {
          return Math.hypot.apply(Math, v);
        };
        maths2.divItems = function divItems(items, divisor) {
          return items.map(function(x) {
            return x / divisor;
          });
        };
        maths2.squareItems = function squareItems(items) {
          return items.map(function(x) {
            return x * x;
          });
        };
        maths2.normalize = function normalize2(v) {
          return this.divItems(v, this.vectorLen(v));
        };
        return maths2;
      }();
      var bezier = function() {
        function bezier2() {
          _classCallCheck(this, bezier2);
        }
        bezier2.q = function q(ctrlPoly, t) {
          var tx = 1 - t;
          var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t);
          return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
        };
        bezier2.qprime = function qprime(ctrlPoly, t) {
          var tx = 1 - t;
          var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
          return maths.addArrays(maths.addArrays(pA, pB), pC);
        };
        bezier2.qprimeprime = function qprimeprime(ctrlPoly, t) {
          return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
        };
        return bezier2;
      }();
      module3.exports = fitCurve2;
      module3.exports.fitCubic = fitCubic;
      module3.exports.createTangent = createTangent;
    });
  })(fitCurve$1);
  var fitCurve = fitCurve$1.exports;
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };
  function create$5() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function multiply$2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation$1(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function create$4() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function multiply$1(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len2 = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len2 < EPSILON) {
      return null;
    }
    len2 = 1 / len2;
    x *= len2;
    y *= len2;
    z *= len2;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len2 = Math.hypot(x, y, z);
    var s, c, t;
    if (len2 < EPSILON) {
      return null;
    }
    len2 = 1 / len2;
    x *= len2;
    y *= len2;
    z *= len2;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function create$3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function normalize$3(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len2 = x * x + y * y + z * z;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = a[0] * len2;
    out[1] = a[1] * len2;
    out[2] = a[2] * len2;
    return out;
  }
  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function equals$1(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
  var div$1 = divide;
  var dist = distance$1;
  var len = length;
  (function() {
    var vec = create$3();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  })();
  function create$2() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function normalize$2(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len2 = x * x + y * y + z * z + w * w;
    if (len2 > 0) {
      len2 = 1 / Math.sqrt(len2);
    }
    out[0] = x * len2;
    out[1] = y * len2;
    out[2] = z * len2;
    out[3] = w * len2;
    return out;
  }
  (function() {
    var vec = create$2();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  })();
  function create$1() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad;
  }
  function slerp(out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i = 0;
      if (m[4] > m[0])
        i = 1;
      if (m[8] > m[i * 3 + i])
        i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  var normalize$1 = normalize$2;
  (function() {
    var tmpvec3 = create$3();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function(out, a, b) {
      var dot2 = dot$1(a, b);
      if (dot2 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a);
        normalize$3(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot2 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot2;
        return normalize$1(out, out);
      }
    };
  })();
  (function() {
    var temp1 = create$1();
    var temp2 = create$1();
    return function(out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  })();
  (function() {
    var matr = create$5();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$1(out, fromMat3(out, matr));
    };
  })();
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  function equals(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  (function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  })();
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var TAU = Math.PI * 2;
  var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
    var x = _ref.x, y = _ref.y;
    x *= rx;
    y *= ry;
    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;
    return {
      x: xp + centerx,
      y: yp + centery
    };
  };
  var approxUnitArc = function approxUnitArc2(ang1, ang2) {
    var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);
    return [{
      x: x1 - y1 * a,
      y: y1 + x1 * a
    }, {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    }, {
      x: x2,
      y: y2
    }];
  };
  var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
    var sign = ux * vy - uy * vx < 0 ? -1 : 1;
    var dot2 = ux * vx + uy * vy;
    if (dot2 > 1) {
      dot2 = 1;
    }
    if (dot2 < -1) {
      dot2 = -1;
    }
    return sign * Math.acos(dot2);
  };
  var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rxsq * pypsq + rysq * pxpsq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
  };
  var arcToBezier = function arcToBezier2(_ref2) {
    var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
    var curves = [];
    if (rx === 0 || ry === 0) {
      return [];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return [];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    var segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    for (var i = 0; i < segments; i++) {
      curves.push(approxUnitArc(ang1, ang2));
      ang1 += ang2;
    }
    return curves.map(function(curve) {
      var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
      var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
      var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
      return { x1, y1, x2, y2, x, y };
    });
  };
  class Point {
    static isEqual(a, b, c) {
      if (arguments.length === 2) {
        return a.x === b.x && a.y === b.y;
      } else if (arguments.length === 3) {
        return Point.isEqual(a, b) && Point.isEqual(b, c);
      }
    }
    static isFirst(point2) {
      return point2 && point2.command == "M";
    }
    static DouglasPeuker(tolerance, points, start, last) {
      if (last <= start + 1)
        return;
      let maxdist2 = 0;
      let breakIndex = start;
      const tol2 = tolerance * tolerance;
      const startPoint = points[start];
      const lastPoint = points[last];
      for (var i = start + 1; i < last; i++) {
        const dist2 = Point.segmentDistance2(points[i].x, points[i].y, startPoint, lastPoint);
        if (dist2 <= maxdist2)
          continue;
        breakIndex = i;
        maxdist2 = dist2;
      }
      if (maxdist2 > tol2) {
        points[breakIndex].mark = true;
        Point.DouglasPeuker(tolerance, points, start, breakIndex);
        Point.DouglasPeuker(tolerance, points, breakIndex, last);
      }
    }
    static simply(points, tolerance = 10) {
      if (points.length <= 2) {
        return points;
      }
      points = sapa.clone(points);
      points[0].mark = true;
      points[points.length - 1].mark = true;
      Point.DouglasPeuker(tolerance, points, 0, points.length - 1);
      return points.filter((it) => Boolean(it.mark));
    }
    static segmentDistance2(x, y, A, B) {
      let dx = B.x - A.x;
      let dy = B.y - A.y;
      let lenAB = dx * dx + dy * dy;
      let du = x - A.x;
      let dv = y - A.y;
      let dot2 = dx * du + dy * dv;
      if (lenAB === 0)
        return du * du + dv * dv;
      if (dot2 <= 0)
        return du * du + dv * dv;
      else if (dot2 >= lenAB) {
        du = x - B.x;
        dv = y - B.y;
        return du * du + dv * dv;
      } else {
        const slash = du * dy - dv * dx;
        return slash * slash / lenAB;
      }
    }
    static isInLine(A, B, C) {
      if (A.x === C.x)
        return B.x === C.x;
      if (A.y === C.y)
        return B.y === C.y;
      return (A.x - C.x) * (A.y - C.y) === (C.x - B.x) * (C.y - B.y);
    }
    static isLine(point2) {
      return Point.isInLine(point2.endPoint, point2.startPoint, point2, point2.reversePoint);
    }
    static getReversePoint(start, end) {
      const [x, y] = lerp([], [end.x, end.y, 0], [start.x, start.y, 0], 2);
      return { x, y };
    }
    static getIndexPoint(points, index2) {
      return points[index2];
    }
    static getPoint(points, p0) {
      return points.filter((p) => {
        return Point.isEqual(p.startPoint, p0);
      })[0];
    }
    static getIndex(points, p0) {
      var firstIndex = -1;
      for (var i = 0, len2 = points.length; i < len2; i++) {
        var p = points[i];
        if (Point.isEqual(p.startPoint, p0)) {
          firstIndex = i;
          break;
        }
      }
      return firstIndex;
    }
    static getGroupList(points) {
      const groupList = [];
      let groupIndex = 0;
      points.forEach((point2, index2) => {
        if (point2.command === "M") {
          groupList.push({ point: point2, index: index2, groupIndex: groupIndex++ });
        }
      });
      return groupList;
    }
    static getSplitedGroupList(points) {
      const localPoints = sapa.clone(points);
      const splitedGroupList = [];
      for (var i = 0, groupIndex = -1, len2 = localPoints.length; i < len2; i++) {
        const point2 = localPoints[i];
        if (point2.command === "M") {
          groupIndex++;
          splitedGroupList[groupIndex] = {
            startPointIndex: i,
            point: point2,
            points: []
          };
        }
        splitedGroupList[groupIndex].points.push(point2);
      }
      return splitedGroupList;
    }
    static getGroup(groupList, pointIndex) {
      const list = groupList.filter((group) => group.point.index <= pointIndex);
      return list.pop();
    }
    static getGroupIndex(points, index2) {
      var groupIndex = -1;
      for (var i = 0, len2 = points.length; i < len2; i++) {
        if (points[i].command === "M") {
          groupIndex++;
        }
        if (points[i].index === index2) {
          return groupIndex;
        }
      }
    }
    static getLastPoint(points, index2) {
      if (!points.length)
        return null;
      var lastIndex = -1;
      for (var i = index2 + 1, len2 = points.length; i < len2; i++) {
        if (points[i].command === "M") {
          lastIndex = i - 1;
          break;
        }
      }
      if (lastIndex == -1) {
        lastIndex = points.length - 1;
      }
      if (points[lastIndex] && points[lastIndex].command === "Z") {
        lastIndex -= 1;
      }
      var point2 = points[lastIndex];
      if (point2) {
        point2.index = lastIndex;
      }
      return point2;
    }
    static getFirstPoint(points, index2) {
      var firstIndex = -1;
      for (var i = index2 - 1; i > 0; i--) {
        if (points[i].command === "M") {
          firstIndex = i;
          break;
        }
      }
      if (firstIndex === -1) {
        firstIndex = 0;
      }
      var point2 = points[firstIndex];
      if (point2) {
        point2.index = firstIndex;
      }
      return point2;
    }
    static getConnectedPointList(points, index2) {
      const current = points[index2];
      return points.filter((p, i) => i !== index2 && Point.isEqual(p.startPoint, current.startPoint));
    }
    static getPrevPoint(points, index2) {
      var prevIndex = index2 - 1;
      if (prevIndex < 0) {
        return Point.getLastPoint(points, index2);
      }
      var point2 = points[prevIndex];
      if (point2) {
        point2.index = prevIndex;
      }
      return point2;
    }
    static getNextPoint(points, index2) {
      var currentPoint = points[index2];
      var nextPoint = points[index2 + 1];
      if (nextPoint) {
        nextPoint.index = index2 + 1;
      }
      if (currentPoint.connected || currentPoint.close) {
        nextPoint = Point.getFirstPoint(points, index2);
      }
      return nextPoint;
    }
    static removePoint(points, pIndex, segment) {
      if (segment === "startPoint") {
        return points.filter((_, index2) => index2 !== pIndex);
      }
    }
    static splitPoints(points) {
      let splitedPointGroup = [];
      let lastPoints = [];
      points.forEach((p) => {
        if (Point.isFirst(p)) {
          lastPoints = [p];
          splitedPointGroup.push(lastPoints);
        } else {
          lastPoints.push(p);
        }
      });
      return splitedPointGroup;
    }
    static recoverPoints(pointGroup) {
      const newPoints = [];
      pointGroup.forEach((points) => {
        points.forEach((p, index2) => {
          if (index2 === 0) {
            p.command = "M";
            p.originalCommand = "M";
          }
        });
        newPoints.push.apply(newPoints, points);
      });
      newPoints.forEach((p, index2) => {
        p.index = index2;
      });
      return newPoints;
    }
  }
  class Segment {
    static M(x, y) {
      return {
        command: "M",
        values: [x, y]
      };
    }
    static L(x, y) {
      return {
        command: "L",
        values: [x, y]
      };
    }
    static Q(x1, y1, x, y) {
      return {
        command: "Q",
        values: [x1, y1, x, y]
      };
    }
    static C(x1, y1, x2, y2, x, y) {
      return {
        command: "C",
        values: [x1, y1, x2, y2, x, y]
      };
    }
    static A(rx, ry, xrot, laf, sf, x, y) {
      return {
        command: "A",
        values: [rx, ry, xrot, laf, sf, x, y]
      };
    }
    static Z() {
      return {
        command: "Z",
        values: []
      };
    }
    static isMoveTo(segment) {
      return segment.command === "M";
    }
    static isLineTo(segment) {
      return segment.command === "L";
    }
    static isQuadraticBezierCurve(segment) {
      return segment.command === "Q";
    }
    static isCubicBezierCurve(segment) {
      return segment.command === "C";
    }
    static isArc(segment) {
      return segment.command === "A";
    }
    static isClosePath(segment) {
      return segment.command === "Z";
    }
  }
  function randomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function round(n, k) {
    k = typeof k === "undefined" ? 1 : k;
    return Math.round(n * k) / k;
  }
  function area(x, y, areaWidth = 100) {
    const column = x < 0 ? Math.floor(x / areaWidth) : Math.ceil(x / areaWidth);
    const row = y < 0 ? Math.floor(y / areaWidth) : Math.ceil(y / areaWidth);
    return [row, column];
  }
  function degreeToRadian(degrees) {
    return degrees * (Math.PI / 180);
  }
  function div(num, divNum = 1) {
    return num === 0 ? 0 : num / divNum;
  }
  function radianToDegree(radian) {
    var angle = radian * (180 / Math.PI);
    if (angle < 0) {
      angle = 360 + angle;
    }
    return angle;
  }
  function getXInCircle(angle, radius, centerX = 0) {
    return centerX + radius * Math.cos(degreeToRadian(angle));
  }
  function getYInCircle(angle, radius, centerY = 0) {
    return centerY + radius * Math.sin(degreeToRadian(angle));
  }
  function getXYInCircle(angle, radius, centerX = 0, centerY = 0) {
    return {
      x: getXInCircle(angle, radius, centerX),
      y: getYInCircle(angle, radius, centerY)
    };
  }
  function getDist(x, y, centerX = 0, centerY = 0) {
    return distance([x, y], [centerX, centerY]);
  }
  function getPointBetweenVerties(start, end, pointDist = 0) {
    return lerp([], start, end, 1 + pointDist / dist(start, end));
  }
  function vertiesMap(verties, transformView) {
    if (verties.length === 1) {
      return [transformMat4([], verties[0], transformView)];
    } else if (verties.length === 2) {
      return [
        transformMat4([], verties[0], transformView),
        transformMat4([], verties[1], transformView)
      ];
    } else if (verties.length === 3) {
      return [
        transformMat4([], verties[0], transformView),
        transformMat4([], verties[1], transformView),
        transformMat4([], verties[2], transformView)
      ];
    } else if (verties.length === 4) {
      return [
        transformMat4([], verties[0], transformView),
        transformMat4([], verties[1], transformView),
        transformMat4([], verties[2], transformView),
        transformMat4([], verties[3], transformView)
      ];
    } else if (verties.length === 5) {
      return [
        transformMat4([], verties[0], transformView),
        transformMat4([], verties[1], transformView),
        transformMat4([], verties[2], transformView),
        transformMat4([], verties[3], transformView),
        transformMat4([], verties[4], transformView)
      ];
    }
    return verties.map((v) => {
      return transformMat4([], v, transformView);
    });
  }
  function getTargetPointX(source, target, axis, nextTarget) {
    return [
      source,
      [target[0], source[1], target[2]],
      axis,
      Math.abs(source[0] - target[0]),
      nextTarget
    ];
  }
  function getTargetPointY(source, target, axis, nextTarget) {
    return [
      [target[0], source[1], source[2]],
      target,
      axis,
      Math.abs(source[1] - target[1]),
      nextTarget
    ];
  }
  function invertTargetPoint(arr, isInvert = false) {
    if (isInvert === false)
      return arr;
    const [source, target, axis, dist2, newTarget, sourceVerties, targetVerties] = arr;
    if (newTarget) {
      return [
        [target[0], newTarget[1], target[2]],
        [source[0], newTarget[1], source[2]],
        axis,
        dist2,
        [source[0], source[1], newTarget[2]],
        sourceVerties,
        targetVerties,
        isInvert
      ];
    } else {
      return [
        target,
        source,
        axis,
        dist2,
        newTarget,
        sourceVerties,
        targetVerties,
        isInvert
      ];
    }
  }
  function makeGuidePoint(sourceVerties, targetVerties) {
    let leftVerties = sourceVerties;
    let rightVerties = targetVerties;
    let hasInvert = false;
    if (sourceVerties[4][0] - targetVerties[4][0] > 0) {
      leftVerties = targetVerties;
      rightVerties = sourceVerties;
      hasInvert = true;
    }
    const leftCenter = lerp([], leftVerties[1], leftVerties[2], 0.5);
    const rightCenter = lerp([], rightVerties[0], rightVerties[3], 0.5);
    let pointList = [];
    if (rightVerties[0][1] <= leftCenter[1] && leftCenter[1] <= rightVerties[3][1]) {
      pointList.push(getTargetPointX(leftCenter, rightCenter, "x", null));
    } else if (rightVerties[0][1] <= leftVerties[1][1]) {
      if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
        pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y", null));
      } else {
        pointList.push(getTargetPointX(leftVerties[1], rightCenter, "x", rightVerties[3]));
      }
    } else if (leftVerties[3][0] <= rightVerties[0][0] && rightVerties[0][0] <= leftVerties[2][0]) {
      pointList.push(getTargetPointY(leftVerties[3], rightVerties[0], "y"));
    } else if (rightVerties[3][0] <= leftVerties[0][0] && leftVerties[0][0] <= rightVerties[2][0]) {
      pointList.push(getTargetPointY([rightVerties[0][0], leftVerties[3][1], leftVerties[3][2]], rightVerties[0], "y"));
    } else if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
      pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y"));
    } else {
      pointList.push(getTargetPointX(leftVerties[2], rightCenter, "x", rightVerties[0]));
    }
    pointList.sort((a, b) => {
      return a[3] - b[3];
    });
    return invertTargetPoint([...pointList[0], sourceVerties, targetVerties], hasInvert);
  }
  function getVertiesMaxX(verties) {
    let maxValue = Number.MIN_SAFE_INTEGER;
    verties.forEach((v) => {
      maxValue = Math.max(v[0], maxValue);
    });
    return maxValue;
  }
  function getVertiesMaxY(verties) {
    let maxValue = Number.MIN_SAFE_INTEGER;
    verties.forEach((v) => {
      maxValue = Math.max(v[1], maxValue);
    });
    return maxValue;
  }
  function getVertiesMinX(verties) {
    let maxValue = Number.MAX_SAFE_INTEGER;
    verties.forEach((v) => {
      maxValue = Math.min(v[0], maxValue);
    });
    return maxValue;
  }
  function getVertiesCenterX(verties) {
    let minX = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    verties.forEach((v) => {
      minX = Math.min(v[0], minX);
      maxX = Math.max(v[0], maxX);
    });
    return Math.round((minX + maxX) / 2);
  }
  function getVertiesMinY(verties) {
    let maxValue = Number.MAX_SAFE_INTEGER;
    verties.forEach((v) => {
      maxValue = Math.min(v[1], maxValue);
    });
    return maxValue;
  }
  function getVertiesCenterY(verties) {
    let minY = Number.MAX_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    verties.forEach((v) => {
      minY = Math.min(v[1], minY);
      maxY = Math.max(v[1], maxY);
    });
    return Math.round((minY + maxY) / 2);
  }
  function calculateAngle(rx, ry) {
    return radianToDegree(Math.atan2(ry, rx));
  }
  function calculateAngleForVec3(point2, center, dist2) {
    return calculateAnglePointDistance({ x: point2[0], y: point2[1] }, { x: center[0], y: center[1] }, { dx: dist2[0], dy: dist2[1] });
  }
  function calculateRotationOriginMat4(angle, origin) {
    const view = create$4();
    translate(view, view, origin);
    rotateZ(view, view, degreeToRadian(angle));
    translate(view, view, negate([], origin));
    return view;
  }
  function calculateMatrix(...args2) {
    const view = create$4();
    args2.forEach((v) => {
      multiply$1(view, view, v);
    });
    return view;
  }
  function calculateMatrixInverse(...args2) {
    return invert([], calculateMatrix(...args2));
  }
  function calculateAnglePointDistance(point2, center, dist2) {
    var x = point2.x - center.x;
    var y = point2.y - center.y;
    var angle1 = calculateAngle(x, y);
    var x2 = point2.x + dist2.dx - center.x;
    var y2 = point2.y + dist2.dy - center.y;
    var angle = calculateAngle(x2, y2) - angle1;
    return angle;
  }
  function calculateAngle360(rx, ry) {
    return (calculateAngle(rx, ry) + 180) % 360;
  }
  const UUID_REG = /[xy]/g;
  function uuid() {
    var dt = new Date().getTime();
    var uuid2 = "xxx12-xx-34xx".replace(UUID_REG, function(c) {
      var r = (dt + Math.random() * 16) % 16 | 0;
      dt = Math.floor(dt / 16);
      return (c == "x" ? r : r & 3 | 8).toString(16);
    });
    return uuid2;
  }
  function uuidShort() {
    var dt = new Date().getTime();
    var uuid2 = "idxxxxxxx".replace(UUID_REG, function(c) {
      var r = (dt + Math.random() * 16) % 16 | 0;
      dt = Math.floor(dt / 16);
      return (c == "x" ? r : r & 3 | 8).toString(16);
    });
    return uuid2;
  }
  const splitReg$1 = /[\b\t ,\n]/g;
  function normalize(str) {
    return str.trim().split(splitReg$1).filter((it) => it).map((it) => +it);
  }
  const MAX_CACHE_COUNT$2 = 1e3;
  const cachedTransformOriginMap = /* @__PURE__ */ new Map();
  class TransformOriginCache {
    static has(key) {
      return cachedTransformOriginMap.has(key);
    }
    static get(key) {
      return cachedTransformOriginMap.get(key);
    }
    static set(key, parsedValue) {
      if (cachedTransformOriginMap.size > MAX_CACHE_COUNT$2) {
        cachedTransformOriginMap.clear();
      }
      cachedTransformOriginMap.set(key, parsedValue);
    }
  }
  class TransformOrigin {
    static parseStyle(transformOrigin = "50% 50% 0px") {
      if (TransformOriginCache.has(transformOrigin)) {
        return TransformOriginCache.get(transformOrigin);
      }
      const origins = transformOrigin.trim().split(" ").filter((it) => it.trim());
      let parsedTransformOrigin = null;
      if (origins.length === 1) {
        parsedTransformOrigin = [origins[0], origins[0]].map((it) => editor.Length.parse(it));
      } else {
        parsedTransformOrigin = origins.map((it) => editor.Length.parse(it));
      }
      TransformOriginCache.set(transformOrigin, parsedTransformOrigin);
      return parsedTransformOrigin;
    }
    static scale(transformOrigin, width2, height) {
      let parsedTransformOrigin = TransformOrigin.parseStyle(transformOrigin);
      if (width2 === 0 && height === 0) {
        return [0, 0, 0];
      }
      const originX = parsedTransformOrigin[0].toPx(width2).value;
      const originY = parsedTransformOrigin[1].toPx(height).value;
      const originZ = parsedTransformOrigin[2].value;
      return [originX, originY, originZ];
    }
    static toPx(transformOrigin, width2, height, distance2 = 0) {
      let [transformOriginX, transformOriginY, transformOriginZ] = TransformOrigin.parseStyle(transformOrigin);
      transformOriginX = transformOriginX.toPx(width2);
      transformOriginY = transformOriginY.toPx(height);
      transformOriginZ = transformOriginZ.toPx(distance2);
      return `${transformOriginX} ${transformOriginY} ${transformOriginZ}`;
    }
  }
  class Rect {
    constructor(x, y, width2, height) {
      this.x = x;
      this.y = y;
      this.width = width2;
      this.height = height;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    get centerX() {
      return this.x + this.width / 2;
    }
    get centerY() {
      return this.y + this.height / 2;
    }
    get center() {
      return [this.centerX, this.centerY];
    }
    get topLeft() {
      return [this.left, this.top];
    }
    get topRight() {
      return [this.right, this.top];
    }
    get bottomLeft() {
      return [this.left, this.bottom];
    }
    get bottomRight() {
      return [this.right, this.bottom];
    }
    get vertices() {
      return [this.topLeft, this.topRight, this.bottomLeft, this.bottomRight];
    }
    intersect(rect2) {
      return intersectRectRect(this, rect2);
    }
  }
  function intersectRectRect(rect1, rect2) {
    const minRectX = Math.min(rect1.x, rect2.x);
    const minRectY = Math.min(rect1.y, rect2.y);
    const rect1Verties = rectToVerties(rect1.x - minRectX, rect1.y - minRectY, rect1.width, rect1.height);
    const rect2Verties = rectToVerties(rect2.x - minRectX, rect2.y - minRectY, rect2.width, rect2.height);
    const startPoint = [
      Math.max(rect1Verties[0][0], rect2Verties[0][0]),
      Math.max(rect1Verties[0][1], rect2Verties[0][1]),
      Math.max(rect1Verties[0][2], rect2Verties[0][2])
    ];
    const endPoint = [
      Math.min(rect1Verties[2][0], rect2Verties[2][0]),
      Math.min(rect1Verties[2][1], rect2Verties[2][1]),
      Math.min(rect1Verties[2][2], rect2Verties[2][2])
    ];
    const minX = Math.min(startPoint[0], endPoint[0]);
    const minY = Math.min(startPoint[1], endPoint[1]);
    const maxX = Math.max(startPoint[0], endPoint[0]);
    const maxY = Math.max(startPoint[1], endPoint[1]);
    return new Rect(minX + minRectX, minY + minRectY, maxX - minX, maxY - minY);
  }
  function linePoint(x1, y1, x2, y2, px, py, buffer = 0.1) {
    const dist1 = Math.hypot(px - x1, py - y1);
    const dist2 = Math.hypot(px - x2, py - y2);
    const lineLength = Math.hypot(x1 - x2, y1 - y2);
    const calcDist = dist1 + dist2;
    return calcDist >= lineLength - buffer && calcDist <= lineLength + buffer;
  }
  function lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
    let A = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
    let B = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
    return 0 <= A && A <= 1 && 0 <= B && B <= 1;
  }
  function lineLine(x1, y1, x2, y2, x3, y3, x4, y4, epsilon) {
    if (linePoint(x1, y1, x2, y2, x3, y3))
      return true;
    else if (linePoint(x1, y1, x2, y2, x4, y4))
      return true;
    else if (linePoint(x3, y3, x4, y4, x1, y1))
      return [x1, y1];
    else if (linePoint(x3, y3, x4, y4, x2, y2))
      return [x2, y2];
    return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
  }
  function polyPoint(verties = [], px, py, withoutPoint = false) {
    let isCollision = false;
    const len2 = verties.length;
    if (withoutPoint === false) {
      for (let i = 0; i < len2; i++) {
        const v1 = verties[i];
        const v2 = verties[(i + 1) % len2];
        if (linePoint(v1[0], v1[1], v2[0], v2[1], px, py)) {
          isCollision = true;
          break;
        }
      }
    }
    if (isCollision)
      return true;
    verties.forEach((vector, index2) => {
      const [cx, cy] = vector;
      const [nx, ny] = verties[(index2 + 1) % len2];
      if ((cy >= py && ny < py || cy < py && ny >= py) && px < (nx - cx) * (py - cy) / (ny - cy) + cx) {
        isCollision = !isCollision;
      }
    });
    return isCollision;
  }
  function polyLine(verties = [], x1, y1, x2, y2, withoutPoint = false) {
    const len2 = verties.length;
    return verties.some((vector, index2) => {
      const [x3, y3] = vector;
      const [x4, y4] = verties[(index2 + 1) % len2];
      if (withoutPoint) {
        return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
      } else {
        return lineLine(x1, y1, x2, y2, x3, y3, x4, y4);
      }
    });
  }
  function polyPoly(verties = [], targetVerties = [], withoutPoint = false) {
    const len2 = verties.length;
    return verties.some((vector, index2) => {
      const [x1, y1] = vector;
      const [x2, y2] = verties[(index2 + 1) % len2];
      let collision = polyLine(targetVerties, x1, y1, x2, y2, withoutPoint);
      if (collision)
        return true;
      collision = polyPoint(verties, targetVerties[0][0], targetVerties[0][1], withoutPoint);
      if (collision)
        return true;
      return false;
    });
  }
  function rectToVerties(x, y, width2, height, origin = "50% 50% 0px") {
    const center = TransformOrigin.scale(origin, width2, height);
    return [
      [x, y, 0],
      [x + width2, y, 0],
      [x + width2, y + height, 0],
      [x, y + height, 0],
      [x + center[0], y + center[1], 0]
    ];
  }
  function getRotatePointer(verties, dist2) {
    const topPointer = lerp([], verties[0], verties[1], 0.5);
    const bottomPointer = lerp([], verties[2], verties[3], 0.5);
    const rotatePointer = getPointBetweenVerties(bottomPointer, topPointer, dist2);
    return rotatePointer;
  }
  function itemsToRectVerties(items = []) {
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    const xList = [];
    const yList = [];
    items.forEach((item) => {
      item.originVerties.forEach((vector) => {
        xList.push(vector[0]);
        yList.push(vector[1]);
      });
    });
    minX = Math.min.apply(Math, xList);
    maxX = Math.max.apply(Math, xList);
    minY = Math.min.apply(Math, yList);
    maxY = Math.max.apply(Math, yList);
    if (minX === Number.MAX_SAFE_INTEGER)
      minX = 0;
    if (minY === Number.MAX_SAFE_INTEGER)
      minY = 0;
    if (maxX === Number.MIN_SAFE_INTEGER)
      maxX = 0;
    if (maxY === Number.MIN_SAFE_INTEGER)
      maxY = 0;
    return rectToVerties(minX, minY, maxX - minX, maxY - minY);
  }
  function targetItemsToRectVerties(items = []) {
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    const xList = [];
    const yList = [];
    items.forEach((item) => {
      item.targetVerties.forEach((vector) => {
        xList.push(vector[0]);
        yList.push(vector[1]);
      });
    });
    minX = Math.min.apply(Math, xList);
    maxX = Math.max.apply(Math, xList);
    minY = Math.min.apply(Math, yList);
    maxY = Math.max.apply(Math, yList);
    if (minX === Number.MAX_SAFE_INTEGER)
      minX = 0;
    if (minY === Number.MAX_SAFE_INTEGER)
      minY = 0;
    if (maxX === Number.MIN_SAFE_INTEGER)
      maxX = 0;
    if (maxY === Number.MIN_SAFE_INTEGER)
      maxY = 0;
    return rectToVerties(minX, minY, maxX - minX, maxY - minY);
  }
  function vertiesToRectangle(verties) {
    const x = verties[0][0];
    const y = verties[0][1];
    const width2 = dist(verties[0], verties[1]);
    const height = dist(verties[0], verties[3]);
    return new Rect(x, y, width2, height);
  }
  function vertiesToPath(verties = []) {
    const results = [];
    for (var i = 0; i < verties.length; i++) {
      if (i === 0) {
        results.push(`M ${verties[i][0]} ${verties[i][1]}`);
      } else {
        results.push(`L ${verties[i][0]} ${verties[i][1]}`);
      }
    }
    if (results.length) {
      results.push("Z");
    }
    return results.join(" ");
  }
  function toRectVertiesWithoutTransformOrigin(verties) {
    return toRectVerties(verties).filter((it, index2) => {
      return index2 < 4;
    });
  }
  function toRectVerties(verties) {
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    const xList = [];
    const yList = [];
    verties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
    minX = Math.min.apply(Math, xList);
    maxX = Math.max.apply(Math, xList);
    minY = Math.min.apply(Math, yList);
    maxY = Math.max.apply(Math, yList);
    if (minX === Number.MAX_SAFE_INTEGER)
      minX = 0;
    if (minY === Number.MAX_SAFE_INTEGER)
      minY = 0;
    if (maxX === Number.MIN_SAFE_INTEGER)
      maxX = 0;
    if (maxY === Number.MIN_SAFE_INTEGER)
      maxY = 0;
    return rectToVerties(minX, minY, maxX - minX, maxY - minY);
  }
  const predefinedBezier = {
    linear: true,
    ease: true,
    "ease-in": true,
    "ease-out": true,
    "ease-in-out": true
  };
  const bezierObj = {
    ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)"
  };
  const bezierList = [
    [0, 0, 1, 1, "linear", true],
    [0.25, 0.1, 0.25, 1, "ease", true],
    [0.42, 0, 1, 1, "ease-in", true],
    [0, 0, 0.58, 1, "ease-out", true],
    [0.47, 0, 0.745, 0.715, "ease-in-sine"],
    [0.39, 0.575, 0.565, 1, "ease-out-sine"],
    [0.445, 0.05, 0.55, 0.95, "ease-in-out-sine"],
    [0.55, 0.085, 0.68, 0.53, "ease-in-quad"],
    [0.25, 0.46, 0.45, 0.94, "ease-out-quad"],
    [0.455, 0.03, 0.515, 0.955, "ease-in-out-quad"],
    [0.55, 0.055, 0.675, 0.19, "ease-in-cubic"],
    [0.215, 0.61, 0.355, 1, "ease-out-cubic"],
    [0.645, 0.045, 0.355, 1, "ease-in-out-cubic"],
    [0.895, 0.03, 0.685, 0.22, "ease-in-quart"],
    [0.165, 0.84, 0.44, 1, "ease-out-quart"],
    [0.77, 0, 0.175, 1, "ease-in-out-quart"],
    [0.6, 0.04, 0.98, 0.335, "ease-in-circ"],
    [0.075, 0.82, 0.165, 1, "ease-out-circ"],
    [0.785, 0.135, 0.15, 0.86, "ease-in-out-circ"],
    [0.95, 0.05, 0.795, 0.035, "ease-in-expo"],
    [0.19, 1, 0.22, 1, "ease-out-expo"],
    [1, 0, 0, 1, "ease-in-out-expo"],
    [0.755, 0.05, 0.855, 0.06, "ease-in-quint"],
    [0.23, 1, 0.32, 1, "ease-out-quint"],
    [0.86, 0, 0.07, 1, "ease-in-out-quint"],
    [0.6, -0.28, 0.735, 0.045, "ease-in-back"],
    [0.175, 0.885, 0.32, 1.275, "ease-out-back"],
    [0.68, -0.55, 0.265, 1.55, "ease-in-out-back"]
  ];
  const getPredefinedCubicBezier = (str) => {
    return [...parseCubicBezier(bezierObj[str] || str)];
  };
  const formatCubicBezier = (arr) => {
    arr = arr.map((it) => Math.floor(it * 100) / 100);
    for (var i = 0, len2 = bezierList.length; i < len2; i++) {
      var bezier = bezierList[i];
      if (bezier[0] == arr[0] && bezier[1] == arr[1] && bezier[2] == arr[2] && bezier[3] == arr[3] && bezier[5]) {
        return bezier[4];
      }
    }
    return `cubic-bezier( ${arr.filter((_, index2) => index2 < 4).join(",")} )`;
  };
  function parseCubicBezier(str) {
    if (typeof str == "string") {
      if (predefinedBezier[str]) {
        return bezierList.filter((it) => it[4] === str)[0];
      } else {
        var arr = str.replace("cubic-bezier", "").replace("(", "").replace(")", "").split(",");
        arr = arr.map((it) => parseFloat(it.trim()));
        return arr;
      }
    }
    return str;
  }
  const createBezier = (C1, C2, C3, C4) => {
    var points = [C1, C2, C3, C4];
    return function(t) {
      return getBezierPointOne(points, t);
    };
  };
  const createBezierQuard = (C1, C2, C3) => {
    var points = [C1, C2, C3];
    return function(t) {
      return getBezierPointOneQuard(points, t);
    };
  };
  const createBezierLine = (C1, C2) => {
    var points = [C1, C2];
    return function(t) {
      return getBezierPointOneLine(points, t);
    };
  };
  const checkDist = (obj2, curve, t, x, y) => {
    var p = curve(t);
    var dist2 = getDist(x, y, p.x, p.y);
    if (dist2 < obj2.minDist) {
      obj2.minDist = dist2;
      obj2.minT = t;
    }
  };
  const getPolygonalDist = (points = []) => {
    let total = 0;
    points.forEach((point2, index2) => {
      var next = points[index2 + 1];
      if (!next) {
        return;
      }
      var dist$1 = dist(fromValues(point2.x, point2.y, 0), fromValues(next.x, next.y, 0));
      total += dist$1;
    });
    return total;
  };
  const getCurveDist = (sx, sy, cx1, cy1, cx2, cy2, ex, ey, count = 1e3) => {
    var curve = createBezier({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: cx2, y: cy2 }, { x: ex, y: ey });
    var total = 0;
    var startPoint = curve(0);
    for (var i = 0; i <= count; i++) {
      var t = i / count;
      var xy2 = curve(t);
      total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
      startPoint = xy2;
    }
    return total;
  };
  const getQuardDist = (sx, sy, cx1, cy1, ex, ey, count = 1e3) => {
    var curve = createBezierQuard({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: ex, y: ey });
    var total = 0;
    var startPoint = curve(0);
    for (var i = 0; i <= count; i++) {
      var t = i / count;
      var xy2 = curve(t);
      total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
      startPoint = xy2;
    }
    return total;
  };
  const makeCurveFunction = (curve, count = 10) => {
    var obj2 = {
      minDist: Infinity,
      minT: 0
    };
    return function(x, y) {
      for (var i = 0; i <= count; i++) {
        checkDist(obj2, curve, i / count, x, y);
      }
      var step2 = 1 / (count * 2);
      var t = obj2.minT;
      for (var i = 0; i < count; i++) {
        checkDist(obj2, curve, Math.max(0, t - step2), x, y);
        checkDist(obj2, curve, Math.min(1, t + step2), x, y);
        step2 /= 2;
      }
      return obj2.minT;
    };
  };
  const recoverBezier = (C1, C2, C3, C4, count = 20) => {
    return makeCurveFunction(createBezier(C1, C2, C3, C4), count);
  };
  const recoverBezierQuard = (C1, C2, C3, count = 20) => {
    return makeCurveFunction(createBezierQuard(C1, C2, C3), count);
  };
  const recoverBezierLine = (C1, C2, count = 20) => {
    return makeCurveFunction(createBezierLine(C1, C2), count);
  };
  const createBezierForPattern = (bezierString) => {
    if (bezierString === "linear") {
      var C1 = { x: 0, y: 0 };
      var C2 = { x: 1, y: 1 };
      return createBezierLine(C1, C2);
    }
    var bezierList2 = parseCubicBezier(bezierString);
    var C1 = { x: 0, y: 0 };
    var C2 = { x: bezierList2[0], y: bezierList2[1] };
    var C3 = { x: bezierList2[2], y: bezierList2[3] };
    var C4 = { x: 1, y: 1 };
    return createBezier(C1, C2, C3, C4);
  };
  const interpolate = (p1, p2, t) => {
    return {
      x: p1.x + (p2.x - p1.x) * t,
      y: p1.y + (p2.y - p1.y) * t
    };
  };
  const getBezierPointOne = (points, t) => {
    var p0 = interpolate(points[0], points[1], t);
    var p1 = interpolate(points[1], points[2], t);
    var p2 = interpolate(points[2], points[3], t);
    var p3 = interpolate(p0, p1, t);
    var p4 = interpolate(p1, p2, t);
    return interpolate(p3, p4, t);
  };
  const getBezierPointOneQuard = (points, t) => {
    var p0 = interpolate(points[0], points[1], t);
    var p1 = interpolate(points[1], points[2], t);
    return interpolate(p0, p1, t);
  };
  const getBezierPointOneLine = (points, t) => {
    return interpolate(points[0], points[1], t);
  };
  const getBezierPoints = (points, t) => {
    var p0 = interpolate(points[0], points[1], t);
    var p1 = interpolate(points[1], points[2], t);
    var p2 = interpolate(points[2], points[3], t);
    var p3 = interpolate(p0, p1, t);
    var p4 = interpolate(p1, p2, t);
    var p5 = interpolate(p3, p4, t);
    return {
      first: [points[0], p0, p3, p5],
      second: [p5, p4, p2, points[3]]
    };
  };
  const getBezierPointsQuard = (points, t) => {
    var p0 = interpolate(points[0], points[1], t);
    var p1 = interpolate(points[1], points[2], t);
    var p2 = interpolate(p0, p1, t);
    return {
      first: [points[0], p0, p2],
      second: [p2, p1, points[2]]
    };
  };
  const splitBezierPointsByCount = (points, count = 1) => {
    var result = [];
    while (count > 0) {
      const curve = getBezierPoints(points, 1 / count);
      result.push(curve.first);
      points = curve.second;
      count--;
    }
    return result;
  };
  const splitBezierPointsQuardByCount = (points, count = 1) => {
    var result = [];
    while (count > 0) {
      const curve = getBezierPointsQuard(points, 1 / count);
      result.push(curve.first);
      points = curve.second;
      count--;
    }
    return result;
  };
  const splitBezierPointsLineByCount = (points, count = 1) => {
    var result = [];
    const unit = 1 / count;
    while (count > 0) {
      const curve = getBezierPointsLine(points, unit);
      result.push(curve.first);
      points = curve.second;
      count--;
    }
    return result;
  };
  const getBezierPointsLine = (points, t) => {
    var p0 = interpolate(points[0], points[1], t);
    return {
      first: [points[0], p0],
      second: [p0, points[1]]
    };
  };
  const normalizeCurveForLine = (points) => {
    return [
      clone(points[0]),
      [
        points[0][0] + (points[1][0] - points[0][0]) * 0.33,
        points[0][1] + (points[1][1] - points[0][1]) * 0.33,
        0
      ],
      [
        points[0][0] + (points[1][0] - points[0][0]) * 0.66,
        points[0][1] + (points[1][1] - points[0][1]) * 0.66,
        0
      ],
      clone(points[1])
    ];
  };
  const normalizeCurveForQuard = (points) => {
    const twoOfThree = 2 / 3;
    return [
      clone(points[0]),
      fromValues(points[0][0] + twoOfThree * (points[1][0] - points[0][0]), points[0][1] + twoOfThree * (points[1][1] - points[0][1]), 0),
      fromValues(points[2][0] + twoOfThree * (points[1][0] - points[2][0]), points[2][1] + twoOfThree * (points[1][1] - points[2][1]), 0),
      clone(points[2])
    ];
  };
  const polygonalForCurve = (c1, c2, c3, c4, count = 1e3) => {
    const totalLength = getCurveDist(c1[0], c1[1], c2[0], c2[1], c3[0], c3[1], c4[0], c4[1], count);
    let samplingCount = 10;
    let samplingStep = totalLength / samplingCount;
    let lastLength = 0;
    let points = [];
    const bezierPoints = [c1, c2, c3, c4].map((point2) => ({
      x: point2[0],
      y: point2[1]
    }));
    do {
      points = [];
      let currentLength = 0;
      for (let i = 0; i <= samplingCount; i++) {
        const nextPoint = getBezierPointOne(bezierPoints, currentLength / totalLength);
        points.push(nextPoint);
        currentLength += samplingStep;
      }
      lastLength = getPolygonalDist(points);
      samplingCount += samplingCount * (totalLength - lastLength) / totalLength;
      samplingStep = totalLength / samplingCount;
    } while (totalLength - lastLength > 0.25);
    return points.map((point2) => fromValues(point2.x, point2.y, 0));
  };
  const calculateA = (points) => {
    const a1 = negate([], points[0]);
    const a2 = multiply([], [3, 3, 3], points[1]);
    const a3 = multiply([], [-3, -3, -3], points[2]);
    const a4 = points[3];
    const newP = add([], add([], a1, a2), add([], a3, a4));
    return multiply([], [3, 3, 3], newP);
  };
  const calculateB = (points) => {
    const b1 = points[0];
    const b2 = multiply([], [-2, -2, -2], points[1]);
    const b3 = points[2];
    const newP = add([], add([], b1, b2), b3);
    return multiply([], [6, 6, 6], newP);
  };
  const calculateC = (points) => {
    const newP = add([], points[1], negate([], points[0]));
    return multiply([], [3, 3, 3], newP);
  };
  const findRootForCurve = (points) => {
    const a = calculateA(points);
    const b = calculateB(points);
    const c = calculateC(points);
    const roots = [];
    const distX = b[0] * b[0] - 4 * a[0] * c[0];
    if (distX < 0)
      ;
    else if (distX === 0) {
      let rootX = -b[0] / (2 * a[0]);
      if (isNaN(rootX))
        rootX = 0;
      if (0 <= rootX && rootX <= 1) {
        roots.push(rootX);
      }
    } else if (distX > 0) {
      const rootX1 = (-b[0] + Math.sqrt(distX)) / (2 * a[0]);
      const rootX2 = (-b[0] - Math.sqrt(distX)) / (2 * a[0]);
      if (0 <= rootX1 && rootX1 <= 1) {
        roots.push(rootX1);
      }
      if (0 <= rootX2 && rootX2 <= 1) {
        roots.push(rootX2);
      }
    }
    const distY = b[1] * b[1] - 4 * a[1] * c[1];
    if (distY < 0)
      ;
    else if (distY === 0) {
      let rootY = -b[1] / (2 * a[1]);
      if (isNaN(rootY))
        rootY = 0;
      if (0 <= rootY && rootY <= 1) {
        roots.push(rootY);
      }
    } else if (distY > 0) {
      const rootY1 = (-b[1] + Math.sqrt(distY)) / (2 * a[1]);
      const rootY2 = (-b[1] - Math.sqrt(distY)) / (2 * a[1]);
      if (0 <= rootY1 && rootY1 <= 1) {
        roots.push(rootY1);
      }
      if (0 <= rootY2 && rootY2 <= 1) {
        roots.push(rootY2);
      }
    }
    return roots;
  };
  const getCurveBBox = (points) => {
    const roots = findRootForCurve(points);
    const xyPoints = points.map((p) => {
      return { x: p[0], y: p[1] };
    });
    roots.push(0, 1);
    return roots.map((t) => {
      const { x, y } = getBezierPointOne(xyPoints, t);
      return [x, y, 0];
    });
  };
  const ConstraintsDirection = {
    HORIZONTAL: "constraints-horizontal",
    VERTICAL: "constraints-vertical"
  };
  const Constraints = {
    NONE: "none",
    MIN: "min",
    MAX: "max",
    STRETCH: "stretch",
    SCALE: "scale",
    CENTER: "center"
  };
  const BooleanOperation = {
    DIFFERENCE: "difference",
    INTERSECTION: "intersection",
    UNION: "union",
    REVERSE_DIFFERENCE: "reverse-difference",
    XOR: "xor"
  };
  const StrokeLineCap = {
    BUTT: "butt",
    ROUND: "round",
    SQUARE: "square"
  };
  const StrokeLineJoin = {
    MITER: "miter",
    ROUND: "round",
    BEVEL: "bevel"
  };
  const BlendMode = {
    NORMAL: "normal",
    MULTIPLY: "multiply",
    SCREEN: "screen",
    OVERLAY: "overlay",
    DARKEN: "darken",
    LIGHTEN: "lighten",
    COLOR_DODGE: "color-dodge",
    COLOR_BURN: "color-burn",
    HARD_LIGHT: "hard-light",
    SOFT_LIGHT: "soft-light",
    DIFFERENCE: "difference",
    EXCLUSION: "exclusion",
    HUE: "hue",
    SATURATION: "saturation",
    COLOR: "color",
    LUMINOSITY: "luminosity"
  };
  const TextDecoration = {
    NONE: "none",
    UNDERLINE: "underline",
    OVERLINE: "overline",
    LINE_THROUGH: "line-through",
    BLINK: "blink"
  };
  const TextTransform = {
    NONE: "none",
    CAPITALIZE: "capitalize",
    UPPERCASE: "uppercase",
    LOWERCASE: "lowercase"
  };
  const TextAlign = {
    START: "start",
    END: "end",
    LEFT: "left",
    RIGHT: "right",
    CENTER: "center",
    JUSTIFY: "justify"
  };
  const Overflow = {
    VISIBLE: "visible",
    HIDDEN: "hidden",
    SCROLL: "scroll",
    AUTO: "auto"
  };
  const BorderStyle = {
    NONE: "none",
    HIDDEN: "hidden",
    DOTTED: "dotted",
    DASHED: "dashed",
    SOLID: "solid",
    DOUBLE: "double",
    GROOVE: "groove",
    RIDGE: "ridge",
    INSET: "inset",
    OUTSET: "outset"
  };
  const TransformValue = {
    NONE: "none",
    PERSPECTIVE: "perspective",
    TRANSLATE: "translate",
    TRANSLATE_X: "translateX",
    TRANSLATE_Y: "translateY",
    TRANSLATE_Z: "translateZ",
    TRANSLATE_3D: "translate3d",
    SCALE: "scale",
    SCALE_X: "scaleX",
    SCALE_Y: "scaleY",
    SCALE_Z: "scaleZ",
    SCALE_3D: "scale3d",
    ROTATE: "rotate",
    ROTATE_X: "rotateX",
    ROTATE_Y: "rotateY",
    ROTATE_Z: "rotateZ",
    SKEW: "skew",
    SKEW_X: "skewX",
    SKEW_Y: "skewY",
    MATRIX: "matrix",
    MATRIX_3D: "matrix3d"
  };
  const Layout = {
    DEFAULT: "default",
    FLEX: "flex",
    GRID: "grid"
  };
  const FlexDirection = {
    ROW: "row",
    ROW_REVERSE: "row-reverse",
    COLUMN: "column",
    COLUMN_REVERSE: "column-reverse"
  };
  const JustifyContent = {
    FLEX_START: "flex-start",
    FLEX_END: "flex-end",
    CENTER: "center",
    SPACE_BETWEEN: "space-between",
    SPACE_AROUND: "space-around",
    SPACE_EVENLY: "space-evenly"
  };
  const AlignItems = {
    FLEX_START: "flex-start",
    FLEX_END: "flex-end",
    CENTER: "center",
    BASELINE: "baseline",
    STRETCH: "stretch"
  };
  const AlignContent = {
    FLEX_START: "flex-start",
    FLEX_END: "flex-end",
    CENTER: "center",
    SPACE_BETWEEN: "space-between",
    SPACE_AROUND: "space-around",
    SPACE_EVENLY: "space-evenly"
  };
  const FlexWrap = {
    NOWRAP: "nowrap",
    WRAP: "wrap",
    WRAP_REVERSE: "wrap-reverse"
  };
  const ResizingMode = {
    FIXED: "fixed",
    HUG_CONTENT: "hug-content",
    FILL_CONTAINER: "fill-container"
  };
  const TextClip = {
    NONE: "none",
    TEXT: "text"
  };
  const BoxShadowStyle = {
    OUTSET: "outset",
    INSET: "inset"
  };
  const GradientType = {
    STATIC: "static-gradient",
    LINEAR: "linear-gradient",
    RADIAL: "radial-gradient",
    CONIC: "conic-gradient",
    REPEATING_LINEAR: "repeating-linear-gradient",
    REPEATING_RADIAL: "repeating-radial-gradient",
    REPEATING_CONIC: "repeating-conic-gradient",
    IMAGE: "image",
    URL: "url"
  };
  const RadialGradientSizeType = {
    CLOSEST_SIDE: "closest-side",
    CLOSEST_CORNER: "closest-corner",
    FARTHEST_SIDE: "farthest-side",
    FARTHEST_CORNER: "farthest-corner"
  };
  const RadialGradientType = {
    CIRCLE: "circle",
    ELLIPSE: "ellipse"
  };
  const ClipPathType = {
    NONE: "none",
    CIRCLE: "circle",
    ELLIPSE: "ellipse",
    POLYGON: "polygon",
    INSET: "inset",
    PATH: "path",
    SVG: "svg"
  };
  const VisibilityType = {
    VISIBLE: "visible",
    HIDDEN: "hidden"
  };
  const TimingFunction = {
    LINEAR: "linear",
    EASE: "ease",
    EASE_IN: "ease-in",
    EASE_OUT: "ease-out",
    EASE_IN_OUT: "ease-in-out",
    STEPS: "steps",
    CUBIC_BEZIER: "cubic-bezier",
    PATH: "path"
  };
  const SpreadMethodType = {
    PAD: "pad",
    REFLECT: "reflect",
    REPEAT: "repeat"
  };
  const FuncType = {
    COMMA: "comma",
    COLOR: "color",
    LENGTH: "length",
    GRADIENT: "gradient",
    TIMING: "timing",
    KEYWORD: "keyword",
    STRING: "string",
    NUMBER: "number",
    BOOLEAN: "boolean",
    FUNCTION: "function",
    PATH: "path",
    URL: "url",
    REPEAT: "repeat",
    UNKNOWN: "unknown"
  };
  const PathSegmentType = {
    MOVETO: "M",
    LINETO: "L",
    CURVETO: "C",
    QUARDTO: "Q",
    ARCTO: "A",
    CLOSEPATH: "Z",
    UNKNOWN: "unknown"
  };
  const DirectionType = {
    TO_TOP: "to top",
    TO_RIGHT: "to right",
    TO_BOTTOM: "to bottom",
    TO_LEFT: "to left",
    TO_TOP_LEFT: "to top left",
    TO_TOP_RIGHT: "to top right",
    TO_BOTTOM_LEFT: "to bottom left",
    TO_BOTTOM_RIGHT: "to bottom right"
  };
  const DirectionNumberType = {
    1: DirectionType.TO_TOP_LEFT,
    2: DirectionType.TO_TOP_RIGHT,
    3: DirectionType.TO_BOTTOM_LEFT,
    4: DirectionType.TO_BOTTOM_RIGHT,
    11: DirectionType.TO_TOP,
    12: DirectionType.TO_RIGHT,
    13: DirectionType.TO_BOTTOM,
    14: DirectionType.TO_LEFT
  };
  const TargetActionType = {
    APPEND_CHILD: "appendChild",
    INSERT_BEFORE: "insertBefore",
    INSERT_AFTER: "insertAfter"
  };
  const REG_PARSE_NUMBER_FOR_PATH = /([mMlLvVhHcCsSqQtTaAzZ]([^mMlLvVhHcCsSqQtTaAzZ]*))/g;
  var numberReg = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
  function xy$2(point2) {
    return {
      x: point2[0],
      y: point2[1]
    };
  }
  class PathParser {
    constructor(pathString2 = "") {
      this.reset(pathString2);
    }
    reset(pathString2 = "") {
      this.segments = [];
      this.pathString = pathString2.trim();
      this.parse();
      return this;
    }
    resetSegments(segments) {
      this.segments = segments || [];
      this.pathString = this.joinPath();
      return this;
    }
    addSegments(segments) {
      return this.resetSegments([...this.segments, ...segments]);
    }
    addPath(otherPath, transform2 = create$4()) {
      const newPath = otherPath.clone();
      newPath.transformMat4(transform2);
      return this.addSegments(newPath.segments);
    }
    trim(str = "") {
      var arr = str.match(numberReg) || [];
      return arr.filter((it) => it != "");
    }
    parse() {
      var arr = this.pathString.match(REG_PARSE_NUMBER_FOR_PATH) || [];
      this.segments = arr.map((s) => {
        var command = s[0];
        var values = this.trim(s.replace(command, "")).map((it) => +it);
        return { command, values };
      });
      this.segments = this.segments.map((s, index2) => {
        switch (s.command) {
          case "m":
            var prev = this.segments[index2 - 1];
            if (prev && (prev.command == "z" || prev.command == "Z")) {
              prev = this.segments[index2 - 2];
            }
            var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
            var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
            for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
              s.values[i] += x;
              s.values[i + 1] += y;
            }
            return {
              command: s.command.toUpperCase(),
              values: [...s.values]
            };
          case "c":
          case "l":
          case "q":
          case "s":
          case "t":
          case "v":
          case "h":
            var prev = this.segments[index2 - 1];
            var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
            var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
            for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
              s.values[i] += x;
              s.values[i + 1] += y;
            }
            return {
              command: s.command.toUpperCase(),
              values: [...s.values]
            };
          case "a":
            var prev = this.segments[index2 - 1];
            var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
            var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
            s.values[5] += x;
            s.values[6] += y;
            return {
              command: s.command.toUpperCase(),
              values: [...s.values]
            };
          case "z":
            return {
              command: s.command.toUpperCase(),
              values: []
            };
          default:
            return s;
        }
      });
      this.segments.forEach((it, index2) => {
        const prev = this.segments[index2 - 1];
        if (it.command == "A") {
          const x1 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          const y1 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          const [rx, ry, xrotate, largeArcFlag, sweepFlag, x, y] = it.values;
          const path = PathParser.arcToCurve(x1, y1, rx, ry, xrotate, largeArcFlag, sweepFlag, x, y);
          path.segments.forEach((seg) => {
            if (seg.command !== "M" || seg.command !== "Z")
              ;
          });
        }
      });
      return this;
    }
    convertGenerator() {
      var points = [];
      for (var index2 = 0, len2 = this.segments.length; index2 < len2; index2++) {
        var s = this.segments[index2];
        var nextSegment = this.segments[index2 + 1];
        const { command, values } = s;
        if (command === "M") {
          var [x, y] = values;
          points.push({
            command,
            originalCommand: command,
            startPoint: { x, y },
            endPoint: { x, y },
            reversePoint: { x, y },
            curve: false
          });
        } else if (command === "L") {
          var prevPoint = Point.getPrevPoint(points, points.length);
          if (prevPoint.curve) {
            var [x, y] = values;
            points.push({
              command,
              originalCommand: command,
              startPoint: { x, y },
              endPoint: { x, y },
              reversePoint: sapa.clone(prevPoint.endPoint),
              curve: true
            });
          } else {
            var [x, y] = values;
            points.push({
              command,
              originalCommand: command,
              startPoint: { x, y },
              endPoint: { x, y },
              reversePoint: { x, y },
              curve: false
            });
          }
        } else if (command === "Q") {
          var [cx1, cy1, x, y] = values;
          var prevPoint = Point.getPrevPoint(points, points.length);
          if (prevPoint.curve) {
            var startPoint = { x, y };
            var endPoint = { x, y };
            var reversePoint = { x, y };
            points.push({
              command: "L",
              originalCommand: command,
              startPoint,
              endPoint,
              reversePoint,
              curve: false
            });
            prevPoint.endPoint = { x: cx1, y: cy1 };
          } else {
            if (nextSegment && nextSegment.command === "L") {
              prevPoint.curve = true;
              prevPoint.endPoint = { x: cx1, y: cy1 };
              var startPoint = { x, y };
              var reversePoint = { x, y };
              var endPoint = { x, y };
              points.push({
                command: "L",
                originalCommand: command,
                curve: false,
                startPoint,
                endPoint,
                reversePoint
              });
            } else {
              var startPoint = { x, y };
              var reversePoint = { x: cx1, y: cy1 };
              var endPoint = { x, y };
              points.push({
                command,
                originalCommand: command,
                curve: true,
                startPoint,
                endPoint,
                reversePoint
              });
            }
          }
        } else if (command === "T") {
          var [x, y] = values;
          var prevSegment = this.segments[index2 - 1];
          if (prevSegment && prevSegment.command === "Q") {
            var [cx1, cy1, sx, sy] = prevSegment.values;
            var prevPoint = Point.getPrevPoint(points, points.length);
            prevPoint.endPoint = Point.getReversePoint({ x: sx, y: sy }, { x: cx1, y: cy1 });
            var startPoint = { x, y };
            var endPoint = { x, y };
            var reversePoint = { x, y };
            points.push({
              command: "L",
              originalCommand: command,
              startPoint,
              endPoint,
              reversePoint,
              curve: false
            });
          }
        } else if (command === "C") {
          var prevPoint = Point.getPrevPoint(points, points.length);
          var [cx1, cy1, cx2, cy2, x, y] = values;
          var startPoint = { x, y };
          var reversePoint = { x: cx2, y: cy2 };
          var endPoint = { x, y };
          points.push({
            command,
            originalCommand: command,
            curve: true,
            startPoint,
            endPoint,
            reversePoint
          });
          if (prevPoint) {
            prevPoint.curve = true;
            prevPoint.endPoint = { x: cx1, y: cy1 };
          }
        } else if (command === "S") {
          var [x, y] = values;
          var prevSegment = this.segments[index2 - 1];
          if (prevSegment && prevSegment.command === "C") {
            var [cx2, cy2, sx, sy] = prevSegment.values;
            var prevPoint = Point.getPrevPoint(points, points.length);
            prevPoint.endPoint = Point.getReversePoint(prevPoint.startPoint, prevPoint.reversePoint);
            var startPoint = { x, y };
            var endPoint = { x, y };
            var reversePoint = { x: cx2, y: cy2 };
            points.push({
              command: "Q",
              originalCommand: command,
              startPoint,
              endPoint,
              reversePoint,
              curve: false
            });
          }
        } else if (command === "Z") {
          var prevPoint = Point.getPrevPoint(points, points.length);
          var firstPoint = Point.getFirstPoint(points, points.length);
          if (Point.isEqual(prevPoint.startPoint, firstPoint.startPoint)) {
            prevPoint.connected = true;
            prevPoint.endPoint = sapa.clone(firstPoint.endPoint);
            firstPoint.reversePoint = sapa.clone(prevPoint.reversePoint);
          }
          prevPoint.close = true;
        }
      }
      points = points.filter((p) => !!p);
      return points;
    }
    setSegments(index2, seg) {
      this.segments[index2] = seg;
    }
    getSegments(index2) {
      if (sapa.isNotUndefined(index2)) {
        return this.segments[index2];
      }
      return this.segments;
    }
    joinPath(segments, split = "") {
      var list = segments || this.segments;
      return list.map((it) => {
        return `${it.command} ${it.values.length ? it.values.join(" ") : ""}`;
      }).join(split);
    }
    each(callback, isReturn = false) {
      var newSegments = this.segments.map((segment, index2) => {
        return callback.call(this, segment, index2);
      });
      if (isReturn) {
        return newSegments;
      } else {
        this.segments = newSegments;
      }
      return this;
    }
    _loop(m, isReturn = false) {
      return this.each(function(segment) {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
            var result = m(v, 0);
            segment.values = [result[0], result[1]];
            break;
          case "V":
            var result = m([+v[0], 0]);
            segment.values = [result[0]];
            break;
          case "H":
            var result = m([0, +v[0]]);
            segment.values = [result[1]];
            break;
          case "C":
          case "S":
          case "T":
          case "Q":
            for (var i = 0, len2 = v.length; i < len2; i += 2) {
              var result = m(v, i);
              segment.values[i] = result[0];
              segment.values[i + 1] = result[1];
            }
            break;
        }
        return segment;
      }, isReturn);
    }
    clone() {
      const path = new PathParser();
      path.resetSegments(this.segments.map((it) => {
        return {
          command: it.command,
          values: it.values.slice()
        };
      }));
      return path;
    }
    translate(tx, ty) {
      this.transformMat4(fromTranslation([], [tx, ty, 0]));
      return this;
    }
    translateTo(tx, ty) {
      return this.joinPath(this.transformMat4(fromTranslation([], [tx, ty, 0]), true));
    }
    scale(sx, sy) {
      this.transformMat4(fromScaling([], [sx, sy, 1]));
      return this;
    }
    scaleTo(sx, sy) {
      return this.joinPath(this.transformMat4(fromScaling([], [sx, sy, 1]), true));
    }
    scaleWith(width2, height) {
      const newPath = this.clone();
      const rect2 = vertiesToRectangle(newPath.getBBox());
      newPath.translate(-rect2.x, -rect2.y);
      const scale2 = Math.min(width2 / rect2.width, height / rect2.height);
      return newPath.scale(scale2, scale2).translate(width2 / 2 - rect2.width / 2 * scale2, height / 2 - rect2.height / 2 * scale2);
    }
    scaleFunc(xScale = (x) => x, yScale = (y) => y) {
      return this.each(function(segment) {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
            segment.values = [xScale(v[0]), yScale(v[1])];
            break;
          case "C":
          case "Q":
            for (var i = 0, len2 = v.length; i < len2; i += 2) {
              segment.values[i] = xScale(v[i]);
              segment.values[i + 1] = yScale(v[i + 1]);
            }
            break;
        }
        return segment;
      });
    }
    rotate(angle, centerX = 0, centerY = 0) {
      const view = create$4();
      multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
      multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
      multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
      this.transformMat4(view);
      return this;
    }
    rotateTo(angle, centerX = 0, centerY = 0) {
      const view = create$4();
      multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
      multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
      multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
      return this.joinPath(this.transformMat4(view, true));
    }
    reflectionOrigin() {
      this.transformMat4(fromScaling([], [-1, -1, 0]));
      return this;
    }
    reflectionOriginTo() {
      return this.joinPath(this.transformMat4(fromScaling([], [-1, -1, 0]), true));
    }
    flipX() {
      this.transformMat4(fromScaling([], [1, -1, 0]));
      return this;
    }
    flipXTo() {
      return this.joinPath(this.transformMat4(fromScaling([], [1, -1, 0]), true));
    }
    flipY() {
      this.transformMat4(fromScaling([], [-1, 1, 0]));
      return this;
    }
    flipYTo() {
      return this.joinPath(this.transformMat4(fromScaling([], [-1, 1, 0]), true));
    }
    skewX(angle) {
      this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
      return this;
    }
    skewXTo(angle) {
      return this.joinPath(this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
    }
    skewY(angle) {
      this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
      return this;
    }
    skewYTo(angle) {
      return this.joinPath(this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
    }
    forEachGroup(callback) {
      const groupList = this.getGroup();
      for (let i = 0, len2 = groupList.length; i < len2; i++) {
        const group = groupList[i];
        callback(group, i, groupList);
      }
    }
    forEach(callback) {
      this.forEachGroup((segments, index2, groupList) => {
        for (let i = 0, len2 = segments.length; i < len2; i++) {
          const segment = segments[i];
          callback(segment, i, segments, groupList, index2);
        }
      });
    }
    normalize() {
      const allSegments = [];
      const groupList = this.getGroup();
      groupList.forEach((group) => {
        const newSegments = [];
        group.segments.forEach(({ segment }, index2) => {
          var _a;
          const prevSegment = (_a = group.segments[index2 - 1]) == null ? void 0 : _a.segment;
          if (segment.command === "M") {
            newSegments.push(segment);
            return;
          } else if (segment.command === "L") {
            const localCurve = normalizeCurveForLine([
              [
                prevSegment.values[prevSegment.values.length - 2],
                prevSegment.values[prevSegment.values.length - 1],
                0
              ],
              [segment.values[0], segment.values[1], 0]
            ]);
            newSegments.push({
              command: "C",
              values: [
                localCurve[1][0],
                localCurve[1][1],
                localCurve[2][0],
                localCurve[2][1],
                localCurve[3][0],
                localCurve[3][1]
              ]
            });
            return;
          } else if (segment.command === "C") {
            newSegments.push(segment);
          } else if (segment.command === "Q") {
            const localCurve = normalizeCurveForQuard([
              [
                prevSegment.values[prevSegment.values.length - 2],
                prevSegment.values[prevSegment.values.length - 1],
                0
              ],
              [segment.values[0], segment.values[1], 0],
              [segment.values[2], segment.values[3], 0]
            ]);
            newSegments.push({
              command: "C",
              values: [
                localCurve[1][0],
                localCurve[1][1],
                localCurve[2][0],
                localCurve[2][1],
                localCurve[3][0],
                localCurve[3][1]
              ]
            });
          } else if (segment.command === "Z") {
            newSegments.push(segment);
          }
        });
        allSegments.push(...newSegments);
      });
      return PathParser.fromSegments(allSegments);
    }
    polygonal() {
      const pathList = this.toPathList();
      pathList.forEach((path) => {
        const newSegments = [];
        path.segments.forEach((segment, index2) => {
          const prevSegment = path.segments[index2 - 1];
          if (segment.command === "M") {
            newSegments.push(segment);
          } else if (segment.command === "L") {
            newSegments.push(segment);
          } else if (segment.command === "C") {
            newSegments.push(...polygonalForCurve([
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ], [segment.values[0], segment.values[1], 0], [segment.values[2], segment.values[3], 0], [segment.values[4], segment.values[5], 0]).map((point2) => ({
              command: "L",
              values: [point2[0], point2[1], 0]
            })));
          } else if (segment.command === "Q") {
            newSegments.push(...polygonalForCurve(...normalizeCurveForQuard([
              [
                prevSegment.values[prevSegment.values.length - 2],
                prevSegment.values[prevSegment.values.length - 1],
                0
              ],
              [segment.values[0], segment.values[1], 0],
              [segment.values[2], segment.values[3], 0]
            ])).map((point2) => ({
              command: "L",
              values: [point2[0], point2[1], 0]
            })));
          } else if (segment.command === "Z") {
            newSegments.push(segment);
          }
        });
        path.resetSegments(newSegments);
      });
      return PathParser.joinPathList(pathList);
    }
    divideSegmentByCount(count = 1) {
      let allSegments = [];
      const groupList = this.getGroup();
      groupList.forEach((group) => {
        const newSegments = [];
        group.segments.forEach(({ segment }, index2) => {
          var _a;
          const prevSegment = (_a = group.segments[index2 - 1]) == null ? void 0 : _a.segment;
          if (segment.command === "M") {
            newSegments.push(segment);
          } else if (segment.command === "L") {
            const linePoints = splitBezierPointsLineByCount([
              {
                x: prevSegment.values[prevSegment.values.length - 2],
                y: prevSegment.values[prevSegment.values.length - 1]
              },
              {
                x: segment.values[0],
                y: segment.values[1]
              }
            ], count);
            linePoints.forEach(([, end]) => {
              newSegments.push(Segment.L(end.x, end.y));
            });
          } else if (segment.command === "Q") {
            const quardPoints = splitBezierPointsQuardByCount([
              {
                x: prevSegment.values[prevSegment.values.length - 2],
                y: prevSegment.values[prevSegment.values.length - 1]
              },
              {
                x: segment.values[0],
                y: segment.values[1]
              },
              {
                x: segment.values[2],
                y: segment.values[3]
              }
            ], count);
            quardPoints.forEach(([, middle, end]) => {
              newSegments.push(Segment.Q(middle.x, middle.y, end.x, end.y));
            });
          } else if (segment.command === "C") {
            const curvePoints = splitBezierPointsByCount([
              {
                x: prevSegment.values[prevSegment.values.length - 2],
                y: prevSegment.values[prevSegment.values.length - 1]
              },
              {
                x: segment.values[0],
                y: segment.values[1]
              },
              {
                x: segment.values[2],
                y: segment.values[3]
              },
              {
                x: segment.values[4],
                y: segment.values[5]
              }
            ], count);
            curvePoints.forEach(([, c1, c2, end]) => {
              newSegments.push(Segment.C(c1.x, c1.y, c2.x, c2.y, end.x, end.y));
            });
          } else if (segment.command === "Z") {
            newSegments.push(segment);
          }
        });
        allSegments = allSegments.concat(newSegments);
      });
      return PathParser.fromSegments(allSegments);
    }
    getBBox() {
      let minX = Number.MAX_SAFE_INTEGER, minY = Number.MAX_SAFE_INTEGER;
      let maxX = Number.MIN_SAFE_INTEGER, maxY = Number.MIN_SAFE_INTEGER;
      this.each(function(segment, index2) {
        var v = segment.values;
        var c = segment.command;
        const prevSegment = this.segments[index2 - 1];
        switch (c) {
          case "M":
          case "L":
            minX = Math.min(minX, v[0]);
            maxX = Math.max(maxX, v[0]);
            minY = Math.min(minY, v[1]);
            maxY = Math.max(maxY, v[1]);
            break;
          case "C":
            getCurveBBox([
              [
                prevSegment.values[prevSegment.values.length - 2],
                prevSegment.values[prevSegment.values.length - 1],
                0
              ],
              [v[0], v[1], 0],
              [v[2], v[3], 0],
              [v[4], v[5], 0]
            ]).forEach((p) => {
              minX = Math.min(minX, p[0]);
              maxX = Math.max(maxX, p[0]);
              minY = Math.min(minY, p[1]);
              maxY = Math.max(maxY, p[1]);
            });
            break;
          case "Q":
            getCurveBBox(normalizeCurveForQuard([
              [
                prevSegment.values[prevSegment.values.length - 2],
                prevSegment.values[prevSegment.values.length - 1],
                0
              ],
              [v[0], v[1], 0],
              [v[2], v[3], 0]
            ])).forEach((p) => {
              minX = Math.min(minX, p[0]);
              maxX = Math.max(maxX, p[0]);
              minY = Math.min(minY, p[1]);
              maxY = Math.max(maxY, p[1]);
            });
            break;
        }
        return segment;
      });
      return [
        [minX, minY, 0],
        [maxX, minY, 0],
        [maxX, maxY, 0],
        [minX, maxY, 0]
      ];
    }
    rect() {
      const bbox = this.getBBox();
      return {
        x: bbox[0][0],
        y: bbox[0][1],
        width: distance$1(bbox[0], bbox[1]),
        height: distance$1(bbox[0], bbox[3]),
        right: bbox[0][0] + distance$1(bbox[0], bbox[1]),
        bottom: bbox[0][1] + distance$1(bbox[0], bbox[3])
      };
    }
    getClosedPointInfo({ x, y }, count = 20) {
      let minDist = Number.MAX_SAFE_INTEGER;
      let targetInfo = {};
      let info = {};
      for (var i = 1, len2 = this.segments.length; i < len2; i++) {
        const segment = this.segments[i];
        const prev = this.segments[i - 1].values;
        const current = segment.values;
        const command = segment.command;
        const lastPoint = { x: prev[prev.length - 2], y: prev[prev.length - 1] };
        if (command === "C") {
          var points = [
            lastPoint,
            { x: current[0], y: current[1] },
            { x: current[2], y: current[3] },
            { x: current[4], y: current[5] }
          ];
          var curve = recoverBezier(...points, count);
          var t = curve(x, y);
          info = {
            segment,
            index: i,
            t,
            points,
            targetPoint: getBezierPoints(points, t).first[3]
          };
        } else if (command === "Q") {
          var points = [
            lastPoint,
            { x: current[0], y: current[1] },
            { x: current[2], y: current[3] }
          ];
          var curve = recoverBezierQuard(...points, count);
          var t = curve(x, y);
          info = {
            segment,
            index: i,
            t,
            points,
            targetPoint: getBezierPointsQuard(points, t).first[2]
          };
        } else if (command === "L") {
          var points = [lastPoint, { x: current[0], y: current[1] }];
          var curve = recoverBezierLine(...points, count);
          var t = curve(x, y);
          info = {
            segment,
            index: i,
            t,
            points,
            targetPoint: getBezierPointsLine(points, t).first[1]
          };
        }
        if (info) {
          var dist2 = Math.sqrt(Math.pow(info.targetPoint.x - x, 2) + Math.pow(info.targetPoint.y - y, 2));
          if (dist2 < minDist) {
            minDist = dist2;
            targetInfo = info;
          }
        }
      }
      return targetInfo;
    }
    getClosedPoint({ x, y }, count = 20) {
      const info = this.getClosedPointInfo({ x, y }, count);
      if (info.targetPoint) {
        return info.targetPoint;
      }
      return { x, y };
    }
    isPointInPath({ x, y }, dist$1 = 1) {
      const info = this.getClosedPointInfo({ x, y }, 20);
      if (info.targetPoint) {
        if (dist([info.targetPoint.x, info.targetPoint.y, 0], [x, y, 0]) <= dist$1) {
          return true;
        }
      }
      return false;
    }
    toString(split = "") {
      return this.joinPath(void 0, split);
    }
    toSVGString() {
      return this.d;
    }
    transformMat4(transformMatrix, isReturn = false) {
      return this.each(function(segment) {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
            var result = transformMat4([], [v[0], v[1], 0], transformMatrix);
            segment.values = [result[0], result[1]];
            break;
          case "C":
          case "Q":
            for (var i = 0, len2 = v.length; i < len2; i += 2) {
              var result = transformMat4([], [v[i], v[i + 1], 0], transformMatrix);
              segment.values[i] = result[0];
              segment.values[i + 1] = result[1];
            }
            break;
        }
        return segment;
      }, isReturn);
    }
    transform(customTransformFunction = ([x, y, z]) => [x, y, z]) {
      const bbox = vertiesToRectangle(this.getBBox());
      return this.each(function(segment) {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
          case "C":
          case "Q":
            for (var i = 0, len2 = v.length; i < len2; i += 2) {
              var result = customTransformFunction([v[i], v[i + 1], 0], { bbox });
              segment.values[i] = result[0];
              segment.values[i + 1] = result[1];
            }
            break;
        }
        return segment;
      });
    }
    invert(transformMatrix) {
      this.transformMat4(invert([], transformMatrix));
      return this;
    }
    round(k = 1) {
      this.each(function(segment) {
        segment.values = segment.values.map((it) => round(it, k));
        return segment;
      });
      return this;
    }
    reverseSegments(segments) {
      const newSegments = [];
      let lastIndex = segments.length - 1;
      for (var i = lastIndex; i > 0; i--) {
        const segment = segments[i];
        const v = segment.values;
        const c = segment.command;
        const prevSegment = segments[i - 1];
        const lastX = prevSegment.values[prevSegment.values.length - 2];
        const lastY = prevSegment.values[prevSegment.values.length - 1];
        switch (c) {
          case "L":
            if (i === lastIndex) {
              newSegments.push(Segment.M(v[0], v[1]));
            }
            newSegments.push(Segment.L(lastX, lastY));
            break;
          case "C":
            if (i === lastIndex) {
              newSegments.push(Segment.M(v[4], v[5]));
            }
            newSegments.push(Segment.C(v[2], v[3], v[0], v[1], lastX, lastY));
            break;
          case "Q":
            if (i === lastIndex) {
              newSegments.push(Segment.M(v[2], v[3]));
            }
            newSegments.push(Segment.Q(v[0], v[1], lastX, lastY));
            break;
          case "Z":
            newSegments.push(segment);
            lastIndex = i - 1;
            break;
        }
      }
      if (newSegments[0].command === "Z") {
        newSegments.push(newSegments.shift());
      }
      return newSegments;
    }
    splitSegments() {
      const groupSegments = [];
      let newSegments = [];
      this.segments.forEach((s) => {
        if (s.command === "M") {
          newSegments = [s];
          groupSegments.push(newSegments);
        } else {
          newSegments.push(s);
        }
      });
      return groupSegments;
    }
    reverse(...groupIndexList) {
      const groupSegments = this.splitSegments();
      const newSegments = [];
      if (groupIndexList.length === 0) {
        groupSegments.forEach((segments) => {
          newSegments.push.apply(newSegments, this.reverseSegments(segments));
        });
      } else {
        groupSegments.forEach((segments, index2) => {
          if (groupIndexList.includes(index2)) {
            newSegments.push.apply(newSegments, this.reverseSegments(segments));
          } else {
            newSegments.push.apply(newSegments, segments);
          }
        });
      }
      return this.resetSegments(newSegments);
    }
    reversePathStringByFunc(func) {
      const pathList = this.toPathList().map((p, index2) => {
        if (func(p, index2)) {
          return p.reverse();
        }
        return p;
      });
      return PathParser.joinPathList(pathList).toSVGString();
    }
    getCenterPointers() {
      let arr = [];
      let lastValues = [];
      this.segments.forEach((segment, index2) => {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
            arr.push({
              index: index2,
              pointer: [...segment.values, 0]
            });
            break;
          case "V":
            arr.push({
              index: index2,
              pointer: [v[0], lastValues.pop(), 0]
            });
            break;
          case "H":
            lastValues.pop();
            arr.push({
              index: index2,
              pointer: [lastValues.pop(), v[0], 0]
            });
            break;
          case "C":
          case "S":
          case "T":
          case "Q":
            arr.push({
              index: index2,
              pointer: [v[v.length - 2], v[v.length - 1], 0]
            });
            break;
        }
        lastValues = sapa.clone(v);
      });
      return arr;
    }
    get points() {
      return this.getCenterPointers();
    }
    getSamePointers(pointer, dist2 = 0) {
      return this.getCenterPointers().filter((p) => {
        if (distance$1(p.pointer, pointer) <= dist2) {
          return true;
        }
      });
    }
    getGroup() {
      const groupSegments = [];
      let newSegments = [];
      this.segments.forEach((segment, index2) => {
        if (segment.command === "M") {
          newSegments = [
            {
              index: index2,
              segment
            }
          ];
          groupSegments.push({
            index: index2,
            groupIndex: groupSegments.length,
            segments: newSegments
          });
        } else {
          newSegments.push({
            index: index2,
            segment
          });
        }
      });
      return groupSegments;
    }
    createGroupPath(index2) {
      var _a, _b;
      const path = new PathParser();
      path.resetSegments(((_b = (_a = this.getGroup()[index2]) == null ? void 0 : _a.segments) == null ? void 0 : _b.map((it) => {
        return it.segment;
      })) || []);
      return path;
    }
    toPathList() {
      return this.getGroup().map((group) => {
        return PathParser.fromSegments(group.segments.map((it) => it.segment));
      });
    }
    replaceSegment(index2, ...segments) {
      const newSegments = [...this.segments];
      newSegments.splice(index2, 1, ...segments);
      this.resetSegments(newSegments);
    }
    splitSegmentByPoint(pos, dist2 = 0) {
      const closedPointInfo = this.getClosedPointInfo(pos, dist2);
      if (closedPointInfo && closedPointInfo.t > 0 && closedPointInfo.t < 1) {
        switch (closedPointInfo.segment.command) {
          case "C":
            var list = getBezierPoints(closedPointInfo.points, closedPointInfo.t);
            var first = list.first;
            var firstSegment = Segment.C(first[1].x, first[1].y, first[2].x, first[2].y, first[3].x, first[3].y);
            var second = list.second;
            var secondSegment = Segment.C(second[1].x, second[1].y, second[2].x, second[2].y, second[3].x, second[3].y);
            this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
            break;
          case "Q":
            var list = getBezierPointsQuard(closedPointInfo.points, closedPointInfo.t);
            var first = list.first;
            var firstSegment = Segment.Q(first[1].x, first[1].y, first[2].x, first[2].y);
            var second = list.second;
            var secondSegment = Segment.Q(second[1].x, second[1].y, second[2].x, second[2].y);
            this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
            break;
          case "L":
            var list = getBezierPointsLine(closedPointInfo.points, closedPointInfo.t);
            var first = list.first;
            var firstSegment = Segment.L(first[1].x, first[1].y);
            var second = list.second;
            var secondSegment = Segment.L(second[1].x, second[1].y);
            this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
            break;
          default:
            return;
        }
        return closedPointInfo;
      }
    }
    toMultiSegmentPathList() {
      const paths = [];
      const group = this.getGroup();
      group.forEach((group2) => {
        group2.segments.forEach((s, index2) => {
          var _a;
          const prevSegment = group2.segments[index2 - 1];
          const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
          const lastX = lastValues[lastValues.length - 2];
          const lastY = lastValues[lastValues.length - 1];
          const values = s.segment.values;
          if (s.segment.command === "M")
            ;
          else if (s.segment.command === "L") {
            paths.push(new PathParser(`M ${lastX} ${lastY}L ${values.join(" ")}`));
          } else if (s.segment.command === "C") {
            paths.push(new PathParser(`M ${lastX} ${lastY}C ${values.join(" ")}`));
          } else if (s.segment.command === "Q") {
            paths.push(new PathParser(`M ${lastX} ${lastY}Q ${values.join(" ")}`));
          } else
            ;
        });
      });
      return paths;
    }
    simplify(tolerance = 0.1) {
      const newGroupSegments = [];
      const groupList = this.getGroup();
      groupList.forEach((group) => {
        const points = [
          ...group.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
            return {
              x: it.segment.values[0],
              y: it.segment.values[1]
            };
          })
        ];
        const newPoints = Point.simply(points, tolerance);
        const newSegments = [];
        newPoints.forEach((p, index2) => {
          if (index2 === 0) {
            newSegments.push(Segment.M(p.x, p.y));
          } else {
            newSegments.push(Segment.L(p.x, p.y));
          }
        });
        newGroupSegments.push(...newSegments);
      });
      return PathParser.fromSegments(newGroupSegments);
    }
    smooth(error = 50) {
      let newGroupSegments = [];
      const groupList = this.getGroup();
      groupList.forEach((group) => {
        const points = [
          ...group.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
            return [...it.segment.values, 0];
          })
        ];
        const bezierCurve = fitCurve(points, error);
        const newSegments = [];
        bezierCurve.forEach((curve, index2) => {
          if (index2 === 0) {
            newSegments.push(Segment.M(...curve[0]));
          }
          newSegments.push(Segment.C(curve[1][0], curve[1][1], curve[2][0], curve[2][1], curve[3][0], curve[3][1]));
        });
        if (group.segments[group.segments.length - 1].segment.command.toLowerCase() === "z") {
          newSegments.push(Segment.Z());
        }
        newGroupSegments = newGroupSegments.concat(newSegments);
      });
      return PathParser.fromSegments(newGroupSegments);
    }
    cardinalSplines(tension = 0.5) {
      const newGroupSegments = [];
      const groupList = this.getGroup();
      groupList.forEach((group) => {
        const points = [
          ...group.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
            return [...it.segment.values, 0];
          })
        ];
        const newPoints = [];
        points.forEach((point2, index2) => {
          const prevPoint = points[index2 - 1];
          const nextPoint = points[index2 + 1];
          if (index2 === 0) {
            newPoints.push({ point: point2 });
          } else if (index2 === points.length - 1) {
            const firstPoint = points[0];
            if (equals$1(firstPoint, point2)) {
              const p0 = prevPoint;
              const p1 = point2;
              const p2 = points[1];
              const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
              const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
              const V2 = negate([], V3);
              newPoints.push({
                reversePoint: add([], p1, V2),
                point: p1,
                endPoint: add([], p1, V3)
              });
            } else {
              newPoints.push({ point: point2 });
            }
          } else {
            const p0 = prevPoint;
            const p1 = point2;
            const p2 = nextPoint;
            const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
            const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
            const V2 = negate([], V3);
            newPoints.push({
              reversePoint: add([], p1, V2),
              point: p1,
              endPoint: add([], p1, V3)
            });
          }
        });
        const newSegments = [];
        newPoints.forEach((p, index2) => {
          if (index2 === 0) {
            newSegments.push(Segment.M(p.point[0], p.point[1]));
          } else {
            const prevPoint = newPoints[index2 - 1] || newPoints[newPoints.length - 1];
            if (!prevPoint.endPoint) {
              if (index2 === 1) {
                const lastPoint = newPoints[newPoints.length - 1];
                if (lastPoint.endPoint) {
                  newSegments.push(Segment.C(lastPoint.endPoint[0], lastPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
                } else {
                  newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
                }
              } else {
                newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              }
            } else if (!p.reversePoint) {
              newSegments.push(Segment.Q(prevPoint.endPoint[0], prevPoint.endPoint[1], p.point[0], p.point[1]));
            } else {
              newSegments.push(Segment.C(prevPoint.endPoint[0], prevPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
            }
          }
        });
        newGroupSegments.push(...newSegments);
      });
      const newPath = new PathParser();
      newPath.resetSegments(newGroupSegments);
      return newPath;
    }
    Z() {
      this.segments.push(Segment.Z());
      return this;
    }
    M(x, y) {
      this.segments.push(Segment.M(x, y));
      return this;
    }
    L(x, y) {
      this.segments.push(Segment.L(x, y));
      return this;
    }
    C(x1, y1, x2, y2, x, y) {
      this.segments.push(Segment.C(x1, y1, x2, y2, x, y));
      return this;
    }
    Q(x1, y1, x, y) {
      this.segments.push(Segment.Q(x1, y1, x, y));
      return this;
    }
    drawRect(x, y, width2, height) {
      this.segments.push(Segment.M(x, y), Segment.L(x + width2, y), Segment.L(x + width2, y + height), Segment.L(x, y + height), Segment.L(x, y), Segment.Z());
      return this;
    }
    drawLine(x1, y1, x2, y2) {
      this.segments.push(Segment.M(x1, y1), Segment.L(x2, y2));
      return this;
    }
    drawCircleWithRect(x, y, width2, height = width2) {
      var segmentSize = 0.552284749831;
      const path = new PathParser();
      path.resetSegments([
        Segment.M(0, -1),
        Segment.C(segmentSize, -1, 1, -segmentSize, 1, 0),
        Segment.C(1, segmentSize, segmentSize, 1, 0, 1),
        Segment.C(-segmentSize, 1, -1, segmentSize, -1, 0),
        Segment.C(-1, -segmentSize, -segmentSize, -1, 0, -1),
        Segment.Z()
      ]);
      path.translate(1, 1).scale(width2 / 2, height / 2).translate(x, y);
      this.addPath(path);
      return this;
    }
    drawCircle(cx, cy, radius) {
      return this.drawCircleWithRect(cx - radius, cy - radius, radius * 2, radius * 2);
    }
    drawArc(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      const [x1, y1] = this.lastPoint;
      return this.addPath(PathParser.arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y));
    }
    get verties() {
      let arr = [];
      let lastValues = [];
      this.each(function(segment) {
        var v = segment.values;
        var c = segment.command;
        switch (c) {
          case "M":
          case "L":
            arr.push([...segment.values, 0]);
            break;
          case "V":
            arr.push([v[0], lastValues.pop(), 0]);
            break;
          case "H":
            lastValues.pop();
            arr.push([lastValues.pop(), v[0], 0]);
            break;
          case "C":
          case "S":
          case "T":
          case "Q":
            for (var i = 0, len2 = v.length; i < len2; i += 2) {
              arr.push([v[i], v[i + 1], 0]);
            }
            break;
        }
        lastValues = v;
      });
      return arr;
    }
    get pathVerties() {
      const pathVerties = [];
      this.segments.forEach((segment, segmentIndex) => {
        const prevSegment = this.segments[segmentIndex - 1];
        const nextSegment = this.segments[segmentIndex + 1];
        if (segment.values.length > 0) {
          const arr = segment.values;
          for (var i = 0, len2 = arr.length; i < len2; i += 2) {
            pathVerties.push({
              prevSegment,
              nextSegment,
              segment,
              segmentIndex,
              valueIndex: i,
              vertex: [arr[i], arr[i + 1], 0],
              x: arr[i],
              y: arr[i + 1]
            });
          }
        }
      });
      return pathVerties;
    }
    get d() {
      return this.toString().trim();
    }
    get closed() {
      return this.segments.some((segment) => segment.command === "Z") && equals(this.lastPoint, this.firstPoint);
    }
    get opened() {
      return !this.closed;
    }
    get length() {
      let totalLength = 0;
      const group = this.getGroup();
      group.forEach((group2) => {
        group2.segments.forEach((s, index2) => {
          var _a;
          const prevSegment = group2.segments[index2 - 1];
          const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
          const lastX = lastValues[lastValues.length - 2];
          const lastY = lastValues[lastValues.length - 1];
          const values = s.segment.values;
          if (s.segment.command === "M")
            ;
          else if (s.segment.command === "L") {
            totalLength += getDist(lastX, lastY, values[0], values[1]);
          } else if (s.segment.command === "C") {
            totalLength += getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5]);
          } else if (s.segment.command === "Q") {
            totalLength += getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3]);
          } else
            ;
        });
      });
      return totalLength;
    }
    get lengthList() {
      let totalLengthList = [];
      const group = this.getGroup();
      group.forEach((group2, groupIndex) => {
        group2.segments.forEach((s, index2) => {
          var _a;
          const prevSegment = group2.segments[index2 - 1];
          const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
          const lastX = lastValues[lastValues.length - 2];
          const lastY = lastValues[lastValues.length - 1];
          const values = s.segment.values;
          if (s.segment.command === "M")
            ;
          else if (s.segment.command === "L") {
            totalLengthList.push({
              groupIndex,
              segmentIndex: index2,
              length: getDist(lastX, lastY, values[0], values[1])
            });
          } else if (s.segment.command === "C") {
            totalLengthList.push({
              groupIndex,
              segmentIndex: index2,
              length: getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5])
            });
          } else if (s.segment.command === "Q") {
            totalLengthList.push({
              groupIndex,
              segmentIndex: index2,
              length: getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3])
            });
          } else
            ;
        });
      });
      return totalLengthList;
    }
    get lastSegment() {
      const segment = this.segments[this.segments.length - 1];
      if (segment.command !== "Z") {
        return segment;
      }
      return this.segments[this.segments.length - 2];
    }
    get lastPoint() {
      const values = this.lastSegment.values;
      return [values[values.length - 2], values[values.length - 1]];
    }
    get firstSegment() {
      const segment = this.segments[0];
      return segment;
    }
    get firstPoint() {
      const values = this.firstSegment.values;
      return [values[0], values[1]];
    }
    static joinPathList(pathList = []) {
      const newPath = PathParser.fromSVGString();
      pathList.forEach((path) => {
        newPath.addPath(path);
      });
      return newPath;
    }
    static fromSegments(segments) {
      const path = new PathParser();
      path.resetSegments(segments);
      return path;
    }
    static fromStructuredVerties(verties) {
      const path = new PathParser();
      const segments = [];
      verties.forEach((v) => {
        if (!segments[v.segmentIndex]) {
          segments[v.segmentIndex] = {
            command: v.segment.command,
            values: []
          };
        }
        if (segments[v.segmentIndex].command !== PathSegmentType.CLOSEPATH) {
          segments[v.segmentIndex].values[v.valueIndex] = v.vertex[0];
          segments[v.segmentIndex].values[v.valueIndex + 1] = v.vertex[1];
        }
      });
      path.resetSegments(segments);
      return path;
    }
    static fromSVGString(d = "") {
      return new PathParser(d);
    }
    static makeRect(x, y, width2, height) {
      return PathParser.fromSVGString().drawRect(x, y, width2, height);
    }
    static makeLine(x, y, x2, y2) {
      return PathParser.fromSVGString().drawLine(x, y, x2, y2);
    }
    static makeCircle(x, y, width2, height) {
      return PathParser.fromSVGString().drawCircleWithRect(x, y, width2, height);
    }
    static makePathByPoints(points = []) {
      const segments = points.map((p, index2) => {
        if (index2 === 0) {
          return Segment.M(p.x, p.y);
        } else {
          return Segment.L(p.x, p.y);
        }
      });
      segments.push(Segment.Z());
      return PathParser.fromSegments(segments);
    }
    static makePathByVerties(verties = [], isClosed = true) {
      const segments = verties.map((v, index2) => {
        if (index2 === 0) {
          return Segment.M(v[0], v[1]);
        } else {
          return Segment.L(v[0], v[1]);
        }
      });
      if (isClosed) {
        segments.push(Segment.Z());
      }
      return PathParser.fromSegments(segments);
    }
    static makePolygon(width2, height, count = 3) {
      const segments = [];
      const centerX = 1 / 2;
      const centerY = 1 / 2;
      for (var i = 0; i < count; i++) {
        var angle = i / count * Math.PI * 2 - Math.PI / 2;
        var x = Math.cos(angle) * centerX + centerX;
        var y = Math.sin(angle) * centerY + centerY;
        if (i === 0) {
          segments.push(Segment.M(x, y));
        } else {
          segments.push(Segment.L(x, y));
        }
      }
      segments.push(Segment.L(segments[0].values[0], segments[0].values[1]));
      segments.push(Segment.Z());
      return PathParser.fromSegments(segments).scale(width2, height);
    }
    static makeStar(width2, height, count = 5, radius = 0.5) {
      const segments = [];
      const centerX = 1 / 2;
      const centerY = 1 / 2;
      const outerRadius = Math.min(centerX, centerY);
      const innerRadius = outerRadius * radius;
      const npoints = count * 2;
      let firstX, firstY = 0;
      for (var i = 0; i < npoints; i++) {
        var angle = i / npoints * Math.PI * 2 - Math.PI / 2;
        var radius = i % 2 === 0 ? outerRadius : innerRadius;
        var x = Math.cos(angle) * radius + centerX;
        var y = Math.sin(angle) * radius + centerY;
        if (i === 0) {
          segments.push(Segment.M(x, y));
          firstX = x;
          firstY = y;
        } else {
          segments.push(Segment.L(x, y));
        }
      }
      segments.push(Segment.L(firstX, firstY));
      segments.push(Segment.Z());
      return PathParser.fromSegments(segments).scale(width2, height);
    }
    static makeCurvedStar(width2, height, count = 5, radius = 0.5, tension = 0.5) {
      const starPath = PathParser.makeStar(width2, height, count, radius);
      return starPath.cardinalSplines(tension);
    }
    static arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
      const bezierCurveList = arcToBezier({
        px: x1,
        py: y1,
        cx: x2,
        cy: y2,
        rx,
        ry,
        xAxisRotation,
        largeArcFlag,
        sweepFlag
      });
      const path = new PathParser();
      path.M(x1, y1);
      bezierCurveList.forEach((bezierCurve) => {
        path.C(bezierCurve.x1, bezierCurve.y1, bezierCurve.x2, bezierCurve.y2, bezierCurve.x, bezierCurve.y);
      });
      return path;
    }
    toCurveList() {
      const curveList = [];
      this.segments.forEach((segment, index2) => {
        if (index2 > 0) {
          const prevSegment = this.segments[index2 - 1];
          const lastPoint = [
            prevSegment.values[prevSegment.values.length - 2],
            prevSegment.values[prevSegment.values.length - 1]
          ];
          const points = [
            xy$2(lastPoint),
            xy$2([segment.values[0], segment.values[1]]),
            xy$2([segment.values[2], segment.values[3]]),
            xy$2([segment.values[4], segment.values[5]])
          ];
          curveList.push({
            points,
            curveFunction: createBezier(...points)
          });
        }
      });
      return curveList;
    }
    toInterpolateFunction() {
      const curveList = this.normalize().toCurveList().map((curve) => {
        return {
          points: curve.points,
          curveFunction: curve.curveFunction,
          start: curve.points[0].x,
          end: curve.points[curve.points.length - 1].x
        };
      });
      return (t) => {
        const currentCurve = curveList.find((it) => {
          return it.start <= t && t <= it.end;
        });
        if (currentCurve) {
          const point2 = currentCurve.curveFunction(t);
          return point2.y;
        }
        if (t === 0) {
          return curveList[0].points[0].y;
        }
        const points = curveList[curveList.length - 1].points;
        return points[points.length - 1].y;
      };
    }
  }
  class PathKitManager {
    constructor(editor2) {
      this.editor = editor2;
      this.pathkit = null;
    }
    async load() {
      this.registerPathKit(await PathKitInit());
    }
    registerPathKit(pathkit2) {
      this.pathkit = pathkit2;
      this.editor.emit("updatePathKit");
    }
    has() {
      return !!this.pathkit;
    }
    booleanOperation(first, second, pathOp) {
      const PathKit = this.pathkit;
      return PathKit.MakeFromOp(PathKit.FromSVGString(first), PathKit.FromSVGString(second), pathOp).toSVGString();
    }
    intersection(first, second) {
      const PathKit = this.pathkit;
      if (!PathKit)
        return;
      return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.INTERSECT));
    }
    union(first, second) {
      const PathKit = this.pathkit;
      if (!PathKit)
        return;
      return this.booleanOperation(first, second, PathKit.PathOp.UNION);
    }
    difference(first, second) {
      const PathKit = this.pathkit;
      if (!PathKit)
        return;
      return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.DIFFERENCE));
    }
    reverseDifference(first, second) {
      const PathKit = this.pathkit;
      if (!PathKit)
        return;
      return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.REVERSE_DIFFERENCE));
    }
    xor(first, second) {
      const PathKit = this.pathkit;
      if (!PathKit)
        return;
      return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.XOR));
    }
    reversePathString(pathString2) {
      return PathParser.fromSVGString(pathString2).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
    }
    isValidPath(path) {
      const PathKit = this.pathkit;
      let pathKitPath = PathKit.FromSVGString(path);
      return pathKitPath.isValid();
    }
    simplify(path) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      return pathObject.simplify().toSVGString();
    }
    convertLineJoin(lineJoin) {
      const PathKit = this.pathkit;
      switch (lineJoin) {
        case "miter":
          return PathKit.StrokeJoin.MITER;
        case "round":
          return PathKit.StrokeJoin.ROUND;
        case "bevel":
          return PathKit.StrokeJoin.BEVEL;
      }
    }
    convertLineCap(lineCap) {
      const PathKit = this.pathkit;
      switch (lineCap) {
        case "butt":
          return PathKit.StrokeCap.BUTT;
        case "round":
          return PathKit.StrokeCap.ROUND;
        case "square":
          return PathKit.StrokeCap.SQUARE;
      }
    }
    stroke(path, opt = { width: 1, miter_limit: 4 }) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      if (sapa.isArray(opt["stroke-dasharray"])) {
        const arr = opt["stroke-dasharray"];
        if (arr.length >= 2) {
          pathObject.dash(arr[0], arr[1], +(opt["stroke-dashoffset"] || 0));
        }
      }
      let newPathObject = pathObject.stroke({
        width: +opt["stroke-width"],
        join: this.convertLineJoin(opt["stroke-linejoin"]),
        cap: this.convertLineCap(opt["stroke-linecap"])
      });
      newPathObject.setFillType(PathKit.FillType.WINDING);
      return newPathObject.simplify().toSVGString();
    }
    round(path, opt = { width: 1, miter_limit: 4 }) {
      return this.stroke(path, __spreadProps(__spreadValues({}, opt), {
        "stroke-linejoin": "round"
      }));
    }
    grow(path, opt = { width: 1, miter_limit: 4 }) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      return pathObject.copy().stroke(opt).op(pathObject, PathKit.PathOp.DIFFERENCE).toSVGString();
    }
    shrink(path, opt = { width: 1, miter_limit: 4 }) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      const simplifyPath = pathObject.copy().simplify();
      return pathObject.copy().stroke(opt).op(simplifyPath, PathKit.PathOp.DIFFERENCE).toSVGString();
    }
    dash(path, on, off, phase = 1) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      return pathObject.dash(on, off, phase).toSVGString();
    }
    trim(path, startT, stopT, isComplement = false) {
      const PathKit = this.pathkit;
      const pathObject = PathKit.FromSVGString(path);
      return pathObject.trim(startT, stopT, isComplement).toSVGString();
    }
  }
  class SegmentSelectionManager {
    constructor(editor2) {
      this.$editor = editor2;
      this.selectedPointKeys = {};
      this.selectedPointList = [];
    }
    get length() {
      return this.selectedPointList.length;
    }
    initialize() {
      this.selectedPointKeys = {};
      this.selectedPointList = [];
    }
    makeSegmentKey(index2, key) {
      return `${index2}_${key}`;
    }
    select(...list) {
      this.selectedPointKeys = {};
      this.selectedPointList = list.map(({ key, index: index2 }) => ({
        key,
        index: +index2 || 0
      }));
      list.forEach((it) => {
        var key = this.makeSegmentKey(it.index, it.key);
        this.selectedPointKeys[key] = it;
      });
    }
    toggleSegment(index2, key) {
      if (!this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, { key, index: index2 });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
    toggleSelect(...list) {
      list = list.map((it) => {
        return __spreadProps(__spreadValues({}, it), { included: this.isSelectedSegment(it.index, it.key) });
      });
      const includedList = list.filter((it) => it.included);
      const notIncludedList = list.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    }
    selectKeyIndex(index2, key) {
      if (!this.isSelectedSegment(index2, key)) {
        this.select({ key, index: index2 });
      }
    }
    isSelectedSegment(index2, key) {
      var key = this.makeSegmentKey(index2, key);
      return !!this.selectedPointKeys[key];
    }
  }
  const ADD_BODY_FIRST_MOUSEMOVE = "add/body/first/mousemove";
  const ADD_BODY_MOUSEMOVE = "add/body/mousemove";
  const ADD_BODY_MOUSEUP = "add/body/mouseup";
  const FIRSTMOVE = (method = "move") => {
    return sapa.AFTER(`bodyMouseFirstMove ${method}`);
  };
  const MOVE = (method = "move") => {
    return sapa.AFTER(`bodyMouseMove ${method}`);
  };
  const END = (method = "end") => {
    return sapa.AFTER(`bodyMouseUp ${method}`);
  };
  const UPDATE_VIEWPORT = "updateViewport";
  const TOGGLE_FULLSCREEN = "toggle.fullscreen";
  const REFRESH_SELECTION = "refreshSelection";
  const REFRESH_SELECTION_TOOL = "refreshSelectionTool";
  const REFRESH_CONTENT = "refreshContent";
  const SHOW_COMPONENT_POPUP = "showComponentPopup";
  const SHOW_NOTIFY = "showNotify";
  const RESIZE_WINDOW = "resize.window";
  const RESIZE_CANVAS = "resizeCanvas";
  const UPDATE_CANVAS = "updateCanvas";
  const OPEN_CONTEXT_MENU = "openContextMenu";
  const START_GUESTURE = "startGuesture";
  const END_GUESTURE = "endGuesture";
  const KEYMAP_KEYDOWN = "keymapKeydown";
  const KEYMAP_KEYUP = "keymapKeyup";
  const SET_LOCALE = "setLocale";
  const PUSH_MODE_VIEW = "pushModeView";
  const POP_MODE_VIEW = "popModeView";
  class SelectionManager {
    constructor(editor2) {
      this.$editor = editor2;
      this.$context = this.$editor.context;
      this.project = null;
      this.itemKeys = {};
      this.hoverId = "";
      this.hoverItems = [];
      this.ids = [];
      this.colorsteps = [];
      this.ghosts = [];
      this.cachedItemMatrices = [];
      this.cachedArtBoardVerties = [];
      this.cachedVerties = rectToVerties(0, 0, 0, 0, "50% 50% 0px");
      this.gridInformation = {};
      this.dragTargetItem = null;
      this.$editor.on("config:bodyEvent", () => {
        this.refreshMousePosition();
      });
    }
    refreshMousePosition() {
      const areaWidth = this.$context.config.get("area.width");
      const pos = this.$context.viewport.getWorldPosition();
      this.pos = pos;
      const [row, column] = area(pos[0], pos[1], areaWidth);
      this.row = row;
      this.column = column;
    }
    get modelManager() {
      return this.$context.modelManager;
    }
    get lockManager() {
      return this.$context.lockManager;
    }
    get items() {
      return this.modelManager.searchLiveItemsById(this.ids);
    }
    get current() {
      return this.modelManager.searchItem(this.ids[0]);
    }
    get currentProject() {
      if (!this.project) {
        this.project = this.modelManager.getProjectByIndex();
      }
      return this.project;
    }
    get isEmpty() {
      return !this.length;
    }
    get isOne() {
      if (this.length === 1 && this.current.is("artboard"))
        return true;
      return this.length === 1;
    }
    get isMany() {
      return this.length > 1;
    }
    get length() {
      return this.ids.length;
    }
    get isLayoutItem() {
      var _a;
      return (_a = this.current) == null ? void 0 : _a.isLayoutItem();
    }
    get allLayers() {
      return this.currentProject.allLayers || [];
    }
    get filteredLayers() {
      var _a;
      const areaWidth = this.$editor.context.config.get("area.width");
      return ((_a = this.currentProject) == null ? void 0 : _a.filteredAllLayers((item) => {
        if (item.is("project"))
          return false;
        const areaPosition = item.getAreaPosition(areaWidth);
        if (!areaPosition) {
          return false;
        }
        const { column, row } = areaPosition;
        return column[0] <= this.column && this.column <= column[1] && row[0] <= this.row && this.row <= row[1];
      }).filter((item) => {
        return item.isPointInRect(this.pos[0], this.pos[1]);
      })) || [];
    }
    get notSelectedLayers() {
      return this.filteredLayers.filter((it) => this.check(it) === false);
    }
    get selectedArtboards() {
      return [...new Set(this.items.map((it) => it.artboard))];
    }
    hasChangedField(...args2) {
      if (this.current) {
        return this.current.hasChangedField(...args2);
      }
      return false;
    }
    getRootItem(current) {
      var rootItem = current;
      if (current && current.parentId) {
        rootItem = current.parent;
      }
      return rootItem;
    }
    selectColorStep(...args2) {
      this.colorsteps = args2;
    }
    isSelectedColorStep(id) {
      return this.colorsteps.includes(id);
    }
    selectProject(project2) {
      if (sapa.isString(project2)) {
        project2 = this.modelManager.get(project2);
      }
      this.project = project2;
      this.select();
    }
    isSameIds(newIds) {
      if (this.ids.length != newIds.length) {
        return false;
      }
      if (this.ids.filter((id) => newIds.includes(id)).length === this.ids.length) {
        return true;
      }
      return false;
    }
    filterIds(ids = []) {
      return ids.map((it) => it.id || it).filter(Boolean);
    }
    selectByGroup(...ids) {
      var list = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => {
        return !this.lockManager.get(it.id);
      });
      const newSelectedItems = this.modelManager.convertGroupItems(list);
      return this.select(...newSelectedItems);
    }
    select(...ids) {
      var list = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => !it.lock && it.isAbsolute);
      const newSelectedItems = list.filter((it) => {
        return it.path.filter((element) => list.includes(element)).length < 2;
      });
      const newSelectedIds = newSelectedItems.map((it) => it.id);
      if (this.isSameIds(newSelectedIds)) {
        return false;
      }
      this.itemKeys = {};
      newSelectedItems.forEach((item) => {
        this.itemKeys[item.id] = item;
      });
      this.ids = newSelectedIds;
      this.setRectCache();
      this.$editor.emit(REFRESH_SELECTION);
      return true;
    }
    reload() {
      return this.select(...this.ids);
    }
    reselect() {
      this.setRectCache();
    }
    check(item) {
      return !!this.itemKeys[item.id];
    }
    hasPathOf(item) {
      return item.hasPathOf(this.items.filter((it) => it.isNot("artboard")));
    }
    hasParent(parentId) {
      return this.items.some((it) => it.hasParent(parentId));
    }
    get(id) {
      return this.itemKeys[id];
    }
    empty() {
      this.select();
    }
    itemsByIds(ids = null) {
      let itemIdList = [];
      if (Array.isArray(ids)) {
        itemIdList = ids;
      } else if (sapa.isString(ids) || sapa.isObject(ids)) {
        itemIdList = [ids];
      }
      return this.modelManager.searchItemsById(itemIdList);
    }
    selectById(id) {
      this.select(id);
    }
    selectAfterCopy() {
      this.select(...this.items.map((it) => it.copy()));
    }
    addById(id) {
      if (this.itemKeys[id])
        return;
      this.select(...this.ids, id);
    }
    removeById(id) {
      let ids = id;
      if (sapa.isString(id)) {
        ids = [id];
      }
      const filteredItems = this.ids.filter((id2) => ids.includes(id2) === false);
      this.select(...filteredItems);
    }
    toggleById(id) {
      if (this.itemKeys[id]) {
        this.removeById(id);
      } else {
        this.addById(id);
      }
    }
    getArtboardByPoint(vec) {
      return this.currentProject.artboards.find((artboard2) => {
        return polyPoint(artboard2.originVerties, ...vec);
      });
    }
    changeInLayoutArea() {
      let checkedParentChange = false;
      this.each((instance) => {
        if (instance.is("artboard") === false) {
          if (instance.artboard) {
            const localArtboardVerties = instance.artboard.originVerties;
            const isInArtboard = polyPoint(localArtboardVerties, this.pos[0], this.pos[1]);
            if (isInArtboard) {
              return false;
            }
          }
          const selectedArtBoard = this.cachedArtBoardVerties.find((artboard2) => {
            return polyPoint(artboard2.matrix.originVerties, this.pos[0], this.pos[1]);
          });
          if (selectedArtBoard) {
            if (selectedArtBoard.item !== instance.artboard && selectedArtBoard.item.hasLayout() === false) {
              selectedArtBoard.item.appendChild(instance);
              checkedParentChange = true;
            }
          } else {
            if (instance.artboard) {
              this.currentProject.appendChild(instance);
              checkedParentChange = true;
            }
          }
        }
      });
      return checkedParentChange;
    }
    setRectCache() {
      if (this.isEmpty) {
        this.cachedVerties = [];
        this.cachedRectVerties = [];
        this.cachedItemMatrices = [];
        this.ghosts = [];
        this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
          return { item, matrix: item.matrix };
        });
        return;
      }
      this.cachedVerties = this.verties;
      this.cachedRectVerties = toRectVerties(this.verties);
      this.cachedItemMatrices = [];
      this.cachedChildren = [];
      this.ghosts = [];
      this.items.forEach((it) => {
        if (it.is("artboard")) {
          this.cachedItemMatrices.push(it.matrix);
        } else if (it.hasChildren()) {
          const list = this.modelManager.getAllLayers(it.id).map((it2) => it2.matrix);
          this.cachedChildren.push(...list.map((it2) => it2.id));
          this.cachedItemMatrices.push(...list);
        } else {
          this.cachedItemMatrices.push(it.matrix);
        }
        this.ghosts.push(it.absoluteMatrix);
      });
      this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
        return { item, matrix: item.matrix };
      });
    }
    startToCacheChildren() {
      this.items.forEach((item) => {
        item.startToCacheChildren();
      });
    }
    recoverChildren() {
      this.items.forEach((item) => {
        item.recoverChildren();
      });
    }
    get verties() {
      if (this.isOne) {
        return this.current.verties;
      } else {
        return this.rectVerties;
      }
    }
    get targetVerties() {
      if (this.isOne) {
        return this.current.originVerties;
      } else {
        return targetItemsToRectVerties(this.items);
      }
    }
    get originVerties() {
      return this.rectVerties.filter((_, index2) => index2 < 4);
    }
    get rectVerties() {
      if (this.isEmpty) {
        return [];
      }
      return itemsToRectVerties(this.items);
    }
    get itemRect() {
      const verties = this.verties;
      return {
        x: verties[0][0],
        y: verties[0][1],
        width: distance$1(verties[0], verties[1]),
        height: distance$1(verties[0], verties[3])
      };
    }
    toCloneObject() {
      let data = {};
      this.each((item) => {
        data[item.id] = item.toCloneObject(false);
      });
      return data;
    }
    pack(...keys) {
      let data = {};
      this.each((item) => {
        data[item.id] = {};
        keys.forEach((key) => {
          data[item.id][key] = item[key];
        });
      });
      return data;
    }
    packByIds(ids, ...keys) {
      let data = {};
      let localItems = [];
      if (ids === null) {
        localItems = this.items;
      } else if (sapa.isString(ids) || Array.isArray(ids)) {
        localItems = this.itemsByIds(ids);
      }
      keys.forEach((it) => {
      });
      localItems.forEach((item) => {
        data[item.id] = item.attrs(...keys);
      });
      return data;
    }
    packByValue(valueObject, ids = null) {
      let data = {};
      let localItems = [];
      if (ids === null) {
        localItems = this.items;
      } else if (sapa.isString(ids) || Array.isArray(ids)) {
        localItems = this.itemsByIds(ids);
      }
      localItems.forEach((item) => {
        data[item.id] = {};
        Object.keys(valueObject).forEach((key) => {
          data[item.id][key] = sapa.isFunction(valueObject[key]) ? valueObject[key].call(valueObject, item) : valueObject[key];
        });
      });
      return data;
    }
    each(callback) {
      if (sapa.isFunction(callback)) {
        this.items.forEach((item) => {
          callback(item);
        });
      }
    }
    map(callback) {
      if (sapa.isFunction(callback)) {
        return this.items.map((item, index2) => {
          return callback(item, index2);
        });
      }
      return this.items;
    }
    reset(obj2) {
      Object.entries(obj2).forEach(([id, attrs]) => {
        var _a;
        (_a = this.get(id)) == null ? void 0 : _a.reset(attrs);
      });
    }
    resetCallback(callback) {
      this.each((item) => item.reset(callback(item)));
    }
    resize() {
      this.each((item) => item.resize());
    }
    remove() {
      this.each((item) => item.remove());
      this.empty();
    }
    copy() {
      console.warn("copy is deprecated");
      this.copyItems = this.items.map((item) => item);
    }
    paste() {
      console.warn("paste is deprecated. use copy and paste");
      this.select(...this.copyItems.map((item) => item.copy(10)));
      this.copy();
    }
    hasPoint(point2) {
      var _a;
      if (this.isMany) {
        return polyPoint(this.originVerties, point2[0], point2[1]);
      } else {
        return (_a = this.current) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
      }
    }
    hasChildrenPoint(point2) {
      return this.cachedChildren.some((it) => {
        var _a;
        return (_a = this.modelManager.get(it)) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
      });
    }
    checkChildren(childId) {
      return this.cachedChildren.includes(childId);
    }
    checkHover(itemOrId) {
      if (sapa.isString(itemOrId)) {
        return this.hoverId === itemOrId;
      } else {
        return this.hoverItems.findIndex((it) => it.id === itemOrId.id) > -1;
      }
    }
    hasHoverItem() {
      return this.hoverId !== "";
    }
    selectHoverItem() {
      this.select(this.hoverId);
    }
    setHoverId(id) {
      let isChanged = false;
      if (!id || this.itemKeys[id]) {
        if (this.hoverId != "") {
          isChanged = true;
        }
        this.hoverId = "";
        this.hoverItems = [];
      } else if (this.cachedArtBoardVerties.find((it) => it.item.id === id)) {
        if (this.hoverId != "") {
          isChanged = true;
        }
        this.hoverId = "";
        this.hoverItems = [];
      } else {
        if (this.hoverId != id) {
          isChanged = true;
        }
        this.hoverId = id;
        this.hoverItems = this.itemsByIds([id]).filter((it) => it.isNot("artboard"));
        if (this.hoverItems.length === 0) {
          this.hoverId = "";
          isChanged = true;
        }
      }
      if (isChanged) {
        this.$editor.emit("changeHoverItem");
      }
      return isChanged;
    }
    is(...args2) {
      var _a;
      return args2.includes((_a = this.current) == null ? void 0 : _a.itemType);
    }
    isAll(...args2) {
      return this.items.every((it) => args2.includes(it.itemType));
    }
    updateGridInformation(obj2 = {}) {
      this.gridInformation = obj2;
    }
    updateDragTargetItem(item) {
      this.dragTargetItem = item;
    }
  }
  const MAX_SNAP_DISTANCE = 3;
  const DEFAULT_DIST_VECTOR = { dist: fromValues(0, 0, 0) };
  const AXIS_X = "x";
  const AXIS_Y = "y";
  function checkXAxis(sourceVertex, targetVertex, dist2 = 1) {
    return Math.abs(sourceVertex[0] - targetVertex[0]) < dist2;
  }
  function checkYAxis(sourceVertex, targetVertex, dist2 = 1) {
    return Math.abs(sourceVertex[1] - targetVertex[1]) < dist2;
  }
  class SnapManager {
    constructor(editor2, snapDistance = MAX_SNAP_DISTANCE) {
      this.editor = editor2;
      this.context = this.editor.context;
      this.map = /* @__PURE__ */ new Map();
      this.snapTargetLayers = [];
      this.snapDistance = snapDistance;
    }
    get dist() {
      return this.context.config.get("snap.distance") || this.snapDistance;
    }
    get gridSize() {
      return this.context.config.get("snap.grid") || 50;
    }
    makeSnapTargetLayers() {
      if (!this.context.selection.currentProject)
        return [];
      return this.context.selection.currentProject.allLayers.filter((item) => {
        if (item.is("project"))
          return false;
        if (this.context.selection.check(item))
          return false;
        const inViewport = this.context.viewport.checkInViewportArea(item.originVerties);
        return inViewport;
      });
    }
    clear() {
      this.snapTargetLayers = this.makeSnapTargetLayers();
    }
    convertMatrix(item) {
      const verties = this.convertGuideAndPathMatrix(item);
      const xList = verties.map((it) => it[0]);
      const yList = verties.map((it) => it[1]);
      return {
        id: item.id,
        xList,
        yList,
        verties,
        rectVerties: toRectVertiesWithoutTransformOrigin(item.originVerties)
      };
    }
    convertGuideAndPathMatrix(item) {
      const guideVerties = item.guideVerties;
      return [...guideVerties];
    }
    get snapTargetLayersWithSelection() {
      if (!this.context.selection.currentProject)
        return [];
      return this.context.selection.currentProject.allLayers.filter((item) => {
        if (item.is("project"))
          return false;
        const inViewport = item.verties.some((v) => {
          return this.context.viewport.checkInViewport(v);
        });
        return inViewport;
      });
    }
    getSnapPoints() {
      const points = [];
      this.snapTargetLayersWithSelection.forEach((it) => {
        points.push.apply(points, this.convertGuideAndPathMatrix(it));
      });
      return points;
    }
    checkX(targetXList, sourceXList, dist2 = 0) {
      const checkXList = [];
      targetXList.forEach((targetX, targetIndex) => {
        sourceXList.forEach((sourceX, sourceIndex) => {
          if (Math.abs(targetX - sourceX) <= dist2) {
            checkXList.push({
              targetX,
              sourceX,
              sourceIndex,
              targetIndex,
              dx: targetX - sourceX
            });
          }
        });
      });
      return checkXList;
    }
    checkY(targetYList, sourceYList, dist2 = 0) {
      const checkYList = [];
      targetYList.forEach((targetY, targetIndex) => {
        sourceYList.forEach((sourceY, sourceIndex) => {
          const localDistY = targetY - sourceY;
          if (Math.abs(localDistY) <= dist2) {
            checkYList.push({
              targetY,
              sourceY,
              sourceIndex,
              targetIndex,
              dy: localDistY
            });
          }
        });
      });
      return checkYList;
    }
    check(sourceVerties, dist2 = 0) {
      const snaps = [];
      const sourceXList = sourceVerties.map((it) => it[0]);
      const sourceYList = sourceVerties.map((it) => it[1]);
      const guideXList = this.context.config.get("horizontal.line");
      const guideYList = this.context.config.get("vertical.line");
      if (guideXList && guideYList) {
        const x = this.checkX(guideXList, sourceXList, dist2)[0];
        const y = this.checkY(guideYList, sourceYList, dist2)[0];
        const distVector = fromValues(x ? x.dx : 0, y ? y.dy : 0, 0);
        if (sapa.isNotZero(distVector[0]) || sapa.isNotZero(distVector[1])) {
          snaps.push({ target: null, dist: distVector });
        }
      }
      this.snapTargetLayers.forEach((target) => {
        const x = this.checkX(target.xList, sourceXList, dist2)[0];
        const y = this.checkY(target.yList, sourceYList, dist2)[0];
        const distVector = fromValues(x ? x.dx : 0, y ? y.dy : 0, 0);
        if (sapa.isNotZero(distVector[0]) || sapa.isNotZero(distVector[1])) {
          snaps.push({ target, dist: distVector });
        }
      });
      return snaps.find((it) => sapa.isNotZero(it[0]) || sapa.isNotZero(it[1])) || DEFAULT_DIST_VECTOR;
    }
    checkPoint(sourceVertex) {
      const snap = this.check([sourceVertex]);
      return add([], sourceVertex, snap.dist);
    }
    getGuidesByPointPoint(sourceVerties, targetVerties, dist$1 = 0) {
      const points = [];
      const groupPoints = {};
      let sourceVertex, targetVertex;
      for (let sourceIndex = 0, sourceLength = sourceVerties.length; sourceIndex < sourceLength; sourceIndex++) {
        sourceVertex = sourceVerties[sourceIndex];
        const keyX = `${sourceVertex[0]}_x`;
        const keyY = `${sourceVertex[1]}_y`;
        if (!groupPoints[keyX]) {
          groupPoints[keyX] = [];
        }
        if (!groupPoints[keyY]) {
          groupPoints[keyY] = [];
        }
        for (let targetIndex = 0, targetLength = targetVerties.length; targetIndex < targetLength; targetIndex++) {
          targetVertex = targetVerties[targetIndex];
          if (checkXAxis(sourceVertex, targetVertex, dist$1)) {
            groupPoints[keyX].push([
              sourceVertex,
              targetVertex,
              AXIS_X,
              dist(sourceVertex, targetVertex)
            ]);
          }
          if (checkYAxis(sourceVertex, targetVertex, dist$1)) {
            groupPoints[keyY].push([
              sourceVertex,
              targetVertex,
              AXIS_Y,
              dist(sourceVertex, targetVertex)
            ]);
          }
        }
      }
      Object.keys(groupPoints).forEach((key) => {
        if (groupPoints[key] && groupPoints[key].length) {
          const sorted = groupPoints[key].sort((a, b) => a[3] - b[3]);
          points.push(...sorted);
        }
      });
      return points;
    }
    findGuide(sourceVerties, dist2 = 0) {
      const guides = [];
      this.snapTargetLayers.forEach((target) => {
        const points = this.getGuidesByPointPoint(sourceVerties, target.guideVerties, dist2);
        guides.push.apply(guides, points);
      });
      guides.sort((a, b) => {
        return a[3] - b[3];
      });
      return guides.filter((_, index2) => index2 < 10);
    }
    findGuideOne(sourceVerties) {
      return [this.findGuide(sourceVerties)[0]];
    }
    getWorldPosition() {
      const pos = round$1([], this.context.viewport.getWorldPosition());
      const snap = this.check([pos], 3 / this.context.viewport.scale);
      const newPos = add([], snap.dist, pos);
      return newPos;
    }
    getSnapTarget() {
      const pos = round$1([], this.context.viewport.getWorldPosition());
      const snap = this.check([pos], 3 / this.context.viewport.scale);
      const newPos = add([], snap.dist, pos);
      return {
        vertex: newPos,
        snap
      };
    }
  }
  class TimelineSelectionManager {
    constructor(editor2) {
      this.$editor = editor2;
      this.items = [];
      this.itemKeys = {};
    }
    initialize() {
      this.items = [];
      this.itemKeys = {};
    }
    currentProject(callback) {
      var project2 = this.$editor.context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
      }
    }
    empty() {
      this.select();
    }
    each(callback) {
      this.items.forEach((item, index2) => {
        callback && callback(item, index2);
      });
    }
    refreshCache(list) {
      this.items = list;
      this.itemKeys = {};
      this.items.forEach((it) => {
        this.itemKeys[it.id] = it;
      });
    }
    cachedList() {
      return this.items.map((it) => {
        return __spreadValues({}, it);
      });
    }
    checked(id) {
      return !!this.itemKeys[id];
    }
    selectLayer(layerId) {
      this.currentProject((project2) => {
        var list = project2.getKeyframeListReturnArray().filter((it) => {
          return it.layerId === layerId;
        });
        this.refreshCache(list);
      });
    }
    toggleLayerContainer(animationId) {
      this.currentProject((project2) => {
        project2.getSelectedTimeline().animations.filter((it) => {
          return it.id === animationId;
        }).forEach((it) => {
          it.collapsed = !it.collapsed;
        });
      });
    }
    selectProperty(layerId, property) {
      this.currentProject((project2) => {
        var list = project2.getKeyframeListReturnArray().filter((it) => {
          return it.layerId === layerId && it.property === property;
        });
        this.refreshCache(list);
      });
    }
    select(...args2) {
      this.refreshCache(args2);
    }
    selectBySearch(list, startTime, endTime) {
      this.currentProject((project2) => {
        var totalList = [];
        list.forEach((it) => {
          var results = [];
          if (it.property) {
            var p = project2.getTimelineProperty(it.layerId, it.property);
            results = p.keyframes.filter((keyframe2) => {
              return startTime <= keyframe2.time && keyframe2.time <= endTime;
            });
          } else {
            var p = project2.getTimelineObject(it.layerId);
            p.properties.filter((property) => {
              return property.property === it.property;
            }).forEach((property) => {
              results.push.apply(results, property.keyframes.filter((keyframe2) => {
                return startTime <= keyframe2.time && keyframe2.time <= endTime;
              }));
            });
          }
          totalList.push.apply(totalList, results);
        });
        var uniqueOffset = {};
        totalList.forEach((it) => {
          uniqueOffset[it.id] = it;
        });
        this.select(...Object.values(uniqueOffset));
      });
    }
    checkLayer(layerId) {
      return Object.keys(this.itemKeys).some((key) => {
        return this.itemKeys[key].layerId === layerId;
      });
    }
    checkProperty(layerId, property) {
      return Object.keys(this.itemKeys).some((key) => {
        return this.itemKeys[key].layerId === layerId && this.itemKeys[key].property === property;
      });
    }
  }
  class VisibleManager {
    constructor(editor2) {
      this.editor = editor2;
      this.hiddenList = {};
    }
    get list() {
      return Object.keys(this.hiddenList);
    }
    get(key) {
      return !this.hiddenList[key];
    }
    set(key, value) {
      if (value) {
        delete this.hiddenList[key];
      } else {
        this.hiddenList[key] = true;
      }
    }
    toggle(key) {
      if (this.get(key)) {
        this.set(key, false);
      } else {
        this.set(key, true);
      }
    }
  }
  var AlignmentProperty$1 = "";
  const DEFAULT_TITLE = "";
  const DEFAULT_ICON = "";
  const DEFAULT_CHECKED = false;
  class MenuItem extends editor.EditorElement {
    template() {
      return `
        <button 
            type="button" 
            class='elf--menu-item ${this.getClassName()}' 
            data-no-title="${this.isHideTitle()}" 
            ${this.isHideTitle() && this.isHideTooltip() === false ? `data-tooltip="${this.getTitle()}"` : ""} 
            checked="${this.getChecked() ? "checked" : ""}"
            ${this.isDisabled() ? "disabled" : ""}
            data-direction="${this.getDirection()}"
        >
            <div class="icon ${this.getIcon()}" ref="$icon">${editor.iconUse(this.getIconString()) || this.getIconString() || ""}</div>
            ${this.isHideTitle() ? "" : `<div class="title">${this.getTitle()}</div>`}
            
        </button>
        `;
    }
    getClassName() {
      return "";
    }
    clickButton() {
    }
    getChecked() {
      return DEFAULT_CHECKED;
    }
    isDisabled() {
      return false;
    }
    setSelected(isSelected) {
      this.$el.toggleClass("selected", isSelected);
    }
    getTitle() {
      return DEFAULT_TITLE;
    }
    getIcon() {
      return DEFAULT_ICON;
    }
    setIcon(iconString) {
      this.refs.$icon.html(icon[iconString] || iconString || "");
    }
    getIconString() {
      return DEFAULT_ICON;
    }
    isHideTitle() {
      return false;
    }
    isHideTooltip() {
      return true;
    }
    [sapa.CLICK()](e) {
      this.clickButton(e);
    }
    getDirection() {
      return this.props.direction || "";
    }
    static createMenuItem(opt = {}) {
      return class extends MenuItem {
        getIconString() {
          return opt.iconString || "add_box";
        }
        getTitle() {
          return opt.title || "New Item";
        }
        isHideTitle() {
          return opt.isHideTitle || true;
        }
        clickButton(e) {
          opt.clickButton(e);
        }
        getDirection() {
          return opt.direction;
        }
      };
    }
  }
  class BottomAlign extends MenuItem {
    getIconString() {
      return "align_vertical_bottom";
    }
    getTitle() {
      return "Bottom";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.bottom");
    }
  }
  class CenterAlign extends MenuItem {
    getIconString() {
      return "align_horizontal_center";
    }
    getTitle() {
      return "Center";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.center");
    }
  }
  class LeftAlign extends MenuItem {
    getIconString() {
      return "align_horizontal_left";
    }
    getTitle() {
      return "Left";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.left");
    }
  }
  class MiddleAlign extends MenuItem {
    getIconString() {
      return "align_vertical_center";
    }
    getTitle() {
      return "middle";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.middle");
    }
  }
  class RightAlign extends MenuItem {
    getIconString() {
      return "align_horizontal_right";
    }
    getTitle() {
      return "Right";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.right");
    }
  }
  class SameHeight extends MenuItem {
    getIconString() {
      return "vertical_distribute";
    }
    getTitle() {
      return "height";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("same.height");
    }
  }
  class SameWidth extends MenuItem {
    getIconString() {
      return "horizontal_distribute";
    }
    getTitle() {
      return "width";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("same.width");
    }
  }
  class TopAlign extends MenuItem {
    getIconString() {
      return "align_vertical_top";
    }
    getTitle() {
      return "Top";
    }
    isHideTitle() {
      return true;
    }
    clickButton() {
      this.$commands.emit("sort.top");
    }
  }
  class AlignmentProperty extends editor.BaseProperty {
    components() {
      return {
        LeftAlign,
        CenterAlign,
        RightAlign,
        TopAlign,
        MiddleAlign,
        BottomAlign,
        SameWidth,
        SameHeight
      };
    }
    getTitle() {
      return this.$i18n("alignment.property.title");
    }
    isHideHeader() {
      return true;
    }
    getBody() {
      return `
      <div class="elf--alignment-item">
        ${sapa.createComponentList("LeftAlign", "CenterAlign", "RightAlign", "TopAlign", "MiddleAlign", "BottomAlign", ["SameWidth", { direction: "bottom" }], "SameHeight")}
      </div>
    `;
    }
  }
  function alignment(editor2) {
    editor2.registerUI("inspector.tab.style", {
      AlignmentProperty
    });
  }
  var AnimationProperty$1 = "";
  function randomItem(...args2) {
    return args2[randomNumber(0, args2.length - 1)];
  }
  function repeat(count) {
    return [...Array(count)];
  }
  function CSS_TO_STRING(style2, postfix = "") {
    var newStyle = style2 || {};
    return Object.keys(newStyle).filter((key) => sapa.isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
  }
  function STRING_TO_CSS(str = "", splitChar = ";", keySplitChar = ":") {
    str = str + "";
    var style2 = {};
    if (str === "")
      return style2;
    str.split(splitChar).forEach((it) => {
      var [key, ...value] = it.split(keySplitChar).map((it2) => it2.trim());
      if (key != "") {
        style2[key] = value.join(keySplitChar);
      }
    });
    return style2;
  }
  function OBJECT_TO_PROPERTY(obj2) {
    const target = obj2 || {};
    return Object.keys(target).map((key) => {
      if (key === "class") {
        if (sapa.isObject(obj2[key])) {
          return `${key}="${sapa.classnames(obj2[key])}"`;
        }
      }
      if (key === "style") {
        if (sapa.isObject(obj2[key])) {
          return `${key}="${CSS_TO_STRING(obj2[key])}"`;
        }
      }
      if (sapa.isBoolean(obj2[key]) || sapa.isUndefined(obj2[key]) || obj2[key] === "undefined") {
        if (obj2[key]) {
          return key;
        } else {
          return "";
        }
      }
      return `${key}="${obj2[key]}"`;
    }).join(" ");
  }
  function TAG_TO_STRING(str) {
    return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function mapjoin(arr, callback, joinString = "") {
    return arr.map(callback).join(joinString);
  }
  function isArrayEquals(A, B) {
    const s = /* @__PURE__ */ new Set([...A, ...B]);
    return s.size === A.length && s.size === B.length;
  }
  const curveToPath = (timingFunction, width2, height) => {
    const currentBezier = getPredefinedCubicBezier(timingFunction);
    return `
        M0 ${width2} 
        C 
        ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height : (1 - currentBezier[1]) * height},
        ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height},
        ${width2} 0
    `;
  };
  const curveToPointLine = (timingFunction, width2, height) => {
    const currentBezier = getPredefinedCubicBezier(timingFunction);
    return `
        M 0 ${width2} 
        L ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height : (1 - currentBezier[1]) * height}
        M ${width2} 0
        L ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height}
    `;
  };
  const valueMap = (obj2, valueFunction) => {
    const newObj = sapa.clone(obj2);
    Object.keys(newObj).forEach((key) => {
      newObj[key] = valueFunction(newObj[key]);
    });
    return newObj;
  };
  const objectFloor = (obj2) => valueMap(obj2, Math.floor);
  class AnimationProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("title");
    }
    getBody() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--animation-list",
        ref: "$animationList"
      });
    }
    getTools() {
      return /* @__PURE__ */ sapa.createElementJsx("button", {
        type: "button",
        ref: "$add",
        title: "add Fill"
      }, editor.iconUse("add"));
    }
    isFirstShow() {
      return true;
    }
    get localeKey() {
      return "animation.property";
    }
    [sapa.LOAD("$animationList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      return current.animation.map((it, index2) => {
        const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
        const path = curveToPath(it.timingFunction, 30, 30);
        return /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "animation-group-item"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: `animation-item ${selectedClass}`,
          "data-index": index2,
          ref: `animationIndex${index2}`
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "timing preview",
          "data-index": index2,
          ref: `$preview${index2}`
        }, /* @__PURE__ */ sapa.createElementJsx("svg", {
          class: "item-canvas",
          width: "30",
          height: "30",
          viewBox: "0 0 30 30"
        }, /* @__PURE__ */ sapa.createElementJsx("path", {
          d: path,
          stroke: "white",
          "stroke-width": "1",
          fill: "none"
        }))), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "name"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "title"
        }, it.name ? it.name : `&lt; ${this.$i18n("select a keyframe")} &gt;`, /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "play-state",
          title: this.$i18n("play.state"),
          "data-index": index2,
          "data-play-state-selected-value": it.playState
        }, /* @__PURE__ */ sapa.createElementJsx("small", {
          "data-play-state-value": "running"
        }, editor.iconUse("play")), /* @__PURE__ */ sapa.createElementJsx("small", {
          "data-play-state-value": "paused"
        }, editor.iconUse("pause")))), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "labels"
        }, /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "count",
          title: this.$i18n("iteration.count")
        }, /* @__PURE__ */ sapa.createElementJsx("small", null, it.iterationCount)), /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "delay",
          title: this.$i18n("delay")
        }, /* @__PURE__ */ sapa.createElementJsx("small", null, it.delay)), /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "duration",
          title: this.$i18n("duration")
        }, /* @__PURE__ */ sapa.createElementJsx("small", null, it.duration)), /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "direction",
          title: this.$i18n("direction")
        }, /* @__PURE__ */ sapa.createElementJsx("small", null, it.direction)), /* @__PURE__ */ sapa.createElementJsx("label", {
          class: "fill-mode",
          title: this.$i18n("fill.mode")
        }, /* @__PURE__ */ sapa.createElementJsx("small", null, it.fillMode)))), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "tools"
        }, /* @__PURE__ */ sapa.createElementJsx("button", {
          type: "button",
          class: "del",
          "data-index": index2
        }, editor.iconUse("remove2")))));
      });
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refresh();
    }
    [sapa.CLICK("$add")]() {
      var current = this.$context.selection.current;
      if (current) {
        const animation2 = current.animation || [];
        animation2.push({
          itemType: "animation",
          checked: true,
          name: "none",
          direction: "normal",
          duration: editor.Length.second(0),
          timingFunction: "linear",
          delay: editor.Length.second(0),
          iterationCount: editor.Length.string("infinite"),
          playState: "running",
          fillMode: "none"
        });
        this.$commands.executeCommand("setAttribute", "add animation property", this.$context.selection.packByValue({
          animation: [...animation2]
        }));
        this.nextTick(() => {
          this.refresh();
        }, 100);
      } else {
        window.alert("Select a layer");
      }
    }
    [sapa.CLICK("$animationList .tools .del")](e) {
      var removeIndex = e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      const animation2 = current.animation || [];
      animation2.splice(removeIndex, 1);
      this.$commands.executeCommand("setAttribute", "remove animation property", this.$context.selection.packByValue({
        animation: [...animation2]
      }));
      this.refresh();
    }
    [sapa.CLICK("$animationList .play-state")](e) {
      var index2 = +e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      const animation2 = current.animation || [];
      var currentAnimation = animation2[index2];
      if (currentAnimation) {
        currentAnimation.playState = currentAnimation.playState === "running" ? "paused" : "running";
        e.$dt.attr("data-play-state-selected-value", currentAnimation.playState);
        this.$commands.executeCommand("setAttribute", "remove animation property", this.$context.selection.packByValue({
          animation: [...animation2]
        }));
      }
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.refs[`animationIndex${selectedIndex}`].addClass("selected");
      } else {
        this.refs[`animationIndex${selectedIndex}`].removeClass("selected");
      }
    }
    viewAnimationPicker($preview) {
      if (typeof this.selectedIndex === "number") {
        this.selectItem(this.selectedIndex, false);
      }
      this.selectedIndex = +$preview.attr("data-index");
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      const animation2 = this.current.animation || [];
      var currentAnimation = animation2[this.selectedIndex];
      this.currentAnimation = sapa.clone(currentAnimation);
      this.viewAnimationPropertyPopup();
    }
    viewAnimationPropertyPopup() {
      if (!this.currentAnimation)
        return;
      const animation2 = this.currentAnimation;
      this.emit("showAnimationPropertyPopup", {
        changeEvent: "changeAnimationPropertyPopup",
        data: sapa.clone(animation2),
        instance: this
      });
    }
    [sapa.CLICK("$animationList .preview")](e) {
      this.viewAnimationPicker(e.$dt);
    }
    [sapa.SUBSCRIBE("changeAnimationPropertyPopup")](data) {
      if (this.currentAnimation) {
        const animation2 = this.current.animation;
        animation2[this.selectedIndex] = data;
        if (this.current) {
          this.$commands.executeCommand("setAttribute", "change animation property", this.$context.selection.packByValue({
            animation: [...animation2]
          }));
          this.nextTick(() => {
            this.refresh();
          }, 10);
        }
      }
    }
  }
  var AnimationPropertyPopup$1 = "";
  class AnimationPropertyPopup extends editor.BasePopup {
    getTitle() {
      return this.$i18n("animation.property.popup.title");
    }
    initState() {
      return {
        changeEvent: "",
        instance: {},
        data: {}
      };
    }
    updateData(opt) {
      this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
      if (this.state.instance) {
        this.state.instance.trigger(this.state.changeEvent, this.state.data);
      }
    }
    getBody() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--animation-property-popup",
        ref: "$popup"
      });
    }
    [sapa.LOAD("$popup") + sapa.DOMDIFF]() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "box"
      }, this.templateForKeyframe(), this.templateForTimingFunction(), this.templateForIterationCount(), this.templateForDelay(), this.templateForDuration(), this.templateForDirection(), this.templateForFillMode(), this.templateForPlayState());
    }
    templateForTimingFunction() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "timing-function"
      }, /* @__PURE__ */ sapa.createElementJsx("label", null, this.$i18n("animation.property.popup.timing.function")), sapa.createComponent("CubicBezierEditor", {
        ref: "$cubicBezierEditor",
        key: "timingFunction",
        value: this.state.data.timingFunction || "linear",
        onChange: "changeCubicBezier"
      }));
    }
    templateForKeyframe() {
      var current = this.$context.selection.current;
      var names2 = [];
      if (current && current.keyframes) {
        names2 = current.keyframes.map((it) => {
          return { key: it.name, value: it.name };
        });
      }
      names2.unshift({ key: "Select a keyframe", value: "" });
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "name"
      }, /* @__PURE__ */ sapa.createElementJsx("label", null, this.$i18n("animation.property.popup.keyframe")), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "input grid-1"
      }, /* @__PURE__ */ sapa.createElementJsx("select", {
        ref: "$name"
      }, names2.map((it) => {
        var selected = it.value === this.state.data.name ? true : void 0;
        var label = this.$i18n(it.key);
        return /* @__PURE__ */ sapa.createElementJsx("option", {
          value: it.value,
          selected
        }, label);
      }))));
    }
    [sapa.CHANGE("$name")]() {
      this.updateData({ name: this.refs.$name.value });
    }
    templateForDirection() {
      var options2 = "normal,reverse,alternate,alternate-reverse".split(",").map((it) => {
        return `${it}:${this.$i18n(it)}`;
      }).join(",");
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "direction"
      }, sapa.createComponent("SelectEditor", {
        label: this.$i18n("animation.property.popup.direction"),
        ref: "$direction",
        key: "direction",
        value: this.state.data.direction,
        options: options2,
        onChange: "changeSelect"
      }));
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value) {
      this.updateData({ [key]: value });
    }
    templateForPlayState() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "play-state"
      }, sapa.createComponent("SelectEditor", {
        label: this.$i18n("animation.property.popup.play.state"),
        ref: "$playState",
        key: "playState",
        value: this.state.data.playState,
        options: ["paused", "running"],
        onChange: "changeSelect"
      }));
    }
    templateForFillMode() {
      var options2 = "none,forwards,backwards,both".split(",").map((it) => {
        return `${it}:${this.$i18n(it)}`;
      }).join(",");
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "fill-mode"
      }, sapa.createComponent("SelectEditor", {
        label: this.$i18n("animation.property.popup.fill.mode"),
        ref: "$fillMode",
        key: "fillMode",
        value: this.state.data.fillMode,
        options: options2,
        onChange: "changeSelect"
      }));
    }
    templateForDelay() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "delay"
      }, sapa.createComponent("InputRangeEditor", {
        ref: "$delay",
        label: this.$i18n("animation.property.popup.delay"),
        key: "delay",
        value: this.state.data.delay,
        units: ["s", "ms"],
        onChange: "changeRangeEditor"
      }));
    }
    templateForDuration() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "duration"
      }, sapa.createComponent("InputRangeEditor", {
        ref: "$duration",
        label: this.$i18n("animation.property.popup.duration"),
        key: "duration",
        value: this.state.data.duration,
        units: ["s", "ms"],
        onChange: "changeRangeEditor"
      }));
    }
    templateForIterationCount() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "iteration-count"
      }, sapa.createComponent("IterationCountEditor", {
        ref: "$iterationCount",
        label: this.$i18n("animation.property.popup.iteration"),
        key: "iterationCount",
        value: this.state.iterationCount || 0,
        units: ["normal", "infinite"],
        onChange: "changeRangeEditor"
      }));
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      if (key === "iterationCount") {
        if (value.unit === "normal") {
          value = editor.Length.number(value.value);
        } else {
          value = editor.Length.string(value.unit);
        }
      }
      this.updateData({ [key]: value });
    }
    [sapa.SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
      this.updateData({ [key]: value });
    }
    [sapa.SUBSCRIBE("showAnimationPropertyPopup")](data) {
      this.setState(data);
      this.show(250);
      this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
    }
    [sapa.SUBSCRIBE("hideAnimationPropertyPopup")]() {
      this.$el.hide();
    }
  }
  function animation(editor2) {
    editor2.registerUI("inspector.tab.transition", {
      AnimationProperty
    });
    editor2.registerUI("popup", {
      AnimationPropertyPopup
    });
  }
  function appearance(editor$1) {
    editor$1.registerUI("inspector.tab.style", {
      AppearanceProperty: editor.ObjectProperty.create({
        title: editor$1.$i18n("background.color.property.title"),
        editableProperty: "appearance",
        preventUpdate: true,
        inspector: (current) => {
          return [
            {
              type: "column",
              size: [1, 1],
              columns: [
                {
                  key: "backgroundColor",
                  editor: "color-view",
                  editorOptions: {
                    compact: true,
                    format: true
                  },
                  defaultValue: current.backgroundColor
                },
                {
                  key: "mixBlendMode",
                  editor: "blend-select",
                  editorOptions: {
                    label: "tonality",
                    compact: true
                  },
                  defaultValue: current.mixBlendMode || BlendMode.NORMAL
                }
              ]
            },
            {
              key: "overflow",
              editor: "select",
              editorOptions: {
                label: editor$1.$i18n("background.color.property.overflow"),
                options: [
                  Overflow.VISIBLE,
                  Overflow.HIDDEN,
                  Overflow.SCROLL,
                  Overflow.AUTO
                ].map((it) => {
                  return {
                    value: it,
                    text: editor$1.$i18n(`background.color.property.overflow.${it}`)
                  };
                })
              },
              defaultValue: current.overflow
            }
          ];
        }
      })
    });
  }
  var ArtBoardSizeProperty$1 = "";
  var artboardSize = [
    {
      category: "Web",
      groups: [
        {
          group: "Landscape",
          devices: [
            { device: "Web Small", size: "1024x600" },
            { device: "Web Medium", size: "1280x800" },
            { device: "Web Large", size: "1440x900" },
            { device: "Web X Large", size: "1920x1200" }
          ]
        },
        {
          group: "Portrait",
          devices: [
            { device: "Web Small", size: "600x1024" },
            { device: "Web Medium", size: "800x1280" },
            { device: "Web Large", size: "900x1440" },
            { device: "Web X Large", size: "1200x1920" }
          ]
        }
      ]
    },
    {
      category: "Apple Devices",
      groups: [
        {
          group: "iphone",
          devices: [
            { device: "iPhone 8", size: "375x667" },
            { device: "iPhone 8 Plus", size: "414x736" },
            { device: "iPhone SE", size: "320x568" },
            { device: "iPhone XS", size: "375x812" },
            { device: "iPhone XR", size: "414x896" },
            { device: "iPhone XS Max", size: "414x896" }
          ]
        },
        {
          group: "ipad",
          devices: [
            { device: "iPad", size: "768x1024" },
            { device: "iPad Pro", size: "1024x1366" }
          ]
        },
        {
          group: "apple watch",
          devices: [
            { device: "Apple Watch 38nm", size: "272x340" },
            { device: "Apple Watch 40nm", size: "326x394" },
            { device: "Apple Watch 42nm", size: "313x390" },
            { device: "Apple Watch 44nm", size: "368x448" }
          ]
        },
        {
          group: "apple tv",
          devices: [{ device: "Apple TV", size: "1920x1080" }]
        },
        { group: "MAC", devices: [{ device: "Touch Bar", size: "1085x30" }] }
      ]
    },
    {
      category: "Android Devices",
      groups: [
        {
          group: "android mobile",
          devices: [{ device: "Android Mobile", size: "360x640" }]
        },
        {
          group: "android tablet",
          devices: [{ device: "Android Tablet", size: "768x1024" }]
        }
      ]
    }
  ];
  class ArtBoardSizeProperty extends editor.BaseProperty {
    getClassName() {
      return "elf--artboard-size-list";
    }
    get editableProperty() {
      return "artboardSize";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    initState() {
      return {
        selectedIndex: 0
      };
    }
    getTitle() {
      return "ArtBoard Preset";
    }
    getTools() {
      var categories = artboardSize.map((it, index2) => {
        return { category: it.category, index: index2 };
      });
      return sapa.createComponent("SelectEditor", {
        ref: "$select",
        value: categories[0].category,
        options: categories.map((it) => it.category),
        onchange: "changeSizeIndex"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeSizeIndex")](key, value) {
      var selectedIndex = this.state.selectedIndex;
      artboardSize.forEach((it, index2) => {
        if (it.category === value) {
          selectedIndex = index2;
        }
      });
      this.state.selectedIndex = selectedIndex;
      this.refresh();
    }
    getBody() {
      return `
      <div class='artboard-size-item' ref='$list'></div>
    `;
    }
    makeDevice(device) {
      return `
      <div class='device-item' data-size='${device.size}'>
        <div class='title'>${device.device}</div>
        <div class='size'>${device.size}</div>
      </div>
    `;
    }
    [sapa.CLICK("$list .device-item")](e) {
      var size = e.$dt.attr("data-size");
      this.$commands.emit("resizeArtBoard", size);
    }
    makeGroup(group) {
      return `
      <div class='group-item'>
        <div class='title'>${group.group}</div>
      </div>
      <div class='devices'>
        ${group.devices.map((device) => this.makeDevice(device)).join("")}
      </div>
    `;
    }
    makeCategory(category) {
      return `
      <div class='category'>
        <div class='title'>${category.category}</div>
      </div>
      <div class='groups'>
        ${category.groups.map((group) => this.makeGroup(group)).join("")}
      </div>
    `;
    }
    [sapa.LOAD("$list") + sapa.DOMDIFF]() {
      var category = artboardSize[this.state.selectedIndex];
      return category.groups.map((group) => this.makeGroup(group));
    }
  }
  function artboard(editor2) {
    editor2.registerUI("inspector.tab.style", {
      ArtBoardSizeProperty
    });
  }
  var BackdropFilterProperty$1 = "";
  const filter_list$2 = [
    "blur",
    "grayscale",
    "hue-rotate",
    "invert",
    "brightness",
    "contrast",
    "drop-shadow",
    "opacity",
    "saturate",
    "sepia",
    "svg"
  ];
  class BackdropFilterProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("backdrop.filter.property.title");
    }
    getTitleClassName() {
      return "filter";
    }
    getBodyClassName() {
      return "no-padding";
    }
    getBody() {
      return `<div class='full filter-property' ref='$body'></div>`;
    }
    getTools() {
      return `
      <select class="filter-select" ref="$filterSelect"></select>
      <button type="button" ref="$add" title="add Filter">${editor.iconUse("add")}</button>
    `;
    }
    [sapa.CLICK("$add")]() {
      var filterType = this.refs.$filterSelect.value;
      this.children.$filterEditor.trigger("add", filterType);
    }
    [sapa.LOAD("$filterSelect")]() {
      var list = filter_list$2.map((it) => {
        return { title: this.$i18n(`filter.property.${it}`), value: it };
      });
      var svgFilterList = this.getSVGFilterList();
      var totalList = [];
      if (svgFilterList.length) {
        totalList = [...list, { title: "-------", value: "" }, ...svgFilterList];
      } else {
        totalList = [...list];
      }
      return totalList.map((it) => {
        var { title, value } = it;
        return `<option value='${value}'>${title}</option>`;
      });
    }
    getSVGFilterList() {
      var current = this.$context.selection.currentProject;
      var arr = [];
      if (current) {
        arr = current.svgfilters.map((it) => {
          return {
            title: `svg - #${it.id}`,
            value: it.id
          };
        });
      }
      return arr;
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || {};
      var value = current.backdropFilter;
      return `
      <div>
        ${sapa.createComponent("FilterEditor", {
        ref: "$filterEditor",
        key: "backdropFilter",
        value: sapa.clone(value),
        hideLabel: true,
        onchange: "changeFilterEditor"
      })}
      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
      this.$commands.executeCommand("setAttribute", "change backdrop filter", this.$context.selection.packByValue({
        [key]: sapa.clone(filter2)
      }));
    }
    get editableProperty() {
      return "backdropFilter";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow") + sapa.DEBOUNCE(1e3)]() {
      this.refresh();
    }
  }
  function backdropFilter(editor2) {
    editor2.registerUI("inspector.tab.style", {
      BackdropFilterProperty
    });
  }
  class BackgroundClipProperty extends editor.BaseProperty {
    getTitle() {
      return "Background Clip";
    }
    isFirstShow() {
      return false;
    }
    getTools() {
      return `<div ref='$backgroundClip' style='padding-top: 3px;'></div>`;
    }
    [sapa.LOAD("$backgroundClip")]() {
      var current = this.$context.selection.current || {};
      var clip = current.backgroundClip || "";
      return sapa.createComponent("SelectEditor", {
        ref: "$1",
        key: "backgroundClip",
        icon: true,
        value: clip,
        options: ["", "paddinb-box", "border-box", "content-box", "text"],
        onchange: "changeSelect"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value) {
      this.$commands.executeCommand("setAttribute", "change background clip", this.$context.selection.packByValue({
        [key]: value
      }));
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(["rect", "circle", "text"]);
    }
  }
  function backgroundClip(editor2) {
    editor2.registerElement({
      BackgroundClipProperty
    });
  }
  var BackgroundImageEditor$1 = "";
  const CSS_FUNC_REGEXP = /(([-]?[\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?)|#(?:[\da-f]{8})|(#(?:[\da-f]{3}){1,2}|([a-z_-]+)\([^()]+\)|([a-z_-]+))|(,)/gi;
  const CSS_LENGTH_REGEXP = /^[-]?([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?$/gi;
  const CSS_KEYWORD_REGEXP = /^[a-z_-]+$/gi;
  const GRADIENT_LIST = [
    GradientType.STATIC,
    GradientType.LINEAR,
    GradientType.RADIAL,
    GradientType.CONIC,
    GradientType.REPEATING_CONIC,
    GradientType.REPEATING_LINEAR,
    GradientType.REPEATING_RADIAL
  ];
  const TIMIING_LIST = [
    TimingFunction.LINEAR,
    TimingFunction.EASE,
    TimingFunction.EASE_IN,
    TimingFunction.EASE_OUT,
    TimingFunction.EASE_IN_OUT
  ];
  const CSS_FUNC_MATCHES = (str) => {
    if (str === ",") {
      return "comma";
    } else if (str.indexOf("#") === 0) {
      return "hex";
    } else if (Color__namespace.isColorName(str)) {
      return "color";
    } else if (GRADIENT_LIST.includes(str) || TIMIING_LIST.includes(str)) {
      return str;
    } else if (str.match(CSS_LENGTH_REGEXP)) {
      return "length";
    } else if (str.match(CSS_KEYWORD_REGEXP)) {
      return "keyword";
    }
  };
  const findFunctionEndIndex = (allString, startIndex, funcStartCharacter = "(", funcEndCharacter = ")") => {
    const result = [];
    for (var i = startIndex; i < allString.length; i++) {
      const it = allString[i];
      if (it === funcStartCharacter) {
        result.push(funcStartCharacter);
      } else if (it === funcEndCharacter) {
        result.pop();
        if (result.length === 0) {
          break;
        }
      }
    }
    if (result.length > 0) {
      return -1;
    }
    return i + 1;
  };
  const makeFuncType = (type) => {
    if (GRADIENT_LIST.includes(type)) {
      return FuncType.GRADIENT;
    } else if (TIMIING_LIST.includes(type)) {
      return FuncType.TIMING;
    } else if (type === "color") {
      return FuncType.COLOR;
    } else if (type === "hex") {
      return FuncType.COLOR;
    } else if (type === "length") {
      return FuncType.LENGTH;
    } else if (type === "comma") {
      return FuncType.COMMA;
    }
    return type;
  };
  const makeGroupFunction = (type) => (item, allString, funcStartCharacter = "(", funcEndCharacter = ")") => {
    const lastIndex = findFunctionEndIndex(allString, item.startIndex, funcStartCharacter, funcEndCharacter);
    if (lastIndex === -1) {
      return {
        convert: true,
        funcType: makeFuncType(type),
        matchedString: allString,
        type,
        startIndex: item.startIndex,
        endIndex: item.startIndex + allString.length
      };
    }
    const matchedString = allString.substring(item.startIndex, lastIndex);
    const matchedStringIndex = matchedString.indexOf(funcStartCharacter) + funcStartCharacter.length;
    const args2 = allString.substring(item.startIndex + matchedStringIndex, item.startIndex + matchedString.lastIndexOf(funcEndCharacter));
    const startIndex = item.startIndex;
    const endIndex = item.startIndex + matchedString.length;
    const newParsed = parseValue(args2).map((it) => {
      return __spreadProps(__spreadValues({}, it), {
        fullTextStartIndex: item.startIndex + matchedStringIndex + it.startIndex,
        fullTextEndIndex: item.startIndex + matchedStringIndex + it.endIndex
      });
    });
    let parameters = [];
    let commaIndex = 0;
    newParsed.forEach((it) => {
      if (it.func === FuncType.COMMA) {
        commaIndex++;
      } else {
        if (!parameters[commaIndex])
          parameters[commaIndex] = [];
        parameters[commaIndex].push(it);
      }
    });
    return {
      convert: true,
      funcType: makeFuncType(type),
      type,
      startIndex,
      endIndex,
      matchedString,
      args: args2,
      parameters
    };
  };
  const CSS_FUNC_PARSER_MAP = {
    length: (item) => editor.Length.parse(item.matchedString),
    hex: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    rgb: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    rgba: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    hsl: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    hsla: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    color: (item) => __spreadValues({
      funcType: FuncType.COLOR
    }, Color__namespace.parse(item.matchedString)),
    steps: (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.STEPS,
      count: +item.parameters[0],
      direction: item.parameters[1]
    }),
    path: (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.PATH,
      d: item.args
    }),
    repeat: (item) => {
      return {
        funcType: FuncType.REPEAT,
        count: +item.parameters[0],
        length: editor.Length.parse(item.parameters[1])
      };
    },
    "static-gradient": makeGroupFunction("static-gradient"),
    "linear-gradient": makeGroupFunction("linear-gradient"),
    "radial-gradient": makeGroupFunction("radial-gradient"),
    "conic-gradient": makeGroupFunction("conic-gradient"),
    "repeating-linear-gradient": makeGroupFunction("repeating-linear-gradient"),
    "repeating-radial-gradient": makeGroupFunction("repeating-radial-gradient"),
    "repeating-conic-gradient": makeGroupFunction("repeating-conic-gradient"),
    "cubic-bezier": (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.CUBIC_BEZIER,
      matchedString: item.matchedString,
      x1: +item.parameters[0],
      y1: +item.parameters[1],
      x2: +item.parameters[2],
      y2: +item.parameters[3]
    }),
    ease: (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.EASE,
      matchedString: item.matchedString,
      x1: 0.25,
      y1: 0.1,
      x2: 0.25,
      y2: 1
    }),
    "ease-in": (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.EASE_IN,
      matchedString: item.matchedString,
      x1: 0.42,
      y1: 0,
      x2: 1,
      y2: 1
    }),
    "ease-out": (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.EASE_OUT,
      matchedString: item.matchedString,
      x1: 0,
      y1: 0,
      x2: 0.58,
      y2: 1
    }),
    "ease-in-out": (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.EASE_IN_OUT,
      matchedString: item.matchedString,
      x1: 0.42,
      y1: 0,
      x2: 0.58,
      y2: 1
    }),
    linear: (item) => ({
      funcType: FuncType.TIMING,
      name: TimingFunction.LINEAR,
      matchedString: item.matchedString,
      x1: 0,
      y1: 0,
      x2: 1,
      y2: 1
    })
  };
  function parseValue(str, {
    funcStartCharacter = "(",
    funcEndCharacter = ")",
    parameterSaparator = ",",
    customFuncMap: customFuncMap2 = {}
  } = {}) {
    let matches = str.match(CSS_FUNC_REGEXP);
    let result = [];
    if (!matches) {
      return result;
    }
    function checkParsedResult(startIndex, endIndex, matchedString) {
      return result.some((it) => {
        if (it.parsed && sapa.isArray(it.parsed)) {
          return it.parsed.some((parsedIt) => {
            if (parsedIt.startIndex === startIndex && parsedIt.endIndex === endIndex && matchedString === parsedIt.matchedString) {
              return true;
            }
            return false;
          });
        }
        if (it.startIndex === startIndex && it.endIndex === endIndex && matchedString === it.matchedString) {
          return true;
        }
        return false;
      });
    }
    var pos = { next: 0 };
    matches = matches.map((matchedString) => {
      const startIndex = str.indexOf(matchedString, pos.next);
      pos.next = startIndex + matchedString.length;
      return { index: startIndex, matchedString };
    });
    pos.next = 0;
    for (var i = 0, len2 = matches.length; i < len2; i++) {
      const { matchedString, index: index2 } = matches[i];
      if (index2 < pos.next)
        continue;
      let parsedFunc = CSS_FUNC_MATCHES(matchedString);
      let item = {
        matchedString
      };
      const startIndex = str.indexOf(item.matchedString, pos.next);
      if (startIndex < 0) {
        continue;
      }
      item.startIndex = startIndex;
      item.endIndex = startIndex + item.matchedString.length;
      const isContinue = checkParsedResult(item.startIndex, item.endIndex, item.matchedString);
      if (isContinue) {
        continue;
      }
      if (parsedFunc) {
        item = __spreadProps(__spreadValues({}, item), {
          func: parsedFunc
        });
      } else {
        const [func, rest] = matchedString.split(funcStartCharacter);
        const [args2] = rest.split(funcEndCharacter);
        item = __spreadProps(__spreadValues({}, item), {
          func,
          args: args2,
          parameters: args2.split(parameterSaparator).map((it) => it.trim())
        });
        parsedFunc = func;
      }
      let customFunctionCallback;
      if (CSS_FUNC_PARSER_MAP[parsedFunc]) {
        customFunctionCallback = CSS_FUNC_PARSER_MAP[parsedFunc] || CSS_FUNC_PARSER_MAP[item.matchedString];
      } else if (customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString]) {
        customFunctionCallback = customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString];
      }
      if (customFunctionCallback) {
        const parsed = customFunctionCallback.call(null, item, str, funcStartCharacter, funcEndCharacter, parameterSaparator);
        if (parsed == null ? void 0 : parsed.convert) {
          item = __spreadValues(__spreadValues({}, item), parsed);
          delete item.convert;
        } else {
          item = __spreadProps(__spreadValues({}, item), {
            parsed
          });
        }
      }
      result.push(item);
      pos.next = item.endIndex;
    }
    return result;
  }
  function parseOneValue(str) {
    return parseValue(str)[0];
  }
  function parseGroupValue(str, customMapFuncName) {
    var _a;
    return (_a = parseValue(`${customMapFuncName}(${str})`, {
      customFuncMap: {
        [customMapFuncName]: makeGroupFunction(customMapFuncName)
      }
    })[0]) == null ? void 0 : _a.parameters;
  }
  class ColorStep {
    constructor(obj2 = {}) {
      this.id = obj2.id || uuidShort();
      this.color = obj2.color || "transparent";
      this.cut = obj2.cut || false;
      this.percent = obj2.percent || 0;
      this.unit = obj2.unit || "%";
      this.px = obj2.px || 0;
      this.em = obj2.em || 0;
      this.prevColorStep = obj2.prevColorStep || null;
      this.timing = obj2.timing || parseValue("linear")[0].parsed;
      this.timingCount = obj2.timingCount || 1;
    }
    toCloneObject() {
      return {
        id: this.id,
        color: this.color,
        cut: this.cut,
        percent: this.percent,
        unit: this.unit,
        px: this.px,
        em: this.em,
        prevColorStep: this.prevColorStep,
        timing: this.timing,
        timingCount: this.timingCount
      };
    }
    on() {
      this.cut = true;
    }
    off() {
      this.cut = false;
    }
    toggle() {
      this.cut = !this.cut;
    }
    toggleTiming() {
      switch (this.timing.name) {
        case TimingFunction.LINEAR:
          this.timing = parseOneValue("steps(1, start)").parsed;
          break;
        case TimingFunction.STEPS:
          this.timing = parseOneValue("ease").parsed;
          this.timingCount = 15;
          break;
        case TimingFunction.EASE:
        case TimingFunction.EASE_IN:
        case TimingFunction.EASE_IN_OUT:
        case TimingFunction.EASE_OUT:
        case TimingFunction.CUBIC_BEZIER:
          this.timing = parseOneValue("path(M 0 0 C 0.25 0.25 0.75 0.75 1 1)").parsed;
          this.timingCount = 15;
          break;
        default:
          this.timing = parseOneValue("linear").parsed;
          this.timingCount = 1;
          break;
      }
    }
    getUnit() {
      return this.unit == "%" ? "percent" : this.unit;
    }
    add(num) {
      var unit = this.getUnit();
      this[unit] += +num;
      return this;
    }
    sub(num) {
      var unit = this.getUnit();
      this[unit] -= +num;
      return this;
    }
    mul(num) {
      var unit = this.getUnit();
      this[unit] *= +num;
      return this;
    }
    div(num) {
      var unit = this.getUnit();
      this[unit] /= +num;
      return this;
    }
    mod(num) {
      var unit = this.getUnit();
      this[unit] %= +num;
      return this;
    }
    get isPx() {
      return this.unit == "px";
    }
    get isPercent() {
      return this.unit == "%" || this.unit === "percent";
    }
    get isEm() {
      return this.unit == "em";
    }
    toLength() {
      if (this.isPx) {
        return editor.Length.px(this.px);
      } else if (this.isPercent) {
        return editor.Length.percent(this.percent);
      } else if (this.isEm) {
        return editor.Length.em(this.em);
      }
    }
    getPrevLength() {
      if (!this.prevColorStep)
        return "";
      return this.prevColorStep.toLength();
    }
    toString() {
      var prev = this.cut ? this.getPrevLength() : "";
      var color = this.color || "transparent";
      return `${color} ${prev} ${this.toLength()}`;
    }
    setValue(percent, maxValue) {
      if (this.isPx) {
        this.px = maxValue * percent / 100;
      } else if (this.isPercent) {
        this.percent = percent;
      } else if (this.isEm) {
        this.em = maxValue * percent / 100 / 16;
      }
      if (this.parent) {
        this.parent.sortColorStep();
      }
    }
    static parse(colorStepString) {
      let colorsteps = [];
      const results = Color__namespace.convertMatches(colorStepString);
      var arr = results.str.split(" ").filter((it) => it.trim());
      const colorIndex = +arr[0].replace("@", "");
      const color = results.matches[colorIndex].color;
      if (arr.length === 1) {
        colorsteps.push(new ColorStep({
          color,
          unit: "%",
          percent: 0,
          hasNotUnit: true
        }));
      } else if (arr.length === 2) {
        const len2 = editor.Length.parse(arr[1]);
        let data = { unit: len2.unit };
        if (len2.isPercent()) {
          data.percent = len2.value;
        } else if (len2.isPx()) {
          data.px = len2.value;
        } else if (len2.isEm()) {
          data.em = len2.value;
        }
        colorsteps.push(new ColorStep(__spreadValues({ color }, data)));
      } else if (arr.length === 3) {
        const len2 = editor.Length.parse(arr[2]);
        let data = { unit: len2.unit };
        if (len2.isPercent()) {
          data.percent = len2.value;
        } else if (len2.isPx()) {
          data.px = len2.value;
        } else if (len2.isEm()) {
          data.em = len2.value;
        }
        colorsteps.push(new ColorStep(__spreadValues({ color, cut: true }, data)));
      }
      return colorsteps;
    }
    static createColorStep(maxCount = 2, maxValue = 100, unitType = "%") {
      var colorStepCount = randomNumber(2, maxCount);
      var unitValue = maxValue / colorStepCount;
      var colorsteps = repeat(colorStepCount).map((_, index2) => {
        return `${Color__namespace.random()} ${index2 * unitValue}${unitType}`;
      }).join(",");
      return colorsteps;
    }
    static createRepeatColorStep(maxCount = 2, unitValue = 1) {
      var colorStepCount = randomNumber(2, maxCount);
      var colorsteps = repeat(colorStepCount).map((_, index2) => {
        return `${Color__namespace.random()} ${editor.Length.parse(unitValue).mul(index2 + 1)}`;
      }).join(",");
      return colorsteps;
    }
  }
  const identity$1 = () => true;
  function _traverse(obj2, filterCallback = identity$1) {
    var results = [];
    let len2 = obj2.layers.length;
    for (let start = len2; start--; ) {
      let it = obj2.layers[start];
      results.push(..._traverse(it.ref, filterCallback));
    }
    if (filterCallback(obj2)) {
      results.push(obj2);
    }
    return results;
  }
  class Item {
    constructor(json = {}) {
      this.ref = new Proxy(this, {
        get: (target, key) => {
          var originMethod = target[key];
          if (sapa.isFunction(originMethod)) {
            return (...args2) => {
              return originMethod.apply(target, args2);
            };
          } else {
            return originMethod || target.json[key];
          }
        },
        set: (target, key, value) => {
          const isDiff = target.json[key] != value;
          if (isDiff) {
            target.json[key] = value;
            this.changed();
          }
          return true;
        }
      });
      if (json instanceof Item) {
        json = json.toJSON();
      }
      this.json = this.convert(Object.assign(this.getDefaultObject(), json));
      this.lastChangedField = {};
      this.lastChangedFieldKeys = [];
      this.cachedValue = {};
      return this.ref;
    }
    getDefaultTitle() {
      return "Item";
    }
    getIcon() {
      return "";
    }
    isAttribute() {
      return false;
    }
    isChanged(timestamp) {
      return this.json.timestamp != Number(timestamp);
    }
    changed() {
      this.json.timestamp = this.json._timestamp + window.performance.now();
    }
    get title() {
      return this.json.name || this.getDefaultTitle();
    }
    renameWithCount() {
      let arr = this.json.name.split(" ");
      if (arr.length < 2) {
        return;
      }
      let last = arr.pop();
      let lastNumber = +last;
      if (sapa.isNumber(lastNumber) && isNaN(lastNumber) === false) {
        lastNumber++;
      } else {
        lastNumber = last;
      }
      const nextName = [...arr, lastNumber].join(" ");
      this.reset({
        name: nextName
      });
    }
    get allLayers() {
      return _traverse(this.ref);
    }
    filteredAllLayers(filterCallback) {
      return _traverse(this.ref, filterCallback);
    }
    get id() {
      return this.json.id;
    }
    get layers() {
      return this.json.layers;
    }
    get parent() {
      return this.json.parent;
    }
    setParent(otherParent) {
      this.json.parent = otherParent;
    }
    get depth() {
      if (!this.parent)
        return 1;
      return this.parent.depth + 1;
    }
    get top() {
      if (!this.parent)
        return this.ref;
      let localParent = this.parent;
      do {
        if (!localParent.parent) {
          return localParent;
        }
        localParent = localParent.parent;
      } while (localParent);
    }
    get project() {
      return this.path.find((it) => it.is("project"));
    }
    get artboard() {
      return this.path.find((it) => it.is("artboard"));
    }
    get path() {
      if (!this.parent)
        return [this.ref];
      const list = this.parent.path;
      list.push(this.ref);
      return list;
    }
    getInnerId(postfix = "") {
      return this.json.id + postfix;
    }
    is(checkItemType) {
      if (!this.json)
        return false;
      return checkItemType === this.json.itemType;
    }
    isNot(checkItemType) {
      return this.is(checkItemType) === false;
    }
    isSVG() {
      return false;
    }
    addCache(key, value) {
      this.cachedValue[key] = value;
    }
    getCache(key) {
      return this.cachedValue[key];
    }
    computed(key, newValueCallback) {
      const cachedKey = `__cachedKey_${key}`;
      const parsedKey = `${cachedKey}__parseValue`;
      const value = this.json[key];
      if (this.getCache(key) === value && this.getCache(parsedKey)) {
        return this.getCache(parsedKey);
      }
      this.addCache(key, value);
      this.addCache(parsedKey, newValueCallback(value, this.ref));
      return this.getCache(parsedKey);
    }
    editable() {
      return true;
    }
    generateListNumber() {
      this.layers.forEach((it, index2) => {
        it.no = index2;
        it.generateListNumber();
      });
    }
    convert(json) {
      if (json.layers) {
        json.layers.forEach((layer) => {
          layer.parent = this.ref;
        });
      }
      return json;
    }
    setCache() {
    }
    toCloneObject(isDeep = true) {
      var json = this.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
      if (isDeep) {
        json.layers = this.json.layers.map((layer) => layer.clone(isDeep));
      }
      return json;
    }
    clone(isDeep = true) {
      var ItemClass = this.constructor;
      var item = new ItemClass(this.toCloneObject(isDeep));
      item.setParent(this.json.parent);
      return item;
    }
    reset(obj2) {
      if (!obj2.__changedId)
        obj2.__changedId = uuid();
      if (this.lastChangedField.__changedId !== obj2.__changedId) {
        this.json = this.convert(Object.assign(this.json, obj2));
        this.lastChangedField = obj2;
        this.lastChangedFieldKeys = Object.keys(obj2);
        this.changed();
      }
      return true;
    }
    hasChangedField(...args2) {
      return args2.some((it) => this.lastChangedFieldKeys.includes(it));
    }
    getDefaultObject(obj2 = {}) {
      var id = uuidShort();
      return __spreadValues({
        id,
        _timestamp: Date.now(),
        _time: window.performance.now(),
        visible: true,
        lock: false,
        selected: false,
        layers: []
      }, obj2);
    }
    attrs(...args2) {
      const result = {};
      args2.forEach((field) => {
        result[field] = sapa.clone(this.json[field]);
      });
      return result;
    }
    hasChildren() {
      return this.layers.length > 0;
    }
    appendChild(layer) {
      if (layer.parent === this.ref) {
        return layer;
      }
      this.resetMatrix(layer);
      if (layer.parent) {
        layer.remove();
      }
      layer.setParent(this.ref);
      this.json.layers.push(layer);
      this.project.addIndexItem(layer);
      return layer;
    }
    prependChildItem(layer) {
      this.resetMatrix(layer);
      if (layer.parent) {
        layer.remove();
      }
      layer.setParent(this.ref);
      this.json.layers.unshift(layer);
      this.project.addIndexItem(layer);
      return layer;
    }
    resetMatrix() {
    }
    refreshMatrixCache() {
    }
    insertChild(layer, index2 = 0) {
      this.resetMatrix(layer);
      if (layer.parent) {
        layer.remove();
      }
      layer.setParent(this.ref);
      this.json.layers.splice(index2, 0, layer);
      this.project.addIndexItem(layer);
      return layer;
    }
    insertAfter(layer) {
      const index2 = this.parent.findIndex(this);
      this.parent.insertChild(layer, index2);
      this.project.addIndexItem(layer);
      return layer;
    }
    insertBefore(layer) {
      const index2 = this.parent.findIndex(this);
      this.parent.insertChild(layer, index2 - 1);
      this.project.addIndexItem(layer);
      return layer;
    }
    setPositionInPlace(position2, item) {
      this.layers.splice(position2, 0, item);
    }
    toggle(field, toggleValue) {
      if (sapa.isUndefined(toggleValue)) {
        this.json[field] = !this.json[field];
      } else {
        this.json[field] = !!toggleValue;
      }
    }
    isTreeItemHide() {
      let currentParent = this.parent;
      let collapsedList = [];
      do {
        if (currentParent.is("project"))
          break;
        collapsedList.push(Boolean(currentParent.collapsed));
        currentParent = currentParent.parent;
      } while (currentParent);
      return Boolean(collapsedList.filter(Boolean).length);
    }
    expectJSON(key) {
      if (key === "parent")
        return false;
      if (sapa.isUndefined(this.json[key]))
        return false;
      return true;
    }
    toJSON() {
      const json = this.json;
      let newJSON = {};
      Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
        newJSON[key] = json[key];
      });
      return newJSON;
    }
    resize() {
    }
    copy(dist2 = 0) {
      return this.json.parent.copyItem(this.ref, dist2);
    }
    findIndex(item) {
      return this.json.layers.indexOf(item.ref);
    }
    copyItem(childItem, dist2 = 10) {
      var child = childItem.clone();
      child.renameWithCount();
      child.move([dist2, dist2, 0]);
      var childIndex = this.findIndex(childItem);
      if (childIndex > -1) {
        this.json.layers.push(child);
        this.project.addIndexItem(child);
      }
      return child;
    }
    remove() {
      this.json.parent.removeChild(this.ref);
      this.project.removeIndexItem(this.ref);
    }
    removeChild(childItem) {
      const index2 = this.findIndex(childItem);
      if (index2 > -1) {
        this.json.layers.splice(index2, 1);
      }
    }
    hasParent(parentId) {
      var isParent = this.json.parent.id === parentId;
      if (!isParent && this.json.parent.is("project") === false)
        return this.json.parent.hasParent(parentId);
      return isParent;
    }
  }
  class PropertyItem extends Item {
    getDefaultObject(obj2 = {}) {
      return __spreadValues({
        selected: false,
        layers: []
      }, obj2);
    }
    isAttribute() {
      return true;
    }
    toCSS() {
      return {};
    }
    toString() {
      return CSS_TO_STRING(this.toCSS());
    }
  }
  class ImageResource extends PropertyItem {
    getDefaultObject(obj2 = {}) {
      return __spreadValues({
        itemType: "image-resource",
        type: "image"
      }, obj2);
    }
    isGradient() {
      return false;
    }
    isLinear() {
      return false;
    }
    isImage() {
      return false;
    }
    hasAngle() {
      return false;
    }
    isUrl() {
      return false;
    }
    isFile() {
      return false;
    }
    isAttribute() {
      return true;
    }
    toString() {
      return "none";
    }
  }
  function easeOutElastic() {
    return (rate) => {
      return Math.pow(2, -10 * rate) * Math.sin((rate - 0.1) * 5 * Math.PI) + 1;
    };
  }
  const stepTimingFunction = (step2 = 1, direction = "end") => {
    var stepDist = 1 / step2;
    return function(rate) {
      let pos = 0;
      const offset = round(rate / stepDist, 1e7);
      if (direction == "start") {
        pos = Math.ceil(offset);
      } else if (direction == "end") {
        if (rate === 0)
          return 0;
        else if (rate === 1)
          return 1;
        pos = Math.ceil(offset) - 1;
      }
      return Math.min(Math.max(stepDist * pos, 0), 1);
    };
  };
  function step(step2 = 1, direction = "end") {
    return stepTimingFunction(step2, direction);
  }
  function stepStart() {
    return stepTimingFunction(1, "start");
  }
  function stepEnd() {
    return stepTimingFunction(1, "end");
  }
  var timingFunctions = {
    step,
    "step-start": stepStart,
    "step-end": stepEnd,
    stepStart,
    stepEnd,
    "ease-out-elastic": easeOutElastic,
    easeOutElastic
  };
  function createTimingFunction(timing = "linear") {
    var [funcName] = timing.split("(").map((it) => it.trim());
    var func = timingFunctions[funcName];
    if (func) {
      var args2 = timing.split("(")[1].split(")")[0].split(",").map((it) => it.trim());
      return func(...args2);
    } else {
      return createCurveFunction(timing);
    }
  }
  function createCurveFunction(timing) {
    var func = createBezierForPattern(timing);
    return (rate) => {
      return func(rate).y;
    };
  }
  const DEFINED_ANGLES$2 = {
    "to top": 0,
    "to top right": 45,
    "to right": 90,
    "to bottom right": 135,
    "to bottom": 180,
    "to bottom left": 225,
    "to left": 270,
    "to top left": 315
  };
  class Gradient extends ImageResource {
    isGradient() {
      return true;
    }
    toString() {
      return "none";
    }
    getDefaultObject(obj2 = {}) {
      return __spreadValues({
        itemType: "image-resource",
        type: "gradient",
        colorsteps: []
      }, obj2);
    }
    toCloneObject() {
      return __spreadProps(__spreadValues({}, super.toCloneObject()), {
        colorsteps: this.json.colorsteps.map((color) => color.clone())
      });
    }
    convert(json) {
      if (json.colorsteps[0] instanceof ColorStep)
        ;
      else {
        json.colorsteps = json.colorsteps.map((c) => new ColorStep(c));
      }
      return json;
    }
    calculateAngle() {
      var angle = this.json.angle;
      return sapa.isUndefined(DEFINED_ANGLES$2[angle]) ? angle : DEFINED_ANGLES$2[angle] || 0;
    }
    addColorStep(colorstep, isSort = true) {
      this.json.colorsteps.push(colorstep);
      if (isSort)
        this.sortColorStep();
      return colorstep;
    }
    pickColorStep(percent) {
      var colorsteps = this.colorsteps;
      if (!colorsteps.length) {
        return { percent: 0, color: "rgba(0,0,0,0)" };
      }
      if (percent < colorsteps[0].percent) {
        return {
          percent,
          color: colorsteps[0].color
        };
      }
      var lastIndex = colorsteps.length - 1;
      if (colorsteps[lastIndex].percent < percent) {
        return {
          percent,
          color: colorsteps[lastIndex].color
        };
      }
      for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
        var currentStep = colorsteps[i];
        var nextStep = colorsteps[i + 1];
        if (currentStep.percent <= percent && percent <= nextStep.percent) {
          const timing = nextStep.timing;
          switch (timing.name) {
            case TimingFunction.STEPS:
              var func = step(timing.count, timing.direction);
              break;
            case TimingFunction.PATH:
              var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
            default:
              var func = createTimingFunction(timing.matchedString);
              break;
          }
          var stopPercent = (percent - currentStep.percent) / (nextStep.percent - currentStep.percent);
          const color = Color__namespace.mix(currentStep.color, nextStep.color, func(stopPercent));
          return {
            percent,
            color
          };
        }
      }
    }
    insertColorStep(percent, startColor = "rgba(216,216,216,0)", endColor = "rgba(216,216,216,1)") {
      var colorsteps = this.colorsteps;
      if (!colorsteps.length) {
        this.addColorStepList([
          new ColorStep({ color: startColor, percent, index: 0 }),
          new ColorStep({ color: endColor, percent: 100, index: 100 })
        ]);
        return;
      }
      if (percent < colorsteps[0].percent) {
        colorsteps[0].index = 1;
        this.addColorStep(new ColorStep({ index: 0, color: colorsteps[0].color, percent }));
        return 0;
      }
      var lastIndex = colorsteps.length - 1;
      if (colorsteps[lastIndex].percent < percent) {
        var color = colorsteps[lastIndex].color;
        var index2 = colorsteps[lastIndex].index + 1;
        this.addColorStep(new ColorStep({ index: index2, color, percent }));
        return index2;
      }
      for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
        var step2 = colorsteps[i];
        var nextStep = colorsteps[i + 1];
        if (step2.percent <= percent && percent <= nextStep.percent) {
          var color = Color__namespace.mix(step2.color, nextStep.color, (percent - step2.percent) / (nextStep.percent - step2.percent), "rgb");
          this.addColorStep(new ColorStep({ index: step2.index + 1, color, percent }));
          return i + 1;
        }
      }
    }
    sortColorStep() {
      var children = this.colorsteps;
      children.sort((a, b) => {
        if (a.percent > b.percent)
          return 1;
        if (a.percent < b.percent)
          return -1;
        if (a.percent == b.percent) {
          if (a.index === b.index)
            return 0;
          return a.index > b.index ? 1 : -1;
        }
      });
      children.forEach((it, index2) => {
        it.index = index2 * 100;
      });
    }
    sortToRight() {
      var children = this.colorsteps;
      const length2 = children.length;
      const unit = 100 / length2;
      children.forEach((it, index2) => {
        it.percent = unit * (index2 + 1);
      });
      this.sortColorStep();
    }
    sortToLeft() {
      var children = this.colorsteps;
      const length2 = children.length;
      const unit = 100 / length2;
      children.forEach((it, index2) => {
        it.percent = unit * index2;
      });
      this.sortColorStep();
    }
    addColorStepList(colorstepList = []) {
      colorstepList.forEach((c) => {
        this.addColorStep(c, false);
      });
      this.sortColorStep();
    }
    getColorStep(id) {
      return this.json.colorsteps.filter((c) => c.id == id)[0];
    }
    clear(...args2) {
      if (args2.length) {
        this.json.colorsteps.splice(+args2[0], 1);
      } else {
        this.json.colorsteps = [];
      }
    }
    removeColorStepByIndex(index2) {
      this.json.colorsteps.splice(index2, 1);
    }
    removeColorStep(id) {
      this.json.colorsteps = this.json.colorsteps.filter((it) => it.id != id);
    }
    get colorsteps() {
      return this.json.colorsteps;
    }
    makeTimingString(timing, timingCount = 1) {
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.EASE:
        case TimingFunction.EASE_IN:
        case TimingFunction.EASE_OUT:
        case TimingFunction.EASE_IN_OUT:
          return `${timing.name} ${timingCount}`;
        case TimingFunction.STEPS:
          return `steps(${timing.count}, ${timing.direction})`;
        case TimingFunction.PATH:
          return `path(${timing.d}) ${timingCount}`;
        default:
          return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2}) ${timingCount}`;
      }
    }
    getColorString() {
      return this.colorsteps.map((it) => {
        const { color, percent, timing, timingCount } = it;
        return `${color} ${percent}% ${this.makeTimingString(timing, timingCount)}`;
      }).join(",");
    }
    static makeColorStepList(colorsteps) {
      const results = [];
      colorsteps.forEach((it, index2) => {
        const { color, percent, timing, timingCount } = it;
        var prevColorStep = colorsteps[index2 - 1];
        if (index2 === 0) {
          results.push({ color, percent });
          return results;
        }
        switch (timing.name) {
          case TimingFunction.STEPS:
            var func = step(timing.count, timing.direction);
            var localColorSteps = [];
            for (var i = 0; i <= timing.count; i++) {
              var stopPercent = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timing.count);
              var stopColor = Color__namespace.mix(prevColorStep.color, color, func(i / timing.count));
              localColorSteps.push({ percent: stopPercent, color: stopColor });
            }
            localColorSteps.forEach((obj2, index3) => {
              if (index3 === 0) {
                results.push({
                  percent: prevColorStep.percent,
                  color: obj2.color
                });
                results.push(obj2);
              } else {
                const prev = localColorSteps[index3 - 1];
                results.push({ percent: prev.percent, color: obj2.color });
                results.push(obj2);
              }
            });
            break;
          case TimingFunction.PATH:
            var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
            var localColorSteps = [];
            for (var i = 0; i <= timingCount; i++) {
              const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
              const stopColor2 = Color__namespace.mix(prevColorStep.color, color, func(i / timingCount));
              localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
            }
            results.push(...localColorSteps);
            break;
          default:
            var func = createTimingFunction(timing.matchedString);
            var localColorSteps = [];
            for (var i = 0; i <= timingCount; i++) {
              const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
              const stopColor2 = Color__namespace.mix(prevColorStep.color, color, func(i / timingCount));
              localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
            }
            results.push(...localColorSteps);
            break;
        }
      });
      return results;
    }
    static toCSSColorString(colorsteps = [], unit = "%", maxValue = 100) {
      const list = Gradient.makeColorStepList(colorsteps);
      return list.map((it) => {
        const { color, percent } = it;
        const pos = percent / 100 * maxValue;
        return `${color} ${pos}${unit}`;
      }).join(",");
    }
    static parseColorSteps(colors2) {
      return colors2.map((it, index2) => {
        var _a, _b, _c;
        if (it.length === 1) {
          const prev = ((_a = colors2[index2 - 1]) == null ? void 0 : _a[1]) || { parsed: { value: 0 } };
          const next = ((_b = colors2[index2 + 1]) == null ? void 0 : _b[1]) || { parsed: { value: 100 } };
          let percent = 0;
          if (!colors2[index2 - 1]) {
            percent = 0;
          } else if (!colors2[index2 + 1]) {
            percent = 100;
          } else {
            percent = prev.parsed.value + (next.parsed.value - prev.parsed.value) * 0.5;
          }
          return new ColorStep({
            color: it[0].matchedString,
            percent,
            unit: "%",
            timing: parseOneValue("linear").parsed,
            timingCount: 1
          });
        }
        if (it.length === 2) {
          return new ColorStep({
            color: it[0].matchedString,
            percent: it[1].parsed.value,
            unit: it[1].parsed.unit,
            timing: parseOneValue("linear").parsed,
            timingCount: 1
          });
        } else if (it.length === 3) {
          if (it[2].parsed.funcType === FuncType.TIMING) {
            return new ColorStep({
              color: it[0].matchedString,
              percent: it[1].parsed.value,
              unit: it[1].parsed.unit,
              timing: it[2].parsed,
              timingCount: (_c = it[3]) == null ? void 0 : _c.parsed.value
            });
          }
          return new ColorStep({
            color: it[0].matchedString,
            percent: it[2].parsed.value,
            unit: it[2].parsed.unit,
            timing: parseOneValue(`steps(1, start)`).parsed
          });
        } else if (it.length === 4) {
          return new ColorStep({
            color: it[0].matchedString,
            percent: it[1].parsed.value,
            unit: it[1].parsed.unit,
            timing: it[2].parsed,
            timingCount: it[3].parsed.value
          });
        }
      });
    }
  }
  const DEFINED_POSITIONS$1 = {
    ["center"]: true,
    ["top"]: true,
    ["left"]: true,
    ["right"]: true,
    ["bottom"]: true
  };
  const DEFINED_ANGLES$1 = {
    "to top": 0,
    "to top right": 45,
    "to right": 90,
    "to bottom right": 135,
    "to bottom": 180,
    "to bottom left": 225,
    "to left": 270,
    "to top left": 315
  };
  class ConicGradient extends Gradient {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: "conic-gradient",
        angle: 0,
        radialPosition: [editor.Position.CENTER, editor.Position.CENTER]
      }, obj2));
    }
    toCloneObject() {
      return __spreadProps(__spreadValues({}, super.toCloneObject()), {
        angle: this.json.angle,
        radialPosition: sapa.clone(this.json.radialPosition)
      });
    }
    hasAngle() {
      return true;
    }
    pickColorStep(percent) {
      return super.pickColorStep((percent + 100) % 100);
    }
    getStartEndPoint(result) {
      let startPoint, endPoint, shapePoint;
      let [rx, ry] = this.json.radialPosition;
      const backRect = result.backRect;
      const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
      if (rx == "center")
        rx = editor.Length.percent(50);
      if (ry == "center")
        ry = editor.Length.percent(50);
      const newRx = rx.toPx(backRect.width);
      const newRy = ry.toPx(backRect.height);
      const centerPoisiton = [
        backRect.x + newRx.value,
        backRect.y + newRy.value,
        0
      ];
      let topLeftPoint = backVerties[0];
      let topRightPoint = backVerties[1];
      let bottomLeftPoint = backVerties[3];
      let bottomRightPoint = backVerties[2];
      const topLeftDist = dist(centerPoisiton, topLeftPoint);
      const topRightDist = dist(centerPoisiton, topRightPoint);
      const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
      const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
      startPoint = clone(centerPoisiton);
      const dist$1 = Math.max(topLeftDist, topRightDist, bottomLeftDist, bottomRightDist);
      endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
      shapePoint = fromValues(startPoint[0], startPoint[1] - dist$1, startPoint[2]);
      return {
        startPoint,
        endPoint,
        shapePoint
      };
    }
    toString() {
      var colorString = this.getColorString();
      var opt = [];
      var json = this.json;
      var conicAngle = json.angle;
      var conicPosition = json.radialPosition || editor.Position.CENTER;
      conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
      if (sapa.isNotUndefined(conicAngle)) {
        conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
        opt.push(`from ${conicAngle}deg`);
      }
      if (conicPosition) {
        opt.push(`at ${conicPosition}`);
      }
      var optString = opt.length ? opt.join(" ") + "," : "";
      return `${json.type}(${optString} ${colorString})`;
    }
    toCSSString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = ConicGradient.toCSSColorString(this.colorsteps, "deg", 360);
      var opt = [];
      var json = this.json;
      var conicAngle = json.angle;
      var conicPosition = json.radialPosition || editor.Position.CENTER;
      conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
      if (sapa.isNotUndefined(conicAngle)) {
        conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
        opt.push(`from ${conicAngle}deg`);
      }
      if (conicPosition) {
        opt.push(`at ${conicPosition}`);
      }
      var optString = opt.length ? opt.join(" ") + "," : "";
      return `${json.type}(${optString} ${colorString})`;
    }
    static parse(str) {
      const result = parseOneValue(str);
      var opt = {
        angle: 0,
        radialPosition: ["center", "center"]
      };
      let [options2, ...colors2] = result.parameters;
      if (options2[0].func !== FuncType.COLOR) {
        let hasFrom = false;
        let hasAt = false;
        let positions = [];
        let angle = [];
        options2.forEach((it) => {
          if (it.func === FuncType.KEYWORD && it.matchedString === "from") {
            hasFrom = true;
          } else if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
            hasAt = true;
          } else if (hasAt) {
            positions.push(it);
          } else if (hasFrom) {
            angle.push(it);
          }
        });
        opt.radialPosition = positions.map((it) => {
          if (it.func === FuncType.KEYWORD) {
            switch (it.matchedString) {
              case "top":
                return editor.Length.percent(0);
              case "left":
                return editor.Length.percent(0);
              case "right":
                return editor.Length.percent(100);
              case "bottom":
                return editor.Length.percent(100);
              case "center":
                return editor.Length.percent(50);
            }
          }
          return it.parsed;
        });
        if (angle.length) {
          opt.angle = angle[0].parsed.value;
        }
      } else {
        colors2 = result.parameters;
      }
      const colorsteps = ConicGradient.parseColorSteps(colors2);
      return new ConicGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
    }
  }
  const DEFINED_DIRECTIONS = {
    0: "to top",
    45: "to top right",
    90: "to right",
    135: "to bottom right",
    180: "to bottom",
    225: "to bottom left",
    270: "to left",
    315: "to top left"
  };
  const DEFINED_ANGLES = {
    "to top": 0,
    "to top right": 45,
    "to right": 90,
    "to bottom right": 135,
    "to bottom": 180,
    "to bottom left": 225,
    "to left": 270,
    "to top left": 315
  };
  class LinearGradient extends Gradient {
    getDefaultObject(obj2) {
      return super.getDefaultObject(__spreadValues({
        type: "linear-gradient",
        angle: 0
      }, obj2));
    }
    toCloneObject() {
      return __spreadProps(__spreadValues({}, super.toCloneObject()), {
        angle: this.json.angle
      });
    }
    isLinear() {
      return true;
    }
    hasAngle() {
      return true;
    }
    getRealAngle() {
      return this.json.angle;
    }
    get angle() {
      return this.getRealAngle();
    }
    toString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = this.getColorString();
      var opt = "";
      var angle = this.json.angle || 0;
      opt = angle;
      if (sapa.isNumber(opt)) {
        opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
      }
      if (sapa.isNumber(opt)) {
        opt = opt > 360 ? opt % 360 : opt;
        opt = `${opt}deg`;
      }
      var result = `${this.json.type}(${opt}, ${colorString})`;
      return result;
    }
    toCSSString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = LinearGradient.toCSSColorString(this.colorsteps);
      var opt = "";
      var angle = this.json.angle || 0;
      opt = angle;
      if (sapa.isNumber(opt)) {
        opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
      }
      if (sapa.isNumber(opt)) {
        opt = opt > 360 ? opt % 360 : opt;
        opt = `${opt}deg`;
      }
      var result = `${this.json.type}(${opt}, ${colorString})`;
      return result;
    }
    static parse(str) {
      const result = parseOneValue(str);
      var opt = {};
      let [options2, ...colors2] = result.parameters;
      const list = [];
      const keywords = [];
      if (options2[0].func !== FuncType.COLOR) {
        options2.forEach((it) => {
          if (it.func === FuncType.KEYWORD) {
            keywords.push(it);
          } else {
            list.push(it);
          }
        });
      } else {
        colors2 = result.parameters;
      }
      let angle = keywords.map((it) => it.matchedString).join(" ");
      if (angle === "") {
        [angle] = list.map((it) => it.parsed.value);
      } else {
        angle = DEFINED_ANGLES[angle];
      }
      opt = __spreadProps(__spreadValues({}, opt), {
        angle
      });
      const colorsteps = LinearGradient.parseColorSteps(colors2);
      return new LinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
    }
  }
  const DEFINED_POSITIONS = {
    ["center"]: true,
    ["top"]: true,
    ["left"]: true,
    ["right"]: true,
    ["bottom"]: true
  };
  class RadialGradient extends Gradient {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: "radial-gradient",
        radialType: "ellipse",
        radialSize: RadialGradientSizeType.FARTHEST_CORNER,
        radialPosition: [editor.Position.CENTER, editor.Position.CENTER]
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "radialSize", "radialPosition"));
    }
    getConerDist(result) {
      let topLeftPoint = result.backVerties[0];
      let topRightPoint = result.backVerties[1];
      let bottomLeftPoint = result.backVerties[3];
      let bottomRightPoint = result.backVerties[2];
      const topLeftDist = dist(result.radialCenterPosition, topLeftPoint);
      const topRightDist = dist(result.radialCenterPosition, topRightPoint);
      const bottomLeftDist = dist(result.radialCenterPosition, bottomLeftPoint);
      const bottomRightDist = dist(result.radialCenterPosition, bottomRightPoint);
      const cornerList = [
        ["top-left", topLeftPoint, topLeftDist],
        ["top-right", topRightPoint, topRightDist],
        ["bottom-left", bottomLeftPoint, bottomLeftDist],
        ["bottom-right", bottomRightPoint, bottomRightDist]
      ];
      cornerList.sort((a, b) => {
        return a[2] - b[2];
      });
      return {
        cornerList,
        topLeftDist,
        topRightDist,
        bottomLeftDist,
        bottomRightDist
      };
    }
    EllipseRadiusToSide(result, isClosest = true) {
      var dx1 = Math.abs(result.radialCenterPoint[0]);
      var dy1 = Math.abs(result.radialCenterPoint[1]);
      var dx2 = Math.abs(result.radialCenterPoint[0] - result.backRect.width);
      var dy2 = Math.abs(result.radialCenterPoint[1] - result.backRect.height);
      if (isClosest) {
        var dx = dx1 < dx2 ? dx1 : dx2;
        var dy = dy1 < dy2 ? dy1 : dy2;
      } else {
        var dx = dx1 > dx2 ? dx1 : dx2;
        var dy = dy1 > dy2 ? dy1 : dy2;
      }
      return { width: dx, height: dy };
    }
    EllipseRadius(newSize, result, isClosest = true) {
      const {
        cornerList,
        topLeftDist,
        topRightDist,
        bottomRightDist,
        bottomLeftDist
      } = this.getConerDist(result);
      const targetList = [
        topLeftDist,
        topRightDist,
        bottomLeftDist,
        bottomRightDist
      ];
      var raySize = isClosest ? Math.min(...targetList) : Math.max(...targetList);
      var point2 = cornerList.find((it) => it[2] === raySize)[1];
      var aspect_ratio = newSize.width / newSize.height;
      if (aspect_ratio === 0) {
        return;
      }
      var distPoint = subtract([], point2, result.radialCenterPosition);
      var a = Math.sqrt(Math.pow(distPoint[0], 2) + Math.pow(distPoint[1], 2) * Math.pow(aspect_ratio, 2));
      var b = a / aspect_ratio;
      return { width: a, height: b };
    }
    getStartEndPoint(result) {
      let startPoint, endPoint, shapePoint;
      const radialType = this.json.radialType;
      const radialSize = this.json.radialSize;
      let [rx, ry] = this.json.radialPosition;
      const backRect = result.backRect;
      const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
      if (rx == "center")
        rx = editor.Length.percent(50);
      if (ry == "center")
        ry = editor.Length.percent(50);
      const newRx = rx.toPx(backRect.width);
      const newRy = ry.toPx(backRect.height);
      const centerPoisiton = [
        backRect.x + newRx.value,
        backRect.y + newRy.value,
        0
      ];
      let leftPoint = [backVerties[0][0], newRy.value, 0];
      let rightPoint = [backVerties[1][0], newRy.value, 0];
      let topPoint = [newRx.value, backVerties[0][1], 0];
      let bottomPoint = [newRx.value, backVerties[3][1], 0];
      const leftDist = dist(centerPoisiton, leftPoint);
      const rightDist = dist(centerPoisiton, rightPoint);
      const topDist = dist(centerPoisiton, topPoint);
      const bottomDist = dist(centerPoisiton, bottomPoint);
      const list = [
        ["top", topPoint, topDist],
        ["left", leftPoint, leftDist],
        ["right", rightPoint, rightDist],
        ["bottom", bottomPoint, bottomDist]
      ];
      list.sort((a, b) => {
        return a[2] - b[2];
      });
      let topLeftPoint = backVerties[0];
      let topRightPoint = backVerties[1];
      let bottomLeftPoint = backVerties[3];
      let bottomRightPoint = backVerties[2];
      const topLeftDist = dist(centerPoisiton, topLeftPoint);
      const topRightDist = dist(centerPoisiton, topRightPoint);
      const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
      const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
      const cornerList = [
        ["top-left", topLeftPoint, topLeftDist],
        ["top-right", topRightPoint, topRightDist],
        ["bottom-left", bottomLeftPoint, bottomLeftDist],
        ["bottom-right", bottomRightPoint, bottomRightDist]
      ];
      cornerList.sort((a, b) => {
        return a[2] - b[2];
      });
      startPoint = clone(centerPoisiton);
      switch (radialType) {
        case RadialGradientType.CIRCLE:
          switch (radialSize) {
            case RadialGradientSizeType.CLOSEST_SIDE:
              var [, , dist$1] = list[0];
              endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
              break;
            case RadialGradientSizeType.CLOSEST_CORNER:
              var [, , dist$1] = cornerList[0];
              endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
              break;
            case RadialGradientSizeType.FARTHEST_SIDE:
              var [, , dist$1] = list[list.length - 1];
              endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
              break;
            case RadialGradientType.CIRCLE:
            case RadialGradientSizeType.FARTHEST_CORNER:
              var [, , dist$1] = cornerList[cornerList.length - 1];
              endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
              break;
            default:
              var dist$1 = (radialSize[0] || radialSize).toPx(dist(result.backVerties[1], result.backVerties[0])).value;
              endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
              break;
          }
          break;
        case RadialGradientType.ELLIPSE:
          switch (radialSize) {
            case RadialGradientSizeType.CLOSEST_SIDE:
              var newSize = this.EllipseRadiusToSide(result, true);
              endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
              break;
            case RadialGradientSizeType.CLOSEST_CORNER:
              var newSize = this.EllipseRadiusToSide(result, true);
              var radius = this.EllipseRadius(newSize, result, true);
              endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
              break;
            case RadialGradientSizeType.FARTHEST_SIDE:
              var newSize = this.EllipseRadiusToSide(result, false);
              endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
              break;
            case RadialGradientSizeType.FARTHEST_CORNER:
              var newSize = this.EllipseRadiusToSide(result, false);
              var radius = this.EllipseRadius(newSize, result, false);
              endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
              break;
            default:
              var raySize = radialSize[0].toPx(dist(result.backVerties[1], result.backVerties[0])).value;
              var shapeSize = radialSize[1].toPx(dist(result.backVerties[3], result.backVerties[0])).value;
              endPoint = fromValues(startPoint[0] + raySize, startPoint[1], startPoint[2]);
              shapePoint = fromValues(startPoint[0], startPoint[1] + shapeSize, startPoint[2]);
              break;
          }
          break;
      }
      return {
        startPoint,
        endPoint,
        shapePoint
      };
    }
    toString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = this.getColorString();
      var json = this.json;
      var opt = "";
      var radialType = json.radialType || RadialGradientType.ELLIPSE;
      var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
      var radialPosition = json.radialPosition || ["center", "center"];
      radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
      radialSize = sapa.isArray(radialSize) ? radialSize.join(" ") : radialSize;
      opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
      return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
    }
    toCSSString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = RadialGradient.toCSSColorString(this.colorsteps);
      var json = this.json;
      var opt = "";
      var radialType = json.radialType || RadialGradientType.ELLIPSE;
      var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
      var radialPosition = json.radialPosition || ["center", "center"];
      radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
      radialSize = sapa.isArray(radialSize) ? radialSize.join(" ") : radialSize;
      opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
      return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
    }
    static parse(str) {
      const result = parseOneValue(str);
      var opt = {
        radialType: RadialGradientType.ELLIPSE,
        radialSize: RadialGradientSizeType.FARTHEST_CORNER,
        radialPosition: ["center", "center"]
      };
      let [options2, ...colors2] = result.parameters;
      if (options2[0].func !== FuncType.COLOR) {
        let radialType = RadialGradientType.ELLIPSE;
        let hasAt = false;
        let positions = [];
        let sizeOption = [];
        options2.forEach((it) => {
          if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
            hasAt = true;
          } else if (hasAt) {
            positions.push(it);
          } else {
            switch (it.matchedString) {
              case RadialGradientType.CIRCLE:
              case RadialGradientType.ELLIPSE:
                radialType = it.matchedString;
                break;
              default:
                sizeOption.push(it);
                break;
            }
          }
        });
        opt.radialType = radialType;
        opt.radialPosition = positions.map((it) => {
          if (it.func === FuncType.KEYWORD) {
            switch (it.matchedString) {
              case "top":
                return editor.Length.percent(0);
              case "left":
                return editor.Length.percent(0);
              case "right":
                return editor.Length.percent(100);
              case "bottom":
                return editor.Length.percent(100);
              case "center":
                return editor.Length.percent(50);
            }
          }
          return it.parsed;
        });
        opt.radialSize = sizeOption.map((it) => {
          if (it.func === FuncType.KEYWORD)
            return it.matchedString;
          return it.parsed;
        });
        if (opt.radialSize.length === 1) {
          opt.radialSize = opt.radialSize[0];
        }
      } else {
        colors2 = result.parameters;
      }
      const colorsteps = RadialGradient.parseColorSteps(colors2);
      return new RadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
    }
  }
  class RepeatingConicGradient extends ConicGradient {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "repeating-conic-gradient",
        angle: 0,
        radialPosition: [editor.Position.CENTER, editor.Position.CENTER]
      });
    }
    static parse(str) {
      var conic2 = ConicGradient.parse(str);
      return new RepeatingConicGradient({
        angle: conic2.angle,
        radialPosition: conic2.radialPosition,
        colorsteps: conic2.colorsteps
      });
    }
  }
  class RepeatingLinearGradient extends LinearGradient {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "repeating-linear-gradient",
        angle: 0
      });
    }
    static parse(str) {
      var linear2 = LinearGradient.parse(str);
      return new RepeatingLinearGradient({
        angle: linear2.angle,
        colorsteps: linear2.colorsteps
      });
    }
  }
  class RepeatingRadialGradient extends RadialGradient {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "repeating-radial-gradient"
      });
    }
    static parse(str) {
      var radial2 = RadialGradient.parse(str);
      return new RepeatingRadialGradient({
        radialType: radial2.radialType,
        radialSize: radial2.radialSize,
        radialPosition: radial2.radialPosition,
        colorsteps: radial2.colorsteps
      });
    }
  }
  class StaticGradient extends Gradient {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "static-gradient",
        static: true,
        colorsteps: [
          new ColorStep({ color: "red", percent: 0, index: 0 }),
          new ColorStep({ color: "red", percent: 100, index: 0 })
        ]
      });
    }
    toCloneObject() {
      return __spreadProps(__spreadValues({}, super.toCloneObject()), {
        static: true
      });
    }
    static parse(str) {
      const result = parseOneValue(str);
      var colorsteps = Gradient.parseColorSteps(result.parameters);
      return new StaticGradient({ colorsteps });
    }
    static create(color = "transparent") {
      return new StaticGradient({
        colorsteps: [
          new ColorStep({ color, percent: 0, index: 0 }),
          new ColorStep({ color, percent: 100, index: 1 })
        ]
      });
    }
    toString() {
      var color = this.json.colorsteps[0].color;
      return `static-gradient(${color})`;
    }
    toCSSString() {
      if (this.colorsteps.length === 0)
        return "";
      const color = this.colorsteps[0].color || "black";
      return `linear-gradient(${color} 0%, ${color} 100%)`;
    }
  }
  const IMAGE_LIST$1 = ["jpg", "jpeg", "png", "gif", "svg"];
  class URLImageResource extends ImageResource {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: GradientType.URL,
        url: "",
        datauri: ""
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri"));
    }
    static parse(str) {
      var url = str.split("(")[1].split(")")[0];
      return new URLImageResource({ url });
    }
    isUrl() {
      return true;
    }
    toString(url) {
      return `url(${url || this.json.url})`;
    }
    static isImageFile(fileExt) {
      return IMAGE_LIST$1.includes(fileExt);
    }
  }
  const RepeatList = [
    "repeat",
    "no-repeat",
    "repeat-x",
    "repeat-y",
    "round",
    "space"
  ];
  class BackgroundImage extends PropertyItem {
    addImageResource(imageResource) {
      this.clear("image-resource");
      return this.addItem("image-resource", imageResource);
    }
    addGradient(gradient2) {
      return this.addImageResource(gradient2);
    }
    setImageUrl(data) {
      if (!data.images)
        return;
      if (!data.images.length)
        return;
      this.reset({
        type: "image",
        image: BackgroundImage.createImage(data.images[0])
      });
    }
    static createImage(url) {
      return new URLImageResource({ url });
    }
    setGradient(data) {
      this.reset({
        type: data.type,
        image: BackgroundImage.createGradient(data, this.json.image)
      });
    }
    static createGradient(data, gradient2) {
      const colorsteps = data.colorsteps || gradient2.colorsteps;
      const angle = data.angle || gradient2.angle;
      const radialType = data.radialType || gradient2.radialType;
      const radialPosition = data.radialPosition || gradient2.radialPosition;
      let json = gradient2.toJSON();
      delete json.itemType;
      delete json.type;
      switch (data.type) {
        case "static-gradient":
          return new StaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
        case "linear-gradient":
          return new LinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
        case "repeating-linear-gradient":
          return new RepeatingLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
        case "radial-gradient":
          return new RadialGradient(__spreadProps(__spreadValues({}, json), {
            colorsteps,
            radialType,
            radialPosition
          }));
        case "repeating-radial-gradient":
          return new RepeatingRadialGradient(__spreadProps(__spreadValues({}, json), {
            colorsteps,
            radialType,
            radialPosition
          }));
        case "conic-gradient":
          return new ConicGradient(__spreadProps(__spreadValues({}, json), {
            colorsteps,
            angle,
            radialPosition
          }));
        case "repeating-conic-gradient":
          return new RepeatingConicGradient(__spreadProps(__spreadValues({}, json), {
            colorsteps,
            angle,
            radialPosition
          }));
      }
      return new Gradient();
    }
    getDefaultObject() {
      return super.getDefaultObject({
        itemType: "background-image",
        checked: false,
        blendMode: "normal",
        size: "auto",
        repeat: "repeat",
        width: editor.Length.percent(100),
        height: editor.Length.percent(100),
        x: editor.Length.percent(0),
        y: editor.Length.percent(0)
      });
    }
    toCloneObject() {
      var json = this.json;
      return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("checked", "blendMode", "size", "repeat", "width", "height", "x", "y")), {
        image: json.image.toString()
      });
    }
    convert(json) {
      json.x = editor.Length.parse(json.x);
      json.y = editor.Length.parse(json.y);
      if (json.width)
        json.width = editor.Length.parse(json.width);
      if (json.height)
        json.height = editor.Length.parse(json.height);
      if (sapa.isString(json.image)) {
        json.image = BackgroundImage.parseImage(json.image);
      }
      return json;
    }
    get image() {
      return this.json.image;
    }
    set image(image2) {
      this.json.image = image2;
    }
    checkField(key, value) {
      if (key === "repeat") {
        return RepeatList.includes(value);
      }
      return super.checkField(key, value);
    }
    recoverOffset(newX, newY, contentBox, dx = 0, dy = 0, options2 = {}) {
      const { x, y, width: width2, height } = this.json;
      const newWidth = Math.floor(width2.toPx(contentBox.width).value + dx);
      const newHeight = options2.shiftKey ? newWidth : Math.floor(height.toPx(contentBox.height).value + dy);
      newX -= contentBox.x;
      newY -= contentBox.y;
      if (newWidth < 0) {
        newX += newWidth;
      }
      if (newHeight < 0) {
        newY += newHeight;
      }
      let nextX = editor.Length.px(newX);
      let nextY = editor.Length.px(newY);
      const dist2 = 2;
      if (x.isPercent()) {
        if (Math.abs(newX) < dist2) {
          nextX = editor.Length.percent(0);
        } else if (Math.abs(contentBox.width - newWidth - newX) < dist2) {
          nextX = editor.Length.percent(100);
        } else if (Math.abs((contentBox.width - newWidth) / 2 - newX) < dist2) {
          nextX = editor.Length.percent(50);
        } else {
          nextX = editor.Length.makePercent(newX, contentBox.width - newWidth);
        }
      }
      if (y.isPercent()) {
        if (Math.abs(newY) < dist2) {
          nextY = editor.Length.percent(0);
        } else if (Math.abs(contentBox.height - newHeight - newY) < dist2) {
          nextY = editor.Length.percent(100);
        } else if (Math.abs((contentBox.height - newHeight) / 2 - newY) < dist2) {
          nextY = editor.Length.percent(50);
        } else {
          nextY = editor.Length.makePercent(newY, contentBox.height - newHeight);
        }
      }
      return {
        x: nextX,
        y: nextY,
        width: editor.Length.px(Math.abs(newWidth)).to(width2.unit, contentBox.width),
        height: editor.Length.px(Math.abs(newHeight)).to(height.unit, contentBox.height)
      };
    }
    getOffset(contentBox) {
      const { x, y, width: width2, height } = this.json;
      const newWidth = width2.toPx(contentBox.width);
      const newHeight = height.toPx(contentBox.height);
      const newX = x.toPx(contentBox.width);
      const newY = y.toPx(contentBox.height);
      return {
        x: contentBox.x + (x.isPercent() ? (contentBox.width - newWidth) * (x.value / 100) : newX),
        y: contentBox.y + (y.isPercent() ? (contentBox.height - newHeight) * (y.value / 100) : newY),
        width: newWidth.value,
        height: newHeight.value
      };
    }
    toBackgroundImageCSS() {
      if (!this.json.image)
        return {};
      return {
        "background-image": this.json.image.toCSSString()
      };
    }
    toBackgroundImageProperty() {
      if (!this.json.image)
        return {};
      return {
        "background-image": this.json.image.toString()
      };
    }
    toBackgroundPositionCSS() {
      var json = this.json;
      return {
        "background-position": `${json.x} ${json.y}`
      };
    }
    toBackgroundSizeCSS() {
      var json = this.json;
      var backgroundSize = "auto";
      if (json.size == "contain" || json.size == "cover") {
        backgroundSize = json.size;
      } else if (json.width.isPercent() && json.width.isPercent()) {
        if (+json.width !== 100 || +json.height !== 100) {
          backgroundSize = `${json.width} ${json.height}`;
        }
      } else {
        backgroundSize = `${json.width} ${json.height}`;
      }
      return {
        "background-size": backgroundSize
      };
    }
    toBackgroundRepeatCSS() {
      var json = this.json;
      return {
        "background-repeat": json.repeat
      };
    }
    toBackgroundBlendCSS() {
      var json = this.json;
      return {
        "background-blend-mode": json.blendMode
      };
    }
    toBackgroundVisibilityCSS() {
      var json = this.json;
      return {
        "background-visibility": json.visibility === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE
      };
    }
    toCSS() {
      const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageCSS()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
      return results;
    }
    toProperty() {
      const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageProperty()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
      return results;
    }
    toString() {
      return sapa.keyMap(this.toCSS(), (key, value) => {
        return `${key}: ${value}`;
      }).join(";");
    }
    toBackgroundCSS() {
      var obj2 = this.toCSS();
      return {
        background: `${obj2["background-image"]} `
      };
    }
    static parse(obj2) {
      return new BackgroundImage(obj2);
    }
    static parseImage(str) {
      const result = parseOneValue(str);
      let image2 = null;
      if (!result || str === "undefined") {
        return StaticGradient.create(str || "transparent");
      }
      switch (result.func) {
        case GradientType.LINEAR:
          image2 = LinearGradient.parse(result.matchedString);
          break;
        case GradientType.REPEATING_LINEAR:
          image2 = RepeatingLinearGradient.parse(result.matchedString);
          break;
        case GradientType.RADIAL:
          image2 = RadialGradient.parse(result.matchedString);
          break;
        case GradientType.REPEATING_RADIAL:
          image2 = RepeatingRadialGradient.parse(result.matchedString);
          break;
        case GradientType.CONIC:
          image2 = ConicGradient.parse(result.matchedString);
          break;
        case GradientType.REPEATING_CONIC:
          image2 = RepeatingConicGradient.parse(result.matchedString);
          break;
        case GradientType.URL:
          image2 = URLImageResource.parse(result.matchedString);
          break;
        default:
          image2 = StaticGradient.parse(result.matchedString);
          break;
      }
      return image2;
    }
    static changeImageType(options2) {
      switch (options2.type) {
        case GradientType.STATIC:
          return new StaticGradient(options2);
        case GradientType.LINEAR:
          return new LinearGradient(options2);
        case GradientType.REPEATING_LINEAR:
          return new RepeatingLinearGradient(options2);
        case GradientType.RADIAL:
          return new RadialGradient(options2);
        case GradientType.REPEATING_RADIAL:
          return new RepeatingRadialGradient(options2);
        case GradientType.CONIC:
          return new ConicGradient(options2);
        case GradientType.REPEATING_CONIC:
          return new RepeatingConicGradient(options2);
        case GradientType.URL:
          return new URLImageResource(options2);
      }
    }
    static parseStyle(style2) {
      var backgroundImages = [];
      if (style2["background-image"]) {
        const result = parseGroupValue(style2["background-image"], "background-image");
        result.forEach((parsedValue, index2) => {
          const item = parsedValue[0];
          let image2;
          switch (item.func) {
            case GradientType.STATIC:
              image2 = StaticGradient.parse(item.matchedString);
              break;
            case GradientType.LINEAR:
              image2 = LinearGradient.parse(item.matchedString);
              break;
            case GradientType.REPEATING_LINEAR:
              image2 = RepeatingLinearGradient.parse(item.matchedString);
              break;
            case GradientType.RADIAL:
              image2 = RadialGradient.parse(item.matchedString);
              break;
            case GradientType.REPEATING_RADIAL:
              image2 = RepeatingRadialGradient.parse(item.matchedString);
              break;
            case GradientType.CONIC:
              image2 = ConicGradient.parse(item.matchedString);
              break;
            case GradientType.REPEATING_CONIC:
              image2 = RepeatingConicGradient.parse(item.matchedString);
              break;
            case GradientType.URL:
              image2 = URLImageResource.parse(item.matchedString);
              break;
          }
          backgroundImages[index2] = new BackgroundImage({
            type: image2.type,
            image: image2
          });
        });
      }
      if (style2["background-repeat"]) {
        style2["background-repeat"].split(",").map((it) => it.trim()).forEach((it, index2) => {
          if (backgroundImages[index2]) {
            backgroundImages[index2].repeat = it;
          }
        });
      }
      if (style2["background-blend-mode"]) {
        style2["background-blend-mode"].split(",").map((it) => it.trim()).forEach((it, index2) => {
          if (backgroundImages[index2]) {
            backgroundImages[index2].blendMode = it;
          }
        });
      }
      if (style2["background-size"]) {
        style2["background-size"].split(",").map((it) => it.trim()).forEach((it, index2) => {
          if (backgroundImages[index2]) {
            if (it == "cover" || it === "contain" || it === "auto") {
              backgroundImages[index2].size = it;
            } else {
              backgroundImages[index2].size = "auto";
              let [width2, height] = it.split(" ");
              backgroundImages[index2].width = editor.Length.parse(width2);
              backgroundImages[index2].height = editor.Length.parse(height);
            }
          }
        });
      }
      if (style2["background-position"]) {
        style2["background-position"].split(",").map((it) => it.trim()).forEach((it, index2) => {
          if (backgroundImages[index2]) {
            let [x, y] = it.split(" ");
            backgroundImages[index2].x = editor.Length.parse(x);
            backgroundImages[index2].y = editor.Length.parse(y);
          }
        });
      }
      if (style2["background-visibility"]) {
        style2["background-visibility"].split(",").map((it) => it.trim()).forEach((it, index2) => {
          if (backgroundImages[index2]) {
            backgroundImages[index2].visibility = it === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE;
          }
        });
      }
      return backgroundImages;
    }
    static toCSS(list) {
      var results = {};
      list.forEach((item) => {
        sapa.keyEach(item.toCSS(), (key, value) => {
          if (!results[key])
            results[key] = [];
          results[key].push(value);
        });
      });
      return sapa.combineKeyArray(results);
    }
    static toProperty(list) {
      var results = {};
      list.forEach((item) => {
        sapa.keyEach(item.toProperty(), (key, value) => {
          if (!results[key])
            results[key] = [];
          results[key].push(value);
        });
      });
      return sapa.combineKeyArray(results);
    }
    static join(list) {
      return CSS_TO_STRING(BackgroundImage.toProperty(list.map((it) => BackgroundImage.parse(it))));
    }
    static joinCSS(list) {
      return BackgroundImage.toCSS(list.map((it) => BackgroundImage.parse(it)));
    }
    static parseList(list = []) {
      return list.map((it) => BackgroundImage.parse(it));
    }
  }
  const types = {
    image: "image",
    "image-resource": "image",
    url: "image",
    "static-gradient": "gradient",
    "linear-gradient": "gradient",
    "repeating-linear-gradient": "gradient",
    "radial-gradient": "gradient",
    "repeating-radial-gradient": "gradient",
    "conic-gradient": "gradient",
    "repeating-conic-gradient": "gradient"
  };
  class BackgroundImageEditor extends editor.EditorElement {
    initState() {
      return {
        hideLabel: this.props.hideLabel || false,
        value: this.props.value,
        images: this.parseBackgroundImage(this.props.value)
      };
    }
    parseBackgroundImage(str) {
      if (str === "")
        return [];
      return BackgroundImage.parseStyle(STRING_TO_CSS(str));
    }
    setValue(value) {
      this.setState({
        value,
        images: this.parseBackgroundImage(value)
      });
    }
    template() {
      return `
            <div class='elf--background-image-editor' >
                <div class='fill-list' ref='$fillList'></div>
            </div>
        `;
    }
    [sapa.LOAD("$fillList") + sapa.DOMDIFF]() {
      const current = this.$context.selection.current || { color: "black" };
      return this.state.images.map((it, index2) => {
        var image2 = it.image;
        var backgroundType = types[image2.type];
        const selectedClass = it.selected ? "selected" : "";
        if (it.selected) {
          this.selectedIndex = index2;
        }
        return `
            <div class='fill-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true' data-fill-type="${backgroundType}" >
                <label draggable="true" data-index="${index2}">${editor.iconUse("drag_indicator")}</label>
                ${sapa.createComponentList([
          "BackgroundPositionEditor",
          {
            key: "background-position",
            index: index2,
            ref: `$bp${index2}`,
            x: it.x,
            y: it.y,
            width: it.width,
            height: it.height,
            repeat: it.repeat,
            size: it.size,
            blendMode: it.blendMode,
            onchange: "changePattern"
          }
        ], [
          "GradientSingleEditor",
          {
            index: index2,
            ref: `$gse${index2}`,
            image: it.image,
            color: current.color,
            key: "background-image",
            onchange: "changePattern"
          }
        ])}
                <div class='fill-info'>
                  <div class='gradient-info'>
                    <div class='blend'>
                        ${sapa.createComponent("BlendSelectEditor", {
          ref: `$blend_${index2}`,
          key: "blendMode",
          value: it.blendMode,
          params: index2,
          compact: true,
          onchange: "changeRangeEditor"
        })}
                    </div>
                    <div class='tools'>
                      <button type="button" class='visibility' data-index='${index2}' title="Visibility">${editor.iconUse(it.visibility === VisibilityType.HIDDEN ? "visible_off" : "visible")}</button>
                    </div>                                       
                    <div class='tools'>
                      <button type="button" class='copy' data-index='${index2}' title="Copy Item">${editor.iconUse("add")}</button>
                    </div>                    
                    <div class='tools'>
                      <button type="button" class='remove' data-index='${index2}' title="Remove Item">${editor.iconUse("remove2")}</button>
                    </div>
                  </div>
                </div>
            </div>
            `;
      });
    }
    modifyBackgroundImage() {
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.images));
      this.parent.trigger(this.props.onchange, this.props.key, value);
    }
    makeGradient(type) {
      switch (type) {
        case "static-gradient":
          return `static-gradient(black)`;
        case "linear-gradient":
          return `linear-gradient(90deg, white 0%, black 100%)`;
        case "repeating-linear-gradient":
          return `repeating-linear-gradient(90deg, white 2%, black 4%)`;
        case "radial-gradient":
          return `radial-gradient(circle, white 0%, black 100%)`;
        case "repeating-radial-gradient":
          return `repeating-radial-gradient(circle, white 2%, black 4%)`;
        case "conic-gradient":
          return `conic-gradient(white 0%, black 100%)`;
        case "repeating-conic-gradient":
          return `repeating-conic-gradient(white 50%, black 100%)`;
      }
    }
    [sapa.SUBSCRIBE("add")](gradientType) {
      this.state.images.unshift(new BackgroundImage({
        image: BackgroundImage.parseImage(this.makeGradient(gradientType))
      }));
      this.refresh();
      this.modifyBackgroundImage();
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.DRAGSTART("$fillList .fill-item > label")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$fillList .fill-item") + sapa.PREVENT]() {
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortBackgroundImage(startIndex, targetIndex) {
      this.sortItem(this.state.images, startIndex, targetIndex);
    }
    [sapa.DROP("$fillList .fill-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      this.selectItem(this.startIndex, true);
      this.sortBackgroundImage(this.startIndex, targetIndex);
      this.refresh();
      this.modifyBackgroundImage();
    }
    getCurrentBackgroundImage() {
      return this.state.images[this.selectedIndex];
    }
    [sapa.CLICK("$fillList .tools .remove")](e) {
      var removeIndex = +e.$dt.attr("data-index");
      this.state.images.splice(removeIndex, 1);
      this.refresh();
      this.modifyBackgroundImage();
    }
    [sapa.CLICK("$fillList .tools .visibility")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.images[index2].visibility = this.state.images[index2].visibility === VisibilityType.HIDDEN ? VisibilityType.VISIBLE : VisibilityType.HIDDEN;
      this.refresh();
      this.modifyBackgroundImage();
    }
    [sapa.CLICK("$fillList .tools .copy")](e) {
      var index2 = +e.$dt.attr("data-index");
      const current = this.state.images[index2];
      this.state.images.splice(index2, 0, current);
      this.refresh();
      this.modifyBackgroundImage();
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.refs[`fillIndex${selectedIndex}`].addClass("selected");
      } else {
        this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
      }
      this.state.images.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
    [sapa.SUBSCRIBE("selectFillPopupTab")](type) {
      var typeName = types[type];
      var $fillItem = this.refs[`fillIndex${this.selectedIndex}`];
      $fillItem.attr("data-fill-type", typeName);
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
      this.trigger("changePattern", key, { [key]: value }, params);
    }
    [sapa.SUBSCRIBE_SELF("changePattern")](key, value, params) {
      var index2 = +params;
      var image2 = this.state.images[index2];
      image2.reset(value);
      this.modifyBackgroundImage();
      this.refresh();
    }
  }
  var BackgroundImagePositionPopup$1 = "";
  class BackgroundImagePositionPopup extends editor.BasePopup {
    get localeKey() {
      return "background.image.position.popup";
    }
    getTitle() {
      return this.$i18n("title");
    }
    initState() {
      return {
        size: this.props.size || "auto",
        repeat: this.props.repeat || "repeat",
        x: this.props.x || 0,
        y: this.props.y || 0,
        width: this.props.width || 0,
        height: this.props.height || 0,
        blendMode: this.props.blendMode
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.emit(this.state.changeEvent, opt, this.state.params);
    }
    templateForSize() {
      return sapa.createComponent("SelectEditor", {
        label: this.$i18n("size"),
        ref: "$size",
        key: "size",
        value: this.state.size,
        options: ["contain", "cover", "auto"],
        onchange: "changeRangeEditor"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      this.updateData({ [key]: value });
    }
    templateForX() {
      return sapa.createComponent("InputRangeEditor", {
        label: "X",
        compact: true,
        ref: "$x",
        key: "x",
        value: this.state.x,
        min: -1e3,
        max: 1e3,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForY() {
      return sapa.createComponent("InputRangeEditor", {
        label: "Y",
        compact: true,
        ref: "$y",
        key: "y",
        value: this.state.y,
        min: -1e3,
        max: 1e3,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForWidth() {
      return sapa.createComponent("InputRangeEditor", {
        label: "W",
        compact: true,
        ref: "$width",
        key: "width",
        value: this.state.width,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForHeight() {
      return sapa.createComponent("InputRangeEditor", {
        label: "H",
        compact: true,
        ref: "$height",
        key: "height",
        value: this.state.height,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForRepeat() {
      return `
    <div class='grid'>
      <label>${this.$i18n("repeat")}</label>
    </div>
    <div class='repeat-list' ref="$repeat" data-value='${this.state.repeat}'>
        <button type="button" value='no-repeat' title="${this.$i18n("type.no-repeat")}"></button>
        <button type="button" value='repeat' title="${this.$i18n("type.repeat")}"></button>
        <button type="button" value='repeat-x' title="${this.$i18n("type.repeat-x")}"></button>
        <button type="button" value='repeat-y' title="${this.$i18n("type.repeat-y")}"></button>
        <button type="button" value='space' title="${this.$i18n("type.space")}"></button>
        <button type="button" value='round' title="${this.$i18n("type.round")}"></button>
    </div>
    `;
    }
    [sapa.CLICK("$repeat button")]({ $dt: $t }) {
      this.refs.$repeat.attr("data-value", $t.value);
      this.updateData({ repeat: $t.value });
    }
    getBody() {
      return `
      <div class="elf--background-image-position-picker" ref='$picker'></div>
    `;
    }
    [sapa.LOAD("$picker") + sapa.DOMDIFF]() {
      return `
      
      <div class='box'>

        <div class='background-property'>
          ${this.templateForSize()}      
          ${this.templateForX()}
          ${this.templateForY()}
          ${this.templateForWidth()}
          ${this.templateForHeight()}
          ${this.templateForRepeat()}
        </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE("showBackgroundImagePositionPopup")](data, params, rect2) {
      this.state.changeEvent = data.changeEvent || "changeFillPopup";
      this.state.params = params;
      this.setState(data.data);
      this.showByRect(this.makeRect(180, 310, rect2));
    }
  }
  var BackgroundImageProperty$1 = "";
  class BackgroundImageProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("background.image.property.title");
    }
    afterRender() {
      this.show();
    }
    getClassName() {
      return "background-image";
    }
    getBodyClassName() {
      return "no-padding";
    }
    getBody() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "full",
        ref: "$property"
      });
    }
    getTools() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "fill-sample-list",
        ref: "$add"
      }, /* @__PURE__ */ sapa.createElementJsx("button", {
        type: "button",
        class: "fill",
        "data-value": "static-gradient"
      }, editor.iconUse("add")));
    }
    [sapa.CLICK("$add [data-value]")](e) {
      this.children.$backgroundImageEditor.trigger("add", e.$dt.data("value"));
    }
    [sapa.LOAD("$property")]() {
      var current = this.$context.selection.current || {};
      var value = current.backgroundImage || "";
      return sapa.createComponent("BackgroundImageEditor", {
        ref: "$backgroundImageEditor",
        key: "backgroundImage",
        value,
        onchange: "changeBackgroundImage"
      });
    }
    get editableProperty() {
      return "backgroundImage";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    checkCurrentItem(item) {
      return this.$context.selection.current === item;
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.IF("checkCurrentItem") + sapa.DEBOUNCE(100)]() {
      if (this.$context.selection.current) {
        if (this.$context.selection.hasChangedField("backgroundImage")) {
          this.refresh();
        }
      }
    }
    [sapa.SUBSCRIBE_SELF("changeBackgroundImage")](key, value) {
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        [key]: value
      }));
    }
  }
  var BackgroundPositionEditor$1 = "";
  class BackgroundPositionEditor extends editor.EditorElement {
    initState() {
      return {
        index: this.props.index,
        x: this.props.x,
        y: this.props.y,
        width: this.props.width,
        height: this.props.height,
        repeat: this.props.repeat,
        size: this.props.size,
        blendMode: this.props.blendMode
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.modifyValue(opt);
    }
    modifyValue(value) {
      this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
    }
    setValue(obj2) {
      this.setState(__spreadValues({}, obj2));
    }
    [sapa.BIND("$miniView")]() {
      return {
        style: {
          "background-image": "linear-gradient(to top right, black, white)",
          "background-repeat": this.state.repeat,
          "background-size": "10px 10px"
        }
      };
    }
    template() {
      return `
            <div class='elf--background-position-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK("$preview")]() {
      this.viewBackgroundPositionPopup();
    }
    viewBackgroundPositionPopup() {
      this.emit("showBackgroundImagePositionPopup", {
        changeEvent: "changeBackgroundPositionPattern",
        data: this.state
      }, {
        id: this.id
      }, this.$el.rect());
    }
    [sapa.SUBSCRIBE("changeBackgroundPositionPattern")](pattern, params) {
      if (params.id === this.id) {
        this.updateData(__spreadValues({}, pattern));
      }
    }
  }
  function backgroundImage(editor2) {
    editor2.registerElement({
      BackgroundImageEditor,
      BackgroundPositionEditor
    });
    editor2.registerUI("inspector.tab.style", {
      BackgroundImageProperty
    });
    editor2.registerUI("popup", {
      BackgroundImagePositionPopup
    });
  }
  var BorderEditor$1 = "";
  var BorderStyles = {
    none: true,
    hidden: true,
    dotted: true,
    dashed: true,
    solid: true,
    double: true,
    groove: true,
    ridge: true,
    inset: true,
    outset: true
  };
  class Border {
    static parseStyle(str) {
      return STRING_TO_CSS(str);
    }
    static parseValue(str = "") {
      var style2 = "";
      var width2 = "";
      var color = "";
      str.split(" ").filter((it) => it.trim()).forEach((value) => {
        if (BorderStyles[value]) {
          style2 = value;
        } else if (Color__namespace.isColor(value)) {
          color = value;
        } else {
          width2 = editor.Length.parse(value).value;
        }
      });
      return {
        style: style2,
        color,
        width: width2
      };
    }
    static joinValue(obj2) {
      return `${obj2.width}px ${obj2.style || "solid"} ${obj2.color}`;
    }
    static join(obj2) {
      var arr = [
        obj2["border"] ? `border: ${obj2["border"]}` : "",
        obj2["border-top"] ? `border-top: ${obj2["border-top"]}` : "",
        obj2["border-left"] ? `border-left: ${obj2["border-left"]}` : "",
        obj2["border-right"] ? `border-right: ${obj2["border-right"]}` : "",
        obj2["border-bottom"] ? `border-bottom: ${obj2["border-bottom"]}` : ""
      ].filter((it) => it);
      return arr.join(";");
    }
  }
  const borderTypeList = [
    "border"
  ];
  const borderTypeTitle = {
    border: "all",
    "border-top": "top",
    "border-right": "right",
    "border-bottom": "bottom",
    "border-left": "left"
  };
  class BorderEditor extends editor.EditorElement {
    initState() {
      var borders = Border.parseStyle(this.props.value);
      var direction = Object.keys(borders)[0] || "border";
      return {
        direction,
        borders
      };
    }
    updateData(obj2) {
      this.setState(obj2, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
    getValue() {
      return Border.join(this.state.borders);
    }
    setValue(value) {
      this.state.borders = Border.parseStyle(value);
      this.refresh();
    }
    [sapa.LOAD("$editorArea")]() {
      return borderTypeList.map((type) => {
        var label = borderTypeTitle[type] || type;
        label = this.$i18n("border.editor." + label);
        return `
      <div>
        ${sapa.createComponent("BorderValueEditor", {
          ref: `$${type}`,
          label,
          key: type,
          value: this.state.borders[type],
          onchange: "changeKeyValue"
        })}
      </div>
      `;
      });
    }
    template() {
      return `
      <div class="elf--border-editor">
        <div class='editor-area' ref='$editorArea'>

        </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      var borders = this.state.borders;
      borders[key] = value;
      this.updateData({ borders });
    }
  }
  var BorderProperty$1 = "";
  class BorderProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("border.property.title");
    }
    getBody() {
      return `<div class="property-item full border-item" ref='$body'></div>`;
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || {};
      var value = current.border || "";
      return sapa.createComponent("BorderEditor", {
        ref: "$1",
        key: "border",
        value,
        onchange: "changeKeyValue"
      });
    }
    get editableProperty() {
      return "border";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      this.$commands.executeCommand("setAttribute", "change border", this.$context.selection.packByValue({
        [key]: value
      }));
    }
  }
  var BorderValueEditor$1 = "";
  const borderStyleList = [
    BorderStyle.NONE,
    BorderStyle.HIDDEN,
    BorderStyle.SOLID,
    BorderStyle.DASHED,
    BorderStyle.DOTTED,
    BorderStyle.DOUBLE,
    BorderStyle.GROOVE,
    BorderStyle.RIDGE,
    BorderStyle.INSET,
    BorderStyle.OUTSET
  ].join(",");
  class BorderValueEditor extends editor.EditorElement {
    initState() {
      return {
        value: Border.parseValue(this.props.value)
      };
    }
    updateData(obj2) {
      this.setState(obj2, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
    getValue() {
      return Border.joinValue(this.state.value);
    }
    setValue(value) {
      this.state.value = Border.parseValue(value);
      this.refresh();
    }
    refresh() {
      const width2 = editor.Length.parse(this.state.value.width === "undefined" ? 0 : this.state.value.width);
      this.children.$width.setValue(width2.value || 0);
      this.children.$style.setValue(this.state.value.style || "solid");
      this.children.$color.setValue(this.state.value.color || "rgba(0, 0, 0, 1)");
    }
    template() {
      var { width: width2, style: style2, color } = this.state.value;
      return `
      <div class="elf--border-value-editor">
        <div class='editor-area'>
          ${sapa.createComponent("NumberInputEditor", {
        label: editor.iconUse("line_weight"),
        compact: true,
        ref: "$width",
        min: 0,
        max: 100,
        step: 1,
        key: "width",
        value: width2,
        onchange: "changeKeyValue"
      })}
          ${sapa.createComponent("SelectEditor", {
        ref: "$style",
        key: "style",
        label: editor.iconUse("line_style"),
        title: "Style",
        compact: true,
        options: borderStyleList,
        value: style2 || "solid",
        onchange: "changeKeyValue"
      })}
          ${sapa.createComponent("ColorViewEditor", {
        ref: "$color",
        key: "color",
        mini: true,
        value: color || "rgba(0, 0, 0, 1)",
        onchange: "changeKeyValue"
      })}
        </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, v) {
      var value = this.state.value;
      value[key] = v;
      this.updateData({ value });
    }
  }
  function border(editor2) {
    editor2.registerElement({
      BorderEditor,
      BorderValueEditor
    });
    editor2.registerUI("inspector.tab.style", {
      BorderProperty
    });
  }
  const typeList$2 = [
    { key: "top", title: "Top" },
    { key: "bottom", title: "Bottom" },
    { key: "left", title: "Left" },
    { key: "right", title: "Right" }
  ];
  const keyList$1 = typeList$2.map((it) => it.key);
  const names = {
    image: "Image",
    "static-gradient": "Static",
    "linear-gradient": "Linear",
    "repeating-linear-gradient": `${editor.iconUse("repeat")} Linear`,
    "radial-gradient": "Radial",
    "repeating-radial-gradient": `${editor.iconUse("repeat")} Radial`,
    "conic-gradient": "Conic",
    "repeating-conic-gradient": `${editor.iconUse("repeat")} Conic`
  };
  class BorderImageProperty extends editor.BaseProperty {
    getTitle() {
      return "Border Image";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refresh();
    }
    getTools() {
      var current = this.$context.selection.current || {};
      var appliedBorderImage = current.appliedBorderImage || false;
      return `
      <label><input type='checkbox' ${appliedBorderImage ? "checked" : ""} ref='$apply' /> Apply</label>
    `;
    }
    [sapa.CLICK("$apply")]() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      var applyBorderImage = this.refs.$apply.checked();
      this.$commands.executeCommand("setAttribute", this.$context.selection.packByValue({
        applyBorderImage
      }));
    }
    getColorStepList(image2) {
      switch (image2.type) {
        case "static-gradient":
        case "linear-gradient":
        case "repeating-linear-gradient":
        case "radial-gradient":
        case "repeating-radial-gradient":
        case "conic-gradient":
        case "repeating-conic-gradient":
          return this.getColorStepString(image2.colorsteps);
      }
      return "";
    }
    getColorStepString(colorsteps) {
      return colorsteps.map((step2) => {
        return `<div class='step' data-colorstep-id="${step2.id}" data-selected='${step2.selected}' style='background-color:${step2.color};'></div>`;
      }).join("");
    }
    [sapa.LOAD("$borderImageView")]() {
      var current = this.$context.selection.current || {
        borderImage: { image: {} }
      };
      var borderImage2 = current.borderImage;
      var backgroundTypeName = borderImage2.type ? names[borderImage2.type] : "";
      const imageCSS = `background-image: ${borderImage2.image.toString()}; background-size: cover;`;
      return ` 
      <div class='preview' ref="$preview">
        <div class='mini-view'>
          <div class='color-view'  style="${imageCSS}" ref="$miniView"></div>
        </div>
      </div> 
      <div class='fill-info'>
        <div class='gradient-info'>
          <div class='fill-title' ref="$fillTitle">${backgroundTypeName}</div>
          <div class='colorsteps' ref="$colorsteps">
            ${this.getColorStepList(borderImage2.image)}
          </div>
        </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeBorderImage")](key, value) {
      if (key === "border-image-slice") {
        keyList$1.forEach((type) => {
          this.children[`$${type}Slice`].setValue(value);
        });
      }
      this.setBorderImageProperty();
    }
    getBody() {
      return `
      <div class="property-item border-image-item" ref='$borderImageView'></div>    
      <div class="property-item border-slice-item">
        <div class="slice-selector" data-selected-value="all" ref="$selector">
          <button type="button" data-value="all">${icon.border_all}</button>
          <button type="button" data-value="partitial">
            ${icon.border_inner}
          </button>
        </div>
        <div class="slice-value">
          ${sapa.createComponent("RangeEditor", {
        ref: "$allSlice",
        key: "border-image-slice",
        onchange: "changeBorderImage"
      })}
        </div>
      </div>
      <div
        class="property-item border-slice-item full has-list"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="slice-setting-box" ref="$sliceSettingBox">
          ${typeList$2.map((it) => {
        return `
              <div>
                <label class='title'>${it.title}</label>
              </div>
              <div>
                ${sapa.createComponent("RangeEditor", {
          ref: `$${it.key}Slice`,
          label: "Slice",
          key: `border-image-slice-${it.key}`,
          onchange: "changeBorderImage"
        })}
              </div>  
              <div>
                ${sapa.createComponent("RangeEditor", {
          ref: `$${it.key}Width`,
          label: "Width",
          key: `border-image-width-${it.key}`,
          onchange: "changeBorderImage"
        })}              
              </div>                
            `;
      }).join("")}
        </div>
      </div>
    `;
    }
    [sapa.CHANGE("$sliceSettingBox select")]() {
      this.setBorderImageProperty();
    }
    [sapa.CLICK("$borderImageView .preview")]() {
      this.viewFillPopup(this.refs.$preview, "");
    }
    [sapa.CLICK("$borderImageView .colorsteps .step")](e) {
      this.refs.$colorsteps.$(`[data-selected="true"]`).removeAttr("data-selected");
      var selectColorStepId = e.$dt.attr("data-colorstep-id");
      e.$dt.attr("data-selected", true);
      var $preview = e.$dt.closest("border-image-item").$(".preview");
      this.viewFillPopup($preview, selectColorStepId);
    }
    getFillData(borderImage2) {
      let data = {
        type: borderImage2.type
      };
      switch (data.type) {
        case "image":
          data.url = borderImage2.image ? borderImage2.image.url : "";
          break;
        default:
          if (borderImage2.image) {
            const image2 = borderImage2.image;
            data.type = image2.type;
            data.colorsteps = [...image2.colorsteps];
            data.angle = image2.angle;
            data.radialType = image2.radialType || "ellipse";
            data.radialPosition = image2.radialPosition || editor.Position.CENTER;
          } else {
            data.colorsteps = [];
            data.angle = 0;
            data.radialType = "ellipse";
            data.radialPosition = editor.Position.CENTER;
          }
          break;
      }
      return data;
    }
    viewFillPopup($preview, selectColorStepId) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.emit("showFillPopup", __spreadProps(__spreadValues({
        changeEvent: "changeBorderImageFillPopup"
      }, this.getFillData(current.borderImage)), {
        selectColorStepId,
        refresh: true
      }));
    }
    viewChangeImage() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      var borderImage2 = current.borderImage;
      if (!borderImage2)
        return;
      var $el = this.getRef("$miniView");
      if ($el && borderImage2.image) {
        $el.css({
          "background-image": borderImage2.image.toString(),
          "background-size": "cover"
        });
      }
      var $el = this.getRef("$fillTitle");
      if ($el) {
        $el.html(names["image"]);
      }
      var $el = this.getRef("$colorsteps", this.selectedIndex);
      if ($el) {
        $el.empty();
      }
    }
    setImage(data) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      current.borderImage.setImageUrl(data);
      this.viewChangeImage(data);
      this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
    }
    viewChangeGradient(data) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      var borderImage2 = current.borderImage;
      if (!borderImage2)
        return;
      var $el = this.getRef("$miniView");
      if ($el) {
        $el.css({
          "background-image": borderImage2.image.toString(),
          "background-size": "cover"
        });
      }
      var $el = this.getRef("$fillTitle");
      if ($el) {
        $el.html(names[data.type]);
      }
      var $el = this.getRef("$colorsteps", this.selectedIndex);
      if ($el) {
        $el.html(this.getColorStepString(data.colorsteps));
      }
    }
    setGradient(data) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      current.borderImage.setGradient(data);
      this.viewChangeGradient(data);
      this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
    }
    [sapa.SUBSCRIBE("changeBorderImageFillPopup")](data) {
      switch (data.type) {
        case "image":
          this.setImage(data);
          break;
        default:
          this.setGradient(data);
          break;
      }
    }
    setBorderImageProperty() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      var borderImage2 = current.borderImage;
      var type = this.refs.$selector.attr("data-selected-value");
      if (type === "all") {
        var len2 = this.children.$allSlice.getValue();
        borderImage2.reset({
          slice: {
            top: len2.clone(),
            right: len2.clone(),
            bottom: len2.clone(),
            left: len2.clone()
          }
        });
      } else {
        keyList$1.forEach((type2) => {
          borderImage2.slice[type2] = this.children[`$${type2}Slice`].getValue();
          borderImage2.width[type2] = this.children[`$${type2}Width`].getValue();
        });
      }
      this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
    }
    [sapa.CLICK("$selector button")](e) {
      var type = e.$dt.attr("data-value");
      this.refs.$selector.attr("data-selected-value", type);
      if (type === "all") {
        this.refs.$partitialSetting.hide();
      } else {
        this.refs.$partitialSetting.show("grid");
      }
      this.setBorderImageProperty();
    }
  }
  function borderImage(editor2) {
    editor2.registerElement({
      BorderImageProperty
    });
  }
  var BorderRadiusEditor$1 = "";
  class BorderRadius {
    static parseStyle(str = "") {
      var obj2 = {
        isAll: true,
        "border-radius": editor.Length.px(0),
        "border-top-left-radius": editor.Length.px(0),
        "border-top-right-radius": editor.Length.px(0),
        "border-bottom-right-radius": editor.Length.px(0),
        "border-bottom-left-radius": editor.Length.px(0)
      };
      var arr = str.split(" ").map((it) => editor.Length.parse(it));
      if (arr.length === 1) {
        obj2.isAll = true;
        obj2["border-radius"] = arr[0];
      } else {
        obj2.isAll = false;
        obj2["border-top-left-radius"] = arr[0];
        obj2["border-top-right-radius"] = arr[1];
        obj2["border-bottom-right-radius"] = arr[2];
        obj2["border-bottom-left-radius"] = arr[3];
        if (arr[0].equals(arr[1]) && arr[0].equals(arr[2]) && arr[0].equals(arr[3])) {
          obj2.isAll = true;
          obj2["border-radius"] = arr[0];
        }
      }
      return obj2;
    }
  }
  const typeList$1 = [
    { key: "border-top-left-radius", title: "topLeft", label: "TL" },
    { key: "border-top-right-radius", title: "topRight", label: "TR" },
    { key: "border-bottom-left-radius", title: "bottomLeft", label: "BL" },
    { key: "border-bottom-right-radius", title: "bottomRight", label: "BR" }
  ];
  const keyList = typeList$1.map((it) => it.key);
  const BorderGroup = {
    ALL: "all",
    PARTITIAL: "partial"
  };
  class BorderRadiusEditor extends editor.EditorElement {
    initState() {
      return __spreadValues({}, BorderRadius.parseStyle(this.props.value));
    }
    template() {
      return `<div class='elf--border-radius-editor' ref='$body'></div>`;
    }
    [sapa.SUBSCRIBE_SELF("changeBorderRadius")](key, value) {
      if (key === "border-radius") {
        keyList.forEach((type) => {
          this.children[`$${type}`].setValue(value.clone());
        });
      }
      this.setBorderRadius();
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      var borderRadius2 = this.state["border-radius"];
      return `
      <div class="border-radius-item">
        <div class="radius-value">
          ${sapa.createComponent("InputRangeEditor", {
        label: editor.iconUse("outline_rect"),
        ref: "$all",
        compact: "true",
        key: "border-radius",
        value: borderRadius2,
        min: 0,
        onchange: "changeBorderRadius"
      })}
        </div>
        <div></div>
        ${sapa.createComponent("ToggleButton", {
        compact: true,
        ref: "$toggle",
        key: "border-all",
        checkedValue: BorderGroup.PARTITIAL,
        value: BorderGroup.ALL,
        toggleLabels: [editor.iconUse("border_inner"), editor.iconUse("border_inner")],
        toggleValues: [BorderGroup.ALL, BorderGroup.PARTITIAL],
        onchange: "changeKeyValue"
      })}
      </div>
      <div
        class="full border-radius-item"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="radius-setting-box" ref="$radiusSettingBox">
          <div>
            ${typeList$1.map((it) => {
        var value = this.state[it.key];
        var title = this.$i18n("border.radius.editor." + it.title);
        var label = it.label;
        return `
                <div>
                  ${sapa.createComponent("InputRangeEditor", {
          compact: true,
          ref: `$${it.key}`,
          label,
          title,
          key: it.key,
          value,
          min: 0,
          step: 1,
          onchange: "changeBorderRadius"
        })}
                </div>  
              `;
      }).join("")}
          </div>
        </div>
      </div>
    `;
    }
    [sapa.INPUT("$radiusSettingBox input")]() {
      this.setBorderRadius();
    }
    [sapa.CHANGE("$radiusSettingBox select")]() {
      this.setBorderRadius();
    }
    setBorderRadius() {
      var type = this.selectedValue;
      if (type === BorderGroup.ALL) {
        this.state["border-radius"] = this.children[`$all`].getValue();
      } else {
        keyList.forEach((key) => {
          this.state[key] = this.children[`$${key}`].getValue();
        });
      }
      this.modifyBorderRadius();
    }
    modifyBorderRadius() {
      var value = "";
      if (this.selectedValue === BorderGroup.ALL) {
        value = this.state["border-radius"] + "";
      } else {
        value = keyList.map((key) => `${this.state[key]}`).join(" ");
      }
      this.parent.trigger(this.props.onchange, value);
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      const type = value;
      if (type === BorderGroup.PARTITIAL) {
        this.selectedValue = BorderGroup.PARTITIAL;
        this.refs.$partitialSetting.show();
      } else {
        this.selectedValue = BorderGroup.ALL;
        this.refs.$partitialSetting.hide();
      }
      this.setBorderRadius();
    }
  }
  class BorderRadiusProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("border.radius.property.title");
    }
    getBody() {
      return `<div class="property-item full border-radius-item" ref='$body'></div>`;
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || {};
      var value = current.borderRadius || "0px";
      return sapa.createComponent("BorderRadiusEditor", {
        ref: "$1",
        value,
        onchange: "changeBorderRadius"
      });
    }
    get editableProperty() {
      return "borderRadius";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100) + sapa.IF("checkShow")]() {
      if (this.$context.selection.hasChangedField("borderRadius")) {
        this.refresh();
      }
    }
    [sapa.SUBSCRIBE_SELF("changeBorderRadius")](value) {
      this.$commands.executeCommand("setAttribute", "change border radius", this.$context.selection.packByValue({
        borderRadius: value
      }));
    }
  }
  function borderRadius(editor2) {
    editor2.registerElement({
      BorderRadiusEditor
    });
    editor2.registerUI("inspector.tab.style", {
      BorderRadiusProperty
    });
  }
  var BoxModelProperty$1 = "";
  const fields = ["margin", "padding"];
  let styleKeys = [];
  fields.forEach((field) => {
    styleKeys.push.apply(styleKeys, ["-top", "-bottom", "-left", "-right"].map((it) => field + it));
  });
  class BoxModelProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("box.model.property.title");
    }
    get editableProperty() {
      return "boxModel";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    checkCurrentItem(item) {
      return this.$context.selection.current === item;
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.IF("checkCurrentItem") + sapa.DEBOUNCE(100)]() {
      const current = this.$context.selection.current;
      if (current == null ? void 0 : current.hasChangedField("padding-left", "padding-right", "padding-top", "padding-bottom")) {
        this.refresh();
      }
    }
    getBody() {
      return `<div class="property-item elf--box-model-item" ref="$boxModelItem"></div>`;
    }
    templateInput(key, current) {
      var value = editor.Length.parse(current[key] || 0);
      return `<input type="number" ref="$${key}" value="${value.value}" tabIndex="1" />`;
    }
    [sapa.LOAD("$boxModelItem") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      return `
      <div>
        <div class="margin" data-title="${this.$i18n("box.model.property.margin")}">
          <div data-value="top">
            ${this.templateInput("margin-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("margin-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("margin-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("margin-right", current)}
          </div>
        </div>
        <div class="padding" data-title="${this.$i18n("box.model.property.padding")}">
          <div data-value="top">
            ${this.templateInput("padding-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("padding-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("padding-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("padding-right", current)}
          </div>
        </div>
        <div class='content' title='Content'>
        
        </div>
      </div>
    `;
    }
    [sapa.INPUT("$boxModelItem input")]() {
      this.resetBoxModel();
    }
    resetBoxModel() {
      var data = {};
      styleKeys.forEach((key) => {
        data[key] = this.refs["$" + key].value;
      });
      this.$commands.executeCommand("setAttribute", "change padding or margin", this.$context.selection.packByValue(data));
    }
  }
  function boxModel(editor2) {
    editor2.registerUI("inspector.tab.style", {
      BoxModelProperty
    });
  }
  var boxShadow$1 = [
    {
      name: "Box",
      shadows: [
        {
          offsetX: 0,
          offsetY: 3,
          blurRadius: 3,
          spreadRadius: 0,
          color: "rgba(0,0,0,0.2)"
        }
      ]
    },
    {
      name: "Shadow-4",
      shadows: [
        {
          offsetX: 0,
          offsetY: 1,
          blurRadius: 1,
          spreadRadius: 0,
          color: "rgba(0,0,0,0.15)"
        },
        {
          offsetX: 0,
          offsetY: 2,
          blurRadius: 2,
          spreadRadius: 0,
          color: "rgba(0,0,0,0.15)"
        },
        {
          offsetX: 0,
          offsetY: 4,
          blurRadius: 4,
          spreadRadius: 0,
          color: "rgba(0,0,0,0.15)"
        },
        {
          offsetX: 0,
          offsetY: 8,
          blurRadius: 8,
          spreadRadius: 0,
          color: "rgba(0,0,0,0.15)"
        }
      ]
    }
  ];
  var BoxShadowProperty$1 = "";
  class BoxShadowProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("boxshadow.property.title");
    }
    getBody() {
      return `
      <div class="full box-shadow-item" ref="$shadowList"></div>
    `;
    }
    getTools() {
      return `
      <select class='box-shadow-samples' ref="$select">
      ${boxShadow$1.map((item, index2) => {
        return `
          <option value="${index2}">${item.name}</option>
        `;
      }).join("")}
      </select>
      <button type="button" ref='$add'>${editor.iconUse("add")}</button>
    `;
    }
    [sapa.CLICK("$add")]() {
      const index2 = +this.refs.$select.value;
      this.children.$boxshadow.trigger("add", boxShadow$1[index2].shadows);
    }
    [sapa.LOAD("$shadowList")]() {
      var current = this.$context.selection.current || {};
      return sapa.createComponent("BoxShadowEditor", {
        ref: "$boxshadow",
        key: "boxShadow",
        value: sapa.clone(current.boxShadow),
        onchange: (key, value) => {
          this.$commands.executeCommand("setAttribute", "change box shadow", this.$context.selection.packByValue({
            [key]: sapa.clone(value)
          }));
        }
      });
    }
    get editableProperty() {
      return "boxShadow";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100) + sapa.IF("checkShow")]() {
      this.refresh();
    }
  }
  function boxShadow(editor2) {
    editor2.registerUI("inspector.tab.style", {
      BoxShadowProperty
    });
  }
  var polygon = {
    key: "polygon",
    title: "Polygon",
    execute: function() {
      return [
        { name: "Triangle", polygon: "50% 0%, 0% 100%, 100% 100%" },
        { name: "Trapezoid", polygon: "20% 0%, 80% 0%, 100% 100%, 0% 100%" },
        {
          name: "Parallelogram",
          polygon: "25% 0%, 100% 0%, 75% 100%, 0% 100%"
        },
        {
          name: "Rhombus",
          polygon: "50% 0%, 100% 50%, 50% 100%, 0% 50%"
        },
        {
          name: "Pentagon",
          polygon: "50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%"
        },
        {
          name: "Hexagon",
          polygon: "50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%"
        },
        {
          name: "Heptagon",
          polygon: "50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%"
        },
        {
          name: "Octagon",
          polygon: "30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%"
        }
      ];
    }
  };
  var ClipPathProperty$1 = "";
  const CLIPPATH_REG = /(content-box|padding-box|border-box|margin-box|view-box|stroke-box|fill-box|none|(inset|circle|ellipse|polygon|path|svg|url)(\(([^)]*)\))?)/gi;
  class ClipPath extends PropertyItem {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "clip-path",
        type: "none",
        value: ""
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
    }
    toString() {
      var type = this.json.type;
      var value = this.json.value;
      var box = this.json.box;
      var results = "";
      switch (type) {
        case "circle":
        case "inset":
        case "ellipse":
        case "polygon":
        case "path":
          results = `${type}(${value})`;
          break;
        case "svg":
          results = `url(#${value})`;
          break;
        default:
          results = "none";
          break;
      }
      return box ? `${box} ${results}` : results;
    }
    toCSS() {
      return {
        "clip-path": this.toString()
      };
    }
    static toCSS(obj2) {
      return new ClipPath(obj2).toCSS();
    }
    static toString(obj2) {
      return ClipPath.toCSS(obj2)["clip-path"];
    }
    static parse(obj2) {
      return new ClipPath(obj2);
    }
    static parseStyle(str) {
      var clippath = {};
      if (!str)
        return {};
      var matches = str.match(CLIPPATH_REG) || [];
      matches.forEach((value) => {
        if (value.includes("-box")) {
          clippath.box = value;
        } else {
          var [clipPathName, clipPathValue] = value.split("(");
          clipPathValue = clipPathValue || "";
          if (clipPathName === "none") {
            clipPathValue = "";
          } else {
            clipPathValue = clipPathValue.split(")")[0];
          }
          clippath.type = clipPathName;
          clippath.value = clipPathValue;
        }
      });
      return clippath;
    }
    static parseStyleForCircle(str = "50% at 50% 50%") {
      var radius = new editor.Length("", "closest-side"), position2 = "";
      str = str || "50% at 50% 50%";
      if (str.includes("at")) {
        [radius, position2] = str.split("at").map((it) => it.trim());
      } else {
        position2 = str.trim();
      }
      var [x, y] = position2.split(" ");
      if (sapa.isUndefined(y)) {
        y = x;
      }
      radius = editor.Length.parse(radius);
      x = editor.Length.parse(x);
      y = editor.Length.parse(y);
      return {
        radius,
        x,
        y
      };
    }
    static parseStyleForEllipse(str = "50% 50%") {
      var radius = `50% 50%`, position2 = "";
      str = str || "50%";
      if (str.includes("at")) {
        [radius, position2] = str.split("at").map((it) => it.trim());
      } else {
        position2 = str.trim();
      }
      var [x, y] = position2.split(" ");
      if (sapa.isUndefined(y)) {
        y = x;
      }
      x = editor.Length.parse(x);
      y = editor.Length.parse(y);
      var [radiusX, radiusY] = radius.split(" ");
      if (sapa.isUndefined(radiusY)) {
        radiusY = radiusX;
      }
      radiusX = editor.Length.parse(radiusX);
      radiusY = editor.Length.parse(radiusY);
      return {
        radiusX,
        radiusY,
        x,
        y
      };
    }
    static parseStyleForInset(str = "") {
      var [inset, round2] = str.split("round");
      var [_count, top, right, bottom, left] = editor.DirectionLength.parse(inset);
      if (round2) {
        var [_roundCount, topRadius, rightRadius, bottomRadius, leftRadius] = editor.DirectionLength.parse(round2);
      }
      return {
        isAll: _count === 1,
        top,
        right,
        bottom,
        left,
        round: round2,
        isAllRadius: _roundCount === 1,
        topRadius,
        rightRadius,
        bottomRadius,
        leftRadius
      };
    }
    static parseStyleForPolygon(str = "") {
      return str.split(",").filter((it) => it.trim()).map((it) => {
        var [x, y] = it.trim().split(" ");
        return {
          x: editor.Length.parse(x),
          y: editor.Length.parse(y)
        };
      });
    }
  }
  const ClipPathSample = {
    [ClipPathType.CIRCLE]: "circle(50% at 50% 50%)",
    [ClipPathType.ELLIPSE]: "ellipse(50% 50% at 50% 50%)",
    [ClipPathType.INSET]: "inset(0% 0% 0% 0%)",
    [ClipPathType.POLYGON]: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
    [ClipPathType.PATH]: "path()"
  };
  class ClipPathProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("clippath.property.title");
    }
    getClassName() {
      return "clip-path-property";
    }
    getBody() {
      return `<div class='elf--clip-path-list' ref='$clippathList'></div>`;
    }
    getTools() {
      return `
      <div ref="$tools" class="add-tools">
        <button type="button" data-value='circle' data-tooltip="Circle">${editor.iconUse("outline_circle")}</button>
        <button type="button" data-value='ellipse' data-tooltip="Ellipse">${editor.iconUse("outline_circle", "scale(1 0.7) translate(0 5)")}</button>
        <button type="button" data-value='inset' data-tooltip="Inset">${editor.iconUse("outline_rect")}</button>
        <button type="button" data-value='polygon' data-tooltip="Polygon">${editor.iconUse("polygon")}</button>
        <button type="button" data-value='path' data-tooltip="Path">${editor.iconUse("pentool")}</button>
        <button type="button" data-value='svg' data-tooltip="SVG">${editor.iconUse("image")}</button>
      </div>
    `;
    }
    makeClipPathTemplate(clippath, func) {
      const isPath = clippath === "path";
      const isPolygon = clippath === "polygon";
      let newPathString = "";
      if (isPath) {
        const pathString2 = func.split("(")[1].split(")")[0];
        let pathObject = PathParser.fromSVGString(pathString2);
        const bbox = pathObject.getBBox();
        const rectangle = vertiesToRectangle(bbox);
        const rate = 260 / rectangle.width;
        const hRate = 150 / rectangle.height;
        const lastRate = Math.min(rate, hRate);
        pathObject = pathObject.translate(-bbox[0][0], -bbox[0][1]).scale(lastRate, lastRate);
        const newBBox = pathObject.getBBox();
        const newRectangle = vertiesToRectangle(newBBox);
        newPathString = pathObject.translate(260 / 2 - newRectangle.width / 2, 0).d;
      }
      let polygonSelect = "";
      if (isPolygon) {
        const polygonList = polygon.execute();
        polygonSelect = sapa.createComponent("SelectEditor", {
          ref: "$polygonSelect",
          options: ["", ...polygonList.map((it) => it.name)],
          onchange: (key, value) => {
            const polygon2 = polygonList.find((it) => it.name === value);
            if (polygon2) {
              this.updatePathInfo({
                "clip-path": `polygon(${polygon2.polygon})`
              });
            }
          }
        });
      }
      return `
      <div>
        <div class='clippath-item'>
          <label>${editor.iconUse("drag_indicator")}</label>
          <div class='title'>
            <div class='name'>${clippath}</div>
            ${isPolygon ? polygonSelect : ""}
          </div>
          <div class='tools'>
            <button type="button" class="del">${editor.iconUse("remove2")}</button>
          </div>        
        </div>
        ${isPath ? `<svg><path d="${newPathString}" fill="transparent" stroke="currentColor" /></svg>` : ""}
      </div>

    `;
    }
    [sapa.CLICK("$clippathList .clippath-item .title .name")]() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.viewClipPathPicker();
    }
    [sapa.CLICK("$clippathList .del") + sapa.PREVENT]() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.$commands.executeCommand("setAttribute", "delete clip-path", this.$context.selection.packByValue({
        clipPath: ""
      }));
      this.emit("hideClipPathPopup");
      window.setTimeout(() => {
        this.refresh();
      }, 100);
    }
    get editableProperty() {
      return "clipPath";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    [sapa.LOAD("$clippathList")]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      if (!current.clipPath)
        return "";
      return this.makeClipPathTemplate(current.clipPath.split("(")[0], current.clipPath);
    }
    [sapa.CLICK("$tools [data-value]")](e) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      if (current.clipPath) {
        window.alert("clip-path is already exists.");
        return;
      }
      if (current) {
        current.reset({
          clipPath: ClipPathSample[e.$dt.data("value")]
        });
        this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.pack("clipPath"));
      }
      this.refresh();
    }
    viewClipPathPicker() {
      var current = this.$context.selection.current;
      if (!current)
        return;
      var obj2 = ClipPath.parseStyle(current.clipPath);
      switch (obj2.type) {
        case "path":
          var d = current.absolutePath(current.clipPathString).d;
          var mode = d ? "modify" : "path";
          this.emit("showPathEditor", mode, {
            changeEvent: (data) => {
              data.d = current.invertPath(data.d).d;
              this.updatePathInfo({
                clipPath: `path(${data.d})`
              });
            },
            current,
            d
          });
          break;
      }
    }
    updatePathInfo(data) {
      if (!data)
        return;
      var current = this.$context.selection.current;
      if (!current)
        return;
      current.reset(data);
      this.refresh();
      this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.packByValue(data));
    }
  }
  function clipPath(editor2) {
    editor2.registerUI("inspector.tab.style", {
      ClipPathProperty
    });
  }
  var ClippathEditorView$2 = "";
  class ClippathPolygonEditorView extends editor.EditorElement {
    initializePolygon() {
      const current = this.$context.selection.current;
      this.state.current = current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.clippath.value = ClipPath.parseStyleForPolygon(this.state.clippath.value);
      this.screenPoints = this.$viewport.applyVerties(vertiesMap(this.state.clippath.value.map((point2) => {
        const { x, y } = point2;
        const newX = x.toPx(this.state.width);
        const newY = y.toPx(this.state.height);
        return fromValues(newX, newY, 0);
      }), current.absoluteMatrix));
      this.clonedScreenPoints = sapa.clone(this.screenPoints);
    }
    [sapa.POINTERSTART("$el .polygon .polygon-pointer") + MOVE("movePolygonPointer") + END("moveEndPolygonPointer")](e) {
      this.initializePolygon();
      this.polygonTargetIndex = +e.$dt.data("index");
    }
    movePolygonPointer(dx, dy) {
      this.clonedScreenPoints[this.polygonTargetIndex] = add([], this.screenPoints[this.polygonTargetIndex], [dx, dy, 0]);
      this.updatePolygon(this.clonedScreenPoints);
    }
    moveEndPolygonPointer() {
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .polygon .polygon-line")](e) {
      this.initializePolygon();
      const index2 = +e.$dt.data("index");
      this.polygonTargetIndex = index2;
      const current = this.screenPoints[this.polygonTargetIndex];
      const next = this.screenPoints[(this.polygonTargetIndex + 1) % this.screenPoints.length];
      const newPoint = lerp([], current, next, 0.5);
      this.screenPoints.splice(this.polygonTargetIndex + 1, 0, newPoint);
      this.updatePolygon(this.screenPoints);
    }
    updatePolygon(screenPoints) {
      const newWorldPoints = this.$viewport.applyVertiesInverse(screenPoints);
      const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
      const newLocalPoints = vertiesMap(newWorldPoints, inverseMatrix);
      this.state.clippath.value = newLocalPoints.map((p) => {
        return [
          editor.Length.makePercent(p[0], this.state.width),
          editor.Length.makePercent(p[1], this.state.height)
        ].join(" ");
      }).join(",");
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .polygon .polygon-center") + MOVE("movePolygonCenter") + END("moveEndPolygonCenter")]() {
      this.initializePolygon();
    }
    movePolygonCenter(dx, dy) {
      const newScreenPoints = this.screenPoints.map((p) => {
        return add([], p, [dx, dy, 0]);
      });
      this.updatePolygon(newScreenPoints);
    }
    moveEndPolygonCenter(dx, dy) {
      if (dx == 0 && dy == 0) {
        switch (this.state.clippath.type) {
          case ClipPathType.POLYGON:
            const value2 = ClipPath.toCSS({
              type: ClipPathType.CIRCLE,
              value: `50% at 50% 50%`
            });
            this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
            break;
        }
        return;
      }
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    templatePolygon(clippath) {
      const current = this.$context.selection.current;
      const points = ClipPath.parseStyleForPolygon(clippath.value).map((point2) => [
        point2.x.toPx(current.screenWidth).value,
        point2.y.toPx(current.screenHeight).value,
        0
      ]);
      const centerPoint = toRectVerties(points)[4];
      const screenPoints = this.$viewport.applyVerties(vertiesMap(points, current.absoluteMatrix));
      const screenCenter = this.$viewport.applyVerties(vertiesMap([centerPoint], current.absoluteMatrix))[0];
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "polygon"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "polygon-back"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        style: "position:absolute;width:100%;height:100%;"
      }, /* @__PURE__ */ sapa.createElementJsx("polygon", {
        points: `${screenPoints.map((it) => [it[0], it[1]].join(",")).join(" ")}`
      }), screenPoints.map((it, index2) => {
        const nextIndex = (index2 + 1) % screenPoints.length;
        const nextPoint = screenPoints[nextIndex];
        return /* @__PURE__ */ sapa.createElementJsx("line", {
          x1: it[0],
          y1: it[1],
          x2: nextPoint[0],
          y2: nextPoint[1],
          class: "polygon-line",
          "data-index": index2
        });
      }), screenPoints.map((it, index2) => {
        return /* @__PURE__ */ sapa.createElementJsx("circle", {
          cx: it[0],
          cy: it[1],
          r: 3,
          class: "polygon-pointer",
          "data-index": index2
        });
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "polygon-center",
        style: {
          left: editor.Length.px(screenCenter[0]),
          top: editor.Length.px(screenCenter[1])
        }
      }));
    }
  }
  class ClippathInsetEditorView extends ClippathPolygonEditorView {
    initializeInset() {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.clippath.value = ClipPath.parseStyleForInset(this.state.clippath.value);
      this.state.inset = this.state.clippath.value;
      const inset = this.state.inset;
      const top = inset.top.toPx(current.screenHeight);
      const left = inset.left.toPx(current.screenWidth);
      const right = editor.Length.px(current.screenWidth - inset.right.toPx(current.screenWidth));
      const bottom = editor.Length.px(current.screenHeight - inset.bottom.toPx(current.screenHeight));
      const verties = this.$viewport.applyVerties(vertiesMap([
        [left, top, 0],
        [right, top, 0],
        [right, bottom, 0],
        [left, bottom, 0]
      ], current.absoluteMatrix));
      const leftPoint = lerp([], verties[0], verties[3], 0.5);
      const topPoint = lerp([], verties[0], verties[1], 0.5);
      const rightPoint = lerp([], verties[1], verties[2], 0.5);
      const bottomPoint = lerp([], verties[2], verties[3], 0.5);
      const centerPoint = lerp([], verties[0], verties[2], 0.5);
      this.screenPoints = [
        leftPoint,
        topPoint,
        rightPoint,
        bottomPoint,
        centerPoint
      ];
    }
    [sapa.POINTERSTART("$el .inset .inset-direction") + sapa.LEFT_BUTTON + MOVE("moveInsetRadius") + END("moveEndInsetRadius")](e) {
      this.initializeInset();
      this.insetTarget = e.$dt.data("direction");
    }
    moveInsetRadius(dx, dy) {
      const { left, top, right, bottom } = this.state.inset;
      let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
      if (this.insetTarget == "left")
        leftPoint = add([], leftPoint, [dx, dy, 0]);
      else if (this.insetTarget == "top")
        topPoint = add([], topPoint, [dx, dy, 0]);
      else if (this.insetTarget == "right")
        rightPoint = add([], rightPoint, [dx, dy, 0]);
      else if (this.insetTarget == "bottom")
        bottomPoint = add([], bottomPoint, [dx, dy, 0]);
      const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
      const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
      const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
      const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
      const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
      const [
        relativeLeftPosition,
        relativeTopPosition,
        relativeRightPosition,
        relativeBottomPosition
      ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
      this.state.clippath.value = [
        top.isPercent() ? editor.Length.makePercent(relativeTopPosition[1], this.state.height) : editor.Length.px(relativeTopPosition[1]),
        right.isPercent() ? editor.Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : editor.Length.px(this.state.width - relativeRightPosition[0]),
        bottom.isPercent() ? editor.Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : editor.Length.px(this.state.height - relativeBottomPosition[1]),
        left.isPercent() ? editor.Length.makePercent(relativeLeftPosition[0], this.state.width) : editor.Length.px(relativeLeftPosition[0])
      ].join(" ");
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndInsetRadius() {
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .inset .inset-center") + sapa.LEFT_BUTTON + MOVE("moveInsetCenter") + END("moveEndInsetCenter")]() {
      this.initializeInset();
    }
    moveInsetCenter(dx, dy) {
      const { left, top, right, bottom } = this.state.inset;
      let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
      leftPoint = add([], leftPoint, [dx, dy, 0]);
      topPoint = add([], topPoint, [dx, dy, 0]);
      rightPoint = add([], rightPoint, [dx, dy, 0]);
      bottomPoint = add([], bottomPoint, [dx, dy, 0]);
      const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
      const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
      const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
      const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
      const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
      const [
        relativeLeftPosition,
        relativeTopPosition,
        relativeRightPosition,
        relativeBottomPosition
      ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
      this.state.clippath.value = [
        top.isPercent() ? editor.Length.makePercent(relativeTopPosition[1], this.state.height) : editor.Length.px(relativeTopPosition[1]),
        right.isPercent() ? editor.Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : editor.Length.px(this.state.width - relativeRightPosition[0]),
        bottom.isPercent() ? editor.Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : editor.Length.px(this.state.height - relativeBottomPosition[1]),
        left.isPercent() ? editor.Length.makePercent(relativeLeftPosition[0], this.state.width) : editor.Length.px(relativeLeftPosition[0])
      ].join(" ");
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndInsetCenter(dx, dy) {
      if (dx == 0 && dy == 0) {
        switch (this.state.clippath.type) {
          case ClipPathType.INSET:
            const value2 = ClipPath.toCSS({
              type: ClipPathType.POLYGON,
              value: `0% 0%, 100% 0%, 100% 100%, 0% 100%`
            });
            this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
            break;
        }
        return;
      }
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    templateInset(clippath) {
      const current = this.$context.selection.current;
      clippath.value = ClipPath.parseStyleForInset(clippath.value);
      const top = clippath.value.top.toPx(current.screenHeight);
      const left = clippath.value.left.toPx(current.screenWidth);
      const right = editor.Length.px(current.screenWidth - clippath.value.right.toPx(current.screenWidth));
      const bottom = editor.Length.px(current.screenHeight - clippath.value.bottom.toPx(current.screenHeight));
      const verties = this.$viewport.applyVerties(vertiesMap([
        [left, top, 0],
        [right, top, 0],
        [right, bottom, 0],
        [left, bottom, 0]
      ], current.absoluteMatrix));
      const leftPoint = lerp([], verties[0], verties[3], 0.5);
      const topPoint = lerp([], verties[0], verties[1], 0.5);
      const rightPoint = lerp([], verties[1], verties[2], 0.5);
      const bottomPoint = lerp([], verties[2], verties[3], 0.5);
      const centerPoint = lerp([], verties[0], verties[2], 0.5);
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-back"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        style: "position:absolute;width:100%;height:100%;"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
            M ${verties[0][0]} ${verties[0][1]}
            L ${verties[1][0]} ${verties[1][1]}
            L ${verties[2][0]} ${verties[2][1]}
            L ${verties[3][0]} ${verties[3][1]}
            Z
          `
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-direction",
        "data-direction": "left",
        style: {
          left: editor.Length.px(leftPoint[0]),
          top: editor.Length.px(leftPoint[1])
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-direction",
        "data-direction": "top",
        style: { left: editor.Length.px(topPoint[0]), top: editor.Length.px(topPoint[1]) }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-direction",
        "data-direction": "right",
        style: {
          left: editor.Length.px(rightPoint[0]),
          top: editor.Length.px(rightPoint[1])
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-direction",
        "data-direction": "bottom",
        style: {
          left: editor.Length.px(bottomPoint[0]),
          top: editor.Length.px(bottomPoint[1])
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "inset-center",
        style: {
          left: editor.Length.px(centerPoint[0]),
          top: editor.Length.px(centerPoint[1])
        }
      }));
    }
  }
  class ClippathCircleEditorView extends ClippathInsetEditorView {
    [sapa.POINTERSTART("$el .circle .circle-radius") + sapa.LEFT_BUTTON + MOVE("moveCircleRadius") + END("moveEndCircleRadius")]() {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
    }
    moveCircleRadius(dx, dy) {
      const current = this.$context.selection.current;
      const { radius, x, y } = this.state.circle;
      const oldX = x.toPx(current.screenWidth);
      const oldY = y.toPx(current.screenHeight);
      const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
      const oldRadius = radius.toPx(current.screenWidth);
      const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadius.value, oldY, 0]], current.absoluteMatrix));
      const newRadius = verties[0];
      const newX = newRadius[0] + dx;
      const newY = newRadius[1] + dy;
      const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
      const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
      const distX = Math.abs(relativePosition[0] - oldX);
      const result = [
        radius.isPercent() ? editor.Length.makePercent(distX, r) : editor.Length.px(distX),
        x,
        y
      ];
      this.state.clippath.value = `${result[0]} at ${result[1]} ${result[2]}`;
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndCircleRadius() {
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .circle .circle-center") + sapa.LEFT_BUTTON + MOVE("moveCircleCenter") + END("moveEndCircleCenter")]() {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
    }
    moveCircleCenter(dx, dy) {
      const current = this.$context.selection.current;
      const { radius, x, y } = this.state.circle;
      const oldX = x.toPx(current.screenWidth);
      const oldY = y.toPx(current.screenHeight);
      const verties = this.$viewport.applyVerties(vertiesMap([[oldX, oldY, 0]], current.absoluteMatrix));
      const center = verties[0];
      const newX = center[0] + dx;
      const newY = center[1] + dy;
      const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
      const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
      const result = [
        radius,
        x.isPercent() ? editor.Length.makePercent(relativePosition[0], this.state.width) : editor.Length.px(relativePosition[0]),
        y.isPercent() ? editor.Length.makePercent(relativePosition[1], this.state.height) : editor.Length.px(relativePosition[1])
      ];
      this.state.clippath.value = `${radius} at ${result[1]} ${result[2]}`;
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndCircleCenter(dx, dy) {
      if (dx == 0 && dy == 0) {
        switch (this.state.clippath.type) {
          case ClipPathType.CIRCLE:
            const value2 = ClipPath.toCSS({
              type: ClipPathType.ELLIPSE,
              value: `${this.state.circle.radius} ${this.state.circle.radius} at ${this.state.circle.x} ${this.state.circle.y}`
            });
            this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
            break;
        }
        return;
      }
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    templateCircle(clippath) {
      const current = this.$context.selection.current;
      const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
      const radius = clippath.value.radius.toPx(r);
      const x = clippath.value.x.toPx(current.screenWidth);
      const y = clippath.value.y.toPx(current.screenHeight);
      const verties = this.$viewport.applyVerties(vertiesMap([
        [x, y, 0],
        [x.value + radius.value, y, 0]
      ], current.absoluteMatrix));
      const center = verties[0];
      const radiusPos = verties[1];
      const dist$1 = dist(center, radiusPos);
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "circle"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "circle-back",
        style: {
          left: editor.Length.px(center[0]),
          top: editor.Length.px(center[1]),
          width: editor.Length.px(dist$1 * 2),
          height: editor.Length.px(dist$1 * 2)
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "circle-center",
        style: {
          left: center[0] + "px",
          top: center[1] + "px"
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "circle-radius",
        style: {
          left: radiusPos[0] + "px",
          top: radiusPos[1] + "px"
        }
      }));
    }
  }
  class ClippathEllipseEditorView extends ClippathCircleEditorView {
    [sapa.POINTERSTART("$el .ellipse .ellipse-radius-x") + sapa.LEFT_BUTTON + MOVE("moveEllipseRadiusX") + END("moveEndEllipseRadiusX")]() {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
    }
    moveEllipseRadiusX(dx, dy) {
      const current = this.$context.selection.current;
      const { radiusX, radiusY, x, y } = this.state.ellipse;
      const oldX = x.toPx(current.screenWidth);
      const oldY = y.toPx(current.screenHeight);
      const oldRadiusX = radiusX.toPx(current.screenWidth);
      const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadiusX.value, oldY, 0]], current.absoluteMatrix));
      const newRadius = verties[0];
      const newX = newRadius[0] + dx;
      const newY = newRadius[1] + dy;
      const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
      const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
      const distX = Math.abs(relativePosition[0] - oldX);
      const result = [
        radiusX.isPercent() ? editor.Length.makePercent(distX, this.state.width) : editor.Length.px(distX),
        x,
        y
      ];
      this.state.clippath.value = `${result[0]} ${radiusY} at ${result[1]} ${result[2]}`;
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .ellipse .ellipse-radius-y") + sapa.LEFT_BUTTON + MOVE("moveEllipseRadiusY") + END("moveEndEllipseRadiusX")]() {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
    }
    moveEllipseRadiusY(dx, dy) {
      const current = this.$context.selection.current;
      const { radiusX, radiusY, x, y } = this.state.ellipse;
      const oldX = x.toPx(current.screenWidth);
      const oldY = y.toPx(current.screenHeight);
      const oldRadiusY = radiusY.toPx(current.screenHeight);
      const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value, oldY.value + oldRadiusY.value, 0]], current.absoluteMatrix));
      const newRadius = verties[0];
      const newX = newRadius[0] + dx;
      const newY = newRadius[1] + dy;
      const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
      const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
      const distY = Math.abs(relativePosition[1] - oldY);
      const result = [
        radiusY.isPercent() ? editor.Length.makePercent(distY, this.state.height) : editor.Length.px(distY),
        x,
        y
      ];
      this.state.clippath.value = `${radiusX} ${result[0]} at ${x} ${y}`;
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndEllipseRadiusX() {
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    [sapa.POINTERSTART("$el .ellipse .ellipse-center") + sapa.LEFT_BUTTON + MOVE("moveEllipseCenter") + END("moveEndEllipseCenter")](e) {
      const current = this.$context.selection.current;
      this.state.current;
      this.state.width = current.screenWidth;
      this.state.height = current.screenHeight;
      this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
      this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
      this.state.left = editor.Length.parse(e.$dt.css("left")).value;
      this.state.top = editor.Length.parse(e.$dt.css("top")).value;
    }
    moveEllipseCenter(dx, dy) {
      const { radiusX, radiusY, x, y } = this.state.ellipse;
      const newLeft = this.state.left + dx;
      const newTop = this.state.top + dy;
      const worldPosition = this.$viewport.applyVertexInverse([
        newLeft,
        newTop,
        0
      ]);
      const relativePosition = vertiesMap([worldPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
      const result = [
        radiusX,
        radiusY,
        x.isPercent() ? editor.Length.makePercent(relativePosition[0], this.state.width) : editor.Length.px(relativePosition[0]),
        y.isPercent() ? editor.Length.makePercent(relativePosition[1], this.state.height) : editor.Length.px(relativePosition[1])
      ];
      this.state.clippath.value = `${radiusX} ${radiusY} at ${result[2]} ${result[3]}`;
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
    }
    moveEndEllipseCenter(dx, dy) {
      if (dx == 0 && dy == 0) {
        switch (this.state.clippath.type) {
          case ClipPathType.ELLIPSE:
            const value2 = ClipPath.toCSS({
              type: ClipPathType.INSET,
              value: ""
            });
            this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
            break;
        }
        return;
      }
      const value = ClipPath.toCSS(this.state.clippath);
      this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
    }
    templateEllipse(clippath) {
      const current = this.$context.selection.current;
      const radiusX = clippath.value.radiusX.toPx(current.screenWidth);
      const radiusY = clippath.value.radiusY.toPx(current.screenHeight);
      const x = clippath.value.x.toPx(current.screenWidth);
      const y = clippath.value.y.toPx(current.screenHeight);
      const verties = this.$viewport.applyVerties(vertiesMap([
        [x, y, 0],
        [x.value + radiusX.value, y, 0],
        [x.value, y.value + radiusY.value, 0]
      ], current.absoluteMatrix));
      const center = verties[0];
      const radiusXPos = verties[1];
      const radiusYPos = verties[2];
      const distX = dist(center, radiusXPos);
      const distY = dist(center, radiusYPos);
      const direction = subtract([], radiusXPos, center);
      const angle = calculateAngle(direction[0], direction[1]);
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "ellipse"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "ellipse-back"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        style: "position:absolute;width:100%;height:100%;"
      }, /* @__PURE__ */ sapa.createElementJsx("ellipse", {
        cx: center[0],
        cy: center[1],
        rx: distX,
        ry: distY,
        transform: `rotate(${angle} ${center[0]} ${center[1]})`
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "ellipse-center",
        style: {
          left: center[0] + "px",
          top: center[1] + "px"
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "ellipse-radius ellipse-radius-x",
        style: {
          left: radiusXPos[0] + "px",
          top: radiusXPos[1] + "px"
        }
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "ellipse-radius ellipse-radius-y",
        style: {
          left: radiusYPos[0] + "px",
          top: radiusYPos[1] + "px"
        }
      }));
    }
  }
  class ClippathEditorView$1 extends ClippathEllipseEditorView {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--clippath-editor-view "
      });
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      const current = this.$context.selection.current;
      if (!current) {
        return "";
      }
      const clippath = ClipPath.parseStyle(current["clip-path"]);
      switch (clippath.type) {
        case ClipPathType.CIRCLE:
          clippath.value = ClipPath.parseStyleForCircle(clippath.value);
          return this.templateCircle(clippath);
        case ClipPathType.ELLIPSE:
          clippath.value = ClipPath.parseStyleForEllipse(clippath.value);
          return this.templateEllipse(clippath);
        case ClipPathType.POLYGON:
          return this.templatePolygon(clippath);
        case ClipPathType.INSET:
          return this.templateInset(clippath);
      }
      return /* @__PURE__ */ sapa.createElementJsx("div", null);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    checkClipPath() {
      if (this.$el.isShow() === false)
        return false;
      const current = this.$context.selection.current;
      if (!current)
        return false;
      return this.$context.selection.current.hasChangedField("clip-path", "angle", "x", "y", "width", "height");
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.IF("checkClipPath") + sapa.DEBOUNCE(10)]() {
      this.refresh();
    }
    [sapa.CLICK("$el")](e) {
      if (sapa.Dom.create(e.target).isTag("svg") || sapa.Dom.create(e.target).hasClass("elf--clippath-editor-view")) {
        this.trigger("hideClippathEditorView");
      }
    }
    [sapa.SUBSCRIBE("hideClippathEditorView")]() {
      this.$el.hide();
    }
    [sapa.SUBSCRIBE("showClippathEditorView")]() {
      this.$el.show();
      this.refresh();
    }
  }
  function ClippathEditorView(editor2) {
    editor2.registerUI("canvas.view", {
      ClippathEditorView: ClippathEditorView$1
    });
  }
  var CodeViewProperty$1 = "";
  class CodeViewProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("code.view.property.title");
    }
    checkConfig() {
      return this.$config.is("inspector.selectedValue", "code");
    }
    [sapa.CONFIG("inspector.selectedValue")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS, REFRESH_SELECTION) + sapa.IF("checkConfig") + sapa.DEBOUNCE(100)]() {
      this.refresh();
    }
    getBody() {
      return `
      <div class="property-item elf--code-view-item" ref='$body'>
        <div class="elf--code-view-item-code" ref='$code'></div>
        <div class="elf--code-view-item-svg" ref='$svg'></div>
      </div>
    `;
    }
    [sapa.LOAD("$code") + sapa.DOMDIFF]() {
      return [
        this.$editor.renderer("html").codeview(this.$context.selection.current)
      ];
    }
    [sapa.LOAD("$svg") + sapa.DOMDIFF]() {
      return [
        this.$editor.renderer("svg").codeview(this.$context.selection.current)
      ];
    }
  }
  function codeview(editor2) {
    editor2.registerUI("inspector.tab.code", {
      CodeViewProperty
    });
  }
  function _currentProject(editor2, callback) {
    var project2 = editor2.context.selection.currentProject;
    if (project2) {
      var timeline = project2.getSelectedTimeline();
      callback && callback(project2, timeline);
    }
  }
  var __glob_0_0$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": _currentProject
  }, Symbol.toStringTag, { value: "Module" }));
  function _doForceRefreshSelection(editor2) {
    editor2.emit("refreshAll");
  }
  var __glob_0_1$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": _doForceRefreshSelection
  }, Symbol.toStringTag, { value: "Module" }));
  var addArtBoard = {
    command: "addArtBoard",
    execute: (editor2, obj2 = {}, center = null) => {
      var project2 = editor2.context.selection.currentProject;
      if (!project2) {
        project2 = editor2.add(editor2.context.modelManager.createModel({ itemType: "project" }));
        editor2.context.selection.selectProject(project2);
      }
      var artboard2 = project2.appendChild(editor2.context.modelManager.createModel(__spreadValues({
        itemType: "artboard",
        x: 300,
        y: 200,
        width: 375,
        height: 667
      }, obj2)));
      if (center) {
        artboard2.reset({
          x: 0,
          y: 0
        });
        artboard2.moveByCenter(center);
      }
      editor2.context.selection.select(artboard2);
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addArtBoard
  }, Symbol.toStringTag, { value: "Module" }));
  var addBackgroundColor = {
    command: "addBackgroundColor",
    execute: function(editor2, color, id = null) {
      editor2.context.commands.executeCommand("setAttribute", "add background color", editor2.context.selection.packByValue({
        backgroundColor: color
      }, id));
    }
  };
  var __glob_0_3$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addBackgroundColor
  }, Symbol.toStringTag, { value: "Module" }));
  var addBackgroundImageAsset = {
    command: "addBackgroundImageAsset",
    execute: function(editor2, url, id = null) {
      var items = editor2.context.selection.itemsByIds(id);
      let itemsMap = {};
      items.forEach((item) => {
        let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
        images.unshift(new BackgroundImage({
          image: new URLImageResource({ url })
        }));
        itemsMap[item.id] = {
          "background-image": BackgroundImage.join(images)
        };
      });
      editor2.context.commands.emit("history.setAttribute", "add background image", itemsMap);
    }
  };
  var __glob_0_4$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addBackgroundImageAsset
  }, Symbol.toStringTag, { value: "Module" }));
  var addBackgroundImageGradient = {
    command: "addBackgroundImageGradient",
    execute: function(editor2, gradient2, id = null) {
      var items = editor2.context.selection.itemsByIds(id);
      let itemsMap = {};
      items.forEach((item) => {
        let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
        images.unshift(new BackgroundImage({
          image: BackgroundImage.parseImage(gradient2)
        }));
        itemsMap[item.id] = {
          backgroundImage: BackgroundImage.join(images)
        };
      });
      editor2.context.commands.emit("history.setAttribute", "add gradient", itemsMap);
    }
  };
  var __glob_0_5$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addBackgroundImageGradient
  }, Symbol.toStringTag, { value: "Module" }));
  const MAX_CACHE_COUNT$1 = 1e3;
  const cachedPatternMap = /* @__PURE__ */ new Map();
  class PatternCache {
    static has(key) {
      return cachedPatternMap.has(key);
    }
    static get(key) {
      return cachedPatternMap.get(key);
    }
    static set(key, parsedValue) {
      if (cachedPatternMap.size > MAX_CACHE_COUNT$1) {
        cachedPatternMap.clear();
      }
      cachedPatternMap.set(key, parsedValue);
    }
  }
  const customFuncMap = {
    check: makeGroupFunction("check"),
    grid: makeGroupFunction("grid"),
    dot: makeGroupFunction("dot"),
    "cross-dot": makeGroupFunction("cross-dot"),
    "diagonal-line": makeGroupFunction("diagonal-line"),
    "vertical-line": makeGroupFunction("vertical-line"),
    "horizontal-line": makeGroupFunction("horizontal-line")
  };
  class Pattern extends PropertyItem {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "pattern"
      }, obj2));
    }
    toString() {
      return `${this.json.type}(${this.json.value || ""})`;
    }
    static parse(obj2) {
      var PatternClass = PatternClassName[obj2.type];
      if (PatternClass) {
        return new PatternClass(obj2);
      }
    }
    static parseStyle(pattern) {
      var patterns2 = [];
      if (!pattern || pattern === "undefined")
        return patterns2;
      pattern = pattern.trim();
      if (PatternCache.has(pattern)) {
        return PatternCache.get(pattern);
      }
      const result = parseValue(pattern, {
        customFuncMap
      });
      result.forEach((item, index2) => {
        const [
          size,
          position2,
          foreColor,
          backColor,
          blendMode = [{ matchedString: "normal" }],
          lineSize = [
            { parsed: editor.Length.parse("1px") },
            { parsed: editor.Length.parse("1px") }
          ]
        ] = item.parameters;
        patterns2[index2] = Pattern.parse({
          type: item.type,
          x: position2[0].parsed,
          y: position2[1].parsed,
          width: size[0].parsed,
          height: size[1].parsed,
          foreColor: foreColor[0].matchedString,
          backColor: backColor[0].matchedString,
          blendMode: blendMode[0].matchedString,
          lineWidth: lineSize[0].parsed,
          lineHeight: lineSize[1].parsed
        });
      });
      PatternCache.set(pattern, patterns2);
      return patterns2;
    }
    static join(list) {
      return list.map((it) => Pattern.parse(it)).join(" ");
    }
    static toCSS(str) {
      let list = [];
      Pattern.parseStyle(str).forEach((it) => {
        list.push.apply(list, BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS())));
      });
      return BackgroundImage.joinCSS(list);
    }
  }
  class BasePattern extends Pattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "base",
        x: 0,
        y: 0,
        width: 20,
        height: 20,
        lineWidth: 1,
        lineHeight: 1,
        foreColor: "black",
        backColor: "white",
        blendMode: "normal"
      });
    }
    convert(json) {
      json = super.convert(json);
      json.width = editor.Length.parse(json.width);
      json.height = editor.Length.parse(json.height);
      json.lineWidth = editor.Length.parse(json.lineWidth);
      json.lineHeight = editor.Length.parse(json.lineHeight);
      json.x = editor.Length.parse(json.x);
      json.y = editor.Length.parse(json.y);
      return json;
    }
    toString() {
      var {
        type,
        width: width2,
        height,
        x,
        y,
        foreColor,
        backColor,
        blendMode,
        lineWidth,
        lineHeight
      } = this.json;
      return `${type}(${width2} ${height}, ${x} ${y}, ${foreColor}, ${backColor}, ${blendMode}, ${lineWidth} ${lineHeight})`;
    }
  }
  class CheckPattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "check"
      });
    }
    toCSS() {
      let { width: width2, height, x, y, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%),repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%);
      background-position: 0px 0px, ${x} ${y};
      background-size: ${width2} ${height}, ${width2} ${height};
      background-blend-mode: ${blendMode}, ${blendMode};
    `;
    }
  }
  class GridPattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "grid"
      });
    }
    toCSS() {
      let {
        width: width2,
        height,
        lineWidth,
        lineHeight,
        backColor,
        foreColor,
        blendMode
      } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: linear-gradient(to bottom,${foreColor} ${lineHeight}, ${backColor} ${lineHeight}),linear-gradient(to right, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height / 2}px, ${width2 / 2}px ${height / 2}px;      
      background-blend-mode: ${blendMode}, ${blendMode};      
    `;
    }
  }
  class DotPattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "dot"
      });
    }
    toCSS() {
      let { width: width2, height, lineWidth, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height / 2}px;          
      background-blend-mode: ${blendMode};      
    `;
    }
  }
  class CrossDotPattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "cross-dot"
      });
    }
    toCSS() {
      let { width: width2, height, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth}),radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2} ${height},${width2} ${height};
      background-position: 0px 0px, ${x} ${y};      
      background-blend-mode: multiply, ${blendMode};
    `;
    }
  }
  class DiagonalLinePattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "diagonal-line"
      });
    }
    toCSS() {
      let { width: width2, height, x, lineWidth, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
    background-image: repeating-linear-gradient(${x}, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} 0px, ${backColor} 50%);
    background-size: ${width2} ${height};      
    background-blend-mode: ${blendMode};
  `;
    }
  }
  class VerticalLinePattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "vertical-line"
      });
    }
    toCSS() {
      let { width: width2, height, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: repeating-linear-gradient(to right, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);
      background-size: ${width2} ${height}; 
      background-position: ${x} ${y};        
      background-blend-mode: ${blendMode};
    `;
    }
  }
  class HorizontalLinePattern extends BasePattern {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "horizontal-line"
      });
    }
    toCSS() {
      let { width: width2, height, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
      backColor = backColor || "transparent";
      foreColor = foreColor || "black";
      return `
      background-image: repeating-linear-gradient( to bottom, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);    
      background-position: ${x} ${y};
      background-size: ${width2} ${height};   
      background-blend-mode: ${blendMode};
    `;
    }
  }
  const PatternClassName = {
    check: CheckPattern,
    grid: GridPattern,
    dot: DotPattern,
    "cross-dot": CrossDotPattern,
    "diagonal-line": DiagonalLinePattern,
    "vertical-line": VerticalLinePattern,
    "horizontal-line": HorizontalLinePattern
  };
  var addBackgroundImagePattern = {
    command: "addBackgroundImagePattern",
    execute: function(editor2, pattern, id = null) {
      var items = editor2.context.selection.itemsByIds(id);
      let itemsMap = {};
      items.forEach((item) => {
        itemsMap[item.id] = {
          pattern: Pattern.join([
            ...Pattern.parseStyle(pattern),
            ...Pattern.parseStyle(item.pattern)
          ])
        };
      });
      editor2.context.commands.emit("history.setAttribute", "add pattern", itemsMap);
    }
  };
  var __glob_0_6$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addBackgroundImagePattern
  }, Symbol.toStringTag, { value: "Module" }));
  function addCustomComponent(editor2, obj2 = {}, center = null) {
    var project2 = editor2.context.selection.currentProject;
    var customComponent = project2.appendChild(editor2.context.modelManager.createModel(__spreadValues({
      x: 300,
      y: 200,
      width: 375,
      height: 667
    }, obj2)));
    if (center) {
      customComponent.reset({
        x: 0,
        y: 0
      });
      customComponent.moveByCenter(center);
    }
    editor2.context.selection.select(customComponent);
    _doForceRefreshSelection(editor2);
  }
  var __glob_0_7$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addCustomComponent
  }, Symbol.toStringTag, { value: "Module" }));
  function addImage(editor2, rect2 = {}, containerItem = void 0) {
    editor2.context.commands.emit("newComponent", "image", rect2, true, containerItem);
  }
  var __glob_0_8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addImage
  }, Symbol.toStringTag, { value: "Module" }));
  function loadOriginalImage(obj2, callback) {
    var img = new window.Image();
    img.onload = () => {
      var info = {
        id: obj2.id,
        local: obj2.local,
        naturalWidth: img.naturalWidth,
        naturalHeight: img.naturalHeight,
        width: img.naturalWidth,
        height: img.naturalHeight
      };
      callback && callback(info, img);
    };
    img.onerror = (e) => {
      console.log(e, e.message);
    };
    img.src = obj2.local;
  }
  var addImageAssetItem = {
    command: "addImageAssetItem",
    execute: function(editor2, imageObject, rect2 = {}, containerItem = void 0) {
      var project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.createImage(imageObject);
        editor2.context.commands.emit("addImageAsset");
        loadOriginalImage(imageObject, (info) => {
          const rate = rect2.width / info.width;
          const width2 = rect2.width;
          const height = info.height * rate;
          editor2.context.commands.emit("addImage", __spreadProps(__spreadValues(__spreadValues({
            src: imageObject.id
          }, info), rect2), {
            width: width2,
            height
          }), containerItem);
        });
      }
    }
  };
  var __glob_0_9$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addImageAssetItem
  }, Symbol.toStringTag, { value: "Module" }));
  function addLayer(editor2, layer, isSelected = true, containerItem) {
    if (!containerItem) {
      containerItem = editor2.context.selection.current || editor2.context.selection.currentProject;
    }
    if (containerItem) {
      if (containerItem.isNot("project") && !containerItem.enableHasChildren()) {
        containerItem = containerItem.parent;
      }
      containerItem.appendChild(layer);
      if (isSelected) {
        editor2.context.selection.select(layer);
      }
      _doForceRefreshSelection(editor2);
    }
  }
  var __glob_0_10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addLayer
  }, Symbol.toStringTag, { value: "Module" }));
  const Language = {
    EN: "en_US",
    FR: "fr_FR",
    KO: "ko_KR"
  };
  const EditingMode = {
    SELECT: "select",
    APPEND: "append",
    DRAW: "draw",
    PATH: "path",
    HAND: "hand"
  };
  const DesignMode = {
    EDIT: "edit",
    PREVIEW: "preview",
    DESIGN: "design",
    ITEM: "item"
  };
  const CanvasViewToolLevel = {
    DRAG_AREA: 0,
    RENDERING_AREA: 256,
    SELECTION_TOOL: 512,
    LAYOUT_TOOL: 768
  };
  const NotifyType = {
    ERROR: "error",
    INFO: "info",
    SUCCESS: "success",
    WARNING: "warning",
    ALERT: "alert"
  };
  const IntersectEpsilonNumberType = {
    RECT: 30
  };
  const ClipboardType = {
    TEXT: "text",
    IMAGE: "image",
    SVG: "svg",
    HTML: "html",
    JSON: "json"
  };
  const ClipboardActionType = {
    COPY: "copy",
    CUT: "cut"
  };
  const MenuItemType = {
    BUTTON: "button",
    LINK: "link",
    SEPARATOR: "separator",
    CHECKBOX: "checkbox",
    RADIO: "radio",
    SUBMENU: "submenu",
    DROPDOWN: "dropdown",
    CUSTOM: "custom"
  };
  const ViewModeType = {
    CanvasView: "CanvasView",
    PathEditorView: "PathEditorView"
  };
  var addLayerView = {
    command: "addLayerView",
    execute: async function(editor2, type, data = {}) {
      editor2.context.selection.empty();
      await editor2.emit("hideAddViewLayer");
      await editor2.emit("removeGuideLine");
      console.log(type, data);
      editor2.context.config.set("editing.mode.itemType", type);
      if (type === "select") {
        editor2.context.selection.empty();
        editor2.context.config.set("editing.mode", EditingMode.SELECT);
      } else if (type === "brush") {
        editor2.context.config.set("editing.mode", EditingMode.DRAW);
        await editor2.emit("showPathDrawEditor");
      } else if (type === "path") {
        editor2.context.config.set("editing.mode", EditingMode.PATH);
        await editor2.emit("showPathEditor", "path");
      } else {
        editor2.context.config.set("editing.mode", EditingMode.APPEND);
        await editor2.emit("showLayerAppendView", type, data);
      }
    }
  };
  var __glob_0_11$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addLayerView
  }, Symbol.toStringTag, { value: "Module" }));
  function addProject(editor2, obj2 = {}) {
    var project2 = editor2.context.modelManager.createModel(__spreadValues({
      itemType: "project"
    }, obj2));
    editor2.context.selection.selectProject(project2);
    _doForceRefreshSelection(editor2);
  }
  var __glob_0_12$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addProject
  }, Symbol.toStringTag, { value: "Module" }));
  var addSVGFilterAssetItem = {
    command: "addSVGFilterAssetItem",
    execute: function(editor2, callback) {
      var project2 = editor2.context.selection.currentProject;
      if (project2) {
        var id = uuidShort();
        var index2 = project2.createSVGFilter({ id, filters: [] });
        callback && callback(index2, id);
      }
    }
  };
  var __glob_0_13$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addSVGFilterAssetItem
  }, Symbol.toStringTag, { value: "Module" }));
  function addText(editor2, rect2 = {}) {
    editor2.context.commands.emit("newComponent", "text", __spreadValues({
      content: "Insert a text",
      width: 300,
      height: 50,
      "font-size": 30
    }, rect2), rect2);
  }
  var __glob_0_14$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addText
  }, Symbol.toStringTag, { value: "Module" }));
  var addTimelineCurrentProperty = {
    command: "addTimelineCurrentProperty",
    execute: function(editor2, options2 = { timing: "linear" }) {
      _currentProject(editor2, (project2) => {
        var list = [];
        editor2.context.selection.each((item) => {
          var keyframeObj = {
            layerId: item.id,
            property: options2.property,
            value: item[options2.property] + "",
            timing: options2.timing,
            editor: options2.editor
          };
          var obj2 = project2.addTimelineKeyframe(keyframeObj);
          if (obj2) {
            list.push(obj2);
          }
        });
        editor2.context.timeline.select(...list);
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      });
    }
  };
  var __glob_0_15$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addTimelineCurrentProperty
  }, Symbol.toStringTag, { value: "Module" }));
  var addTimelineItem = {
    command: "addTimelineItem",
    execute: function(editor2, layerId) {
      _currentProject(editor2, (project2) => {
        if (layerId) {
          project2.addTimelineLayer(layerId);
        } else {
          project2.addTimeline();
        }
        editor2.emit("refreshTimeline");
        editor2.emit("addTimeline");
      });
    }
  };
  var __glob_0_16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var addTimelineKeyframe = {
    command: "addTimelineKeyframe",
    execute: function(editor2, options2 = { timing: "linear" }) {
      _currentProject(editor2, (project2) => {
        var item = editor2.context.modelManager.get(options2.layerId);
        var keyframeObj = {
          layerId: options2.layerId,
          property: options2.property,
          time: options2.time,
          value: item[options2.property] + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        editor2.timeline.select(obj2);
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      });
    }
  };
  var __glob_0_17$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addTimelineKeyframe
  }, Symbol.toStringTag, { value: "Module" }));
  var addTimelineProperty = {
    command: "addTimelineProperty",
    execute: function(editor2, layerList, options2 = { timing: "linear" }) {
      _currentProject(editor2, (project2) => {
        if (Array.isArray(layerList) === false) {
          layerList = [layerList];
        }
        var list = [];
        layerList.forEach((layerId) => {
          var keyframeObj = {
            layerId,
            property: options2.property,
            value: options2.value + "",
            timing: options2.timing,
            editor: options2.editor
          };
          var obj2 = project2.addTimelineKeyframe(keyframeObj);
          if (obj2) {
            list.push(obj2);
          }
        });
        editor2.timeline.select(...list);
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      });
    }
  };
  var __glob_0_18$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addTimelineProperty
  }, Symbol.toStringTag, { value: "Module" }));
  function addVideo(editor2, rect2 = {}, containerItem = void 0) {
    editor2.context.commands.emit("newComponent", "video", rect2, true, containerItem);
  }
  var __glob_0_19$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addVideo
  }, Symbol.toStringTag, { value: "Module" }));
  function loadOriginalVideo(obj2, callback) {
    var video2 = document.createElement("video");
    video2.onloadeddata = () => {
      var info = {
        local: obj2.local,
        naturalWidth: video2.videoWidth,
        naturalHeight: video2.videoHeight,
        width: video2.videoWidth,
        height: video2.videoHeight,
        duration: video2.duration,
        playTime: `0:1:${video2.duration}`,
        volume: video2.volume,
        muted: video2.muted,
        placebackRate: video2.playbackRate
      };
      callback && callback(info, video2);
    };
    video2.src = obj2.local;
  }
  var addVideoAssetItem = {
    command: "addVideoAssetItem",
    execute: function(editor2, videoObject, rect2 = {}, containerItem = void 0) {
      var project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.createVideo(videoObject);
        editor2.emit("addVideoAsset");
        loadOriginalVideo(videoObject, (info) => {
          editor2.context.commands.emit("addVideo", __spreadValues(__spreadValues({ src: videoObject.id }, info), rect2), containerItem);
        });
      }
    }
  };
  var __glob_0_20$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": addVideoAssetItem
  }, Symbol.toStringTag, { value: "Module" }));
  var clipboard_copy$1 = {
    command: "clipboard.copy",
    title: "Copy",
    description: "Copy",
    execute: function(editor2) {
      editor2.context.clipboard.push({
        type: ClipboardActionType.COPY,
        data: editor2.context.selection.ids
      });
    }
  };
  var __glob_0_21$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": clipboard_copy$1
  }, Symbol.toStringTag, { value: "Module" }));
  var clipboard_paste$1 = {
    command: "clipboard.paste",
    execute: async function(editor2) {
      if (!editor2.context.clipboard.isEmpty) {
        editor2.context.commands.emit("history.clipboard.paste", "paste");
      } else {
        var text2 = await window.navigator.clipboard.readText();
        if (text2) {
          editor2.context.commands.emit("convertPasteText", text2);
        }
      }
    }
  };
  var __glob_0_22$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": clipboard_paste$1
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_flatten_path = {
    command: "convert.flatten.path",
    description: "flatten selected multi path",
    execute: (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      let newPath;
      if (current.is("boolean-path") || current.isBooleanItem) {
        let parent = current;
        if (current.isBooleanItem) {
          parent = current.parent;
        }
        newPath = parent.absolutePath(parent["boolean-path"]);
        newPath = parent.invertPath(newPath.d);
        const newLayerAttrs = parent.layers[0].toCloneObject();
        delete newLayerAttrs.id;
        delete newLayerAttrs.parentId;
        delete newLayerAttrs.transform;
        delete newLayerAttrs["boolean-path"];
        delete newLayerAttrs["boolean-operation"];
        const parentParent = parent.parent;
        const newRectInfo = parent.updatePath(newPath.d);
        editor2.context.commands.executeCommand("removeLayer", "remove selected layers", [parent.id]);
        editor2.nextTick(() => {
          editor2.context.commands.executeCommand("addLayer", `add layer - path`, editor2.context.modelManager.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newRectInfo)), true, parentParent);
        });
      } else {
        newPath = PathParser.fromSVGString();
        editor2.context.selection.each((item) => {
          newPath.addPath(item.absolutePath());
        });
        newPath = current.invertPath(newPath.d);
        const parent = current.parent;
        const newPathInfo = current.updatePath(newPath.d);
        const newLayerAttrs = current.toCloneObject();
        delete newLayerAttrs.id;
        editor2.context.commands.executeCommand("removeLayer", "remove selected layers");
        editor2.nextTick(() => {
          editor2.context.commands.executeCommand("addLayer", `add layer - path`, editor2.context.modelManager.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newPathInfo)), true, parent);
        });
      }
    }
  };
  var __glob_0_23$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_flatten_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_no_transform_path = {
    command: "convert.no.transform.path",
    description: "remove transform(rotate, translate, scale) inforation in path layer",
    execute: (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      const parent = current.parent;
      const childPath = current.absolutePath();
      if (parent.is("project")) {
        const verties = childPath.getBBox();
        const newRect = vertiesToRectangle(verties);
        editor2.context.commands.executeCommand("setAttribute", "remove transform for path", editor2.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
          rotate: 0,
          d: childPath.d
        })));
      } else {
        childPath.transformMat4(parent.absoluteMatrixInverse);
        const newRect = parent.updatePath(childPath.d);
        editor2.context.commands.executeCommand("setAttribute", "remove transform for path", editor2.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
          rotate: 0,
          d: childPath.d
        })));
      }
    }
  };
  var __glob_0_24$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_no_transform_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_normalize_path = {
    command: "convert.normalize.path",
    description: "convert segments to bezier curve",
    execute: (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      editor2.context.commands.executeCommand("setAttribute", "normalize path string", editor2.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).normalize().d)));
    }
  };
  var __glob_0_25$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_normalize_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_path_operation = {
    command: "convert.path.operation",
    description: "apply path boolean operation",
    execute: (editor2, booleanOperation) => {
      var _a;
      const current = editor2.context.selection.current;
      if (!current)
        return;
      const changeBooleanOperation = (booleanOperation2) => {
        editor2.context.commands.executeCommand("setAttribute", "change boolean operation", editor2.context.selection.packByValue({
          booleanOperation: booleanOperation2
        }));
        recoverBooleanPath2();
      };
      const recoverBooleanPath2 = () => {
        editor2.nextTick(() => {
          editor2.context.commands.emit("recoverBooleanPath");
          editor2.nextTick(() => {
            editor2.emit(REFRESH_SELECTION);
          });
        });
      };
      if (current.is("boolean-path") || current.isBooleanItem) {
        let parent = current;
        if (current.isBooleanItem) {
          parent = current.parent;
        }
        editor2.context.selection.select(parent);
        changeBooleanOperation(booleanOperation);
      } else {
        if ((_a = editor2.context.selection.current) == null ? void 0 : _a.isNot("boolean-path")) {
          editor2.context.commands.emit("group.item", {
            itemType: "boolean-path",
            title: "Intersection"
          });
        }
        editor2.nextTick(() => {
          var _a2;
          if ((_a2 = editor2.context.selection.current) == null ? void 0 : _a2.is("boolean-path")) {
            changeBooleanOperation(booleanOperation);
          }
        }, 10);
      }
    }
  };
  var __glob_0_26$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_path_operation
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_polygonal_path = {
    command: "convert.polygonal.path",
    description: "convert path to polygonal path",
    execute: (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      editor2.context.commands.executeCommand("setAttribute", "polygonal path string", editor2.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).polygonal().d)));
    }
  };
  var __glob_0_27$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_polygonal_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_simplify_path = {
    command: "convert.simplify.path",
    execute: (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      editor2.context.commands.executeCommand("setAttribute", "change path string", editor2.context.selection.packByValue(current.updatePath(editor2.pathKitManager.simplify(current.d))));
    }
  };
  var __glob_0_28$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_simplify_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_smooth_path = {
    command: "convert.smooth.path",
    description: "convert path to smooth",
    execute: (editor2, divideCount = 5, tolerance = 0.1, tension = 0.5) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      const smoothedPath = PathParser.fromSVGString(current.d).divideSegmentByCount(divideCount).simplify(tolerance).cardinalSplines(tension).d;
      editor2.context.commands.executeCommand("setAttribute", "smooth path string", editor2.context.selection.packByValue(current.updatePath(smoothedPath)));
    }
  };
  var __glob_0_29$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_smooth_path
  }, Symbol.toStringTag, { value: "Module" }));
  var convert_stroke_to_path = {
    command: "convert.stroke.to.path",
    execute: async (editor$1) => {
      const current = editor$1.context.selection.current;
      if (!current)
        return;
      const attrs = current.attrs("d", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "stroke-linejoin", "stroke-linecap");
      const pathAttrs = current.convertStrokeToPath();
      let newD = editor$1.pathKitManager.stroke(current.d || attrs.d, {
        "stroke-width": editor.Length.parse(attrs["stroke-width"]).value,
        "stroke-linejoin": attrs["stroke-linejoin"],
        "stroke-linecap": attrs["stroke-linecap"],
        "stroke-dasharray": attrs["stroke-dasharray"],
        "stroke-dashoffset": attrs["stroke-dashoffset"],
        "fill-rule": "nonezero"
      });
      pathAttrs["fill-rule"] = "nonzero";
      newD = PathParser.fromSVGString(newD).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
      editor$1.context.commands.executeCommand("addLayer", `add layer - path`, editor$1.context.modelManager.createModel(__spreadValues(__spreadValues({}, pathAttrs), current.updatePath(newD))), true, current.parent);
    }
  };
  var __glob_0_30$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convert_stroke_to_path
  }, Symbol.toStringTag, { value: "Module" }));
  var jsVideoUrlParser = { exports: {} };
  (function(module2, exports3) {
    (function(global2, factory) {
      module2.exports = factory();
    })(commonjsGlobal, function() {
      function _typeof(obj2) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj3) {
            return typeof obj3;
          };
        } else {
          _typeof = function(obj3) {
            return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
          };
        }
        return _typeof(obj2);
      }
      var getQueryParams = function getQueryParams2(qs) {
        if (typeof qs !== "string") {
          return {};
        }
        qs = qs.split("+").join(" ");
        var params = {};
        var match = qs.match(/(?:[?](?:[^=]+)=(?:[^&#]*)(?:[&](?:[^=]+)=(?:[^&#]*))*(?:[#].*)?)|(?:[#].*)/);
        var split;
        if (match === null) {
          return {};
        }
        split = match[0].substr(1).split(/[&#=]/);
        for (var i = 0; i < split.length; i += 2) {
          params[decodeURIComponent(split[i])] = decodeURIComponent(split[i + 1] || "");
        }
        return params;
      };
      var combineParams = function combineParams2(params, hasParams) {
        if (_typeof(params) !== "object") {
          return "";
        }
        var combined = "";
        var i = 0;
        var keys = Object.keys(params);
        if (keys.length === 0) {
          return "";
        }
        keys.sort();
        if (!hasParams) {
          combined += "?" + keys[0] + "=" + params[keys[0]];
          i += 1;
        }
        for (; i < keys.length; i += 1) {
          combined += "&" + keys[i] + "=" + params[keys[i]];
        }
        return combined;
      };
      function getLetterTime(timeString) {
        var totalSeconds = 0;
        var timeValues = {
          "s": 1,
          "m": 1 * 60,
          "h": 1 * 60 * 60,
          "d": 1 * 60 * 60 * 24,
          "w": 1 * 60 * 60 * 24 * 7
        };
        var timePairs;
        timeString = timeString.replace(/([smhdw])/g, " $1 ").trim();
        timePairs = timeString.split(" ");
        for (var i = 0; i < timePairs.length; i += 2) {
          totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || "s"];
        }
        return totalSeconds;
      }
      function getColonTime(timeString) {
        var totalSeconds = 0;
        var timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
        var timePairs = timeString.split(":");
        for (var i = 0; i < timePairs.length; i++) {
          totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
        }
        return totalSeconds;
      }
      var getTime = function getTime2(timeString) {
        if (typeof timeString === "undefined") {
          return 0;
        }
        if (timeString.match(/^(\d+[smhdw]?)+$/)) {
          return getLetterTime(timeString);
        }
        if (timeString.match(/^(\d+:?)+$/)) {
          return getColonTime(timeString);
        }
        return 0;
      };
      var util = {
        getQueryParams,
        combineParams,
        getTime
      };
      var getQueryParams$1 = util.getQueryParams;
      function UrlParser() {
        for (var _i = 0, _arr = ["parseProvider", "parse", "bind", "create"]; _i < _arr.length; _i++) {
          var key = _arr[_i];
          this[key] = this[key].bind(this);
        }
        this.plugins = {};
      }
      var urlParser2 = UrlParser;
      UrlParser.prototype.parseProvider = function(url) {
        var match = url.match(/(?:(?:https?:)?\/\/)?(?:[^.]+\.)?(\w+)\./i);
        return match ? match[1] : void 0;
      };
      UrlParser.prototype.parse = function(url) {
        if (typeof url === "undefined") {
          return void 0;
        }
        var provider = this.parseProvider(url);
        var result;
        var plugin = this.plugins[provider];
        if (!provider || !plugin || !plugin.parse) {
          return void 0;
        }
        result = plugin.parse.call(plugin, url, getQueryParams$1(url));
        if (result) {
          result = removeEmptyParameters(result);
          result.provider = plugin.provider;
        }
        return result;
      };
      UrlParser.prototype.bind = function(plugin) {
        this.plugins[plugin.provider] = plugin;
        if (plugin.alternatives) {
          for (var i = 0; i < plugin.alternatives.length; i += 1) {
            this.plugins[plugin.alternatives[i]] = plugin;
          }
        }
      };
      UrlParser.prototype.create = function(op) {
        if (_typeof(op) !== "object" || _typeof(op.videoInfo) !== "object") {
          return void 0;
        }
        var vi = op.videoInfo;
        var params = op.params;
        var plugin = this.plugins[vi.provider];
        params = params === "internal" ? vi.params : params || {};
        if (plugin) {
          op.format = op.format || plugin.defaultFormat;
          if (plugin.formats.hasOwnProperty(op.format)) {
            return plugin.formats[op.format].apply(plugin, [vi, Object.assign({}, params)]);
          }
        }
        return void 0;
      };
      function removeEmptyParameters(result) {
        if (result.params && Object.keys(result.params).length === 0) {
          delete result.params;
        }
        return result;
      }
      var parser = new urlParser2();
      var base = parser;
      var combineParams$1 = util.combineParams;
      function CanalPlus() {
        this.provider = "canalplus";
        this.defaultFormat = "embed";
        this.formats = {
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      CanalPlus.prototype.parseParameters = function(params) {
        delete params.vid;
        return params;
      };
      CanalPlus.prototype.parse = function(url, params) {
        var _this = this;
        var result = {
          mediaType: this.mediaTypes.VIDEO,
          id: params.vid
        };
        result.params = _this.parseParameters(params);
        if (!result.id) {
          return void 0;
        }
        return result;
      };
      CanalPlus.prototype.createEmbedUrl = function(vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = "http://player.canalplus.fr/embed/";
        params.vid = vi.id;
        url += combineParams$1(params);
        return url;
      };
      base.bind(new CanalPlus());
      var combineParams$2 = util.combineParams;
      function Coub() {
        this.provider = "coub";
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      Coub.prototype.parseUrl = function(url) {
        var match = url.match(/(?:embed|view)\/([a-zA-Z\d]+)/i);
        return match ? match[1] : void 0;
      };
      Coub.prototype.parse = function(url, params) {
        var result = {
          mediaType: this.mediaTypes.VIDEO,
          params,
          id: this.parseUrl(url)
        };
        if (!result.id) {
          return void 0;
        }
        return result;
      };
      Coub.prototype.createUrl = function(baseUrl, vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = baseUrl + vi.id;
        url += combineParams$2(params);
        return url;
      };
      Coub.prototype.createLongUrl = function(vi, params) {
        return this.createUrl("https://coub.com/view/", vi, params);
      };
      Coub.prototype.createEmbedUrl = function(vi, params) {
        return this.createUrl("//coub.com/embed/", vi, params);
      };
      base.bind(new Coub());
      var combineParams$3 = util.combineParams, getTime$1 = util.getTime;
      function Dailymotion() {
        this.provider = "dailymotion";
        this.alternatives = ["dai"];
        this.defaultFormat = "long";
        this.formats = {
          "short": this.createShortUrl,
          "long": this.createLongUrl,
          embed: this.createEmbedUrl,
          image: this.createImageUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      Dailymotion.prototype.parseParameters = function(params) {
        return this.parseTime(params);
      };
      Dailymotion.prototype.parseTime = function(params) {
        if (params.start) {
          params.start = getTime$1(params.start);
        }
        return params;
      };
      Dailymotion.prototype.parseUrl = function(url) {
        var match = url.match(/(?:\/video|ly)\/([A-Za-z0-9]+)/i);
        return match ? match[1] : void 0;
      };
      Dailymotion.prototype.parse = function(url, params) {
        var _this = this;
        var result = {
          mediaType: this.mediaTypes.VIDEO,
          params: _this.parseParameters(params),
          id: _this.parseUrl(url)
        };
        return result.id ? result : void 0;
      };
      Dailymotion.prototype.createUrl = function(base2, vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        return base2 + vi.id + combineParams$3(params);
      };
      Dailymotion.prototype.createShortUrl = function(vi, params) {
        return this.createUrl("https://dai.ly/", vi, params);
      };
      Dailymotion.prototype.createLongUrl = function(vi, params) {
        return this.createUrl("https://dailymotion.com/video/", vi, params);
      };
      Dailymotion.prototype.createEmbedUrl = function(vi, params) {
        return this.createUrl("https://www.dailymotion.com/embed/video/", vi, params);
      };
      Dailymotion.prototype.createImageUrl = function(vi, params) {
        delete params.start;
        return this.createUrl("https://www.dailymotion.com/thumbnail/video/", vi, params);
      };
      base.bind(new Dailymotion());
      var combineParams$4 = util.combineParams, getTime$2 = util.getTime;
      function Twitch() {
        this.provider = "twitch";
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video",
          STREAM: "stream",
          CLIP: "clip"
        };
      }
      Twitch.prototype.seperateId = function(id) {
        return {
          pre: id[0],
          id: id.substr(1)
        };
      };
      Twitch.prototype.parseChannel = function(result, params) {
        var channel = params.channel || params.utm_content || result.channel;
        delete params.utm_content;
        delete params.channel;
        return channel;
      };
      Twitch.prototype.parseUrl = function(url, result, params) {
        var match;
        match = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+)(?:\/clip\/(\w+))?)/i);
        if (match && match[2]) {
          result.id = "v" + match[2];
        } else if (params.video) {
          result.id = params.video;
          delete params.video;
        } else if (params.clip) {
          result.id = params.clip;
          result.isClip = true;
          delete params.clip;
        } else if (match && match[1] && match[3]) {
          result.id = match[3];
          result.isClip = true;
        } else if (match && match[3] && match[4]) {
          result.channel = match[3];
          result.id = match[4];
          result.isClip = true;
        } else if (match && match[3]) {
          result.channel = match[3];
        }
        return result;
      };
      Twitch.prototype.parseMediaType = function(result) {
        var mediaType;
        if (result.id) {
          if (result.isClip) {
            mediaType = this.mediaTypes.CLIP;
            delete result.isClip;
          } else {
            mediaType = this.mediaTypes.VIDEO;
          }
        } else if (result.channel) {
          mediaType = this.mediaTypes.STREAM;
        }
        return mediaType;
      };
      Twitch.prototype.parseParameters = function(params) {
        if (params.t) {
          params.start = getTime$2(params.t);
          delete params.t;
        }
        return params;
      };
      Twitch.prototype.parse = function(url, params) {
        var _this = this;
        var result = {};
        result = _this.parseUrl(url, result, params);
        result.channel = _this.parseChannel(result, params);
        result.mediaType = _this.parseMediaType(result);
        result.params = _this.parseParameters(params);
        return result.channel || result.id ? result : void 0;
      };
      Twitch.prototype.createLongUrl = function(vi, params) {
        var url = "";
        if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
          url = "https://twitch.tv/" + vi.channel;
        } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          var sep = this.seperateId(vi.id);
          url = "https://twitch.tv/videos/" + sep.id;
          if (params.start) {
            params.t = params.start + "s";
            delete params.start;
          }
        } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
          if (vi.channel) {
            url = "https://www.twitch.tv/" + vi.channel + "/clip/" + vi.id;
          } else {
            url = "https://clips.twitch.tv/" + vi.id;
          }
        } else {
          return void 0;
        }
        url += combineParams$4(params);
        return url;
      };
      Twitch.prototype.createEmbedUrl = function(vi, params) {
        var url = "https://player.twitch.tv/";
        if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
          params.channel = vi.channel;
        } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          params.video = vi.id;
          if (params.start) {
            params.t = params.start + "s";
            delete params.start;
          }
        } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
          url = "https://clips.twitch.tv/embed";
          params.clip = vi.id;
        } else {
          return void 0;
        }
        url += combineParams$4(params);
        return url;
      };
      base.bind(new Twitch());
      var combineParams$5 = util.combineParams, getTime$3 = util.getTime;
      function Vimeo() {
        this.provider = "vimeo";
        this.alternatives = ["vimeopro"];
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      Vimeo.prototype.parseUrl = function(url) {
        var match = url.match(/(?:\/(?:channels\/[\w]+|(?:(?:album\/\d+|groups\/[\w]+)\/)?videos?))?\/(\d+)/i);
        return match ? match[1] : void 0;
      };
      Vimeo.prototype.parseParameters = function(params) {
        return this.parseTime(params);
      };
      Vimeo.prototype.parseTime = function(params) {
        if (params.t) {
          params.start = getTime$3(params.t);
          delete params.t;
        }
        return params;
      };
      Vimeo.prototype.parse = function(url, params) {
        var result = {
          mediaType: this.mediaTypes.VIDEO,
          params: this.parseParameters(params),
          id: this.parseUrl(url)
        };
        return result.id ? result : void 0;
      };
      Vimeo.prototype.createUrl = function(baseUrl, vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = baseUrl + vi.id;
        var startTime = params.start;
        delete params.start;
        url += combineParams$5(params);
        if (startTime) {
          url += "#t=" + startTime;
        }
        return url;
      };
      Vimeo.prototype.createLongUrl = function(vi, params) {
        return this.createUrl("https://vimeo.com/", vi, params);
      };
      Vimeo.prototype.createEmbedUrl = function(vi, params) {
        return this.createUrl("//player.vimeo.com/video/", vi, params);
      };
      base.bind(new Vimeo());
      var combineParams$6 = util.combineParams, getTime$4 = util.getTime;
      function Wistia() {
        this.provider = "wistia";
        this.alternatives = [];
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl,
          embedjsonp: this.createEmbedJsonpUrl
        };
        this.mediaTypes = {
          VIDEO: "video",
          EMBEDVIDEO: "embedvideo"
        };
      }
      Wistia.prototype.parseUrl = function(url) {
        var match = url.match(/(?:(?:medias|iframe)\/|wvideo=)([\w-]+)/);
        return match ? match[1] : void 0;
      };
      Wistia.prototype.parseChannel = function(url) {
        var match = url.match(/(?:(?:https?:)?\/\/)?([^.]*)\.wistia\./);
        var channel = match ? match[1] : void 0;
        if (channel === "fast" || channel === "content") {
          return void 0;
        }
        return channel;
      };
      Wistia.prototype.parseParameters = function(params, result) {
        if (params.wtime) {
          params.start = getTime$4(params.wtime);
          delete params.wtime;
        }
        if (params.wvideo === result.id) {
          delete params.wvideo;
        }
        return params;
      };
      Wistia.prototype.parseMediaType = function(result) {
        if (result.id && result.channel) {
          return this.mediaTypes.VIDEO;
        } else if (result.id) {
          delete result.channel;
          return this.mediaTypes.EMBEDVIDEO;
        } else {
          return void 0;
        }
      };
      Wistia.prototype.parse = function(url, params) {
        var result = {
          id: this.parseUrl(url),
          channel: this.parseChannel(url)
        };
        result.params = this.parseParameters(params, result);
        result.mediaType = this.parseMediaType(result);
        if (!result.id) {
          return void 0;
        }
        return result;
      };
      Wistia.prototype.createUrl = function(vi, params, url) {
        if (params.start) {
          params.wtime = params.start;
          delete params.start;
        }
        url += combineParams$6(params);
        return url;
      };
      Wistia.prototype.createLongUrl = function(vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = "https://" + vi.channel + ".wistia.com/medias/" + vi.id;
        return this.createUrl(vi, params, url);
      };
      Wistia.prototype.createEmbedUrl = function(vi, params) {
        if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
          return void 0;
        }
        var url = "https://fast.wistia.com/embed/iframe/" + vi.id;
        return this.createUrl(vi, params, url);
      };
      Wistia.prototype.createEmbedJsonpUrl = function(vi) {
        if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
          return void 0;
        }
        return "https://fast.wistia.com/embed/medias/" + vi.id + ".jsonp";
      };
      base.bind(new Wistia());
      var combineParams$7 = util.combineParams;
      function Youku() {
        this.provider = "youku";
        this.defaultFormat = "long";
        this.formats = {
          embed: this.createEmbedUrl,
          "long": this.createLongUrl,
          flash: this.createFlashUrl,
          "static": this.createStaticUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      Youku.prototype.parseUrl = function(url) {
        var match = url.match(/(?:(?:embed|sid)\/|v_show\/id_|VideoIDS=)([a-zA-Z0-9]+)/);
        return match ? match[1] : void 0;
      };
      Youku.prototype.parseParameters = function(params) {
        if (params.VideoIDS) {
          delete params.VideoIDS;
        }
        return params;
      };
      Youku.prototype.parse = function(url, params) {
        var _this = this;
        var result = {
          mediaType: this.mediaTypes.VIDEO,
          id: _this.parseUrl(url),
          params: _this.parseParameters(params)
        };
        if (!result.id) {
          return void 0;
        }
        return result;
      };
      Youku.prototype.createUrl = function(baseUrl, vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = baseUrl + vi.id;
        url += combineParams$7(params);
        return url;
      };
      Youku.prototype.createEmbedUrl = function(vi, params) {
        return this.createUrl("http://player.youku.com/embed/", vi, params);
      };
      Youku.prototype.createLongUrl = function(vi, params) {
        return this.createUrl("http://v.youku.com/v_show/id_", vi, params);
      };
      Youku.prototype.createStaticUrl = function(vi, params) {
        return this.createUrl("http://static.youku.com/v1.0.0638/v/swf/loader.swf?VideoIDS=", vi, params);
      };
      Youku.prototype.createFlashUrl = function(vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = "http://player.youku.com/player.php/sid/" + vi.id + "/v.swf";
        url += combineParams$7(params);
        return url;
      };
      base.bind(new Youku());
      var combineParams$8 = util.combineParams, getTime$5 = util.getTime;
      function YouTube() {
        this.provider = "youtube";
        this.alternatives = ["youtu", "ytimg"];
        this.defaultFormat = "long";
        this.formats = {
          "short": this.createShortUrl,
          "long": this.createLongUrl,
          embed: this.createEmbedUrl,
          shortImage: this.createShortImageUrl,
          longImage: this.createLongImageUrl
        };
        this.imageQualities = {
          "0": "0",
          "1": "1",
          "2": "2",
          "3": "3",
          DEFAULT: "default",
          HQDEFAULT: "hqdefault",
          SDDEFAULT: "sddefault",
          MQDEFAULT: "mqdefault",
          MAXRESDEFAULT: "maxresdefault"
        };
        this.defaultImageQuality = this.imageQualities.HQDEFAULT;
        this.mediaTypes = {
          VIDEO: "video",
          PLAYLIST: "playlist",
          SHARE: "share",
          CHANNEL: "channel"
        };
      }
      YouTube.prototype.parseVideoUrl = function(url) {
        var match = url.match(/(?:(?:v|vi|be|videos|embed)\/(?!videoseries)|(?:v|ci)=)([\w-]{11})/i);
        return match ? match[1] : void 0;
      };
      YouTube.prototype.parseChannelUrl = function(url) {
        var match = url.match(/\/channel\/([\w-]+)/);
        if (match) {
          return {
            id: match[1],
            mediaType: this.mediaTypes.CHANNEL
          };
        }
        match = url.match(/\/(?:c|user)\/([\w-]+)/);
        if (match) {
          return {
            name: match[1],
            mediaType: this.mediaTypes.CHANNEL
          };
        }
      };
      YouTube.prototype.parseParameters = function(params, result) {
        if (params.start || params.t) {
          params.start = getTime$5(params.start || params.t);
          delete params.t;
        }
        if (params.v === result.id) {
          delete params.v;
        }
        if (params.list === result.id) {
          delete params.list;
        }
        return params;
      };
      YouTube.prototype.parseMediaType = function(result) {
        if (result.params.list) {
          result.list = result.params.list;
          delete result.params.list;
        }
        if (result.id && !result.params.ci) {
          result.mediaType = this.mediaTypes.VIDEO;
        } else if (result.list) {
          delete result.id;
          result.mediaType = this.mediaTypes.PLAYLIST;
        } else if (result.params.ci) {
          delete result.params.ci;
          result.mediaType = this.mediaTypes.SHARE;
        } else {
          return void 0;
        }
        return result;
      };
      YouTube.prototype.parse = function(url, params) {
        var channelResult = this.parseChannelUrl(url);
        if (channelResult) {
          return channelResult;
        } else {
          var result = {
            params,
            id: this.parseVideoUrl(url)
          };
          result.params = this.parseParameters(params, result);
          result = this.parseMediaType(result);
          return result;
        }
      };
      YouTube.prototype.createShortUrl = function(vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = "https://youtu.be/" + vi.id;
        if (params.start) {
          url += "#t=" + params.start;
        }
        return url;
      };
      YouTube.prototype.createLongUrl = function(vi, params) {
        var url = "";
        var startTime = params.start;
        delete params.start;
        if (vi.mediaType === this.mediaTypes.CHANNEL) {
          if (vi.id) {
            url += "https://www.youtube.com/channel/" + vi.id;
          } else if (vi.name) {
            url += "https://www.youtube.com/c/" + vi.name;
          } else {
            return void 0;
          }
        } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
          params.feature = "share";
          url += "https://www.youtube.com/playlist";
        } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          params.v = vi.id;
          url += "https://www.youtube.com/watch";
        } else if (vi.mediaType === this.mediaTypes.SHARE && vi.id) {
          params.ci = vi.id;
          url += "https://www.youtube.com/shared";
        } else {
          return void 0;
        }
        if (vi.list) {
          params.list = vi.list;
        }
        url += combineParams$8(params);
        if (vi.mediaType !== this.mediaTypes.PLAYLIST && startTime) {
          url += "#t=" + startTime;
        }
        return url;
      };
      YouTube.prototype.createEmbedUrl = function(vi, params) {
        var url = "https://www.youtube.com/embed";
        if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
          params.listType = "playlist";
        } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          url += "/" + vi.id;
          if (params.loop === "1") {
            params.playlist = vi.id;
          }
        } else {
          return void 0;
        }
        if (vi.list) {
          params.list = vi.list;
        }
        url += combineParams$8(params);
        return url;
      };
      YouTube.prototype.createImageUrl = function(baseUrl, vi, params) {
        if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
          return void 0;
        }
        var url = baseUrl + vi.id + "/";
        var quality = params.imageQuality || this.defaultImageQuality;
        return url + quality + ".jpg";
      };
      YouTube.prototype.createShortImageUrl = function(vi, params) {
        return this.createImageUrl("https://i.ytimg.com/vi/", vi, params);
      };
      YouTube.prototype.createLongImageUrl = function(vi, params) {
        return this.createImageUrl("https://img.youtube.com/vi/", vi, params);
      };
      base.bind(new YouTube());
      var combineParams$9 = util.combineParams, getTime$6 = util.getTime;
      function SoundCloud() {
        this.provider = "soundcloud";
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          TRACK: "track",
          PLAYLIST: "playlist",
          APITRACK: "apitrack",
          APIPLAYLIST: "apiplaylist"
        };
      }
      SoundCloud.prototype.parseUrl = function(url, result) {
        var match = url.match(/(?:m\.)?soundcloud\.com\/(?:([\w-]+)\/(sets\/)?)([\w-]+)/i);
        if (!match) {
          return result;
        }
        result.channel = match[1];
        if (match[1] === "playlists" || match[2]) {
          result.list = match[3];
        } else {
          result.id = match[3];
        }
        return result;
      };
      SoundCloud.prototype.parseParameters = function(params) {
        if (params.t) {
          params.start = getTime$6(params.t);
          delete params.t;
        }
        return params;
      };
      SoundCloud.prototype.parseMediaType = function(result) {
        if (result.id) {
          if (result.channel === "tracks") {
            delete result.channel;
            delete result.params.url;
            result.mediaType = this.mediaTypes.APITRACK;
          } else {
            result.mediaType = this.mediaTypes.TRACK;
          }
        }
        if (result.list) {
          if (result.channel === "playlists") {
            delete result.channel;
            delete result.params.url;
            result.mediaType = this.mediaTypes.APIPLAYLIST;
          } else {
            result.mediaType = this.mediaTypes.PLAYLIST;
          }
        }
        return result;
      };
      SoundCloud.prototype.parse = function(url, params) {
        var result = {};
        result = this.parseUrl(url, result);
        result.params = this.parseParameters(params);
        result = this.parseMediaType(result);
        if (!result.id && !result.list) {
          return void 0;
        }
        return result;
      };
      SoundCloud.prototype.createLongUrl = function(vi, params) {
        var url = "";
        var startTime = params.start;
        delete params.start;
        if (vi.mediaType === this.mediaTypes.TRACK && vi.id && vi.channel) {
          url = "https://soundcloud.com/" + vi.channel + "/" + vi.id;
        } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list && vi.channel) {
          url = "https://soundcloud.com/" + vi.channel + "/sets/" + vi.list;
        } else if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
          url = "https://api.soundcloud.com/tracks/" + vi.id;
        } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
          url = "https://api.soundcloud.com/playlists/" + vi.list;
        } else {
          return void 0;
        }
        url += combineParams$9(params);
        if (startTime) {
          url += "#t=" + startTime;
        }
        return url;
      };
      SoundCloud.prototype.createEmbedUrl = function(vi, params) {
        var url = "https://w.soundcloud.com/player/";
        delete params.start;
        if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
          params.url = "https%3A//api.soundcloud.com/tracks/" + vi.id;
        } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
          params.url = "https%3A//api.soundcloud.com/playlists/" + vi.list;
        } else {
          return void 0;
        }
        url += combineParams$9(params);
        return url;
      };
      base.bind(new SoundCloud());
      var combineParams$a = util.combineParams;
      function TeacherTube() {
        this.provider = "teachertube";
        this.alternatives = [];
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video",
          AUDIO: "audio",
          DOCUMENT: "document",
          CHANNEL: "channel",
          COLLECTION: "collection",
          GROUP: "group"
        };
      }
      TeacherTube.prototype.parse = function(url, params) {
        var result = {};
        result.list = this.parsePlaylist(params);
        result.params = params;
        var match = url.match(/\/(audio|video|document|user\/channel|collection|group)\/(?:[\w-]+-)?(\w+)/);
        if (!match) {
          return void 0;
        }
        result.mediaType = this.parseMediaType(match[1]);
        result.id = match[2];
        return result;
      };
      TeacherTube.prototype.parsePlaylist = function(params) {
        if (params["playlist-id"]) {
          var list = params["playlist-id"];
          delete params["playlist-id"];
          return list;
        }
        return void 0;
      };
      TeacherTube.prototype.parseMediaType = function(mediaTypeMatch) {
        switch (mediaTypeMatch) {
          case "audio":
            return this.mediaTypes.AUDIO;
          case "video":
            return this.mediaTypes.VIDEO;
          case "document":
            return this.mediaTypes.DOCUMENT;
          case "user/channel":
            return this.mediaTypes.CHANNEL;
          case "collection":
            return this.mediaTypes.COLLECTION;
          case "group":
            return this.mediaTypes.GROUP;
        }
      };
      TeacherTube.prototype.createLongUrl = function(vi, params) {
        if (!vi.id) {
          return void 0;
        }
        var url = "https://www.teachertube.com/";
        if (vi.list) {
          params["playlist-id"] = vi.list;
        }
        if (vi.mediaType === this.mediaTypes.CHANNEL) {
          url += "user/channel/";
        } else {
          url += vi.mediaType + "/";
        }
        url += vi.id;
        url += combineParams$a(params);
        return url;
      };
      TeacherTube.prototype.createEmbedUrl = function(vi, params) {
        if (!vi.id) {
          return void 0;
        }
        var url = "https://www.teachertube.com/embed/";
        if (vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.AUDIO) {
          url += vi.mediaType + "/" + vi.id;
        } else {
          return void 0;
        }
        url += combineParams$a(params);
        return url;
      };
      base.bind(new TeacherTube());
      var combineParams$b = util.combineParams;
      function TikTok() {
        this.provider = "tiktok";
        this.defaultFormat = "long";
        this.formats = {
          "long": this.createLongUrl
        };
        this.mediaTypes = {
          VIDEO: "video"
        };
      }
      TikTok.prototype.parse = function(url, params) {
        var result = {
          params,
          mediaType: this.mediaTypes.VIDEO
        };
        var match = url.match(/@([^/]+)\/video\/(\d{19})/);
        if (!match) {
          return;
        }
        result.channel = match[1];
        result.id = match[2];
        return result;
      };
      TikTok.prototype.createLongUrl = function(vi, params) {
        var url = "";
        if (vi.mediaType === this.mediaTypes.VIDEO && vi.id && vi.channel) {
          url += "https://www.tiktok.com/@".concat(vi.channel, "/video/").concat(vi.id);
        } else {
          return void 0;
        }
        url += combineParams$b(params);
        return url;
      };
      base.bind(new TikTok());
      var combineParams$c = util.combineParams;
      function Ted() {
        this.provider = "ted";
        this.formats = {
          "long": this.createLongUrl,
          embed: this.createEmbedUrl
        };
        this.mediaTypes = {
          VIDEO: "video",
          PLAYLIST: "playlist"
        };
      }
      Ted.prototype.parseUrl = function(url, result) {
        var match = url.match(/\/(talks|playlists\/(\d+))\/([\w-]+)/);
        var channel = match ? match[1] : void 0;
        if (!channel) {
          return result;
        }
        result.channel = channel.split("/")[0];
        result.id = match[3];
        if (result.channel === "playlists") {
          result.list = match[2];
        }
        return result;
      };
      Ted.prototype.parseMediaType = function(result) {
        if (result.id && result.channel === "playlists") {
          delete result.channel;
          result.mediaType = this.mediaTypes.PLAYLIST;
        }
        if (result.id && result.channel === "talks") {
          delete result.channel;
          result.mediaType = this.mediaTypes.VIDEO;
        }
        return result;
      };
      Ted.prototype.parse = function(url, params) {
        var result = {
          params
        };
        result = this.parseUrl(url, result);
        result = this.parseMediaType(result);
        if (!result.id) {
          return void 0;
        }
        return result;
      };
      Ted.prototype.createLongUrl = function(vi, params) {
        var url = "";
        if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          url += "https://ted.com/talks/" + vi.id;
        } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
          url += "https://ted.com/playlists/" + vi.list + "/" + vi.id;
        } else {
          return void 0;
        }
        url += combineParams$c(params);
        return url;
      };
      Ted.prototype.createEmbedUrl = function(vi, params) {
        var url = "https://embed.ted.com/";
        if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
          url += "playlists/" + vi.list + "/" + vi.id;
        } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
          url += "talks/" + vi.id;
        } else {
          return void 0;
        }
        url += combineParams$c(params);
        return url;
      };
      base.bind(new Ted());
      var lib = base;
      return lib;
    });
  })(jsVideoUrlParser);
  var urlParser = jsVideoUrlParser.exports;
  var convertPasteText = {
    command: "convertPasteText",
    execute: async (editor2, text2) => {
      const embedUrl = urlParser.create({
        videoInfo: urlParser.parse(text2),
        format: "embed",
        mediaType: "clip"
      });
      if (embedUrl) {
        const center = editor2.context.viewport.center;
        const width2 = 300;
        const height = 200;
        editor2.context.commands.emit("newComponent", "iframe", {
          x: center[0] - width2 / 2,
          y: center[1] - height / 2,
          width: width2,
          height,
          backgroundColor: "transparent",
          url: embedUrl
        });
      }
    }
  };
  var __glob_0_31$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convertPasteText
  }, Symbol.toStringTag, { value: "Module" }));
  function convertPath(editor2, pathString2, rect2 = null) {
    var current = editor2.context.selection.current;
    if (current) {
      if (current.is("svg-path", "svg-brush", "svg-textpath")) {
        var d = pathString2;
        if (rect2) {
          var parser = new PathParser(pathString2);
          parser.scale(current.width / rect2.width, current.height / rect2.height);
          d = parser.d;
        }
        editor2.context.commands.executeCommand("setAttribute", "set attribute -d", editor2.context.selection.packByValue({ d }, current.id));
      } else if (current.clipPath.includes("path")) {
        var d = pathString2;
        if (rect2) {
          var parser = new PathParser(pathString2);
          parser.scale(current.width / rect2.width, current.height / rect2.height);
          d = parser.d;
        }
        editor2.context.commands.executeCommand("setAttribute", "change clip path", editor2.context.selection.packByValue({ clipPath: `path(${d})` }, current.id));
      }
    }
  }
  var __glob_0_32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": convertPath
  }, Symbol.toStringTag, { value: "Module" }));
  var copy_path = {
    command: "copy.path",
    description: "copy as path for item with path string(d attribute)",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      if (current) {
        let newPath = PathParser.fromSVGString(current.d);
        try {
          const newLayerAttrs = current.toSVGPath();
          editor2.context.commands.executeCommand("addLayer", `copy path`, editor2.context.modelManager.createModel(__spreadValues(__spreadValues({
            itemType: "svg-path"
          }, newLayerAttrs), current.updatePath(newPath.d))), true, current.parent);
        } catch (e) {
          console.error(e);
        }
      }
    }
  };
  var __glob_0_33$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": copy_path
  }, Symbol.toStringTag, { value: "Module" }));
  var copyLayer = {
    command: "history.copyLayer",
    description: "copy in selected items ",
    description_ko: ["\uC120\uD0DD\uB41C \uC544\uC774\uD15C\uC744 \uAE30\uC900\uC73C\uB85C \uBCF5\uC81C\uD55C\uB2E4. "],
    execute: async function(editor2, ids = []) {
      let currentIds = ids.map((id) => editor2.get(id)).filter(Boolean).map((item) => item.id);
      if (!currentIds.length) {
        currentIds = editor2.context.selection.ids;
      }
      if (!currentIds.length)
        return;
      const items = await editor2.json.renderAll(currentIds.map((it) => editor2.get(it)));
      const newIds = [];
      const itemList = {};
      const parentList = {};
      let updateData = {};
      items.forEach((itemJSON) => {
        const referenceId = itemJSON.referenceId;
        const sourceItem = editor2.get(referenceId);
        parentList[sourceItem.parentId] = sourceItem.parent;
        const model = editor2.context.modelManager.createModel(itemJSON);
        model.renameWithCount();
        sourceItem.insertAfter(model);
        newIds.push(model.id);
        itemList[model.id] = itemJSON;
        updateData[model.id] = model.toCloneObject();
      });
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor2.context.commands.emit("setAttribute", updateData);
      editor2.nextTick(() => {
        editor2.context.selection.select(...newIds);
      });
    }
  };
  var __glob_0_34$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": copyLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var copyTimelineProperty = {
    command: "copyTimelineProperty",
    execute: function(editor2, layerId, property, newTime = null) {
      _currentProject(editor2, (project2) => {
        project2.copyTimelineKeyframe(layerId, property, newTime);
        editor2.emit("refreshTimeline");
      });
    }
  };
  var __glob_0_35$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": copyTimelineProperty
  }, Symbol.toStringTag, { value: "Module" }));
  var deleteTimelineKeyframe = {
    command: "deleteTimelineKeyframe",
    execute: function(editor2) {
      _currentProject(editor2, (project2) => {
        editor2.timeline.each((item) => {
          project2.deleteTimelineKeyframe(item.layerId, item.property, item.id);
        });
        editor2.timeline.empty();
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      });
    }
  };
  var __glob_0_36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": deleteTimelineKeyframe
  }, Symbol.toStringTag, { value: "Module" }));
  var doubleclick_item = {
    command: "doubleclick.item",
    execute: function(editor2, evt, id) {
      const item = editor2.get(id);
      if (editor2.context.selection.isOne && item) {
        if (editor2.context.selection.checkChildren(item.id)) {
          editor2.context.selection.select(item);
        } else {
          if (editor2.context.selection.check(item)) {
            editor2.context.commands.emit("open.editor");
            editor2.emit("removeGuideLine");
          } else {
            this.selectInWorldPosition(editor2, evt, item);
          }
        }
      } else {
        this.selectInWorldPosition(editor2, evt, item);
      }
    },
    selectInWorldPosition: function(editor2, evt, item) {
      const point2 = editor2.context.viewport.getWorldPosition(evt);
      if (editor2.context.selection.hasPoint(point2) || editor2.context.selection.hasChildrenPoint(point2)) {
        editor2.context.selection.select(item);
        editor2.context.snapManager.clear();
      }
    }
  };
  var __glob_0_37$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": doubleclick_item
  }, Symbol.toStringTag, { value: "Module" }));
  function downloadFile(datauri, filename = "elf.json") {
    var a = document.createElement("a");
    a.href = datauri;
    a.download = filename;
    a.click();
  }
  var downloadJSON = {
    command: "downloadJSON",
    execute: function(editor2, filename) {
      var json = JSON.stringify(editor2.context.modelManager.toJSON());
      var datauri = "data:application/json;base64," + window.btoa(unescape(encodeURIComponent(json)));
      downloadFile(datauri, filename || "elf.json");
    }
  };
  var __glob_0_38$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": downloadJSON
  }, Symbol.toStringTag, { value: "Module" }));
  var ExportManager = {
    makeProjectStyle(item) {
      const keyframeString = item.toKeyframeString();
      const rootVariable = item.toRootVariableCSS();
      return `
      :root {
        ${CSS_TO_STRING(rootVariable)}
      }
      /* keyframe */
      ${keyframeString}
    `;
    },
    makeStyle(item, appendCSS = "") {
      if (item.is("project")) {
        return this.makeProjectStyle(item);
      }
      const cssString = item.generateView(`[data-id='${item.id}']`, appendCSS);
      return `
    ${cssString}
    ` + item.layers.map((it) => {
        return this.makeStyle(it);
      }).join("");
    },
    makeSvg(project2) {
      const SVGString = project2.toSVGString ? project2.toSVGString() : "";
      return `
      ${SVGString ? `<svg width="0" height="0">${SVGString}</svg>` : ""}
    `;
    },
    generateSVG(editor2, rootItem) {
      return editor2.replaceLocalUrltoRealUrl(editor2.svg.render(rootItem));
    }
  };
  function createImagePng(img, callback, imageType = "image/png") {
    var canvas = sapa.Dom.create("canvas");
    var { width: width2, height } = img;
    canvas.resize({ width: width2, height });
    canvas.drawImage(img);
    callback && callback(canvas.toDataURL(imageType));
  }
  var downloadPNG = {
    command: "downloadPNG",
    execute: function(editor2) {
      const item = editor2.context.selection.current;
      if (item) {
        const svgString = ExportManager.generateSVG(editor2, item).trim();
        const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
        const filename = item.id;
        loadOriginalImage({ local: datauri }, (info, img) => {
          createImagePng(img, (pngDataUri) => {
            downloadFile(pngDataUri, filename);
          });
        });
      }
    }
  };
  var __glob_0_39$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": downloadPNG
  }, Symbol.toStringTag, { value: "Module" }));
  var downloadSVG = {
    command: "downloadSVG",
    execute: function(editor2) {
      const item = editor2.context.selection.current;
      if (item) {
        var svgString = ExportManager.generateSVG(editor2, item).trim();
        var datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
        var filename = item.id;
        downloadFile(datauri, filename);
      }
    }
  };
  var __glob_0_40$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": downloadSVG
  }, Symbol.toStringTag, { value: "Module" }));
  var drop_asset = {
    command: "drop.asset",
    execute: async function(editor2, obj2, id = null) {
      if (obj2.color) {
        editor2.context.commands.emit("addBackgroundColor", obj2.color, id);
      } else if (obj2.gradient) {
        editor2.context.commands.emit("addBackgroundImageGradient", obj2.gradient, id);
      } else if (obj2.pattern) {
        editor2.context.commands.emit("addBackgroundImagePattern", obj2.pattern, id);
      } else if (obj2.imageUrl) {
        editor2.context.commands.emit("addBackgroundImageAsset", obj2.imageUrl, id);
      } else if (obj2.asset) {
        const assetData = await editor2.storageManager.getCustomAsset(obj2.asset.id);
        if (assetData) {
          editor2.context.commands.emit("addArtBoard", assetData, obj2.asset.center);
        }
      }
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_41$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": drop_asset
  }, Symbol.toStringTag, { value: "Module" }));
  var dropImageUrl = {
    command: "dropImageUrl",
    execute: function(editor2, imageUrl) {
      loadOriginalImage({ local: imageUrl }, (info) => {
        editor2.context.commands.emit("addImage", __spreadValues({ src: info.local }, info));
      });
    }
  };
  var __glob_0_42$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": dropImageUrl
  }, Symbol.toStringTag, { value: "Module" }));
  var editor_config_body_event = {
    command: "change.bodyEvent",
    description: "fire when bodyEvent was set",
    execute: function(editor2) {
      const $target = sapa.Dom.create(editor2.context.config.get("bodyEvent").target);
      editor2.context.config.init("onMouseMovepageContainer", $target);
    }
  };
  var __glob_0_43$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editor_config_body_event
  }, Symbol.toStringTag, { value: "Module" }));
  var fileDropItems = {
    command: "fileDropItems",
    execute: function(editor2, items = []) {
      editor2.context.commands.emit("updateResource", items);
    }
  };
  var __glob_0_44$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": fileDropItems
  }, Symbol.toStringTag, { value: "Module" }));
  function timecode(fps, seconds) {
    var h = Math.floor(seconds / 3600);
    var m = Math.floor(seconds / 60 % 60);
    var s = Math.floor(seconds % 60);
    var f = Math.round((seconds - Math.floor(seconds)) * fps);
    if (f === fps) {
      f = 0;
      s += 1;
      if (s === 60) {
        m += 1;
        if (m === 60) {
          h += 1;
        }
      }
    }
    return [h, m, s, f].map((t) => {
      return (t + "").padStart(2, "0");
    }).join(":");
  }
  function makeTimer(opt) {
    var timer = {
      id: 0,
      start: 0,
      speed: opt.speed || 1,
      elapsed: opt.elapsed || 0,
      duration: opt.duration || 0,
      iterationStartCount: 1,
      iterationCount: opt.iterationCount || Number.MAX_SAFE_INTEGER,
      direction: opt.direction || "normal",
      log: [],
      logIndex: 0,
      tick: opt.tick || (() => {
      }),
      startCallback: opt.start || (() => {
      }),
      endCallback: opt.end || (() => {
      }),
      firstCallback: opt.first || (() => {
      }),
      lastCallback: opt.last || (() => {
      })
    };
    const isForward = () => {
      if (timer.direction === "normal") {
        return true;
      } else if (timer.direction === "reverse") {
        return false;
      } else if (timer.direction === "alternate") {
        return timer.iterationStartCount % 2 === 1;
      } else if (timer.direction === "alternate-reverse") {
        return timer.iterationStartCount % 2 === 0;
      }
    };
    const calculateForDirection = (rate) => {
      return isForward() ? rate : 1 - rate;
    };
    const tick = (now) => {
      var isStart = false;
      if (timer.start === null) {
        timer.start = now;
        isStart = true;
      }
      const dt = now - timer.start;
      timer.elapsed += dt * timer.speed;
      timer.start = now;
      if (timer.elapsed > timer.duration) {
        timer.elapsed = timer.duration;
      }
      var elapsed = calculateForDirection(timer.elapsed / timer.duration) * timer.duration;
      if (isStart)
        timer.startCallback(elapsed, timer);
      timer.log[timer.logIndex++] = { elapsed, dt: timer.lastTime - elapsed };
      timer.lastTime = elapsed;
      timer.tick(elapsed, timer);
      if (timer.elapsed === timer.duration) {
        end();
      } else {
        frameStart();
      }
    };
    const frameStart = () => {
      timer.id = window.requestAnimationFrame(tick);
    };
    const end = () => {
      timer.endCallback(timer.elapsed, timer);
      timer.iterationStartCount++;
      if (timer.iterationStartCount > timer.iterationCount) {
        timer.lastCallback(timer.elapsed, timer);
        window.cancelAnimationFrame(timer.id);
      } else {
        timer.start = null;
        timer.elapsed = 0;
        frameStart();
      }
    };
    const play = (opt2 = {}) => {
      timer.start = null;
      timer.iterationStartCount = 1;
      timer.log = [];
      timer.lastTime = 0;
      timer.logIndex = 0;
      if (sapa.isNumber(opt2.elapsed))
        timer.elapsed = opt2.elapsed;
      if (sapa.isNumber(opt2.speed))
        timer.speed = opt2.speed;
      if (sapa.isNumber(opt2.duration))
        timer.duration = opt2.duration;
      if (sapa.isNumber(opt2.iterationCount))
        timer.iterationCount = opt2.iterationCount || Number.MAX_SAFE_INTEGER;
      if (sapa.isString(opt2.direction))
        timer.direction = opt2.direction;
      if (sapa.isFunction(opt2.tick))
        timer.tick = opt2.tick;
      if (sapa.isFunction(opt2.start))
        timer.startCallback = opt2.start;
      if (sapa.isFunction(opt2.end))
        timer.endCallback = opt2.end;
      if (sapa.isFunction(opt2.first))
        timer.firstCallback = opt2.first;
      if (sapa.isFunction(opt2.last))
        timer.lastCallback = opt2.last;
      if (sapa.isFunction(opt2.stop))
        timer.stopCallback = opt2.stop;
      timer.firstCallback(timer.elapsed, timer);
      frameStart();
    };
    const stop = () => {
      timer.stopCallback(timer.elapsed, timer);
      window.cancelAnimationFrame(timer.id);
    };
    const seek = (t) => {
      timer.elapsed = t;
      timer.tick(timer.elapsed, timer);
    };
    const first = () => {
      seek(0);
    };
    const last = () => {
      seek(timer.duration);
    };
    return {
      play,
      stop,
      tick,
      first,
      last,
      seek,
      timer
    };
  }
  var firstTimelineItem = {
    command: "firstTimelineItem",
    execute: function(editor2) {
      _currentProject(editor2, (project2, timeline) => {
        var firstTime = project2.getSelectedTimelineFirstTime();
        project2.setTimelineCurrentTime(timecode(timeline.fps, firstTime));
        project2.seek();
        editor2.emit("playTimeline");
      });
    }
  };
  var __glob_0_45$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": firstTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var group_item$1 = {
    command: "group.item",
    execute: function(editor2, opt = {}) {
      if (editor2.context.selection.length === 0)
        return;
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.generateListNumber();
        const list = editor2.context.selection.map((item) => {
          return { depth: item.depth, item };
        });
        list.sort((a, b) => {
          if (a.depth === b.depth) {
            return a.no > b.no ? -1 : 1;
          }
          return a.depth > b.depth ? 1 : -1;
        });
        const groupLayer = editor2.context.modelManager.createModel(__spreadValues(__spreadValues({
          itemType: "rect"
        }, editor2.context.selection.itemRect), opt));
        list[0].item.insertAfter(groupLayer);
        list.forEach(({ item }) => {
          groupLayer.appendChild(item);
        });
        editor2.context.selection.select(groupLayer);
        editor2.emit("refreshAll");
      }
    }
  };
  var __glob_0_46$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": group_item$1
  }, Symbol.toStringTag, { value: "Module" }));
  var history_addLayer = {
    command: "history.addLayer",
    description: "add layer in history ",
    execute: function(editor2, message, layer, isSelected = true, containerItem) {
      editor2.context.commands.emit("addLayer", layer, isSelected, containerItem);
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [layer, isSelected, containerItem],
          undoValues: [layer.id]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues }) {
      editor2.context.commands.emit("addLayer", ...currentValues);
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    },
    undo: function(editor2, { undoValues }) {
      const ids = undoValues;
      const items = editor2.context.selection.itemsByIds(ids);
      items.forEach((item) => {
        if (item) {
          item.remove();
        }
      });
      editor2.nextTick(() => {
        editor2.context.selection.empty();
        editor2.emit("refreshAll");
      });
    }
  };
  var __glob_0_47$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_addLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var history_bring_forward = {
    command: "history.bring.forward",
    description: "bring forward",
    execute: function(editor2, message, layer = editor2.context.selection.current) {
      const currentLayer = editor2.get(layer);
      const lastValues = currentLayer.hierarchy;
      const oldParentLayer = currentLayer.parent;
      let currentValues = {};
      let nextParentLayer = null;
      if (currentLayer.isLast) {
        nextParentLayer = oldParentLayer.next;
        if (!nextParentLayer) {
          return;
        }
        if (nextParentLayer.enableHasChildren()) {
          nextParentLayer.appendChild(currentLayer);
          currentValues = currentLayer.hierarchy;
        } else {
          nextParentLayer.insertAfter(currentLayer);
          currentValues = currentLayer.hierarchy;
        }
      } else {
        currentLayer.parent.bringForward(currentLayer.id);
        currentValues = currentLayer.hierarchy;
      }
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentLayer.parent.attrsWithId("children")));
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [currentValues],
          undoValues: [lastValues]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [newValues], undoValues: [lastValues] }) {
      const currentLayer = editor2.get(newValues.id);
      const currentTarget = editor2.get(newValues.parentId);
      const lastParent = editor2.get(lastValues.parentId);
      currentTarget.insertChild(currentLayer, newValues.index);
      currentLayer.reset(newValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
    },
    undo: function(editor2, { currentValues: [newValues], undoValues: [lastValues] }) {
      const currentLayer = lastValues;
      const lastLayer = editor2.get(currentLayer.id);
      const lastParent = editor2.get(currentLayer.parentId);
      const currentParent = editor2.get(newValues.parentId);
      const lastIndex = currentLayer.index;
      lastParent.insertChild(lastLayer, lastIndex);
      lastLayer.reset(lastValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
    }
  };
  var __glob_0_48$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_bring_forward
  }, Symbol.toStringTag, { value: "Module" }));
  var history_bring_front = {
    command: "history.bring.front",
    description: "bring front",
    execute: function(editor2, message, layer = editor2.context.selection.current) {
      const currentLayer = editor2.get(layer);
      const lastValues = currentLayer.hierachy;
      const oldParentLayer = currentLayer.parent;
      let currentValues = {};
      if (currentLayer.isLast) {
        return;
      } else {
        currentLayer.parent.bringFront(currentLayer.id);
        currentValues = currentLayer.hierarchy;
      }
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")));
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [currentValues],
          undoValues: [lastValues]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [newValues] }) {
      const currentLayer = editor2.get(newValues.id);
      const currentTarget = editor2.get(newValues.parentId);
      currentTarget.insertChild(currentLayer, newValues.index);
      currentLayer.reset(newValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
    },
    undo: function(editor2, { undoValues: [lastValues] }) {
      const currentLayer = lastValues;
      const lastLayer = editor2.get(currentLayer.id);
      const lastParent = editor2.get(currentLayer.parentId);
      const lastIndex = currentLayer.index;
      lastParent.insertChild(lastLayer, lastIndex);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")));
    }
  };
  var __glob_0_49$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_bring_front
  }, Symbol.toStringTag, { value: "Module" }));
  var history_clipboard_paste = {
    command: "history.clipboard.paste",
    description: "paste in clipboard ",
    description_ko: ["\uD074\uB9BD\uBCF4\uB4DC \uB370\uC774\uD0C0\uB97C \uAE30\uC900\uC73C\uB85C paste \uB97C \uC801\uC6A9\uD55C\uB2E4. "],
    execute: async function(editor2, message, clipboardData = void 0, hasHistory = true) {
      const data = clipboardData || editor2.context.clipboard.last;
      if (data.type == ClipboardActionType.COPY) {
        const ids = data.data;
        const items = await editor2.json.renderAll(ids.map((it) => editor2.get(it)));
        const newIds = [];
        const itemList = {};
        const parentList = {};
        let updateData = {};
        items.forEach((itemJSON) => {
          const referenceId = itemJSON.referenceId;
          const sourceItem = editor2.get(referenceId);
          parentList[sourceItem.parentId] = sourceItem.parent;
          const model = editor2.context.modelManager.createModel(itemJSON);
          model.renameWithCount();
          sourceItem.insertAfter(model);
          newIds.push(model.id);
          itemList[model.id] = itemJSON;
          updateData[model.id] = model.toCloneObject();
        });
        Object.values(parentList).forEach((parent) => {
          updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
        });
        editor2.context.commands.emit("setAttribute", updateData);
        editor2.nextTick(() => {
          editor2.context.selection.select(...newIds);
          if (hasHistory) {
            editor2.context.history.add(message, this, {
              currentValues: [data],
              undoValues: [newIds, editor2.context.selection.ids]
            });
          }
          editor2.context.history.saveSelection();
        });
      }
    },
    redo: function(editor2, { currentValues: [data] }) {
      editor2.context.commands.emit("history.clipboard.paste", "paste", data, false);
    },
    undo: function(editor2, { currentValues: [data], undoValues: [newIds, selectedIds] }) {
      if (data.type === ClipboardActionType.COPY) {
        const parentList = {};
        newIds.forEach((id) => {
          const item = editor2.get(id);
          parentList[item.parentId] = item.parent;
          if (item) {
            item.remove();
          }
        });
        let updateData = {};
        Object.values(parentList).forEach((parent) => {
          updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
        });
        editor2.context.selection.select(...selectedIds);
        editor2.context.commands.emit("setAttribute", updateData);
      }
    }
  };
  var __glob_0_50$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_clipboard_paste
  }, Symbol.toStringTag, { value: "Module" }));
  var history_copyLayer = {
    command: "history.copyLayer",
    description: "copy in selected items ",
    description_ko: ["\uC120\uD0DD\uB41C \uC544\uC774\uD15C\uC744 \uAE30\uC900\uC73C\uB85C \uBCF5\uC81C\uD55C\uB2E4. "],
    execute: async function(editor2, message, ids = []) {
      let currentIds = ids.map((id) => editor2.get(id)).filter(Boolean).map((item) => item.id);
      if (!currentIds.length) {
        currentIds = editor2.context.selection.ids;
      }
      if (!currentIds.length)
        return;
      const items = await editor2.json.renderAll(currentIds.map((it) => editor2.get(it)));
      const newIds = [];
      const itemList = {};
      const parentList = {};
      let updateData = {};
      items.forEach((itemJSON) => {
        const referenceId = itemJSON.referenceId;
        const sourceItem = editor2.get(referenceId);
        parentList[sourceItem.parentId] = sourceItem.parent;
        const model = editor2.context.modelManager.createModel(itemJSON);
        model.renameWithCount();
        sourceItem.insertAfter(model);
        newIds.push(model.id);
        itemList[model.id] = itemJSON;
        updateData[model.id] = model.toCloneObject();
      });
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor2.context.commands.emit("setAttribute", updateData);
      editor2.nextTick(() => {
        editor2.context.selection.select(...newIds);
        editor2.context.history.add(message, this, {
          currentValues: [currentIds],
          undoValues: [newIds, editor2.context.selection.ids]
        });
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [currentIds] }) {
      editor2.context.commands.emit("copyLayer", currentIds);
    },
    undo: function(editor2, { undoValues: [newIds, selectedIds] }) {
      const parentList = {};
      newIds.forEach((id) => {
        const item = editor2.get(id);
        parentList[item.parentId] = item.parent;
        if (item) {
          item.remove();
        }
      });
      let updateData = {};
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor2.context.selection.select(...selectedIds);
      editor2.context.commands.emit("setAttribute", updateData);
    }
  };
  var __glob_0_51$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_copyLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var history_group_item = {
    command: "history.group.item",
    description: "History Group Item",
    execute: function(editor2, message = "selection") {
      var _a;
      const currentValues = editor2.context.selection.ids;
      const projectId = (_a = editor2.context.selection.currentProject) == null ? void 0 : _a.id;
      const undoValues = editor2.context.history.selectedIds;
      if (isArrayEquals(currentValues, undoValues)) {
        return;
      }
      editor2.context.history.add(message, this, {
        currentValues: {
          ids: currentValues,
          projectId
        },
        undoValues: {
          ids: undoValues,
          projectId
        }
      });
    },
    redo: function(editor2, { currentValues: [ids, projectId] }) {
    },
    undo: function(editor2, { undoValues: [ids, projectId] }) {
    }
  };
  var __glob_0_52$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_group_item
  }, Symbol.toStringTag, { value: "Module" }));
  var history_moveLayer = {
    command: "history.moveLayer",
    description: "move layer in world ",
    execute: function(editor2, message, layers = [], dist2 = [0, 0, 0]) {
      if (sapa.isArray(layers) === false) {
        layers = [layers];
      }
      const targetItems = editor2.context.selection.itemsByIds(layers);
      const lastValues = {};
      const currentValues = {};
      targetItems.forEach((it) => {
        const oldPosition = it.absoluteMove(dist2);
        const newPosition = it.attrs("x", "y");
        lastValues[it.id] = oldPosition;
        currentValues[it.id] = newPosition;
      });
      editor2.context.commands.emit("setAttribute", currentValues);
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [layers, dist2],
          undoValues: [lastValues]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [layers, dist2] }) {
      const targetItems = editor2.context.selection.itemsByIds(layers);
      const localChanges = {};
      targetItems.forEach((it) => {
        it.absoluteMove(dist2);
        const newPosition = it.attrs("x", "y");
        localChanges[it.id] = newPosition;
      });
      editor2.context.commands.emit("setAttribute", localChanges);
    },
    undo: function(editor2, { undoValues: [lastValues] }) {
      editor2.context.commands.emit("setAttribute", lastValues);
    }
  };
  var __glob_0_53$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_moveLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var history_moveLayerToTarget = {
    command: "history.moveLayerToTarget",
    description: "move layer to target in world ",
    execute: function(editor2, message, layer, target, dist2 = [0, 0, 0], targetAction = TargetActionType.APPEND_CHILD) {
      const currentLayer = editor2.get(layer) || layer;
      const currentParentLayer = currentLayer.parent;
      const currentTarget = editor2.get(target) || editor2.context.selection.currentProject;
      const lastValues = currentLayer.hierachy;
      if (dist2) {
        currentLayer.absoluteMove(dist2);
      }
      let currentValues = {};
      if (targetAction === TargetActionType.APPEND_CHILD) {
        currentTarget.appendChild(currentLayer);
        currentValues = currentTarget.attrsWithId("children");
      } else if (targetAction === TargetActionType.INSERT_BEFORE) {
        currentTarget.insertBefore(currentLayer);
        currentValues = currentTarget.parent.attrsWithId("children");
      } else if (targetAction === TargetActionType.INSERT_AFTER) {
        currentTarget.insertAfter(currentLayer);
        currentValues = currentTarget.parent.attrsWithId("children");
      }
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentValues), currentParentLayer && currentParentLayer.isNot("project") ? currentParentLayer.attrsWithId("children") : {}));
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [currentLayer.hierachy],
          undoValues: [lastValues, currentLayer.parentId]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [info] }) {
      const currentLayer = editor2.get(info.id);
      const currentTarget = editor2.get(info.parentId);
      currentTarget.insertChild(currentLayer, info.index);
      currentLayer.reset(info.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
    },
    undo: function(editor2, { undoValues: [lastValues, currentParentId] }) {
      const currentLayer = lastValues;
      const lastLayer = editor2.get(currentLayer.id);
      const lastParent = editor2.get(currentLayer.parentId);
      const currentParent = editor2.get(currentParentId);
      const lastIndex = currentLayer.index;
      lastParent.insertChild(lastLayer, lastIndex);
      lastLayer.reset(lastValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
    }
  };
  var __glob_0_54$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_moveLayerToTarget
  }, Symbol.toStringTag, { value: "Module" }));
  var history_refreshSelection = {
    command: "history.refreshSelection",
    description: `save selection in history `,
    description_ko: "Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
    execute: function(editor2, message = "selection") {
      var _a;
      const currentValues = editor2.context.selection.ids;
      const projectId = (_a = editor2.context.selection.currentProject) == null ? void 0 : _a.id;
      const undoValues = editor2.context.history.selectedIds;
      if (isArrayEquals(currentValues, undoValues)) {
        return;
      }
      editor2.context.history.add(message, this, {
        currentValues: [currentValues, projectId],
        undoValues: [undoValues, projectId]
      });
      this.nextAction(editor2);
    },
    nextAction(editor2) {
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [ids, projectId] }) {
      editor2.context.selection.selectProject(projectId);
      editor2.context.selection.select(...ids);
      this.nextAction(editor2);
    },
    undo: function(editor2, { undoValues: [ids, projectId] }) {
      editor2.context.selection.selectProject(projectId);
      editor2.context.selection.select(...ids);
      this.nextAction(editor2);
    }
  };
  var __glob_0_55$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_refreshSelection
  }, Symbol.toStringTag, { value: "Module" }));
  var history_refreshSelectionProject = {
    command: "history.refreshSelectionPorject",
    description: `save project selection in history `,
    description_ko: "Project Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
    execute: function(editor2, message = "selection", projectId) {
      var _a;
      const currentValues = [projectId];
      const undoValues = [(_a = editor2.context.selection.currentProject) == null ? void 0 : _a.id];
      if (isArrayEquals(currentValues, undoValues)) {
        return;
      }
      editor2.context.selection.selectProject(projectId);
      editor2.context.history.add(message, this, {
        currentValues,
        undoValues
      });
      this.nextAction(editor2);
    },
    nextAction(editor2) {
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
        editor2.emit("refreshProjectList");
      });
    },
    redo: function(editor2, { currentValues: [projectId] }) {
      editor2.context.selection.selectProject(projectId);
      this.nextAction(editor2);
    },
    undo: function(editor2, { undoValues: [projectId] }) {
      editor2.context.selection.selectProject(projectId);
      this.nextAction(editor2);
    }
  };
  var __glob_0_56 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_refreshSelectionProject
  }, Symbol.toStringTag, { value: "Module" }));
  function filterChildren(items = []) {
    return items.filter((item) => {
      let total = 0;
      item.path.forEach((treeItem) => {
        total += items.filter((it) => it.id === treeItem.id).length ? 1 : 0;
      });
      return total === 1;
    });
  }
  var history_removeLayer = {
    command: "history.removeLayer",
    description: "remove layer",
    execute: function(editor2, message, ids = void 0) {
      let items = editor2.context.selection.itemsByIds(ids || editor2.context.selection.ids);
      items = filterChildren(items);
      const filtedIds = items.map((it) => it.id);
      editor2.context.modelManager.markRemove(filtedIds);
      const parentIds = items.map((it) => it.parentId);
      items.forEach((item) => {
        item.remove();
        editor2.context.selection.removeById(item.id);
      });
      editor2.context.history.add(message, this, {
        currentValues: [filtedIds, parentIds],
        undoValues: filtedIds
      });
      editor2.nextTick(() => {
        editor2.context.selection.removeById(filtedIds);
        parentIds.forEach((parentId) => {
          editor2.context.commands.emit("update", parentId, {
            changedChildren: true
          });
        });
        editor2.emit("refreshAll");
        editor2.emit("removeGuideLine");
        editor2.nextTick(() => {
          editor2.context.history.saveSelection();
        });
      });
    },
    redo: function(editor2, { currentValues }) {
      const ids = currentValues[0];
      let items = editor2.context.selection.itemsByIds(ids || editor2.context.selection.ids);
      items = filterChildren(items);
      editor2.context.modelManager.markRemove(items.map((it) => it.id));
      items.forEach((item) => item.remove());
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    },
    undo: function(editor2, { undoValues: recoverIds }) {
      editor2.context.modelManager.unmarkRemove(recoverIds);
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    }
  };
  var __glob_0_57 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_removeLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var history_removeProject = {
    command: "history.removeProject",
    description: "remove project",
    execute: function(editor2, message, projectId) {
      const index2 = editor2.context.modelManager.markRemoveProject(projectId);
      editor2.context.history.add(message, this, {
        currentValues: [projectId],
        undoValues: [projectId, index2]
      });
      editor2.nextTick(() => {
        editor2.context.selection.selectProject(editor2.context.modelManager.projects[0]);
        editor2.emit("refreshAll");
        editor2.emit("removeGuideLine");
        editor2.nextTick(() => {
          editor2.context.history.saveSelection();
        });
      });
    },
    redo: function(editor2, { currentValues: [projectId] }) {
      editor2.context.modelManager.markRemoveProject(projectId);
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    },
    undo: function(editor2, { undoValues: [projectId, index2] }) {
      editor2.context.modelManager.unmarkRemoveProject(projectId, index2);
      editor2.nextTick(() => {
        editor2.context.selection.selectProject(projectId);
        editor2.emit("refreshAll");
      });
    }
  };
  var __glob_0_58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_removeProject
  }, Symbol.toStringTag, { value: "Module" }));
  var history_send_back = {
    command: "history.send.back",
    description: "send back",
    execute: function(editor2, message, layer = editor2.context.selection.current) {
      const currentLayer = editor2.get(layer);
      const lastValues = currentLayer.hierarchy;
      const oldParentLayer = currentLayer.parent;
      let currentValues = {};
      if (currentLayer.isFirst()) {
        return;
      } else {
        currentLayer.parent.sendBack(currentLayer.id);
        currentValues = currentLayer.hierarchy;
      }
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")));
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [currentValues],
          undoValues: [lastValues]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [newValues] }) {
      const currentLayer = editor2.get(newValues.id);
      const currentTarget = editor2.get(newValues.parentId);
      currentTarget.insertChild(currentLayer, newValues.index);
      currentLayer.reset(newValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
    },
    undo: function(editor2, { undoValues: [lastValues] }) {
      const currentLayer = lastValues;
      const lastLayer = editor2.get(currentLayer.id);
      const lastParent = editor2.get(currentLayer.parentId);
      const lastIndex = currentLayer.index;
      lastParent.insertChild(lastLayer, lastIndex);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle", "parentId")), lastParent.attrsWithId("children")));
    }
  };
  var __glob_0_59 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_send_back
  }, Symbol.toStringTag, { value: "Module" }));
  var history_send_backward = {
    command: "history.send.backward",
    description: "send backward",
    execute: function(editor2, message, layer = editor2.context.selection.current) {
      const currentLayer = editor2.get(layer);
      const lastValues = currentLayer.hierarchy;
      const oldParentLayer = currentLayer.parent;
      let currentValues = {};
      let prevParentLayer = null;
      if (currentLayer.isFirst) {
        prevParentLayer = oldParentLayer.prev;
        if (!prevParentLayer) {
          return;
        }
        prevParentLayer.insertBefore(currentLayer);
        currentValues = currentLayer.hierarchy;
      } else {
        currentLayer.parent.sendBackward(currentLayer.id);
        currentValues = currentLayer.hierarchy;
      }
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentLayer.parent.attrsWithId("children")));
      editor2.nextTick(() => {
        editor2.context.history.add(message, this, {
          currentValues: [currentValues],
          undoValues: [lastValues]
        });
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues: [newValues], undoValues: [lastValues] }) {
      const currentLayer = editor2.get(newValues.id);
      const currentTarget = editor2.get(newValues.parentId);
      const lastParent = editor2.get(lastValues.parentId);
      currentTarget.insertChild(currentLayer, newValues.index);
      currentLayer.reset(newValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
    },
    undo: function(editor2, { currentValues: [newValues], undoValues: [lastValues] }) {
      const currentLayer = lastValues;
      const lastLayer = editor2.get(currentLayer.id);
      const lastParent = editor2.get(currentLayer.parentId);
      const currentParent = editor2.get(newValues.parentId);
      const lastIndex = currentLayer.index;
      lastParent.insertChild(lastLayer, lastIndex);
      lastLayer.reset(lastValues.attrs);
      editor2.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
    }
  };
  var __glob_0_60 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_send_backward
  }, Symbol.toStringTag, { value: "Module" }));
  var history_setAttribute = {
    command: "history.setAttribute",
    execute: function(editor2, message, multiAttrs = {}, context = { origin: "*" }) {
      editor2.context.commands.emit("setAttribute", multiAttrs, context);
      editor2.context.history.add(message, this, {
        currentValues: [multiAttrs],
        undoValues: editor2.context.history.getUndoValues(multiAttrs)
      });
      editor2.nextTick(() => {
        editor2.context.history.saveSelection();
      });
    },
    redo: function(editor2, { currentValues }) {
      editor2.context.commands.emit("setAttribute", ...currentValues);
      editor2.nextTick(() => {
        editor2.context.selection.reselect();
        editor2.emit("refreshAll");
      });
    },
    undo: function(editor2, { undoValues }) {
      const ids = Object.keys(undoValues);
      const items = editor2.context.selection.itemsByIds(ids);
      items.forEach((item) => {
        item.reset(undoValues[item.id]);
      });
      editor2.context.selection.reselect();
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    }
  };
  var __glob_0_61 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_setAttribute
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_down$1 = {
    command: "item.move.depth.down",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      if (current) {
        current.orderPrev();
      }
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_62 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_down$1
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_first = {
    command: "item.move.depth.first",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      if (current) {
        current.orderFirst();
      }
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_63 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_first
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_last = {
    command: "item.move.depth.last",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      if (current) {
        current.orderLast();
      }
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_64 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_last
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_up$1 = {
    command: "item.move.depth.up",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      if (current) {
        current.orderNext();
      }
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_65 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_up$1
  }, Symbol.toStringTag, { value: "Module" }));
  var lastTimelineItem = {
    command: "lastTimelineItem",
    execute: function(editor2) {
      _currentProject(editor2, (project2, timeline) => {
        var lastTime = project2.getSelectedTimelineLastTime();
        project2.setTimelineCurrentTime(timecode(timeline.fps, lastTime));
        project2.seek();
        editor2.emit("playTimeline");
      });
    }
  };
  var __glob_0_66 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": lastTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var load_json = {
    command: "load.json",
    execute: function(editor2, json, context = { origin: "*" }) {
      editor2.context.modelManager.load(json, context);
      _doForceRefreshSelection(editor2);
    }
  };
  var __glob_0_67 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": load_json
  }, Symbol.toStringTag, { value: "Module" }));
  var moveLayer = {
    command: "moveLayer",
    description: "move layer by keydown with matrix ",
    execute: function(editor2, dx = 0, dy = 0) {
      const absoluteDist = [dx, dy, 0];
      editor2.context.selection.items.forEach((it) => {
        it.absoluteMove(absoluteDist);
      });
      editor2.context.commands.executeCommand("setAttribute", "item move down", editor2.context.selection.pack("x", "y"));
      editor2.nextTick(() => {
        editor2.context.selection.reselect();
      });
    }
  };
  var __glob_0_68 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": moveLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var moveLayerForItems = {
    command: "moveLayerForItems",
    description: "mova layer by multi items ",
    execute: function(editor2, moveItems = []) {
      const itemsMap = {};
      moveItems.forEach((it) => {
        it.item.absoluteMove(it.dist);
        itemsMap[it.item.id] = it.item.attrs("x", "y");
      });
      editor2.context.commands.emit("history.setAttribute", "item move", itemsMap);
      editor2.nextTick(() => {
        editor2.context.selection.reselect();
      });
    }
  };
  var __glob_0_69 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": moveLayerForItems
  }, Symbol.toStringTag, { value: "Module" }));
  var moveSelectionToCenter = {
    command: "moveSelectionToCenter",
    description: "Move selection project or artboards to center on Viewport",
    execute: function(editor2, withScale = true) {
      var _a, _b, _c, _d, _e;
      let areaVerties = [];
      if ((_a = editor2.context.selection) == null ? void 0 : _a.isEmpty) {
        if (((_c = (_b = editor2.context.selection) == null ? void 0 : _b.currentProject) == null ? void 0 : _c.layers.length) > 0) {
          areaVerties = itemsToRectVerties((_d = editor2.context.selection) == null ? void 0 : _d.currentProject.layers);
        } else {
          areaVerties = rectToVerties(0, 0, 100, 100);
        }
      } else {
        areaVerties = itemsToRectVerties((_e = editor2.context.selection) == null ? void 0 : _e.items);
      }
      editor2.context.commands.emit("moveToCenter", areaVerties, withScale);
    }
  };
  var __glob_0_70 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": moveSelectionToCenter
  }, Symbol.toStringTag, { value: "Module" }));
  function newComponent(editor2, itemType, obj2, isSelected = true, containerItem = void 0) {
    if (itemType === "svg-textpath") {
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        fontSize: obj2.height,
        textLength: "100%",
        d: PathParser.makeLine(0, obj2.height, obj2.width, obj2.height).d
      });
    } else if (itemType === "svg-circle") {
      itemType = "svg-path";
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        backgroundColor: void 0,
        fill: `#C4C4C4`,
        d: PathParser.makeCircle(0, 0, obj2.width, obj2.height).d
      });
    } else if (itemType === "svg-rect") {
      itemType = "svg-path";
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        backgroundColor: void 0,
        fill: `#C4C4C4`,
        d: PathParser.makeRect(0, 0, obj2.width, obj2.height).d
      });
    } else if (itemType === "text") {
      obj2 = __spreadValues({
        width: 300,
        height: 50
      }, obj2);
    } else if (itemType === "artboard") {
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        backgroundColor: "white"
      });
    }
    const newObjAttrs = __spreadValues({ itemType }, obj2);
    const item = editor2.context.modelManager.createModel(newObjAttrs);
    editor2.context.commands.executeCommand("moveLayerToTarget", `add layer - ${itemType}`, item, containerItem);
    editor2.nextTick(() => {
      editor2.emit("appendLayer", item);
      if (isSelected) {
        editor2.context.selection.select(item);
      }
    });
  }
  var __glob_0_71 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": newComponent
  }, Symbol.toStringTag, { value: "Module" }));
  var nextTimelineItem = {
    command: "nextTimelineItem",
    execute: function(editor2) {
      _currentProject(editor2, (project2, timeline) => {
        var nextTime = project2.getSelectedTimelineNextTime();
        project2.setTimelineCurrentTime(timecode(timeline.fps, nextTime));
        project2.seek();
        editor2.emit("playTimeline");
      });
    }
  };
  var __glob_0_72 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": nextTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var open_editor = {
    command: "open.editor",
    description: "Open custom editor for item  when doubleclick is fired",
    execute: function(editor2, current) {
      if (!current && editor2.context.selection.isOne === false)
        return;
      current = current || editor2.context.selection.current;
      if (current) {
        if (current.editablePath) {
          editor2.emit("showPathEditor", "modify", {
            box: "canvas",
            current,
            matrix: current.matrix,
            isControl: true,
            disableCurve: true,
            d: current.editablePath,
            changeEvent: (data) => {
              editor2.context.commands.executeCommand("setAttribute", "change editable path", editor2.context.selection.packByValue(__spreadValues({}, current.recoverEditablePath(data.d)), [current.id]));
              editor2.nextTick(() => {
                if (editor2.context.stateManager.isPointerUp) {
                  editor2.context.commands.emit("recoverBooleanPath");
                }
              });
            }
          });
          editor2.emit("hideSelectionToolView");
        } else if (current.d) {
          editor2.emit("showPathEditor", "modify", {
            box: "canvas",
            current,
            matrix: current.matrix,
            d: current.absolutePath().d,
            changeEvent: (data) => {
              const newCurrent = editor2.context.selection.current;
              if (newCurrent.isSVG() && newCurrent.isNot("svg-path")) {
                const newPathData = newCurrent.toSVGPath();
                const newPath = editor2.context.modelManager.createModel(__spreadValues({
                  itemType: "svg-path"
                }, newPathData));
                editor2.context.selection.select(newPath);
                newCurrent.insertAfter(newPath);
                editor2.nextTick(() => {
                  editor2.context.commands.emit("removeLayer", [newCurrent.id]);
                  editor2.context.commands.emit("updatePathItem", data);
                });
              } else {
                editor2.context.commands.emit("updatePathItem", data);
                editor2.nextTick(() => {
                  if (editor2.context.stateManager.isPointerUp) {
                    editor2.context.commands.emit("recoverBooleanPath");
                  }
                });
              }
            }
          });
          editor2.emit("hideSelectionToolView");
        } else if (current.clipPath) {
          var obj2 = ClipPath.parseStyle(current.clipPath);
          if (obj2.type === "path") {
            var d = current.absolutePath(current.clipPathString).d;
            var mode = d ? "modify" : "path";
            editor2.emit("showPathEditor", mode, {
              changeEvent: (data) => {
                const resultPath = current.invertPath(data.d).d;
                editor2.context.commands.executeCommand("setAttribute", "change clip-path", editor2.context.selection.packByValue({
                  clipPath: `path(${resultPath})`
                }));
              },
              current,
              d
            });
            editor2.emit("hideSelectionToolView");
          } else if (obj2.type === "svg")
            ;
          else {
            editor2.emit("showClippathEditorView");
          }
        } else
          ;
      }
    }
  };
  var __glob_0_73 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": open_editor
  }, Symbol.toStringTag, { value: "Module" }));
  var pauseTimelineItem = {
    command: "pauseTimelineItem",
    execute: function(editor2) {
      if (editor2.timer) {
        editor2.timer.stop();
      }
    }
  };
  var __glob_0_74 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": pauseTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var playTimelineItem = {
    command: "playTimelineItem",
    description: "Play button action",
    execute: function(editor2, speed = 1, iterationCount = 1, direction = "normal") {
      editor2.context.selection.empty();
      _currentProject(editor2, (project2, timeline) => {
        var lastTime = project2.getSelectedTimelineLastTime();
        if (editor2.timer) {
          editor2.timer.stop();
        } else {
          editor2.timer = makeTimer({
            elapsed: timeline.currentTime * 1e3,
            speed,
            duration: lastTime * 1e3,
            iterationCount,
            direction
          });
        }
        editor2.timer.play({
          duration: lastTime * 1e3,
          elapsed: timeline.currentTime * 1e3,
          speed,
          iterationCount,
          direction,
          tick: (elapsed) => {
            project2.seek(timecode(timeline.fps, elapsed / 1e3));
            editor2.emit("playTimeline");
          },
          last: (elapsed) => {
            project2.seek(timecode(timeline.fps, elapsed / 1e3));
            editor2.emit("playTimeline");
            editor2.nextTick(() => {
              editor2.emit("stopTimeline");
            });
          },
          stop: (elapsed) => {
            project2.stop(timecode(timeline.fps, elapsed / 1e3));
            editor2.emit("stopTimeline");
          }
        });
      });
    }
  };
  var __glob_0_75 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": playTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var prevTimelineItem = {
    command: "prevTimelineItem",
    execute: function(editor2) {
      _currentProject(editor2, (project2, timeline) => {
        var prevTime = project2.getSelectedTimelinePrevTime();
        project2.setTimelineCurrentTime(timecode(timeline.fps, prevTime));
        project2.seek();
        editor2.emit("playTimeline");
      });
    }
  };
  var __glob_0_76 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": prevTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var recoverBooleanPath = {
    command: "recoverBooleanPath",
    description: "recover box rectangle for boolean path result",
    execute: function(editor2) {
      const current = editor2.context.selection.current;
      let booleanContainer;
      if (current && current.isBooleanItem) {
        booleanContainer = current.parent;
      } else if (current && current.is("boolean-path")) {
        booleanContainer = current;
      }
      if (booleanContainer) {
        const isBooleanItem = typeof current.isBooleanItem === "boolean" && current.isBooleanItem;
        const booleanPath = booleanContainer.d;
        if (!booleanPath) {
          return;
        }
        const layersCache = booleanContainer.layers.map((it) => {
          return {
            item: it,
            matrix: it.matrix
          };
        });
        const newBooleanContainerRect = booleanContainer.updatePath(booleanPath);
        delete newBooleanContainerRect.d;
        booleanContainer.reset(newBooleanContainerRect);
        layersCache.forEach((it) => {
          booleanContainer.resetMatrix(it.item);
        });
        const ids = [...layersCache.map((it) => it.item.id), booleanContainer.id];
        const data = editor2.context.selection.packByIds(ids, "x", "y", "width", "height");
        editor2.context.commands.executeCommand("setAttribute", "fit boolean path", data, {
          origin: "*",
          doNotChildrenScale: isBooleanItem
        });
      }
    }
  };
  var __glob_0_77 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": recoverBooleanPath
  }, Symbol.toStringTag, { value: "Module" }));
  var refreshArtboard = {
    command: "refreshArtboard",
    execute: function(editor2) {
      const command = editor2.createCommandMaker();
      command.emit("refreshLayerTreeView");
      command.emit("refreshAllCanvas");
      command.emit(UPDATE_CANVAS);
      command.emit("refreshAllElementBoundSize");
      command.emit(REFRESH_SELECTION);
      command.run();
    }
  };
  var __glob_0_78 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": refreshArtboard
  }, Symbol.toStringTag, { value: "Module" }));
  function makeEmitList(maker, current) {
    var _a;
    if (current.hasLayout()) {
      maker.emit("refreshElementBoundSize", current);
    } else {
      if (current && (current.isLayoutItem() || ((_a = current.parent) == null ? void 0 : _a.is("boolean-path")))) {
        maker.emit("refreshElementBoundSize", current.parent);
      } else {
        maker.emit("refreshElementBoundSize", current);
      }
    }
  }
  var refreshElement = {
    command: "refreshElement",
    execute: function(editor2, current, checkRefreshCanvas = true) {
      const maker = editor2.createCommandMaker();
      if (sapa.isArray(current)) {
        if (checkRefreshCanvas) {
          maker.emit("refreshAllCanvas");
        }
        maker.emit(UPDATE_CANVAS, current);
        current.forEach((item) => {
          makeEmitList(maker, item);
        });
      } else {
        if (checkRefreshCanvas) {
          if (current && current.hasChangedField("children", "changedChildren", "parentId")) {
            maker.emit("refreshAllCanvas");
          }
        }
        maker.emit(UPDATE_CANVAS, current);
        makeEmitList(maker, current);
      }
      maker.run();
    }
  };
  var __glob_0_79 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": refreshElement
  }, Symbol.toStringTag, { value: "Module" }));
  function refreshHistory(editor2) {
    editor2.context.commands.emit("saveJSON");
  }
  var __glob_0_80 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": refreshHistory
  }, Symbol.toStringTag, { value: "Module" }));
  var refreshSelectedOffset = {
    command: "refreshSelectedOffset",
    execute: function(editor2) {
      var offset = editor2.timeline.items[0];
      if (offset) {
        editor2.emit("refreshOffsetValue", offset);
      }
    }
  };
  var __glob_0_81 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": refreshSelectedOffset
  }, Symbol.toStringTag, { value: "Module" }));
  var removeAnimationItem = {
    command: "removeAnimationItem",
    execute: function(editor2, id) {
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.removeAnimationItem(id);
        editor2.timeline.empty();
        editor2.emit("refreshTimeline");
        editor2.emit("removeAnimation");
      }
    }
  };
  var __glob_0_82 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeAnimationItem
  }, Symbol.toStringTag, { value: "Module" }));
  var removeLayer$1 = {
    command: "removeLayer",
    execute: function(editor2, ids = void 0) {
      const currentIds = ids || editor2.context.selection.ids;
      const removedIds = [];
      editor2.context.selection.itemsByIds(currentIds).forEach((item) => {
        removedIds.push(item.id);
        item.remove();
      });
      editor2.context.selection.removeById(removedIds);
      editor2.nextTick(() => {
        editor2.emit("refreshAll");
      });
    }
  };
  var __glob_0_83 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeLayer$1
  }, Symbol.toStringTag, { value: "Module" }));
  var removeTimeline = {
    command: "removeTimeline",
    execute: function(editor2, layerId) {
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.removeTimeline(layerId);
        editor2.timeline.empty();
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      }
    }
  };
  var __glob_0_84 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeTimeline
  }, Symbol.toStringTag, { value: "Module" }));
  var removeTimelineProperty = {
    command: "removeTimelineProperty",
    execute: function(editor2, layerId, property) {
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.removeTimelineProperty(layerId, property);
        editor2.timeline.empty();
        editor2.emit("refreshTimeline");
        editor2.emit("refreshSelectedOffset");
      }
    }
  };
  var __glob_0_85 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeTimelineProperty
  }, Symbol.toStringTag, { value: "Module" }));
  function resizeArtBoard(editor2, size = "") {
    var current = editor2.context.selection.current;
    if (current && current.is("artboard")) {
      if (!size.trim())
        return;
      var [width2, height] = size.split("x");
      width2 = +width2;
      height = +height;
      current.resize(width2, height);
      editor2.context.selection.select(current);
      _doForceRefreshSelection(editor2);
    }
  }
  var __glob_0_86 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": resizeArtBoard
  }, Symbol.toStringTag, { value: "Module" }));
  var rotateLayer = {
    command: "rotateLayer",
    description: "rotate layer by keydown with matrix ",
    execute: function(editor2, distAngle = 0) {
      editor2.context.commands.executeCommand("setAttribute", "change rotate", editor2.context.selection.packByValue({
        angle: editor2.context.selection.current.angle + distAngle
      }));
    }
  };
  var __glob_0_87 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": rotateLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var same_height = {
    command: "same.height",
    description: "fit at the same height",
    execute: function(editor2) {
      var len2 = editor2.context.selection.length;
      if (len2 == 1)
        ;
      else if (len2 > 1) {
        const rect2 = vertiesToRectangle(editor2.context.selection.verties);
        editor2.context.commands.executeCommand("setAttribute", "fit at the same height", editor2.context.selection.packByValue({
          y: rect2.y,
          height: rect2.height
        }));
      }
    }
  };
  var __glob_0_88 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": same_height
  }, Symbol.toStringTag, { value: "Module" }));
  var same_width = {
    command: "same.width",
    description: "fit at the same width",
    execute: function(editor2) {
      if (editor2.context.selection.isMany) {
        const rect2 = vertiesToRectangle(editor2.context.selection.verties);
        editor2.context.commands.executeCommand("setAttribute", "fit at the same width", editor2.context.selection.packByValue({
          x: rect2.x,
          width: rect2.width
        }));
      }
    }
  };
  var __glob_0_89 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": same_width
  }, Symbol.toStringTag, { value: "Module" }));
  var saveJSON = {
    command: "saveJSON",
    execute: function(editor2) {
      editor2.saveItem("model", editor2.context.modelManager.toJSON());
    }
  };
  var __glob_0_90 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": saveJSON
  }, Symbol.toStringTag, { value: "Module" }));
  var savePNG = {
    command: "savePNG",
    execute: function(editor2, callbackCommand = "") {
      const item = editor2.context.selection.current;
      if (item) {
        const svgString = ExportManager.generateSVG(editor2, item).trim();
        const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
        loadOriginalImage({ local: datauri }, (info, img) => {
          createImagePng(img, (pngDataUri) => {
            if (callbackCommand) {
              editor2.emit(callbackCommand, pngDataUri);
            }
          });
        });
      }
    }
  };
  var __glob_0_91 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": savePNG
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_delete$1 = {
    command: "segment.delete",
    execute: function(editor2) {
      editor2.emit("deleteSegment");
    }
  };
  var __glob_0_92 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_delete$1
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_down = {
    command: "segment.move.down",
    execute: function(editor2, obj2 = { dy: 1 }) {
      const dy = +obj2.dy;
      editor2.emit("moveSegment", 0, dy);
    }
  };
  var __glob_0_93 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_down
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_left = {
    command: "segment.move.left",
    execute: function(editor2, obj2 = { dx: 1 }) {
      const dx = +obj2.dx;
      editor2.emit("moveSegment", -1 * dx, 0);
    }
  };
  var __glob_0_94 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_left
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_right = {
    command: "segment.move.right",
    execute: function(editor2, obj2 = { dx: 1 }) {
      const dx = +obj2.dx;
      editor2.emit("moveSegment", dx, 0);
    }
  };
  var __glob_0_95 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_right
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_up = {
    command: "segment.move.up",
    execute: function(editor2, obj2 = { dy: 1 }) {
      const dy = +obj2.dy;
      editor2.emit("moveSegment", 0, -1 * dy);
    }
  };
  var __glob_0_96 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_up
  }, Symbol.toStringTag, { value: "Module" }));
  var select_all$1 = {
    command: "select.all",
    execute: function(editor2) {
      var project2 = editor2.context.selection.currentProject;
      if (project2) {
        editor2.context.selection.select(...project2.layers);
        editor2.context.commands.emit("history.refreshSelection");
      }
    }
  };
  var __glob_0_97 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": select_all$1
  }, Symbol.toStringTag, { value: "Module" }));
  var select_none = {
    command: "select.none",
    execute: function(editor2) {
      editor2.context.selection.empty();
      editor2.context.commands.emit("history.refreshSelection");
    }
  };
  var __glob_0_98 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": select_none
  }, Symbol.toStringTag, { value: "Module" }));
  var selectTimelineItem = {
    command: "selectTimelineItem",
    execute: function(editor2, selectedId) {
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.selectTimeline(selectedId);
        editor2.emit("refreshTimeline");
        editor2.emit("selectTimeline");
      }
    }
  };
  var __glob_0_99 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": selectTimelineItem
  }, Symbol.toStringTag, { value: "Module" }));
  var setAttribute = {
    command: "setAttribute",
    execute: function(editor2, multiAttrs = {}, context = { origin: "*" }) {
      const messages = [];
      Object.entries(multiAttrs).forEach(([id, attrs]) => {
        const item = editor2.get(id);
        const newAttrs = {};
        Object.entries(attrs).forEach(([key, value]) => {
          newAttrs[key] = sapa.isFunction(value) ? value(item) : value;
        });
        messages.push({ id: item.id, parentId: item.parentId, attrs: newAttrs });
      });
      if (messages.length == 0) {
        return;
      }
      let hasRefreshCanvas = false;
      const children = [];
      messages.forEach((message) => {
        const item = editor2.get(message.id);
        if (item) {
          item.reset(message.attrs, context);
          if (item.hasChangedField("layout")) {
            item.layers.forEach((child) => {
              if (child.isLayout(Layout.DEFAULT))
                ;
              else if (child.isLayout(Layout.FLEX))
                ;
              else if (child.isLayout(Layout.GRID))
                ;
              editor2.context.commands.emit("refreshElement", child);
            });
          }
          children.push(item);
          if (item.hasChangedHirachy) {
            hasRefreshCanvas = true;
          }
        }
        if (item.is("project")) {
          return;
        }
        if (item.parent && item.parent.is("project")) {
          return;
        }
        if (item.isLayoutItem() || item.isBooleanItem) {
          const parent = editor2.get(message.parentId);
          if (message.parentId && (parent == null ? void 0 : parent.isNot("project"))) {
            parent.reset({ changedChildren: true }, context);
            hasRefreshCanvas = true;
          }
        }
      });
      if (children.length) {
        editor2.context.commands.emit("refreshElement", children, false);
      }
      if (hasRefreshCanvas) {
        editor2.emit("refreshAllCanvas");
      }
    }
  };
  var __glob_0_100 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": setAttribute
  }, Symbol.toStringTag, { value: "Module" }));
  var setTimelineOffset = {
    command: "setTimelineOffset",
    debounce: 100,
    execute: function(editor2, obj2) {
      const project2 = editor2.context.selection.currentProject;
      if (project2) {
        project2.setTimelineKeyframeOffsetValue(obj2.layerId, obj2.property, obj2.id, obj2.value, obj2.timing, obj2.time);
        editor2.emit("refreshTimeline");
      }
    }
  };
  var __glob_0_101 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": setTimelineOffset
  }, Symbol.toStringTag, { value: "Module" }));
  var showExportView = {
    command: "showExportView",
    execute: function(editor2) {
      editor2.emit("showExportWindow");
    }
  };
  var __glob_0_102 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": showExportView
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_bottom = {
    command: "sort.bottom",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else {
          const parent = current.parent;
          const distY = getVertiesMaxY(parent.verties) - getVertiesMaxY(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", 0, distY);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightY = getVertiesMaxY(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightY = getVertiesMaxY(item.verties);
          return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_103 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_bottom
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_center = {
    command: "sort.center",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else if (current.artboard) {
          const distX = getVertiesCenterX(current.artboard.verties) - getVertiesCenterX(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", distX, 0);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightX = getVertiesCenterX(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightX = getVertiesCenterX(item.verties);
          return { item, dist: [maxRightX - itemRightX, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_104 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_center
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_left = {
    command: "sort.left",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else {
          const parent = current.parent;
          const distX = getVertiesMinX(parent.verties) - getVertiesMinX(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", distX, 0);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightX = getVertiesMinX(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightX = getVertiesMinX(item.verties);
          return { item, dist: [maxRightX - itemRightX, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_105 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_left
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_middle = {
    command: "sort.middle",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else if (current.artboard) {
          const distY = getVertiesCenterY(current.artboard.verties) - getVertiesCenterY(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", 0, distY);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightY = getVertiesCenterY(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightY = getVertiesCenterY(item.verties);
          return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_106 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_middle
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_right = {
    command: "sort.right",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else {
          const parent = current.parent;
          const distX = getVertiesMaxX(parent.verties) - getVertiesMaxX(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", distX, 0);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightX = getVertiesMaxX(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightX = getVertiesMaxX(item.verties);
          return { item, dist: [maxRightX - itemRightX, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_107 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_right
  }, Symbol.toStringTag, { value: "Module" }));
  var sort_top = {
    command: "sort.top",
    execute: function(editor2) {
      if (editor2.context.selection.isOne) {
        const current = editor2.context.selection.current;
        if (current.parent.is("project"))
          ;
        else {
          const parent = current.parent;
          const distY = getVertiesMinY(parent.verties) - getVertiesMinY(editor2.context.selection.verties);
          editor2.context.commands.emit("moveLayer", 0, distY);
        }
      } else if (editor2.context.selection.isMany) {
        let maxRightY = getVertiesMinY(editor2.context.selection.verties);
        editor2.context.commands.emit("moveLayerForItems", editor2.context.selection.map((item) => {
          let itemRightY = getVertiesMinY(item.verties);
          return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
        }));
      }
    }
  };
  var __glob_0_108 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": sort_top
  }, Symbol.toStringTag, { value: "Module" }));
  var switch_path = {
    command: "switch.path",
    execute: async (editor2) => {
      const current = editor2.context.selection.current;
      if (!current)
        return;
      if (current.is("boolean-path") || current.isBooleanItem) {
        let parent = current;
        if (current.isBooleanItem) {
          parent = current.parent;
        }
        editor2.context.selection.select(parent);
        editor2.context.commands.executeCommand("setAttribute", "change boolean operation", editor2.context.selection.packByValue({
          booleanOperation: parent["boolean-operation"],
          children: parent.children.reverse()
        }));
        editor2.nextTick(() => {
          editor2.context.commands.emit("recoverBooleanPath");
          editor2.context.selection.select(current);
        });
      }
    }
  };
  var __glob_0_109 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": switch_path
  }, Symbol.toStringTag, { value: "Module" }));
  var ungroup_item$1 = {
    command: "ungroup.item",
    execute: function(editor2) {
      if (editor2.context.selection.length === 0)
        return;
      const current = editor2.context.selection.current;
      if (current) {
        let groupLayer = current;
        let layers = [...groupLayer.layers];
        layers.reverse();
        layers.forEach((child) => {
          groupLayer.insertBefore(child);
        });
        editor2.context.selection.select(...layers);
        editor2.emit("refreshAll");
      }
    }
  };
  var __glob_0_110 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": ungroup_item$1
  }, Symbol.toStringTag, { value: "Module" }));
  var updateClipPath = {
    command: "updateClipPath",
    description: "update clip-path property ",
    execute: function(editor2, pathObject) {
      editor2.context.commands.executeCommand("setAttribute", "change clip-path", editor2.context.selection.packByValue({
        clipPath: `path(${pathObject.d})`
      }));
    }
  };
  var __glob_0_111 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateClipPath
  }, Symbol.toStringTag, { value: "Module" }));
  var updateImage = {
    command: "updateImage",
    execute: function(editor2, imageFileOrBlob, rect2, containerItem) {
      var reader = new window.FileReader();
      reader.onload = (e) => {
        var datauri = e.target.result;
        var local = window.URL.createObjectURL(imageFileOrBlob);
        editor2.context.commands.emit("addImageAssetItem", {
          id: uuidShort(),
          type: imageFileOrBlob.type,
          name: imageFileOrBlob.name,
          original: datauri,
          local
        }, rect2, containerItem);
      };
      reader.readAsDataURL(imageFileOrBlob);
    }
  };
  var __glob_0_112 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateImage
  }, Symbol.toStringTag, { value: "Module" }));
  var updateImageAssetItem = {
    command: "updateImageAssetItem",
    execute: function(editor2, item, callback) {
      var reader = new window.FileReader();
      reader.onload = (e) => {
        var datauri = e.target.result;
        var local = window.URL.createObjectURL(item);
        var project2 = editor2.context.selection.currentProject;
        if (project2) {
          const image2 = project2.createImage({
            id: uuidShort(),
            type: item.type,
            name: item.name,
            original: datauri,
            local
          });
          editor2.context.commands.emit("addImageAsset");
          sapa.isFunction(callback) && callback(image2.id);
        }
      };
      reader.readAsDataURL(item);
    }
  };
  var __glob_0_113 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateImageAssetItem
  }, Symbol.toStringTag, { value: "Module" }));
  const MAX_CACHE_COUNT = 1e3;
  const cachedTransformMap = /* @__PURE__ */ new Map();
  class TransformCache {
    static has(key) {
      return cachedTransformMap.has(key);
    }
    static get(key) {
      return cachedTransformMap.get(key);
    }
    static set(key, parsedValue) {
      if (cachedTransformMap.size > MAX_CACHE_COUNT) {
        cachedTransformMap.clear();
      }
      cachedTransformMap.set(key, parsedValue);
    }
  }
  const TRANSFORM_REG = /((matrix|translate(X|Y|Z|3d)?|scale(X|Y|Z|3d)?|rotate(X|Y|Z|3d)?|skew(X|Y)?|matrix(3d)?|perspective)\(([^)]*)\))/gi;
  class Transform extends PropertyItem {
    getDefaultObject() {
      return {
        itemType: "transform",
        value: []
      };
    }
    toCloneObject() {
      return __spreadValues({}, this.attrs("itemType", "type", "value"));
    }
    toString() {
      return `${this.json.type}(${this.json.value.join(", ") || ""})`;
    }
    static join(list) {
      var firstType = "perspective";
      var lastType = "matrix3d";
      var arr = list.filter((it) => it.type === firstType);
      var last = list.filter((it) => it.type === lastType);
      var arr2 = list.filter((it) => it.type !== firstType && it.type !== lastType);
      return [...arr, ...arr2, ...last].map((it) => new Transform(it).toString()).join(" ");
    }
    hasNumberValue() {
      var type = this.json.type;
      return type.includes("matrix") || type.includes("scale");
    }
    static parse(transform2) {
      return new Transform(transform2);
    }
    static remove(transform2, type = []) {
      if (typeof type === "string") {
        type = [type];
      }
      return Transform.filter(transform2, (it) => {
        return type.includes(it.type) === false;
      });
    }
    static filter(transform2, filterFunction) {
      return Transform.join(Transform.parseStyle(transform2, false).filter((it) => filterFunction(it)));
    }
    static replace(transform2, valueObject) {
      var obj2 = Transform.parseStyle(transform2, false);
      var tObject = obj2.find((t) => t.type === valueObject.type);
      if (tObject) {
        tObject.value = valueObject.value;
      } else {
        obj2.push(valueObject);
      }
      return Transform.join(obj2);
    }
    static replaceAll(oldTransform, newTransform) {
      var oldT = Transform.parseStyle(oldTransform, false);
      var newT = Transform.parseStyle(newTransform);
      for (var i = 0, len2 = newT.length; i < len2; i++) {
        var newObject = newT[i];
        var oldObject = oldT.find((t) => t.type === newObject.type);
        if (oldObject) {
          oldObject.value = newObject.value;
        } else {
          oldT.push(newObject);
        }
      }
      return Transform.join(oldT);
    }
    static addTransform(oldTransform, newTransform) {
      var oldT = Transform.parseStyle(oldTransform, false);
      var newT = Transform.parseStyle(newTransform);
      for (var i = 0, len2 = newT.length; i < len2; i++) {
        var newObject = newT[i];
        var oldObject = oldT.find((t) => t.type === newObject.type);
        if (oldObject) {
          newObject.value.forEach((v, i2) => {
            oldObject.value[i2].value += v.value;
          });
        } else {
          oldT.push(newObject);
        }
      }
      return Transform.join(oldT);
    }
    static get(transform2, type) {
      var arr = Transform.parseStyle(transform2, true);
      if (typeof type === "function") {
        arr = arr.find(type);
      } else {
        arr = arr.find((it) => it.type === type);
      }
      if (arr) {
        return arr.value;
      }
      return void 0;
    }
    static createRotateKey(transform2, angle, field) {
      return `${transform2}:::${field}(${angle})`;
    }
    static rotate(transform2, angle, field = "rotate") {
      const key = Transform.createRotateKey(transform2, angle, field);
      if (TransformCache.has(key))
        return TransformCache.get(key);
      TransformCache.set(key, Transform.replace(transform2, { type: field, value: [angle] }));
      return TransformCache.get(key);
    }
    static rotateZ(transform2, angle) {
      return Transform.rotate(transform2, angle, "rotateZ");
    }
    static rotateX(transform2, angle) {
      return Transform.rotate(transform2, angle, "rotateX");
    }
    static rotateY(transform2, angle) {
      return Transform.rotate(transform2, angle, "rotateY");
    }
    static parseStyle(transform2, doCache = true) {
      var transforms = [];
      if (!transform2)
        return transforms;
      if (doCache && TransformCache.has(transform2)) {
        return TransformCache.get(transform2);
      }
      var matches = transform2.match(TRANSFORM_REG) || [];
      matches.forEach((value, index2) => {
        var [transformName, transformValue] = value.split("(");
        transformValue = transformValue.split(")")[0];
        var arr = transformValue.split(",");
        if (transformValue.includes("matrix") || transformValue.includes("scale")) {
          arr = arr.map((it) => editor.Length.number(it.trim()));
        } else {
          arr = arr.map((it) => editor.Length.parse(it.trim()));
        }
        transforms[index2] = Transform.parse({
          type: transformName,
          value: arr
        });
      });
      if (doCache) {
        TransformCache.set(transform2, transforms);
      }
      return transforms;
    }
    static createTransformMatrix(parsedTransformList, width2, height) {
      const view = create$4();
      for (let i = 0, len2 = parsedTransformList.length; i < len2; i++) {
        const it = parsedTransformList[i];
        switch (it.type) {
          case "translate":
          case "translateX":
          case "translateY":
          case "translateZ":
            var values = it.value;
            if (it.type === "translate") {
              values = [
                values[0].toPx(width2).value,
                values[1].toPx(height).value,
                0
              ];
            } else if (it.type === "translateX") {
              values = [values[0].toPx(width2).value, 0, 0];
            } else if (it.type === "translateY") {
              values = [0, values[0].toPx(height).value, 0];
            } else if (it.type === "translateZ") {
              values = [0, 0, values[0].toPx().value];
            }
            translate(view, view, values);
            break;
          case "rotate":
          case "rotateZ":
            rotateZ(view, view, degreeToRadian(it.value[0].value));
            break;
          case "rotateX":
            rotateX(view, view, degreeToRadian(it.value[0].value));
            break;
          case "rotateY":
            rotateY(view, view, degreeToRadian(it.value[0].value));
            break;
          case "rotate3d":
            var values = it.value;
            rotate(view, view, degreeToRadian(it.value[3].value), [
              values[0].value,
              values[1].value,
              values[2].value
            ]);
            break;
          case "scale":
            scale(view, view, [it.value[0].value, it.value[1].value, 1]);
            break;
          case "scaleX":
            scale(view, view, [it.value[0].value, 1, 1]);
            break;
          case "scaleY":
            scale(view, view, [1, it.value[0].value, 1]);
            break;
          case "scaleZ":
            scale(view, view, [1, 1, it.value[0].value]);
            break;
          case "skewX":
            var rad = it.value[0].toDeg().toRad();
            multiply$1(view, view, fromValues$1(1, 0, 0, 0, Math.tan(rad.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
            break;
          case "skewY":
            var rad = it.value[0].toDeg().toRad();
            multiply$1(view, view, fromValues$1(1, Math.tan(rad.value), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
            break;
          case "skew":
            const skewX = it.value[0].toDeg().toRad();
            const skewY = it.value.length > 1 ? it.value[1].toDeg().toRad() : skewX;
            multiply$1(view, view, fromValues$1(1, Math.tan(skewY.value), 0, 0, Math.tan(skewX.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
            break;
          case "matrix":
            var values = it.value;
            values = [
              values[0].value,
              values[1].value,
              0,
              0,
              values[2].value,
              values[3].value,
              0,
              0,
              0,
              0,
              1,
              0,
              values[4].value,
              values[5].value,
              0,
              1
            ];
            multiply$1(view, view, values);
            break;
          case "matrix3d":
            var values = it.value.map((it2) => it2.value);
            multiply$1(view, view, values);
            break;
          case "perspective":
            var values = it.value;
            perspective(view, Math.PI * 0.5, width2 / height, 1, values[0].value);
            break;
        }
      }
      return view;
    }
    static fromScale(scale2) {
      if (scale2[0] === 1 && scale2[1] === 1) {
        return "";
      }
      const list = [];
      if (scale2[0] != 1)
        list.push(`scaleX(${scale2[0]})`);
      if (scale2[1] != 1)
        list.push(`scaleY(${scale2[1]})`);
      if (scale2[2] != 1)
        list.push(`scaleZ(${scale2[2]})`);
      return list.join(" ");
    }
  }
  var updatePathItem = {
    command: "updatePathItem",
    description: "Update path string for selected svg path item",
    execute: function(editor2, pathObject) {
      const current = editor2.context.selection.current;
      if (current) {
        if (pathObject.box === "box") {
          const newPath = current.invertPath(pathObject.d);
          editor2.context.commands.executeCommand("setAttribute", "change local path", editor2.context.selection.packByValue({
            d: newPath.d
          }));
        } else {
          const newPath = new PathParser(pathObject.d);
          newPath.transformMat4(pathObject.matrix.absoluteMatrixInverse);
          let bbox = newPath.getBBox();
          const newWidth = distance$1(bbox[1], bbox[0]);
          const newHeight = distance$1(bbox[3], bbox[0]);
          let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), pathObject.matrix.absoluteMatrix);
          let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(pathObject.matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
          const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), current.getLocalTransformMatrix(newWidth, newHeight));
          const realXY = getTranslation([], calculateMatrix(pathObject.matrix.parentMatrixInverse, worldMatrix, invert([], current.getLocalTransformMatrix(newWidth, newHeight))));
          editor2.context.commands.executeCommand("setAttribute", "change path", editor2.context.selection.packByValue({
            d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
            x: realXY[0],
            y: realXY[1],
            width: newWidth,
            height: newHeight
          }));
        }
      }
    }
  };
  var __glob_0_114 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updatePathItem
  }, Symbol.toStringTag, { value: "Module" }));
  var updateResource = {
    command: "updateResource",
    execute: function(editor2, items) {
      items.forEach((item) => {
        switch (item.type) {
          case "image/svg+xml":
          case "image/png":
          case "image/gif":
          case "image/jpg":
          case "image/jpeg":
            editor2.context.commands.emit("updateImage", item);
            break;
          case "text/plain":
          case "text/html":
            editor2.context.commands.emit("addText", {
              content: item.data
            });
            break;
          case "text/uri-list":
            editor2.context.commands.emit("updateUriList", item);
            break;
        }
      });
    }
  };
  var __glob_0_115 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateResource
  }, Symbol.toStringTag, { value: "Module" }));
  class AssetParser {
    static parse(datauri, enableParselocal = false) {
      var [, data] = datauri.split("data:");
      var [mediaType, ...content2] = data.split(",");
      var [mimeType, encoding] = mediaType.split(";");
      content2 = content2.join(",");
      return {
        mimeType,
        local: enableParselocal && AssetParser.getLink(mimeType, encoding, content2)
      };
    }
    static getLink(mimeType, encoding, content2) {
      if (encoding === "base64") {
        var binary = window.atob(content2);
        var len2 = binary.length;
        var unit8Array = new window.Uint8Array(len2);
        for (var i = 0; i < len2; i++) {
          unit8Array[i] = binary.charCodeAt(i);
        }
        var blob = new window.Blob([unit8Array], { type: mimeType });
        return window.URL.createObjectURL(blob);
      }
      return "";
    }
  }
  var updateUriList = {
    command: "updateUriList",
    execute: function(editor2, item) {
      var datauri = item.data;
      if (datauri.indexOf("data:") > -1) {
        var info = AssetParser.parse(datauri, true);
        switch (info.mimeType) {
          case "image/png":
          case "image/gif":
          case "image/jpg":
          case "image/jpeg":
            editor2.context.commands.emit("addImageAssetItem", {
              id: uuidShort(),
              type: info.mimeType,
              name: "",
              original: datauri,
              local: info.local
            });
            break;
        }
      } else {
        var ext = item.data.split(".").pop();
        var name = item.data.split("/").pop();
        switch (ext) {
          case "png":
          case "jpg":
          case "gif":
          case "svg":
            editor2.context.commands.emit("addImageAssetItem", {
              id: uuidShort(),
              type: "image/" + ext,
              name,
              original: item.data,
              local: item.data
            });
            break;
        }
      }
    }
  };
  var __glob_0_116 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateUriList
  }, Symbol.toStringTag, { value: "Module" }));
  var updateVideo = {
    command: "updateVideo",
    execute: function(editor2, item, rect2, containerItem = void 0) {
      var reader = new window.FileReader();
      reader.onload = (e) => {
        var datauri = e.target.result;
        var local = window.URL.createObjectURL(item);
        editor2.context.commands.emit("addVideoAssetItem", {
          id: uuidShort(),
          type: item.type,
          name: item.name,
          original: datauri,
          local
        }, rect2, containerItem);
      };
      reader.readAsDataURL(item);
    }
  };
  var __glob_0_117 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateVideo
  }, Symbol.toStringTag, { value: "Module" }));
  var updateVideoAssetItem = {
    command: "updateVideoAssetItem",
    execute: function(editor2, item, callback) {
      var reader = new window.FileReader();
      reader.onload = (e) => {
        var datauri = e.target.result;
        var local = window.URL.createObjectURL(item);
        var project2 = editor2.context.selection.currentProject;
        if (project2) {
          project2.createVideo({
            id: uuidShort(),
            type: item.type,
            name: item.name,
            original: datauri,
            local
          });
          editor2.emit("addVideoAsset");
          sapa.isFunction(callback) && callback(local);
        }
      };
      reader.readAsDataURL(item);
    }
  };
  var __glob_0_118 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": updateVideoAssetItem
  }, Symbol.toStringTag, { value: "Module" }));
  var update = {
    command: "update",
    description: "Update the model",
    execute: function(editor2, id = null, attrs = {}, context = { origin: "*" }) {
      const item = editor2.get(id);
      if (item) {
        const isChanged = item.reset(attrs, context);
        if (isChanged) {
          editor2.context.commands.emit("refreshElement", item);
        }
      }
    }
  };
  var __glob_0_119 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": update
  }, Symbol.toStringTag, { value: "Module" }));
  const modules$3 = { "./command_list/_currentProject.js": __glob_0_0$3, "./command_list/_doForceRefreshSelection.js": __glob_0_1$3, "./command_list/addArtBoard.js": __glob_0_2$3, "./command_list/addBackgroundColor.js": __glob_0_3$3, "./command_list/addBackgroundImageAsset.js": __glob_0_4$3, "./command_list/addBackgroundImageGradient.js": __glob_0_5$3, "./command_list/addBackgroundImagePattern.js": __glob_0_6$3, "./command_list/addCustomComponent.js": __glob_0_7$3, "./command_list/addImage.js": __glob_0_8$3, "./command_list/addImageAssetItem.js": __glob_0_9$3, "./command_list/addLayer.js": __glob_0_10$3, "./command_list/addLayerView.js": __glob_0_11$3, "./command_list/addProject.js": __glob_0_12$3, "./command_list/addSVGFilterAssetItem.js": __glob_0_13$3, "./command_list/addText.js": __glob_0_14$3, "./command_list/addTimelineCurrentProperty.js": __glob_0_15$3, "./command_list/addTimelineItem.js": __glob_0_16$3, "./command_list/addTimelineKeyframe.js": __glob_0_17$3, "./command_list/addTimelineProperty.js": __glob_0_18$3, "./command_list/addVideo.js": __glob_0_19$3, "./command_list/addVideoAssetItem.js": __glob_0_20$3, "./command_list/clipboard.copy.js": __glob_0_21$2, "./command_list/clipboard.paste.js": __glob_0_22$2, "./command_list/convert.flatten.path.js": __glob_0_23$2, "./command_list/convert.no.transform.path.js": __glob_0_24$1, "./command_list/convert.normalize.path.js": __glob_0_25$1, "./command_list/convert.path.operation.js": __glob_0_26$1, "./command_list/convert.polygonal.path.js": __glob_0_27$1, "./command_list/convert.simplify.path.js": __glob_0_28$1, "./command_list/convert.smooth.path.js": __glob_0_29$1, "./command_list/convert.stroke.to.path.js": __glob_0_30$1, "./command_list/convertPasteText.js": __glob_0_31$1, "./command_list/convertPath.js": __glob_0_32$1, "./command_list/copy.path.js": __glob_0_33$1, "./command_list/copyLayer.js": __glob_0_34$1, "./command_list/copyTimelineProperty.js": __glob_0_35$1, "./command_list/deleteTimelineKeyframe.js": __glob_0_36$1, "./command_list/doubleclick.item.js": __glob_0_37$1, "./command_list/downloadJSON.js": __glob_0_38$1, "./command_list/downloadPNG.js": __glob_0_39$1, "./command_list/downloadSVG.js": __glob_0_40$1, "./command_list/drop.asset.js": __glob_0_41$1, "./command_list/dropImageUrl.js": __glob_0_42$1, "./command_list/editor.config.body.event.js": __glob_0_43$1, "./command_list/fileDropItems.js": __glob_0_44$1, "./command_list/firstTimelineItem.js": __glob_0_45$1, "./command_list/group.item.js": __glob_0_46$1, "./command_list/history.addLayer.js": __glob_0_47$1, "./command_list/history.bring.forward.js": __glob_0_48$1, "./command_list/history.bring.front.js": __glob_0_49$1, "./command_list/history.clipboard.paste.js": __glob_0_50$1, "./command_list/history.copyLayer.js": __glob_0_51$1, "./command_list/history.group.item.js": __glob_0_52$1, "./command_list/history.moveLayer.js": __glob_0_53$1, "./command_list/history.moveLayerToTarget.js": __glob_0_54$1, "./command_list/history.refreshSelection.js": __glob_0_55$1, "./command_list/history.refreshSelectionProject.js": __glob_0_56, "./command_list/history.removeLayer.js": __glob_0_57, "./command_list/history.removeProject.js": __glob_0_58, "./command_list/history.send.back.js": __glob_0_59, "./command_list/history.send.backward.js": __glob_0_60, "./command_list/history.setAttribute.js": __glob_0_61, "./command_list/item.move.depth.down.js": __glob_0_62, "./command_list/item.move.depth.first.js": __glob_0_63, "./command_list/item.move.depth.last.js": __glob_0_64, "./command_list/item.move.depth.up.js": __glob_0_65, "./command_list/lastTimelineItem.js": __glob_0_66, "./command_list/load.json.js": __glob_0_67, "./command_list/moveLayer.js": __glob_0_68, "./command_list/moveLayerForItems.js": __glob_0_69, "./command_list/moveSelectionToCenter.js": __glob_0_70, "./command_list/newComponent.js": __glob_0_71, "./command_list/nextTimelineItem.js": __glob_0_72, "./command_list/open.editor.js": __glob_0_73, "./command_list/pauseTimelineItem.js": __glob_0_74, "./command_list/playTimelineItem.js": __glob_0_75, "./command_list/prevTimelineItem.js": __glob_0_76, "./command_list/recoverBooleanPath.js": __glob_0_77, "./command_list/refreshArtboard.js": __glob_0_78, "./command_list/refreshElement.js": __glob_0_79, "./command_list/refreshHistory.js": __glob_0_80, "./command_list/refreshSelectedOffset.js": __glob_0_81, "./command_list/removeAnimationItem.js": __glob_0_82, "./command_list/removeLayer.js": __glob_0_83, "./command_list/removeTimeline.js": __glob_0_84, "./command_list/removeTimelineProperty.js": __glob_0_85, "./command_list/resizeArtBoard.js": __glob_0_86, "./command_list/rotateLayer.js": __glob_0_87, "./command_list/same.height.js": __glob_0_88, "./command_list/same.width.js": __glob_0_89, "./command_list/saveJSON.js": __glob_0_90, "./command_list/savePNG.js": __glob_0_91, "./command_list/segment.delete.js": __glob_0_92, "./command_list/segment.move.down.js": __glob_0_93, "./command_list/segment.move.left.js": __glob_0_94, "./command_list/segment.move.right.js": __glob_0_95, "./command_list/segment.move.up.js": __glob_0_96, "./command_list/select.all.js": __glob_0_97, "./command_list/select.none.js": __glob_0_98, "./command_list/selectTimelineItem.js": __glob_0_99, "./command_list/setAttribute.js": __glob_0_100, "./command_list/setTimelineOffset.js": __glob_0_101, "./command_list/showExportView.js": __glob_0_102, "./command_list/sort.bottom.js": __glob_0_103, "./command_list/sort.center.js": __glob_0_104, "./command_list/sort.left.js": __glob_0_105, "./command_list/sort.middle.js": __glob_0_106, "./command_list/sort.right.js": __glob_0_107, "./command_list/sort.top.js": __glob_0_108, "./command_list/switch.path.js": __glob_0_109, "./command_list/ungroup.item.js": __glob_0_110, "./command_list/updateClipPath.js": __glob_0_111, "./command_list/updateImage.js": __glob_0_112, "./command_list/updateImageAssetItem.js": __glob_0_113, "./command_list/updatePathItem.js": __glob_0_114, "./command_list/updateResource.js": __glob_0_115, "./command_list/updateUriList.js": __glob_0_116, "./command_list/updateVideo.js": __glob_0_117, "./command_list/updateVideoAssetItem.js": __glob_0_118, "./command_list/model/update.js": __glob_0_119 };
  const obj = {};
  Object.entries(modules$3).forEach(([key, value]) => {
    key = key.replace("./command_list/", "").replace(".js", "");
    obj[key] = value.default;
  });
  function commands(editor2) {
    editor2.loadCommands(obj);
  }
  var area_width = {
    key: "area.width",
    defaultValue: 100,
    title: "Area Width to find layers fastly",
    description: "Set area width/height",
    type: "number"
  };
  var __glob_0_0$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": area_width
  }, Symbol.toStringTag, { value: "Module" }));
  var debug_mode = {
    key: "debug.mode",
    defaultValue: false,
    title: "debug mode",
    description: "Set debug mode to on ",
    type: "boolean"
  };
  var __glob_0_1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": debug_mode
  }, Symbol.toStringTag, { value: "Module" }));
  var editing_css_itemType = {
    key: "editing.css.itemType",
    defaultValue: "rect",
    title: "set item type for  editing css",
    description: "set item type for  editing css",
    type: "string"
  };
  var __glob_0_2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editing_css_itemType
  }, Symbol.toStringTag, { value: "Module" }));
  var editing_draw_itemType = {
    key: "editing.draw.itemType",
    defaultValue: "path",
    title: "set item type for  editing draw",
    description: "set item type for  editing draw",
    type: "string"
  };
  var __glob_0_3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editing_draw_itemType
  }, Symbol.toStringTag, { value: "Module" }));
  var editing_mode_itemType = {
    key: "editing.mode.itemType",
    defaultValue: "select",
    title: "set item type for  editing mode",
    description: "set item type for  editing mode",
    type: "string"
  };
  var __glob_0_4$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editing_mode_itemType
  }, Symbol.toStringTag, { value: "Module" }));
  var editing_mode = {
    key: "editing.mode",
    defaultValue: EditingMode.SELECT,
    title: "set editing mode for Editor",
    description: "set editing mode (select, append, draw, path)",
    type: "string"
  };
  var __glob_0_5$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editing_mode
  }, Symbol.toStringTag, { value: "Module" }));
  var editing_svg_itemType = {
    key: "editing.svg.itemType",
    defaultValue: "svg-rect",
    title: "set item type for  editing svg",
    description: "set item type for  editing svg",
    type: "string"
  };
  var __glob_0_6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editing_svg_itemType
  }, Symbol.toStringTag, { value: "Module" }));
  var editor_design_mode = {
    key: "editor.design.mode",
    defaultValue: "design",
    title: "Editor Design Mode ",
    description: "Set editor's design mode",
    options: ["design", "item"],
    type: "select"
  };
  var __glob_0_7$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editor_design_mode
  }, Symbol.toStringTag, { value: "Module" }));
  var editor_layout_mode = {
    key: "editor.layout.mode",
    defaultValue: "all",
    title: "Editor Layout Mode ",
    description: "Set editor's layout mode",
    type: "string"
  };
  var __glob_0_8$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": editor_layout_mode
  }, Symbol.toStringTag, { value: "Module" }));
  var fixed_angle = {
    key: "fixed.angle",
    defaultValue: 15,
    title: "fixed angle count",
    description: "Set fixed angle",
    type: "number"
  };
  var __glob_0_9$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": fixed_angle
  }, Symbol.toStringTag, { value: "Module" }));
  var fixed_gradient_angle = {
    key: "fixed.gradient.angle",
    defaultValue: 1,
    title: "fixed gradient angle count",
    description: "Set fixed gradient angle",
    type: "number"
  };
  var __glob_0_10$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": fixed_gradient_angle
  }, Symbol.toStringTag, { value: "Module" }));
  var history_delay_ms = {
    key: "history.delay.ms",
    defaultValue: 500,
    title: "history delay milliseconds",
    description: "Set history delay time",
    type: "number"
  };
  var __glob_0_11$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_delay_ms
  }, Symbol.toStringTag, { value: "Module" }));
  var horizontal_line = {
    key: "horizontal.line",
    defaultValue: [],
    title: "horizontal guide line for snap ",
    description: "horizontal guide line for snap",
    type: "array"
  };
  var __glob_0_12$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": horizontal_line
  }, Symbol.toStringTag, { value: "Module" }));
  var horizontal_line_selected_index = {
    key: "horizontal.line.selected.index",
    defaultValue: -1,
    title: "selected horizontal guide line index",
    description: "selected horizontal guide line index",
    type: "number"
  };
  var __glob_0_13$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": horizontal_line_selected_index
  }, Symbol.toStringTag, { value: "Module" }));
  var set_drag_path_area = {
    key: "set.drag.path.area",
    defaultValue: false,
    title: "Drag path area",
    description: "Drag path area",
    type: "boolean",
    storage: "none"
  };
  var __glob_0_14$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": set_drag_path_area
  }, Symbol.toStringTag, { value: "Module" }));
  var set_move_control_point = {
    key: "set.move.control.point",
    defaultValue: false,
    title: "Moving Control Point",
    description: "Moving Control Point",
    type: "boolean",
    storage: "none"
  };
  var __glob_0_15$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": set_move_control_point
  }, Symbol.toStringTag, { value: "Module" }));
  var show_left_panel = {
    key: "show.left.panel",
    defaultValue: true,
    title: "Show left panel",
    description: "Set left panel visibility to on",
    type: "boolean"
  };
  var __glob_0_16$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": show_left_panel
  }, Symbol.toStringTag, { value: "Module" }));
  var show_outline = {
    key: "show.outline",
    defaultValue: false,
    title: "Show outline",
    description: "Set outline visibility to on",
    type: "boolean"
  };
  var __glob_0_17$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": show_outline
  }, Symbol.toStringTag, { value: "Module" }));
  var show_right_panel = {
    key: "show.right.panel",
    defaultValue: true,
    title: "Show right panel",
    description: "Set right panel visibility to on",
    type: "boolean"
  };
  var __glob_0_18$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": show_right_panel
  }, Symbol.toStringTag, { value: "Module" }));
  var show_ruler = {
    key: "show.ruler",
    defaultValue: true,
    title: "Show ruler",
    description: "Set ruler visibility to on",
    type: "boolean"
  };
  var __glob_0_19$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": show_ruler
  }, Symbol.toStringTag, { value: "Module" }));
  var snap_distance = {
    key: "snap.distance",
    defaultValue: 3,
    title: "Snap distance between objects",
    description: "Set snap distance",
    type: "number"
  };
  var __glob_0_20$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": snap_distance
  }, Symbol.toStringTag, { value: "Module" }));
  var snap_grid = {
    key: "snap.grid",
    defaultValue: 50,
    title: "Snap grid size between objects",
    description: "Set snap grid size",
    type: "number"
  };
  var __glob_0_21$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": snap_grid
  }, Symbol.toStringTag, { value: "Module" }));
  var vertical_line = {
    key: "vertical.line",
    defaultValue: [],
    title: "vertical guide line for snap ",
    description: "vertical guide line for snap",
    type: "array"
  };
  var __glob_0_22$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": vertical_line
  }, Symbol.toStringTag, { value: "Module" }));
  var vertical_line_selected_index = {
    key: "vertical.line.selected.index",
    defaultValue: -1,
    title: "selected vertical guide line index",
    description: "selected vertical guide line index",
    type: "number"
  };
  var __glob_0_23$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": vertical_line_selected_index
  }, Symbol.toStringTag, { value: "Module" }));
  const modules$2 = { "./config_list/area.width.js": __glob_0_0$2, "./config_list/debug.mode.js": __glob_0_1$2, "./config_list/editing.css.itemType.js": __glob_0_2$2, "./config_list/editing.draw.itemType.js": __glob_0_3$2, "./config_list/editing.mode.itemType.js": __glob_0_4$2, "./config_list/editing.mode.js": __glob_0_5$2, "./config_list/editing.svg.itemType.js": __glob_0_6$2, "./config_list/editor.design.mode.js": __glob_0_7$2, "./config_list/editor.layout.mode.js": __glob_0_8$2, "./config_list/fixed.angle.js": __glob_0_9$2, "./config_list/fixed.gradient.angle.js": __glob_0_10$2, "./config_list/history.delay.ms.js": __glob_0_11$2, "./config_list/horizontal.line.js": __glob_0_12$2, "./config_list/horizontal.line.selected.index.js": __glob_0_13$2, "./config_list/set.drag.path.area.js": __glob_0_14$2, "./config_list/set.move.control.point.js": __glob_0_15$2, "./config_list/show.left.panel.js": __glob_0_16$2, "./config_list/show.outline.js": __glob_0_17$2, "./config_list/show.right.panel.js": __glob_0_18$2, "./config_list/show.ruler.js": __glob_0_19$2, "./config_list/snap.distance.js": __glob_0_20$2, "./config_list/snap.grid.js": __glob_0_21$1, "./config_list/vertical.line.js": __glob_0_22$1, "./config_list/vertical.line.selected.index.js": __glob_0_23$1 };
  var configs$1 = Object.values(modules$2).map((it) => it.default);
  function configs(editor2) {
    configs$1.forEach((config) => {
      editor2.registerConfig(config);
    });
  }
  class Selector extends PropertyItem {
    static parse(obj2) {
      return new Selector(obj2);
    }
    getDefaultObject(obj2) {
      return super.getDefaultObject(__spreadValues({
        itemType: "selector",
        selector: "",
        properties: []
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("selector", "properties"));
    }
    isMultiStyle(key) {
      switch (key) {
        case "background-image":
        case "var":
          return true;
      }
      return false;
    }
    getMultiStyleString(p) {
      switch (p.key) {
        case "background-image":
          return p.value.toString() + ";";
      }
      return p.value.toString() + " !important;";
    }
    toPropertyString() {
      return this.json.properties.map((p) => {
        if (this.isMultiStyle(p.key)) {
          return this.getMultiStyleString(p);
        } else {
          var value = p.value.toString();
          if (value) {
            var key = p.key;
            if (key === "x")
              key = "left";
            else if (key === "y")
              key = "top";
            return `${key}: ${value} !important;`;
          } else {
            return "";
          }
        }
      }).join("\n");
    }
    toCSSText(prefix = "") {
      return `${prefix}${this.json.selector} {
    ${this.toPropertyString()}
}`;
    }
    toCSS() {
      return {};
    }
    toString(prefix = "") {
      return this.toCSSText(prefix);
    }
  }
  var DefaultLayoutEngine = {
    startCache(container) {
      container.addCache("cachedSize", {
        width: container.width,
        height: container.height
      });
      container.addCache("cachedLayerMatrix", container.layers.map((child) => {
        child.startToCacheChildren();
        const { x, y, width: width2, height } = child.attrs("x", "y", "width", "height");
        return {
          id: child.id,
          matrix: { x, y, width: width2, height },
          constraints: {
            horizontal: child[ConstraintsDirection.HORIZONTAL],
            vertical: child[ConstraintsDirection.VERTICAL]
          }
        };
      }));
    },
    recover(container) {
      const obj2 = {
        width: container.width,
        height: container.height
      };
      const currentContainerWidth = obj2.width;
      const currentContainerHeight = obj2.height;
      const cachedSize = container.getCache("cachedSize");
      const oldContainerWidth = cachedSize.width;
      const oldContainerHeight = cachedSize.height;
      const scaleX = currentContainerWidth / oldContainerWidth;
      const scaleY = currentContainerHeight / oldContainerHeight;
      const cachedLayerMatrix = container.getCache("cachedLayerMatrix");
      cachedLayerMatrix.forEach(({ id, matrix, constraints }) => {
        const item = container.find(id);
        const { x, y, width: width2, height } = matrix;
        const left = x;
        const right = oldContainerWidth - x - width2;
        const top = y;
        const bottom = oldContainerHeight - y - height;
        const localObj = {};
        switch (constraints.horizontal) {
          case Constraints.MIN:
            localObj.x = left;
            break;
          case Constraints.MAX:
            localObj.x = currentContainerWidth - right - width2;
            break;
          case Constraints.STRETCH:
            localObj.x = left;
            localObj.width = currentContainerWidth - left - right;
            break;
          case Constraints.SCALE:
            localObj.x = left * scaleX;
            localObj.width = width2 * scaleX;
            break;
          case Constraints.CENTER:
            const halfWidth = width2 / 2;
            const scaleNew = (x + halfWidth) / oldContainerWidth;
            localObj.x = scaleNew * currentContainerWidth - halfWidth;
            break;
        }
        switch (constraints.vertical) {
          case Constraints.MIN:
            localObj.y = top;
            break;
          case Constraints.MAX:
            localObj.y = currentContainerHeight - bottom - height;
            break;
          case Constraints.STRETCH:
            localObj.y = top;
            localObj.height = currentContainerHeight - top - bottom;
            break;
          case Constraints.SCALE:
            localObj.y = top * scaleY;
            localObj.height = height * scaleY;
            break;
          case Constraints.CENTER:
            const halfHeight = height / 2;
            const scaleNew = (y + halfHeight) / oldContainerHeight;
            localObj.y = scaleNew * currentContainerHeight - halfHeight;
            break;
        }
        item.reset(localObj);
        item.recoverChildren();
      });
    }
  };
  var GridLayoutEngine = {
    startCache() {
    },
    recover() {
    },
    updateGridArea(currentItem, gridInformation, scale2 = 1) {
      if (currentItem.isInGrid() === false)
        return;
      const lastVerties = currentItem.originVerties;
      const targetRect = vertiesToRectangle(lastVerties);
      const { items } = gridInformation;
      const epsilon = IntersectEpsilonNumberType.RECT / scale2;
      const checkedGridRowColumnList = items.filter((it) => {
        return polyPoly(lastVerties, it.originVerties);
      }).filter((it) => {
        const intersect = intersectRectRect(it.originRect, targetRect);
        return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
      });
      if (checkedGridRowColumnList.length === 0)
        return;
      const rows = checkedGridRowColumnList.map((it) => it.row);
      rows.sort((a, b) => a - b);
      const columns = checkedGridRowColumnList.map((it) => it.column);
      columns.sort((a, b) => a - b);
      const gridColumnStart = columns[0];
      const gridColumnEnd = columns[columns.length - 1];
      const gridRowStart = rows[0];
      const gridRowEnd = rows[rows.length - 1];
      const gridArea = {
        "grid-column-start": gridColumnStart,
        "grid-column-end": gridColumnEnd + 1,
        "grid-row-start": gridRowStart,
        "grid-row-end": gridRowEnd + 1
      };
      currentItem.reset(gridArea);
      return gridArea;
    }
  };
  class Offset extends PropertyItem {
    static parse(obj2) {
      return new Offset(obj2);
    }
    getDefaultObject() {
      return super.getDefaultObject({
        itemType: "offset",
        offset: editor.Length.percent(0),
        color: "rgba(255, 255, 255, 1)",
        properties: []
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offset", "color", "properties"));
    }
    convert(json) {
      json = super.convert(json);
      json.offset = editor.Length.parse(json.offset);
      return json;
    }
    toCSSText() {
      return `${this.json.offset} ${CSS_TO_STRING(this.toCSS())}`;
    }
    createProperty(data = {}) {
      return this.addProperty(__spreadValues({
        checked: true,
        value: 0
      }, data));
    }
    addProperty(property) {
      this.json.properties.push(property);
    }
    removeProperty(removeIndex) {
      this.json.properties.splice(removeIndex, 1);
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortProperty(startIndex, targetIndex) {
      this.sortItem(this.json.properties, startIndex, targetIndex);
    }
    updateProperty(index2, data = {}) {
      Object.assign(this.json.properties[+index2], __spreadValues({}, data));
    }
    updatePropertyByKey(key, data = {}) {
      var arr = this.json.properties;
      var index2 = -1;
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (this.json.properties[i].key === key) {
          index2 = i;
          break;
        }
      }
      Object.assign(this.json.properties[+index2], __spreadValues({}, data));
    }
    toCSS() {
      var obj2 = {};
      this.json.properties.forEach((it) => {
        obj2 = __spreadValues(__spreadValues({}, obj2), it.toCSS());
      });
      return obj2;
    }
    toString() {
      return this.toCSSText();
    }
  }
  class Keyframe extends PropertyItem {
    static parse(obj2) {
      return new Keyframe(obj2);
    }
    static parseStyle(style2) {
      var keyframes = [];
      var keyframeKeys = {};
      if (style2["keyframe"]) {
        var results = Color.convertMatches(style2["keyframe"]);
        results.str.split("|").map((it) => it.trim()).forEach((frameInfo, index2) => {
          var [name, offset, property, ...values] = frameInfo.split(" ");
          var propertyValue = values.join(" ");
          if (!keyframeKeys[name]) {
            keyframeKeys[name] = new Keyframe({
              name
            });
            keyframes[index2] = name;
          }
          var filteredOffset = keyframeKeys[name].offsets.filter((it) => {
            return it.offset.equals(editor.Length.parse(offset));
          });
          var offsetObj = null;
          if (filteredOffset.length) {
            offsetObj = filteredOffset[0];
          } else {
            offsetObj = new Offset({
              offset: editor.Length.parse(offset)
            });
            keyframeKeys[name].offsets.push(offsetObj);
          }
          offsetObj.addProperty({
            key: property,
            value: Color.reverseMatches(propertyValue, results.matches)
          });
        });
      }
      return keyframes.map((name) => {
        keyframeKeys[name].offsets.forEach((offset) => {
          var vars = [];
          var properties = [];
          offset.properties.forEach((p) => {
            if (p.key.includes("--")) {
              vars.push(p);
            } else {
              properties.push(p);
            }
          });
          let varValue = vars.map((it) => `${it.key}:${it.value}`).join(";");
          if (vars.length) {
            properties.push({ key: "var", value: varValue });
          }
          offset.properties = properties;
        });
        return keyframeKeys[name];
      });
    }
    getDefaultObject() {
      return super.getDefaultObject({
        itemType: "keyframe",
        name: "sample",
        selectedType: "list",
        offsets: []
      });
    }
    toCloneObject() {
      var { offsets } = this.json;
      return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name", "selectedType")), {
        offsets: offsets.map((offset) => offset.clone())
      });
    }
    isMultiStyle(key) {
      switch (key) {
        case "background-image":
        case "var":
          return true;
      }
      return false;
    }
    getMultiStyleString(p) {
      switch (p.key) {
        case "background-image":
          return p.value.toString() + ";";
        case "var":
          var value = (p.value + "").split(";").map((str) => {
            return `--` + str;
          }).join(";");
          return value + ";";
      }
      return p.value.toString() + ";";
    }
    toOffsetString(it) {
      var tabString = "      ";
      return `${it.offset.toString()} {
${tabString}${it.properties.map((p) => {
        if (this.isMultiStyle(p.key)) {
          return this.getMultiStyleString(p);
        } else {
          var value = (p.value || "").toString();
          if (value) {
            var key = p.key;
            if (key === "x")
              key = "left";
            else if (key === "y")
              key = "top";
            return `${key}: ${value};`;
          } else {
            return "";
          }
        }
      }).join("").replace(/;/g, ";\n" + tabString).trim()}
  }`;
    }
    toOffsetText() {
      var offsets = this.json.offsets.map((it) => {
        return it;
      });
      offsets.sort((a, b) => {
        return a.offset.value > b.offset.value ? 1 : -1;
      });
      return offsets.map((it) => {
        if (it.properties.length === 0)
          return "";
        return this.toOffsetString(it);
      }).join("\n");
    }
    toCSSText() {
      var offsets = this.json.offsets.map((it) => {
        return it;
      });
      offsets.sort((a, b) => {
        return a.offset.value > b.offset.value ? 1 : -1;
      });
      return `
@keyframes ${this.json.name} {

  ${this.toOffsetText()}

}
`;
    }
    createOffset(data = {}) {
      return this.addOffset(new Offset(__spreadValues({
        checked: true
      }, data)));
    }
    addOffset(offset) {
      this.json.offsets.push(offset);
    }
    removeOffset(removeIndex) {
      this.json.offsets.splice(removeIndex, 1);
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortOffset(startIndex, targetIndex) {
      this.sortItem(this.json.offsets, startIndex, targetIndex);
    }
    updateOffset(index2, data = {}) {
      this.json.offsets[+index2].reset(data);
    }
    toCSS() {
      return {};
    }
    toString() {
      return this.toCSSText();
    }
  }
  class BaseModel {
    constructor(json = {}, modelManager) {
      __privateAdd(this, _modelManager, null);
      __privateAdd(this, _json, {});
      __privateAdd(this, _cachedValue, {});
      __privateAdd(this, _timestamp, 0);
      __privateAdd(this, _lastChangedField, {});
      __privateAdd(this, _collapsed, false);
      this.setModelManager(modelManager);
      this.initializeModel(json);
    }
    initializeModel(json) {
      __privateSet(this, _json, this.convert(Object.assign(this.getDefaultObject(), json)));
    }
    get manager() {
      return __privateGet(this, _modelManager);
    }
    setModelManager(modelManager) {
      __privateSet(this, _modelManager, modelManager);
    }
    getDefaultTitle() {
      return "Item";
    }
    getIcon() {
      return "";
    }
    isChanged(timestamp) {
      console.log("isChanged", timestamp);
      return this.timestamp != Number(timestamp);
    }
    changed() {
      __privateSet(this, _timestamp, __privateGet(this, _timestamp) + Date.now());
    }
    get timestamp() {
      return __privateGet(this, _timestamp);
    }
    get title() {
      return this.name || this.getDefaultTitle();
    }
    get itemType() {
      return this.get("itemType");
    }
    get name() {
      return this.get("name");
    }
    get children() {
      return this.get("children");
    }
    get collapsed() {
      return __privateGet(this, _collapsed);
    }
    set collapsed(value) {
      __privateSet(this, _collapsed, value);
    }
    get visibility() {
      return this.get("visibility");
    }
    set visibility(value) {
      this.set("visibility", value);
    }
    renameWithCount() {
      let arr = __privateGet(this, _json).name.split(" ");
      if (arr.length < 2) {
        return;
      }
      let last = arr.pop();
      let lastNumber = +last;
      if (sapa.isNumber(lastNumber) && isNaN(lastNumber) === false) {
        lastNumber++;
      } else {
        lastNumber = last;
      }
      const nextName = [...arr, lastNumber].join(" ");
      this.reset({
        name: nextName
      });
    }
    get allLayers() {
      return this.manager.getAllLayers(this.id);
    }
    get layers() {
      return this.manager.getLayers(this.id) || [];
    }
    filteredAllLayers(filterCallback) {
      return this.manager.getAllLayers(this.id, filterCallback);
    }
    get id() {
      return __privateGet(this, _json).id;
    }
    get parentId() {
      const parentId = __privateGet(this, _json).parentId;
      if (parentId === this.id)
        return void 0;
      return parentId;
    }
    get parent() {
      if (!this.parentId)
        return void 0;
      return this.manager.get(this.parentId);
    }
    get depth() {
      return this.path.length;
    }
    get top() {
      return this.path.filter((it) => it.isNot("project")).shift();
    }
    get project() {
      return this.path.find((it) => it.is("project"));
    }
    get artboard() {
      return this.path.find((it) => it.is("artboard"));
    }
    get path() {
      const path = [this];
      let parent;
      while (parent = path[0].parent) {
        path.unshift(parent);
      }
      return path;
    }
    get pathIds() {
      return this.path.map((it) => it.id);
    }
    setParentId(parentId) {
      this.reset({ parentId });
      this.manager.setChanged("setParentId", this.id, { parentId });
    }
    get childrenLength() {
      return __privateGet(this, _json).children.length;
    }
    get index() {
      var _a;
      return (_a = this.parent) == null ? void 0 : _a.findIndex(this);
    }
    get isFirst() {
      return this.index === 0;
    }
    get isLast() {
      return this.index === this.parent.childrenLength - 1;
    }
    get first() {
      return this.parent.layers[0];
    }
    get last() {
      const parent = this.parent;
      return parent.layers[parent.childrenLength - 1];
    }
    get prev() {
      var _a;
      const index2 = this.index;
      if (this.isFirst) {
        return this;
      }
      return (_a = this.parent) == null ? void 0 : _a.layers[index2 - 1];
    }
    get next() {
      var _a;
      const index2 = this.index;
      if (this.isLast) {
        return this;
      }
      return (_a = this.parent) == null ? void 0 : _a.layers[index2 + 1];
    }
    get hierarchy() {
      return this.getInformationForHierarchy("x", "y", "angle");
    }
    getInformationForHierarchy(...args2) {
      const parent = this.parent;
      const index2 = this.index;
      return {
        id: this.id,
        index: index2,
        parentId: this.parentId,
        prev: index2 === 0 ? void 0 : parent.children[index2 - 1],
        next: index2 === parent.childrenLength - 1 ? void 0 : parent.children[index2 + 1],
        attrs: this.attrs(...args2)
      };
    }
    getInnerId(postfix = "") {
      return __privateGet(this, _json).id + postfix;
    }
    is(checkItemType) {
      return __privateGet(this, _json).itemType === checkItemType;
    }
    isNot(checkItemType) {
      return this.is(checkItemType) === false;
    }
    get(key) {
      return __privateGet(this, _json)[key];
    }
    removeField(key) {
      delete __privateGet(this, _json)[key];
    }
    set(key, value) {
      this.reset({ [key]: value });
    }
    isSVG() {
      return false;
    }
    addCache(key, value) {
      __privateGet(this, _cachedValue)[key] = value;
    }
    getCache(key) {
      return __privateGet(this, _cachedValue)[key];
    }
    hasCache(key) {
      return Boolean(__privateGet(this, _cachedValue)[key]);
    }
    computed(key, newValueCallback, isForce = false) {
      const cachedKey = `__cachedKey_${key}`;
      const parsedKey = `${cachedKey}__parseValue`;
      const value = __privateGet(this, _json)[key];
      if (isForce)
        ;
      else {
        if (this.getCache(cachedKey) === value && this.getCache(parsedKey)) {
          return this.getCache(parsedKey);
        }
      }
      this.addCache(cachedKey, value);
      this.addCache(parsedKey, newValueCallback(value, this));
      return this.getCache(parsedKey);
    }
    computedValue(key) {
      const cachedKey = `__cachedKey_${key}`;
      const parsedKey = `${cachedKey}__parseValue`;
      return this.getCache(parsedKey);
    }
    editable() {
      return true;
    }
    generateListNumber() {
      this.layers.forEach((it, index2) => {
        it.no = index2;
        it.generateListNumber();
      });
    }
    convert(json = {}) {
      return json;
    }
    setCache() {
    }
    toCloneObject(isDeep = true) {
      const json = {};
      Object.keys(__privateGet(this, _json)).forEach((field) => {
        if (sapa.isNotUndefined(this.get(field))) {
          json[field] = sapa.clone(this.get(field));
        }
      });
      if (isDeep) {
        json.layers = this.layers.map((layer) => {
          return layer.clone(isDeep);
        });
      }
      return json;
    }
    clone(isDeep = true) {
      return __privateGet(this, _modelManager).clone(this.id, isDeep);
    }
    reset(obj2, context = { origin: "*" }) {
      var _a;
      __privateSet(this, _json, this.convert(Object.assign(__privateGet(this, _json), obj2)));
      __privateSet(this, _lastChangedField, obj2);
      if (context.origin === "*") {
        (_a = __privateGet(this, _modelManager)) == null ? void 0 : _a.setChanged("reset", this.id, obj2);
      }
      this.changed();
      return true;
    }
    hasChangedField(...args2) {
      return args2.some((it) => __privateGet(this, _lastChangedField)[it] !== void 0);
    }
    get hasChangedHirachy() {
      return this.hasChangedField("children", "parentId");
    }
    getDefaultObject(obj2 = {}) {
      var id = obj2.id || uuid();
      return __spreadValues({
        id,
        name: "",
        itemType: "base",
        children: [],
        parentId: "",
        visibility: "visible"
      }, obj2);
    }
    attrs(...args2) {
      const result = {};
      args2.forEach((field) => {
        if (sapa.isNotUndefined(this.get(field))) {
          result[field] = sapa.clone(this.get(field));
        }
      });
      return result;
    }
    attrsWithId(...args2) {
      return {
        [this.id]: this.attrs(...args2)
      };
    }
    hasChildren() {
      return this.children.length > 0;
    }
    appendChild(layer) {
      if (layer.parentId === this.id) {
        const hasId = this.children.find((it) => it === layer.id);
        if (Boolean(hasId) === false) {
          this.children.push(layer.id);
          __privateGet(this, _modelManager).setChanged("appendChild", this.id, {
            child: layer.id,
            oldParentId: layer.parentId
          });
        }
        return layer;
      }
      this.resetMatrix(layer);
      if (layer.parent) {
        layer.remove();
      }
      layer.setParentId(this.id);
      this.children.push(layer.id);
      return layer;
    }
    resetMatrix() {
    }
    refreshMatrixCache() {
    }
    insertChild(layer, index2 = 0) {
      var _a;
      this.resetMatrix(layer);
      if (layer.parent && ((_a = layer.parent) == null ? void 0 : _a.id) !== this.id) {
        layer.remove();
      }
      layer.setParentId(this.id);
      let list = this.children.map((id, childIndex) => {
        return { id, index: childIndex };
      });
      const childItem = list.find((it) => it.id === layer.id);
      const targetIndex = index2 - 0.5;
      if (childItem) {
        childItem.index = targetIndex;
      } else {
        list.push({ id: layer.id, index: targetIndex });
      }
      list.sort((a, b) => {
        return a.index - b.index;
      });
      this.reset({
        children: list.map((it) => it.id)
      });
      __privateGet(this, _modelManager).setChanged("insertChild", this.id, {
        childId: layer.id,
        index: 0
      });
      return layer;
    }
    insertAfter(layer) {
      this.parent.insertChild(layer, this.index + 1);
      return layer;
    }
    insertBefore(layer) {
      this.parent.insertChild(layer, this.index);
      return layer;
    }
    toggle(field, toggleValue) {
      if (sapa.isUndefined(toggleValue)) {
        this.reset({
          [field]: !this.get(field)
        });
      } else {
        this.reset({
          [field]: !!toggleValue
        });
      }
    }
    isTreeItemHide() {
      let currentParent = this.parent;
      let collapsedList = [];
      do {
        if (currentParent.is("project"))
          break;
        collapsedList.push(Boolean(currentParent.collapsed));
        currentParent = currentParent.parent;
      } while (currentParent);
      return Boolean(collapsedList.filter(Boolean).length);
    }
    expectJSON(key) {
      if (sapa.isUndefined(this.get(key)))
        return false;
      return true;
    }
    toJSON() {
      const json = __privateGet(this, _json);
      let newJSON = {};
      Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
        newJSON[key] = json[key];
      });
      if (this.hasChildren()) {
        newJSON.layers = this.layers.map((layer) => {
          return layer.toJSON();
        });
      }
      return newJSON;
    }
    resize() {
    }
    copy(dist2 = 0) {
      return this.parent.copyItem(this.id, dist2);
    }
    findIndex(child) {
      return this.children.indexOf(child.id);
    }
    find(id) {
      return __privateGet(this, _modelManager).get(id);
    }
    copyItem(childItemId, dist2 = 10) {
      const childItem = this.find(childItemId);
      var child = childItem.clone();
      child.renameWithCount();
      child.absoluteMove([dist2, dist2, 0]);
      var childIndex = this.findIndex(childItem);
      if (childIndex > -1) {
        this.children.push(child.id);
      }
      return child;
    }
    remove() {
      this.parent.removeChild(this.id);
    }
    removeChild(childItemId) {
      return __privateGet(this, _modelManager).removeChild(this.id, childItemId);
    }
    hasParent(findParentId) {
      return this.parentId === findParentId;
    }
    hasPathOf(targetItems = []) {
      const path = this.path;
      return targetItems.filter((it) => it.id !== this.id).some((target) => {
        return path.find((it) => it.id === target.id);
      });
    }
    hasChild(childId) {
      return this.children.includes(childId);
    }
    to() {
    }
    sendBackward(targetId) {
      const siblings = this.children;
      const result = {};
      let selectedIndex = -1;
      siblings.forEach((id, index2) => {
        result[id] = { id, index: index2 };
        if (id === targetId) {
          selectedIndex = index2;
        }
      });
      result[targetId].index = selectedIndex - 1.5;
      const children = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
      this.reset({
        children
      });
    }
    sendBack(targetId) {
      const siblings = this.children;
      const result = {};
      siblings.forEach((id, index2) => {
        result[id] = { id, index: index2 };
      });
      result[targetId].index = -1;
      const children = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
      this.reset({
        children
      });
    }
    bringForward(targetId) {
      const siblings = this.children;
      const result = {};
      let selectedIndex = -1;
      siblings.forEach((id, index2) => {
        result[id] = { id, index: index2 };
        if (id === targetId) {
          selectedIndex = index2;
        }
      });
      result[targetId].index = selectedIndex + 1.5;
      const children = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
      this.reset({
        children
      });
    }
    bringFront(targetId) {
      const siblings = this.children;
      const result = {};
      siblings.forEach((id, index2) => {
        result[id] = { id, index: index2 };
      });
      result[targetId].index = Number.MAX_SAFE_INTEGER;
      const children = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
      this.reset({
        children
      });
    }
  }
  _modelManager = new WeakMap();
  _json = new WeakMap();
  _cachedValue = new WeakMap();
  _timestamp = new WeakMap();
  _lastChangedField = new WeakMap();
  _collapsed = new WeakMap();
  class BaseAssetModel extends BaseModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        svgfilters: [],
        keyframes: []
      }, obj2));
    }
    get keyframes() {
      return this.get("keyframes");
    }
    get svgfilters() {
      return this.get("svgfilters");
    }
    addKeyframe(keyframe2) {
      this.keyframes.push(keyframe2);
      return keyframe2;
    }
    createKeyframe(data = {}) {
      return this.addKeyframe(new Keyframe(__spreadValues({
        checked: true
      }, data)));
    }
    removeKeyframe(removeIndex) {
      this.removePropertyList(this.keyframes, removeIndex);
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortKeyframe(startIndex, targetIndex) {
      this.sortItem(this.keyframes, startIndex, targetIndex);
    }
    updateKeyframe(index2, data = {}) {
      this.keyframes[+index2].reset(data);
    }
    toKeyframeString(isAnimate = false) {
      return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
    }
    copyPropertyList(arr, index2) {
      var copyObject = __spreadValues({}, arr[index2]);
      arr.splice(index2, 0, copyObject);
    }
    removePropertyList(arr, removeIndex) {
      arr.splice(removeIndex, 1);
    }
    getSVGFilterIndex(id) {
      var _a;
      var filter2 = this.svgfilters.map((it, index2) => {
        return { id: it.id, index: index2 };
      }).filter((it) => {
        return it.id === id;
      });
      return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
    }
    removeSVGFilter(removeIndex) {
      this.removePropertyList(this.svgfilters, removeIndex);
    }
    copySVGFilter(index2) {
      this.copyPropertyList(this.svgfilters, index2);
    }
    sortSVGFilter(startIndex, targetIndex) {
      this.sortItem(this.svgfilters, startIndex, targetIndex);
    }
    setSVGFilterValue(index2, value) {
      this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
    }
    addSVGFilter(obj2 = {}) {
      this.svgfilters.push(obj2);
      var index2 = this.svgfilters.length - 1;
      return index2;
    }
    createSVGFilter(data = {}) {
      return this.addSVGFilter(__spreadValues({
        id: uuidShort()
      }, data));
    }
  }
  class MovableModel extends BaseAssetModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        angle: 0,
        x: 0,
        y: 0,
        width: 300,
        height: 300,
        position: "absolute",
        perspective: "",
        perspectiveOrigin: "",
        transformOrigin: "50% 50% 0px"
      }, obj2));
    }
    get isAbsolute() {
      return this.position === "absolute";
    }
    get isDragSelectable() {
      return true;
    }
    get isBooleanItem() {
      return void 0;
    }
    get resizableWitChildren() {
      return false;
    }
    get perspective() {
      return this.get("perspective");
    }
    get perspectiveOrigin() {
      return this.get("perspectiveOrigin");
    }
    get transform() {
      return `rotateZ(${editor.Length.deg(this.angle)})`;
    }
    get localMatrix() {
      if (!this.hasCache("localTransform")) {
        this.addCache("localTransform", this.getLocalTransformMatrix());
      }
      return this.getCache("localTransform") || this.getLocalTransformMatrix();
    }
    get localMatrixInverse() {
      if (!this.hasCache("localTransformInverse")) {
        this.addCache("localTransformInverse", this.getLocalTransformMatrixInverse());
      }
      return this.getCache("localTransformInverse") || this.getLocalTransformMatrixInverse();
    }
    get transformWithTranslate() {
      if (!this.hasCache("transformWithTranslate")) {
        this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
      }
      return this.getCache("transformWithTranslate") || this.getTransformWithTranslate(this);
    }
    get transformWithTranslateToTranspose() {
      if (!this.hasCache("transformWithTranslateTranspose")) {
        this.addCache("transformWithTranslateTranspose", this.getTransformWithTranslate(this));
      }
      return this.getCache("transformWithTranslateTranspose") || transpose([], this.getTransformWithTranslate(this));
    }
    get transformWithTranslateInverse() {
      if (!this.hasCache("transformWithTranslateInverse")) {
        this.addCache("transformWithTranslateInverse", this.getTransformWithTranslate(this));
      }
      return this.getCache("transformWithTranslateInverse") || invert([], this.getTransformWithTranslate(this));
    }
    get itemMatrix() {
      if (!this.hasCache("itemTransform")) {
        this.addCache("itemTransform", this.getItemTransformMatrix());
      }
      return this.getCache("itemTransform") || this.getItemTransformMatrix();
    }
    get itemMatrixInverse() {
      if (!this.hasCache("itemTransformInverse")) {
        this.addCache("itemTransformInverse", this.getItemTransformMatrixInverse());
      }
      return this.getCache("itemTransformInverse") || this.getItemTransformMatrixInverse();
    }
    get absoluteMatrix() {
      if (!this.hasCache("absoluteMatrix")) {
        this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
      }
      return this.getCache("absoluteMatrix") || this.getAbsoluteMatrix();
    }
    get absoluteMatrixInverse() {
      if (!this.hasCache("absoluteMatrixInverse")) {
        this.addCache("absoluteMatrixInverse", this.getAbsoluteMatrixInverse());
      }
      return this.getCache("absoluteMatrixInverse") || this.getAbsoluteMatrixInverse();
    }
    get relativeMatrix() {
      if (!this.hasCache("relativeMatrix")) {
        this.addCache("relativeMatrix", this.getRelativeMatrix());
      }
      return this.getCache("relativeMatrix") || this.getRelativeMatrix();
    }
    get relativeMatrixInverse() {
      if (!this.hasCache("relativeMatrixInverse")) {
        this.addCache("relativeMatrixInverse", this.getRelativeMatrixInverse());
      }
      return this.getCache("relativeMatrixInverse") || this.getRelativeMatrixInverse();
    }
    get verties() {
      if (!this.hasCache("verties")) {
        this.addCache("verties", this.getVerties());
      }
      return this.getCache("verties") || this.getVerties();
    }
    get contentVerties() {
      if (!this.hasCache("contentVerties")) {
        this.addCache("contentVerties", this.getContentVerties());
      }
      return this.getCache("contentVerties") || this.getContentVerties();
    }
    get originVerties() {
      if (!this.hasCache("vertiesWithoutTransformOrigin")) {
        this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
      }
      return this.getCache("vertiesWithoutTransformOrigin") || this.rectVerties();
    }
    get localVerties() {
      if (!this.hasCache("localVerties")) {
        this.addCache("localVerties", this.getLocalVerties());
      }
      return this.getCache("localVerties") || this.getLocalVerties();
    }
    get guideVerties() {
      if (!this.hasCache("guideVerties")) {
        this.addCache("guideVerties", this.getGuideVerties());
      }
      return this.getCache("guideVerties") || this.getGuideVerties();
    }
    get xList() {
      if (!this.hasCache("xList")) {
        this.addCache("xList", this.getXList());
      }
      return this.getCache("xList") || this.getXList();
    }
    get yList() {
      if (!this.hasCache("yList")) {
        this.addCache("yList", this.getYList());
      }
      return this.getCache("yList") || this.getYList();
    }
    get areaPosition() {
      if (!this.hasCache("areaPosition")) {
        this.addCache("areaPosition", this.getAreaPosition(100));
      }
      return this.getCache("areaPosition") || this.getAreaPosition(100);
    }
    get offsetX() {
      return this.x;
    }
    get offsetY() {
      return this.y;
    }
    get screenWidth() {
      return this.width;
    }
    get screenHeight() {
      return this.height;
    }
    get y() {
      return this.get("y");
    }
    set y(value) {
      this.set("y", value);
    }
    get x() {
      return this.get("x");
    }
    set x(value) {
      this.set("x", value);
    }
    get width() {
      return this.get("width");
    }
    set width(value) {
      this.set("width", value);
    }
    get height() {
      return this.get("height");
    }
    set height(value) {
      this.set("height", value);
    }
    get angle() {
      return this.get("angle");
    }
    set angle(value) {
      this.set("angle", value);
    }
    get position() {
      return this.get("position");
    }
    set position(value) {
      this.set("position", value);
    }
    get transformOrigin() {
      return this.get("transformOrigin");
    }
    set transformOrigin(value) {
      this.reset({
        transformOrigin: value
      });
    }
    get translate() {
      return [0, 0, 0];
    }
    get scale() {
      return [1, 1, 1];
    }
    get rotate() {
      return [0, 0, degreeToRadian(this.angle)];
    }
    get origin() {
      return TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight);
    }
    get absoluteOrigin() {
      return vertiesMap([this.origin], this.absoluteMatrix)[0];
    }
    get quat() {
      return fromEuler(create$1(), 0, 0, this.angle);
    }
    getAreaPosition(areaSize = 100) {
      const verties = this.getVerties();
      const rect2 = toRectVerties(verties);
      const [startRow, startColumn] = area(rect2[0][0], rect2[0][1], areaSize);
      const [endRow, endColumn] = area(rect2[2][0], rect2[2][1], areaSize);
      return {
        column: [startColumn, endColumn],
        row: [startRow, endRow]
      };
    }
    reset(obj2, context = { origin: "*" }) {
      const isChanged = super.reset(obj2, context);
      if (this.hasChangedField("children", "x", "y", "width", "height", "boxModel", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal") || this.changedLayout) {
        this.refreshMatrixCache();
      }
      return isChanged;
    }
    changed() {
      super.changed();
      this.changedRect = this.hasChangedField("children", "x", "y", "width", "height", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal");
    }
    setParentId(otherParentId) {
      super.setParentId(otherParentId);
      this.refreshMatrixCache();
    }
    refreshMatrixCache() {
      this.setCacheItemTransformMatrix();
      this.setCacheLocalTransformMatrix();
      this.setCacheAbsoluteMatrix();
      this.setCacheLocalVerties();
      this.setCacheVerties();
      this.setCacheGuideVerties();
      this.setCacheAreaPosition();
      this.layers.forEach((it) => {
        it.refreshMatrixCache();
      });
    }
    setCacheItemTransformMatrix() {
      this.addCache("itemTransform", this.getItemTransformMatrix());
      this.addCache("itemTransformInverse", invert([], this.getCache("itemTransform")));
    }
    setCacheLocalTransformMatrix() {
      this.addCache("localTransform", this.getLocalTransformMatrix());
      this.addCache("localTransformInverse", invert([], this.getCache("localTransform")));
      this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
      this.addCache("transformWithTranslateInverse", invert([], this.getCache("transformWithTranslate")));
      this.addCache("transformWithTranslateTranspose", transpose([], this.getCache("transformWithTranslate")));
    }
    setCacheAbsoluteMatrix() {
      this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
      this.addCache("absoluteMatrixInverse", invert([], this.getCache("absoluteMatrix")));
      this.addCache("relativeMatrix", this.getRelativeMatrix());
      this.addCache("relativeMatrixInverse", invert([], this.getCache("relativeMatrix")));
    }
    setCacheVerties() {
      this.addCache("verties", this.getVerties());
      this.addCache("contentVerties", this.getContentVerties());
      this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
    }
    setCacheLocalVerties() {
      this.addCache("localVerties", this.getLocalVerties());
    }
    setCacheGuideVerties() {
      this.addCache("guideVerties", this.getGuideVerties());
      this.addCache("xList", this.getXList());
      this.addCache("yList", this.getYList());
    }
    setCacheAreaPosition() {
      this.addCache("areaPosition", this.getAreaPosition(100));
    }
    move(distVector = [0, 0, 0]) {
      this.reset({
        x: round(this.offsetX + distVector[0]),
        y: round(this.offsetY + distVector[1])
      });
    }
    moveByCenter(newCenter = [0, 0, 0]) {
      this.reset({
        x: newCenter[0] - this.screenWidth / 2,
        y: newCenter[1] - this.screenHeight / 2
      });
    }
    absoluteMove(absoluteDist = [0, 0, 0]) {
      var _a;
      const oldVertex = this.verties[4];
      const newVertex = add([], oldVertex, absoluteDist);
      const newVerties = vertiesMap([oldVertex, newVertex], ((_a = this.parent) == null ? void 0 : _a.absoluteMatrixInverse) || identity$2([]));
      const newDist = subtract([], newVerties[1], newVerties[0]);
      const oldPosition = this.attrs("x", "y");
      this.move(newDist);
      return oldPosition;
    }
    startToCacheChildren() {
    }
    recoverChildren() {
    }
    resize(width2, height) {
      this.startToCacheChildren();
      this.reset({ width: width2, height });
      this.recoverChildren();
    }
    setAngle(angle = 0) {
      this.reset({
        angle
      });
    }
    addAngle(angle = 0) {
      this.setAngle(this.angle + angle);
    }
    checkInArea(areaVerties) {
      return polyPoly(areaVerties, this.originVerties);
    }
    hasPoint(x, y) {
      return this.isPointInRect(x, y);
    }
    isPointInRect(x, y) {
      return polyPoint(this.originVerties, x, y);
    }
    isIncludeByArea(areaVerties) {
      return this.originVerties.map((vector) => {
        return polyPoint(areaVerties, ...vector);
      }).filter(Boolean).length === 4;
    }
    getPerspectiveMatrix() {
      const hasPerspective = this.perspective;
      if (!hasPerspective) {
        return void 0;
      }
      let [
        perspectiveOriginX = editor.Length.percent(50),
        perspectiveOriginY = editor.Length.percent(50)
      ] = TransformOrigin.parseStyle(this.perspectiveOrigin);
      const width2 = this.screenWidth;
      const height = this.screenHeight;
      perspectiveOriginX = perspectiveOriginX.toPx(width2).value;
      perspectiveOriginY = perspectiveOriginY.toPx(height).value;
      const view = create$4();
      translate(view, view, [perspectiveOriginX, perspectiveOriginY, 0]);
      if (this.perspective && this.perspective != "none") {
        multiply$1(view, view, fromValues$1(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1 / editor.Length.parse(this.perspective).value, 1));
      } else {
        return void 0;
      }
      translate(view, view, [-perspectiveOriginX, -perspectiveOriginY, 0]);
      return view;
    }
    getItemTransformMatrix() {
      const list = Transform.parseStyle(this.transform);
      const width2 = this.screenWidth;
      const height = this.screenHeight;
      return Transform.createTransformMatrix(list, width2, height);
    }
    getItemTransformMatrixInverse() {
      return invert([], this.getItemTransformMatrix());
    }
    getLocalTransformMatrix(width2, height) {
      const origin = TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", sapa.isUndefined(width2) ? this.screenWidth : width2, sapa.isUndefined(height) ? this.screenHeight : height);
      const view = create$4();
      translate(view, view, origin);
      multiply$1(view, view, this.itemMatrix);
      translate(view, view, negate([], origin));
      return view;
    }
    getLocalTransformMatrixInverse(width2, height) {
      return invert([], this.getLocalTransformMatrix(width2, height));
    }
    getDirectionTransformMatrix(vertexOffset, width2, height) {
      const x = this.offsetX;
      const y = this.offsetY;
      const center = add([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", width2, height), negate([], vertexOffset));
      const view = create$4();
      translate(view, view, [x, y, 0]);
      translate(view, view, vertexOffset);
      translate(view, view, center);
      multiply$1(view, view, this.itemMatrix);
      translate(view, view, negate([], center));
      return view;
    }
    getDirectionTopLeftMatrix(width2, height) {
      return this.getDirectionTransformMatrix([0, 0, 0], width2, height);
    }
    getDirectionLeftMatrix(width2, height) {
      return this.getDirectionTransformMatrix([0, height / 2, 0], width2, height);
    }
    getDirectionTopMatrix(width2, height) {
      return this.getDirectionTransformMatrix([width2 / 2, 0, 0], width2, height);
    }
    getDirectionBottomLeftMatrix(width2, height) {
      return this.getDirectionTransformMatrix([0, height, 0], width2, height);
    }
    getDirectionTopRightMatrix(width2, height) {
      return this.getDirectionTransformMatrix([width2, 0, 0], width2, height);
    }
    getDirectionRightMatrix(width2, height) {
      return this.getDirectionTransformMatrix([width2, height / 2, 0], width2, height);
    }
    getDirectionBottomRightMatrix(width2, height) {
      return this.getDirectionTransformMatrix([width2, height, 0], width2, height);
    }
    getDirectionBottomMatrix(width2, height) {
      return this.getDirectionTransformMatrix([width2 / 2, height, 0], width2, height);
    }
    getAbsoluteMatrix() {
      let transform2 = create$4();
      if (this.parent) {
        multiply$1(transform2, transform2, this.parent.absoluteMatrix);
        if (sapa.isFunction(this.parent.getPerspectiveMatrix)) {
          const perspectiveMatrix = this.parent.getPerspectiveMatrix();
          if (perspectiveMatrix) {
            multiply$1(transform2, transform2, perspectiveMatrix);
          }
        }
      }
      multiply$1(transform2, transform2, this.getRelativeMatrix());
      if (transform2.filter((it) => !isNaN(it)).length === 0) {
        return create$4();
      }
      return transform2;
    }
    getRelativeMatrix() {
      let transform2 = create$4();
      const offsetX = this.offsetX;
      const offsetY = this.offsetY;
      translate(transform2, transform2, [offsetX, offsetY, 0]);
      multiply$1(transform2, transform2, this.localMatrix);
      return transform2;
    }
    getRelativeMatrixInverse() {
      return invert([], this.getRelativeMatrix());
    }
    getTransformWithTranslate(item) {
      item = item || this;
      let view = create$4();
      const offsetX = item.offsetX;
      const offsetY = item.offsetY;
      translate(view, view, [offsetX, offsetY, 0]);
      multiply$1(view, view, item.localMatrix);
      return view;
    }
    getAbsoluteMatrixInverse() {
      return invert([], this.getAbsoluteMatrix());
    }
    getLocalVerties(width2, height) {
      width2 = sapa.isNotUndefined(width2) ? width2 : this.screenWidth;
      height = sapa.isNotUndefined(height) ? height : this.screenHeight;
      let model = rectToVerties(0, 0, width2, height, this.transformOrigin);
      return model;
    }
    getVerties(width2, height) {
      width2 = sapa.isNotUndefined(width2) ? width2 : this.screenWidth;
      height = sapa.isNotUndefined(height) ? height : this.screenHeight;
      let x = 0;
      let y = 0;
      if (this.parent && this.parent.is("project") === false) {
        const contentBox = this.parent.contentBox;
        x = contentBox.x;
        y = contentBox.y;
      }
      let model = rectToVerties(x, y, width2, height, this.transformOrigin);
      return vertiesMap(model, this.absoluteMatrix);
    }
    getContentVerties(width2, height) {
      width2 = sapa.isNotUndefined(width2) ? width2 : this.screenWidth;
      height = sapa.isNotUndefined(height) ? height : this.screenHeight;
      const center = TransformOrigin.scale(this.transformOrigin, width2, height);
      const paddingTop = this.get("padding-top") || 0;
      const paddingRight = this.get("padding-right") || 0;
      const paddingBottom = this.get("padding-bottom") || 0;
      const paddingLeft = this.get("padding-left") || 0;
      const model = rectToVerties(0 + paddingLeft, 0 + paddingTop, width2 - paddingLeft - paddingRight, height - paddingTop - paddingBottom, this.transformOrigin);
      model[4] = center;
      return vertiesMap(model, this.absoluteMatrix);
    }
    rectVerties() {
      return this.verties.filter((_, index2) => index2 < 4);
    }
    getGuideVerties() {
      const verties = this.originVerties;
      return [
        ...verties,
        lerp([], verties[0], verties[1], 0.5),
        lerp([], verties[1], verties[2], 0.5),
        lerp([], verties[2], verties[3], 0.5),
        lerp([], verties[3], verties[0], 0.5)
      ];
    }
    getXList() {
      return [...new Set(this.guideVerties.map((it) => it[0]))];
    }
    getYList() {
      return [...new Set(this.guideVerties.map((it) => it[1]))];
    }
    get nestedAngle() {
      if (this.parent) {
        return this.parent.nestedAngle + this.angle;
      }
      return this.angle || 0;
    }
    get toRectVerties() {
      return itemsToRectVerties([this]);
    }
    get matrix() {
      const id = this.id;
      const x = this.offsetX;
      const y = this.offsetY;
      const width2 = this.screenWidth;
      const height = this.screenHeight;
      const originalTransform = this.transform;
      const originalTransformOrigin = this.transformOrigin || "50% 50% 0px";
      const transformOriginMatrix = this.getTransformOriginMatrix();
      const transformOriginMatrixInverse = this.getTransformOriginMatrixInverse();
      const parentMatrix = this.parent.absoluteMatrix;
      const parentMatrixInverse = this.parent.absoluteMatrixInverse;
      const localMatrix = this.localMatrix;
      const localMatrixInverse = this.localMatrixInverse;
      const itemMatrix = this.itemMatrix;
      const itemMatrixInverse = this.itemMatrixInverse;
      const absoluteMatrix = this.absoluteMatrix;
      const absoluteMatrixInverse = this.absoluteMatrixInverse;
      const relativeMatrix = this.relativeMatrix;
      const relativeMatrixInverse = this.relativeMatrixInverse;
      const directionMatrix = {
        "to top left": this.getDirectionTopLeftMatrix(width2, height),
        "to top": this.getDirectionTopMatrix(width2, height),
        "to top right": this.getDirectionTopRightMatrix(width2, height),
        "to right": this.getDirectionRightMatrix(width2, height),
        "to bottom left": this.getDirectionBottomLeftMatrix(width2, height),
        "to bottom": this.getDirectionBottomMatrix(width2, height),
        "to bottom right": this.getDirectionBottomRightMatrix(width2, height),
        "to left": this.getDirectionLeftMatrix(width2, height)
      };
      const verties = this.verties;
      const xList = verties.map((it) => it[0]);
      const yList = verties.map((it) => it[1]);
      return {
        id,
        x,
        y,
        width: width2,
        height,
        transform: originalTransform,
        originalTransformOrigin,
        verties,
        originVerties: this.originVerties,
        xList,
        yList,
        directionMatrix,
        parentMatrix,
        parentMatrixInverse,
        localMatrix,
        localMatrixInverse,
        itemMatrix,
        itemMatrixInverse,
        absoluteMatrix,
        absoluteMatrixInverse,
        relativeMatrix,
        relativeMatrixInverse,
        transformOriginMatrix,
        transformOriginMatrixInverse
      };
    }
    absolutePath(pathString2 = "") {
      const d = pathString2 || this.d;
      const pathParser = new PathParser(d);
      pathParser.transformMat4(this.absoluteMatrix);
      return pathParser;
    }
    invertPath(pathString2 = "") {
      const path = new PathParser(pathString2);
      path.transformMat4(this.absoluteMatrixInverse);
      return path;
    }
    invertPoint(point2) {
      return transformMat4([], point2, this.absoluteMatrixInverse);
    }
    invertPathString(pathString2 = "") {
      return this.invertPath(pathString2).d;
    }
    updatePath(d) {
      const matrix = this.matrix;
      const newPath = new PathParser(d);
      let bbox = newPath.getBBox();
      const newWidth = distance$1(bbox[1], bbox[0]);
      const newHeight = distance$1(bbox[3], bbox[0]);
      let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), matrix.absoluteMatrix);
      let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
      const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), this.getLocalTransformMatrix(newWidth, newHeight));
      const realXY = getTranslation([], calculateMatrix(matrix.parentMatrixInverse, worldMatrix, invert([], this.getLocalTransformMatrix(newWidth, newHeight))));
      return {
        d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
        x: realXY[0],
        y: realXY[1],
        width: newWidth,
        height: newHeight
      };
    }
    checkInAreaForAll(areaVerties) {
      const items = [...this.checkInAreaForLayers(areaVerties)];
      if (this.is("artboard"))
        return items;
      if (this.is("project"))
        return items;
      if (this.checkInArea(areaVerties)) {
        items.push(this);
      }
      return items;
    }
    checkInAreaForLayers(areaVerties) {
      var items = [];
      this.layers.forEach((layer) => {
        items.push.apply(items, layer.checkInAreaForLayers(areaVerties));
        if (layer.checkInArea(areaVerties)) {
          items.push(layer);
        }
      });
      return items;
    }
    getTransformOriginMatrix() {
      return fromTranslation([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight));
    }
    getTransformOriginMatrixInverse() {
      return invert([], this.getTransformOriginMatrix());
    }
    recoverMatrix(newChildMatrix) {
      const matrix = calculateMatrix(this.absoluteMatrixInverse, newChildMatrix.absoluteMatrix);
      const q = getRotation([], matrix);
      const axis = [];
      const rad = getAxisAngle(axis, q);
      const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
      const newTransformMatrix = create$4();
      fromRotation(newTransformMatrix, rad, axis);
      const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(newChildMatrix.transformOriginMatrix, newTransformMatrix, newChildMatrix.transformOriginMatrixInverse)));
      return { x, y, angle };
    }
    resetMatrix(childItem) {
      const matrix = calculateMatrix(this.absoluteMatrixInverse, childItem.absoluteMatrix);
      const q = getRotation([], matrix);
      const axis = [];
      const rad = getAxisAngle(axis, q);
      const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
      const newTransformMatrix = create$4();
      fromRotation(newTransformMatrix, rad, axis);
      const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(childItem.getTransformOriginMatrix(), newTransformMatrix, childItem.getTransformOriginMatrixInverse())));
      childItem.reset({ x, y, angle });
      this.manager.setChanged("resetMatrix", this.id, {
        end: true,
        childItemId: childItem == null ? void 0 : childItem.id
      });
    }
    setOrder(targetIndex) {
      var parent = this.parent;
      var startIndex = this.index;
      if (startIndex > -1) {
        parent.children[startIndex] = parent.children[targetIndex];
        parent.children[targetIndex] = this.id;
        this.manager.setChanged("setOrder", this.id, {
          targetIndex,
          startIndex,
          parentId: parent.id
        });
      }
    }
    orderNext() {
      if (this.isLast) {
        if (this.parent.next) {
          let next = this.parent.next;
          if (next.enableHasChildren()) {
            next.appendChild(this);
          } else {
            next.insertAfter(this);
          }
        }
        return;
      }
      var startIndex = this.index;
      if (startIndex > -1) {
        this.setOrder(startIndex + 1);
      }
    }
    orderPrev() {
      if (this.isFirst) {
        const prev = this.parent.prev;
        if (prev) {
          prev.insertBefore(this);
        }
        return;
      }
      var startIndex = this.index;
      if (startIndex > 0) {
        this.setOrder(startIndex - 1);
      }
    }
    orderFirst() {
      this.setOrder(0);
    }
    orderLast() {
      this.setOrder(this.parent.childrenLength - 1);
    }
    orderTop() {
    }
    orderBottom() {
    }
  }
  const LayoutEngine = {
    [Layout.DEFAULT]: DefaultLayoutEngine,
    [Layout.GRID]: GridLayoutEngine
  };
  class GroupModel extends MovableModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        layout: Layout.DEFAULT,
        constraintsHorizontal: Constraints.NONE,
        constraintsVertical: Constraints.NONE,
        flexDirection: FlexDirection.ROW,
        flexWrap: FlexWrap.NOWRAP,
        justifyContent: JustifyContent.FLEX_START,
        alignItems: AlignItems.FLEX_START,
        alignContent: AlignContent.FLEX_START,
        order: 0,
        flexGrow: 0,
        flexShrink: 0,
        flexBasis: "auto",
        gap: 0,
        resizingHorizontal: ResizingMode.FIXED,
        resizingVertical: ResizingMode.FIXED,
        gridTemplateRows: "auto",
        gridColumnGap: "0px",
        gridTemplateColumns: "auto",
        gridRowGap: "0px",
        gridTemplateAreas: "",
        gridAutoRows: "auto",
        gridAutoColumns: "auto",
        gridAutoFlow: "row"
      }, obj2));
    }
    reset(obj2, context = { origin: "*" }) {
      const isChanged = super.reset(obj2, context);
      if (this.hasChangedField("resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal") || this.changedLayout) {
        this.refreshResizableCache();
      }
      return isChanged;
    }
    refreshResizableCache() {
      this.addCache("resizable", this.getAutoResizable());
    }
    get autoResizable() {
      return this.getCache("resizable");
    }
    getAutoResizable() {
      if (this.parent.is("project")) {
        return false;
      }
      if (this.resizingHorizontal === ResizingMode.FIXED && this.resizingVertical === ResizingMode.FIXED) {
        if (this.constraintsHorizontal === Constraints.NONE && this.constraintsVertical === Constraints.NONE) {
          return false;
        }
      }
      return true;
    }
    get layout() {
      return this.get("layout");
    }
    get constraintsHorizontal() {
      return this.get("constraintsHorizontal");
    }
    set constraintsHorizontal(value) {
      this.reset({
        constraintsHorizontal: value
      });
    }
    get constraintsVertical() {
      return this.get("constraintsVertical");
    }
    set constraintsVertical(value) {
      this.reset({
        constraintsVertical: value
      });
    }
    get flexDirection() {
      return this.get("flexDirection");
    }
    set flexDirection(value) {
      this.reset({
        flexDirection: value
      });
    }
    get flexWrap() {
      return this.get("flexWrap");
    }
    set flexWrap(value) {
      this.reset({
        flexWrap: value
      });
    }
    get justifyContent() {
      return this.get("justifyContent");
    }
    set justifyContent(value) {
      this.reset({
        justifyContent: value
      });
    }
    get alignItems() {
      return this.get("alignItems");
    }
    set alignItems(value) {
      this.reset({
        alignItems: value
      });
    }
    get alignContent() {
      return this.get("alignContent");
    }
    set alignContent(value) {
      this.reset({
        alignContent: value
      });
    }
    get order() {
      return this.get("order");
    }
    set order(value) {
      this.reset({
        order: value
      });
    }
    get flexGrow() {
      return this.get("flexGrow");
    }
    set flexGrow(value) {
      this.reset({
        flexGrow: value
      });
    }
    get flexShrink() {
      return this.get("flexShrink");
    }
    set flexShrink(value) {
      this.reset({
        flexShrink: value
      });
    }
    get flexBasis() {
      return this.get("flexBasis");
    }
    set flexBasis(value) {
      this.reset({
        flexBasis: value
      });
    }
    get gap() {
      return this.get("gap");
    }
    set gap(value) {
      this.reset({
        gap: value
      });
    }
    get resizingHorizontal() {
      return this.get("resizingHorizontal");
    }
    set resizingHorizontal(value) {
      this.reset({
        resizingHorizontal: value
      });
    }
    get resizingVertical() {
      return this.get("resizingVertical");
    }
    set resizingVertical(value) {
      this.reset({
        resizingVertical: value
      });
    }
    get gridTemplateRows() {
      return this.get("gridTemplateRows");
    }
    set gridTemplateRows(value) {
      this.reset({
        gridTemplateRows: value
      });
    }
    get gridColumnGap() {
      return this.get("gridColumnGap");
    }
    set gridColumnGap(value) {
      this.reset({
        gridColumnGap: value
      });
    }
    get gridTemplateColumns() {
      return this.get("gridTemplateColumns");
    }
    set gridTemplateColumns(value) {
      this.reset({
        gridTemplateColumns: value
      });
    }
    get gridRowGap() {
      return this.get("gridRowGap");
    }
    set gridRowGap(value) {
      this.reset({
        gridRowGap: value
      });
    }
    get gridTemplateAreas() {
      return this.get("gridTemplateAreas");
    }
    set gridTemplateAreas(value) {
      this.reset({
        gridTemplateAreas: value
      });
    }
    get gridAutoRows() {
      return this.get("gridAutoRows");
    }
    set gridAutoRows(value) {
      this.reset({
        gridAutoRows: value
      });
    }
    get gridAutoColumns() {
      return this.get("gridAutoColumns");
    }
    set gridAutoColumns(value) {
      this.reset({
        gridAutoColumns: value
      });
    }
    get gridAutoFlow() {
      return this.get("gridAutoFlow");
    }
    set gridAutoFlow(value) {
      this.reset({
        gridAutoFlow: value
      });
    }
    isLayoutItem() {
      var _a;
      return !!((_a = this.parent) == null ? void 0 : _a.hasLayout());
    }
    hasConstraints() {
      return this.isLayout(Layout.DEFAULT);
    }
    hasLayout() {
      return !this.hasConstraints() || Boolean(this.layout) === false;
    }
    isLayout(layout2) {
      return this.layout === layout2;
    }
    isInDefault() {
      var _a;
      const parentLayout = ((_a = this.parent) == null ? void 0 : _a.layout) || "default";
      return Layout.DEFAULT === parentLayout;
    }
    isInGrid() {
      return this.isInLayout(Layout.GRID);
    }
    isInFlex() {
      return this.isInLayout(Layout.FLEX);
    }
    isInLayout(layout2) {
      var _a;
      return ((_a = this.parent) == null ? void 0 : _a.layout) === layout2;
    }
    changeConstraints(direction, value, shiftKey = false) {
      const h = this.get(direction);
      let newConstraints = value;
      if (h === Constraints.MAX) {
        if (value === Constraints.MAX) {
          newConstraints = Constraints.SCALE;
        }
        if (shiftKey && value === Constraints.MIN) {
          newConstraints = Constraints.STRETCH;
        }
      } else if (h === Constraints.MIN) {
        if (value === Constraints.MIN) {
          newConstraints = Constraints.SCALE;
        } else if (shiftKey && value === Constraints.MAX) {
          newConstraints = Constraints.STRETCH;
        }
      } else if (h === Constraints.STRETCH) {
        if (value === Constraints.MIN) {
          newConstraints = Constraints.MAX;
        } else if (value === Constraints.MAX) {
          newConstraints = Constraints.MIN;
        }
      }
      this.reset({
        [direction]: newConstraints
      });
    }
    startToCacheChildren() {
      var _a;
      (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.startCache(this);
    }
    recoverChildren() {
      var _a;
      (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.recover(this);
    }
  }
  const editableList = [
    "appearance",
    "position",
    "right",
    "bottom",
    "rootVariable",
    "variable",
    "transform",
    "filter",
    "backdropFilter",
    "backgroundColor",
    "backgroundImage",
    "borderRadius",
    "border",
    "boxShadow",
    "clipPath",
    "color",
    "perspectiveOrigin",
    "transformOrigin",
    "transformStyle",
    "perspective",
    "mixBlendMode",
    "overflow",
    "opacity",
    "box-model",
    "layout",
    "flex-layout",
    "grid-layout",
    "animation",
    "transition",
    "pattern",
    "boolean-operation"
  ];
  const editableKeys = {};
  editableList.forEach(function(key) {
    editableKeys[key] = true;
  });
  class DomModel extends GroupModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        rootVariable: "",
        variable: "",
        color: "black",
        overflow: "visible",
        opacity: 1,
        pattern: "",
        selectors: [],
        svg: [],
        filter: [],
        backdropFilter: [],
        transition: [],
        animation: [],
        gridColumnStart: "",
        gridColumnEnd: "",
        gridRowStart: "",
        gridRowEnd: "",
        gridColumnGap: "",
        gridRowGap: ""
      }, obj2));
    }
    get gridColumnStart() {
      return this.get("gridColumnStart");
    }
    set gridColumnStart(value) {
      this.set("gridColumnStart", value);
    }
    get gridColumnEnd() {
      return this.get("gridColumnEnd");
    }
    set gridColumnEnd(value) {
      this.set("gridColumnEnd", value);
    }
    get gridRowStart() {
      return this.get("gridRowStart");
    }
    set gridRowStart(value) {
      this.set("gridRowStart", value);
    }
    get gridRowEnd() {
      return this.get("gridRowEnd");
    }
    set gridRowEnd(value) {
      this.set("gridRowEnd", value);
    }
    get gridColumnGap() {
      return this.get("gridColumnGap");
    }
    set gridColumnGap(value) {
      this.set("gridColumnGap", value);
    }
    get gridRowGap() {
      return this.get("gridRowGap");
    }
    set gridRowGap(value) {
      this.set("gridRowGap", value);
    }
    get pattern() {
      return this.get("pattern");
    }
    set pattern(value) {
      this.reset({
        pattern: value
      });
    }
    get selectors() {
      return this.get("selectors");
    }
    set selectors(value) {
      this.reset({
        selectors: value
      });
    }
    get svg() {
      return this.get("svg");
    }
    set svg(value) {
      this.reset({ svg: value });
    }
    get rootVariable() {
      return this.get("rootVariable");
    }
    set rootVariable(value) {
      this.reset({
        rootVariable: value
      });
    }
    get variable() {
      return this.get("variable");
    }
    set variable(value) {
      this.reset({
        variable: value
      });
    }
    get filter() {
      return this.get("filter");
    }
    set filter(value) {
      this.reset({
        filter: value
      });
    }
    get backdropFilter() {
      return this.get("backdropFilter");
    }
    set backdropFilter(value) {
      this.reset({
        backdropFilter: value
      });
    }
    get backgroundColor() {
      return this.get("backgroundColor");
    }
    set backgroundColor(value) {
      this.reset({
        backgroundColor: value
      });
    }
    get backgroundImage() {
      return this.get("backgroundImage");
    }
    set backgroundImage(value) {
      this.reset({
        backgroundImage: value
      });
    }
    get textClip() {
      return this.get("textClip");
    }
    set textClip(value) {
      this.reset({
        textClip: value
      });
    }
    get borderRadius() {
      return this.get("borderRadius");
    }
    set borderRadius(value) {
      this.reset({
        borderRadius: value
      });
    }
    get border() {
      return this.get("border");
    }
    set border(value) {
      this.reset({
        border: value
      });
    }
    get boxShadow() {
      return this.get("boxShadow");
    }
    set boxShadow(value) {
      this.reset({
        boxShadow: value
      });
    }
    get textShadow() {
      return this.get("textShadow");
    }
    set textShadow(value) {
      this.reset({
        textShadow: value
      });
    }
    get clipPath() {
      return this.get("clipPath");
    }
    set clipPath(value) {
      this.reset({
        clipPath: value
      });
    }
    get color() {
      return this.get("color");
    }
    set color(value) {
      this.reset({
        color: value
      });
    }
    get opacity() {
      return this.get("opacity");
    }
    set opacity(value) {
      this.reset({
        opacity: value
      });
    }
    get transformStyle() {
      return this.get("transformStyle");
    }
    set transformStyle(value) {
      this.reset({
        transformStyle: value
      });
    }
    get fontSize() {
      return this.get("fontSize");
    }
    set fontSize(value) {
      this.reset({
        fontSize: value
      });
    }
    get fontFamily() {
      return this.get("fontFamily");
    }
    set fontFamily(value) {
      this.reset({
        fontFamily: value
      });
    }
    get fontWeight() {
      return this.get("fontWeight");
    }
    set fontWeight(value) {
      this.reset({
        fontWeight: value
      });
    }
    get fontStyle() {
      return this.get("fontStyle");
    }
    set fontStyle(value) {
      this.reset({
        fontStyle: value
      });
    }
    get fontVariant() {
      return this.get("fontVariant");
    }
    set fontVariant(value) {
      this.reset({
        fontVariant: value
      });
    }
    get fontStretch() {
      return this.get("fontStretch");
    }
    set fontStretch(value) {
      this.reset({
        fontStretch: value
      });
    }
    get lineHeight() {
      return this.get("lineHeight");
    }
    set lineHeight(value) {
      this.reset({
        lineHeight: value
      });
    }
    get letterSpacing() {
      return this.get("letterSpacing");
    }
    set letterSpacing(value) {
      this.reset({
        letterSpacing: value
      });
    }
    get wordSpacing() {
      return this.get("wordSpacing");
    }
    set wordSpacing(value) {
      this.reset({
        wordSpacing: value
      });
    }
    get textDecoration() {
      return this.get("textDecoration");
    }
    set textDecoration(value) {
      this.reset({
        textDecoration: value
      });
    }
    get textAlign() {
      return this.get("textAlign");
    }
    set textAlign(value) {
      this.reset({
        textAlign: value
      });
    }
    get textTransform() {
      return this.get("textTransform");
    }
    set textTransform(value) {
      this.reset({
        textTransform: value
      });
    }
    get textOverflow() {
      return this.get("text-overflow");
    }
    set textOverflow(value) {
      this.reset({
        "text-overflow": value
      });
    }
    get textIndent() {
      return this.get("textIndent");
    }
    set textIndent(value) {
      this.reset({
        textIndent: value
      });
    }
    get mixBlendMode() {
      return this.get("mixBlendMode");
    }
    set mixBlendMode(value) {
      this.reset({
        mixBlendMode: value
      });
    }
    get visibility() {
      return this.get("visibility");
    }
    set visibility(value) {
      this.reset({
        visibility: value
      });
    }
    get zIndex() {
      return this.get("z-index");
    }
    set zIndex(value) {
      this.reset({
        "z-index": value
      });
    }
    get overflow() {
      return this.get("overflow");
    }
    set overflow(value) {
      this.reset({
        overflow: value
      });
    }
    get animation() {
      return this.get("animation");
    }
    set animation(value) {
      this.reset({
        animation: value
      });
    }
    get transition() {
      return this.get("transition");
    }
    set transition(value) {
      this.reset({
        transition: value
      });
    }
    get marginTop() {
      return this.get("marginTop");
    }
    set marginTop(value) {
      this.reset({
        marginTop: value
      });
    }
    get marginRight() {
      return this.get("marginRight");
    }
    set marginRight(value) {
      this.reset({
        marginRight: value
      });
    }
    get marginBottom() {
      return this.get("marginBottom");
    }
    set marginBottom(value) {
      this.reset({
        marginBottom: value
      });
    }
    get marginLeft() {
      return this.get("marginLeft");
    }
    set marginLeft(value) {
      this.reset({
        marginLeft: value
      });
    }
    get paddingTop() {
      return this.get("paddingTop");
    }
    set paddingTop(value) {
      this.reset({
        paddingTop: value
      });
    }
    get paddingRight() {
      return this.get("paddingRight");
    }
    set paddingRight(value) {
      this.reset({
        paddingRight: value
      });
    }
    get paddingBottom() {
      return this.get("paddingBottom");
    }
    set paddingBottom(value) {
      this.reset({
        paddingBottom: value
      });
    }
    get paddingLeft() {
      return this.get("paddingLeft");
    }
    set paddingLeft(value) {
      this.reset({
        paddingLeft: value
      });
    }
    editable(editablePropertyName) {
      switch (editablePropertyName) {
        case "svg-item":
        case "transformOrigin":
        case "perspective":
        case "perspectiveOrigin":
          return false;
      }
      return Boolean(editableKeys[editablePropertyName]);
    }
    get changedBoxModel() {
      return this.hasChangedField("marginTop", "marginLeft", "marginBottom", "marginRight", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom");
    }
    get changedFlexLayout() {
      return this.hasChangedField("flexDirection", "flexWrap", "justifyContent", "alignItems", "alignContent", "order", "flexBasis", "flexGrow", "flexShrink", "flexFlow");
    }
    get changedGridLayout() {
      return this.hasChangedField("gridTemplateRows", "gridTemplateColumns", "gridTemplateAreas", "gridAutoRows", "gridAutoColumns", "gridAutoFlow", "gridRowGap", "gridColumnGap", "gridRowStart", "gridRowEnd", "gridColumnStart", "gridColumnEnd", "gridArea");
    }
    get changedLayoutItem() {
      return this.hasChangedField("resizingHorizontal", "resizingVertical");
    }
    get changedLayout() {
      return this.hasChangedField("layout") || this.changedBoxModel || this.changedFlexLayout || this.changedGridLayout || this.changedLayoutItem;
    }
    addSelector(selector2) {
      this.selectors.push(selector2);
      return selector2;
    }
    createSelector(data = {}) {
      return this.addSelector(new Selector(__spreadValues({
        checked: true
      }, data)));
    }
    removePropertyList(arr, removeIndex) {
      arr.splice(removeIndex, 1);
    }
    removeSelector(removeIndex) {
      this.removePropertyList(this.selectors, removeIndex);
    }
    enableHasChildren() {
      return true;
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    updateSelector(index2, data = {}) {
      this.selectors[+index2].reset(data);
    }
    traverse(item, results, hasLayoutItem) {
      if (item.isAttribute())
        return;
      if (!hasLayoutItem && item.isLayoutItem() && !item.isRootItem())
        return;
      results.push(item);
      item.children.forEach((child) => {
        this.traverse(child, results);
      });
    }
    tree(hasLayoutItem) {
      var results = [];
      this.children.forEach((item) => {
        this.traverse(item, results, hasLayoutItem);
      });
      return results;
    }
    convert(json) {
      json = super.convert(json);
      if (json.padding) {
        json["paddingTop"] = editor.Length.parse(json.padding);
        json["paddingRight"] = editor.Length.parse(json.padding);
        json["paddingBottom"] = editor.Length.parse(json.padding);
        json["paddingLeft"] = editor.Length.parse(json.padding);
        delete json.padding;
      }
      return json;
    }
    reset(obj2, context = { origin: "*" }) {
      const isChanged = super.reset(obj2, context);
      if (this.hasChangedField("clipPath")) {
        this.setClipPathCache();
      }
      if (this.hasChangedField("width", "height")) {
        if (this.cacheClipPath) {
          const d = this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
          this.clipPath = `path(${d})`;
          this.modelManager.setChanged("reset", this.id, {
            clipPath: this.clipPath
          });
        }
      }
      if (this.hasChangedField("backgroundImage", "pattern")) {
        this.setBackgroundImageCache();
      }
      return isChanged;
    }
    setBackgroundImageCache() {
      let list = [];
      if (this.pattern) {
        const patternList = this.computed("pattern", (pattern) => {
          return Pattern.parseStyle(pattern).map((it) => {
            return BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS()));
          });
        });
        for (var i = 0, len2 = patternList.length; i < len2; i++) {
          list.push.apply(list, patternList[i]);
        }
      }
      if (this.backgroundImage) {
        const backgroundList = this.computed("backgroundImage", (backgroundImage2) => {
          return BackgroundImage.parseStyle(STRING_TO_CSS(backgroundImage2));
        });
        list.push.apply(list, backgroundList.filter((it) => it.visibility !== VisibilityType.HIDDEN));
      }
      if (list.length) {
        const project2 = this.top;
        this.cacheBackgroundImage = BackgroundImage.joinCSS(list);
        const cacheList = list.filter((it) => it.type === GradientType.URL).map((it) => it.image.url);
        let cacheImage = this.cacheBackgroundImage["background-image"];
        cacheList.forEach((url) => {
          const imageUrl = project2.getImageValueById(url);
          cacheImage = cacheImage.replace(url, `"${imageUrl}"`);
        });
        this.cacheBackgroundImage["background-image"] = cacheImage;
      } else {
        this.cacheBackgroundImage = {};
        this.cacheBackgroundImageOriginal = [];
      }
    }
    setClipPathCache() {
      var obj2 = ClipPath.parseStyle(this.clipPath);
      this.cacheClipPathObject = obj2;
      if (obj2.type === "path") {
        this.cacheClipPath = new PathParser(obj2.value.trim());
        this.cacheClipPathWidth = this.width;
        this.cacheClipPathHeight = this.height;
      }
    }
    setCache() {
      super.setCache();
      this.setClipPathCache();
    }
    get clipPathString() {
      if (!this.cacheClipPath) {
        this.setClipPathCache();
      }
      if (this.cacheClipPath) {
        return this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
      }
    }
    getBackgroundImage(index2) {
      const backgroundImages = BackgroundImage.parseStyle(STRING_TO_CSS(this.backgroundImage));
      return backgroundImages[index2 || 0];
    }
    get borderWidth() {
      const border2 = Border.parseStyle(this.border);
      const borderObject = Border.parseValue(border2.border);
      if (borderObject == null ? void 0 : borderObject.width) {
        return {
          borderLeftWidth: borderObject == null ? void 0 : borderObject.width,
          borderRightWidth: borderObject == null ? void 0 : borderObject.width,
          borderTopWidth: borderObject == null ? void 0 : borderObject.width,
          borderBottomWidth: borderObject == null ? void 0 : borderObject.width
        };
      }
      return {
        borderLeftWidth: 0,
        borderRightWidth: 0,
        borderTopWidth: 0,
        borderBottomWidth: 0
      };
    }
    get contentBox() {
      const x = 0;
      const y = 0;
      const width2 = this.screenWidth;
      const height = this.screenHeight;
      {
        const borderWidth = this.borderWidth;
        return {
          x: x + borderWidth.borderLeftWidth,
          y: y + borderWidth.borderTopWidth,
          width: width2 - borderWidth.borderLeftWidth - borderWidth.borderRightWidth,
          height: height - borderWidth.borderTopWidth - borderWidth.borderBottomWidth
        };
      }
    }
    getGradientLineLength(width2, height, angle) {
      return Math.abs(width2 * Math.sin(degreeToRadian(angle))) + Math.abs(height * Math.cos(degreeToRadian(angle)));
    }
    createBackgroundImageMatrix(index2) {
      const contentBox = this.contentBox;
      const backgroundImage2 = this.getBackgroundImage(index2);
      const { image: image2 } = backgroundImage2;
      const backRect = backgroundImage2.getOffset(contentBox);
      const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
      const result = {
        backRect,
        backVerties,
        absoluteMatrix: this.absoluteMatrix,
        backgroundImage: backgroundImage2
      };
      switch (image2.type) {
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          let [rx, ry] = image2.radialPosition;
          if (rx == "center")
            rx = editor.Length.percent(50);
          if (ry == "center")
            ry = editor.Length.percent(50);
          const newRx = rx.toPx(backRect.width);
          const newRy = ry.toPx(backRect.height);
          const centerVerties = vertiesMap([
            [newRx.value + backRect.x, newRy.value + backRect.y, 0],
            [newRx.value + backRect.x, newRy.value + backRect.y - 1, 0]
          ], this.absoluteMatrix);
          result.radialCenterPosition = centerVerties[0];
          result.radialCenterStick = centerVerties[1];
          result.radialCenterPoint = [newRx.value, newRy.value, 0];
          if (image2.type === GradientType.RADIAL || image2.type === GradientType.REPEATING_RADIAL) {
            const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
            const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
            result.radialCenterPosition = newStartPoint2;
            result.startPoint = newStartPoint2;
            result.endPoint = newEndPoint2;
            result.shapePoint = newShapePoint;
            result.colorsteps = image2.colorsteps.map((it) => {
              const offset = it.toLength();
              return {
                id: it.id,
                cut: it.cut,
                color: it.color,
                timing: it.timing,
                timingCount: it.timingCount,
                pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
              };
            });
          } else if (image2.type === GradientType.CONIC || image2.type === GradientType.REPEATING_CONIC) {
            const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
            const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
            result.radialCenterPosition = newStartPoint2;
            result.startPoint = newStartPoint2;
            result.endPoint = newEndPoint2;
            result.shapePoint = newShapePoint;
            [result.startPoint, result.endPoint, result.shapePoint] = vertiesMap([result.startPoint, result.endPoint, result.shapePoint], calculateRotationOriginMat4(image2.angle, result.radialCenterPosition));
            const targetPoint = result.shapePoint;
            result.colorsteps = image2.colorsteps.map((it) => {
              const angle = it.percent * 3.6;
              const [newPos] = vertiesMap([targetPoint], calculateRotationOriginMat4(angle, result.radialCenterPosition));
              return {
                id: it.id,
                cut: it.cut,
                color: it.color,
                timing: it.timing,
                timingCount: it.timingCount,
                pos: newPos
              };
            });
          }
          break;
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          result.gradientLineLength = this.getGradientLineLength(backRect.width, backRect.height, image2.angle);
          result.centerPosition = lerp([], backVerties[0], backVerties[2], 0.5);
          const startPoint = add([], result.centerPosition, [
            0,
            result.gradientLineLength / 2,
            0
          ]);
          const endPoint = subtract([], result.centerPosition, [
            0,
            result.gradientLineLength / 2,
            0
          ]);
          const areaStartPoint = clone(startPoint);
          const areaEndPoint = clone(endPoint);
          const [newStartPoint, newEndPoint, newAreaStartPoint, newAreaEndPoint] = vertiesMap([startPoint, endPoint, areaStartPoint, areaEndPoint], calculateRotationOriginMat4(image2.angle, result.centerPosition));
          result.endPoint = newEndPoint;
          result.startPoint = newStartPoint;
          result.areaStartPoint = newAreaStartPoint;
          result.areaEndPoint = newAreaEndPoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const offset = it.toLength();
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
            };
          });
          break;
      }
      return result;
    }
  }
  class LayerModel extends DomModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "layer",
        name: "New Layer",
        tagName: "div"
      }, obj2));
    }
    getDefaultTitle() {
      return "Layer";
    }
  }
  class ArtBoard extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "artboard",
        name: "New ArtBoard",
        width: 1e3,
        height: 1e3,
        backgroundColor: "white",
        transformStyle: "flat"
      }, obj2));
    }
    getDefaultTitle() {
      return "ArtBoard";
    }
    editable(editablePropertyName) {
      switch (editablePropertyName) {
        case "border":
        case "borderRadius":
          return false;
        case "artboardSize":
        case "layout":
          return true;
      }
      return super.editable(editablePropertyName);
    }
  }
  const IMAGE_LIST = ["jpg", "jpeg", "png", "gif", "svg"];
  class SVGImageResource extends ImageResource {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: "url",
        url: "",
        datauri: "",
        patternUnits: "userSpaceOnUse",
        patternWidth: "100%",
        patternHeight: "100%",
        imageX: "0%",
        imageY: "0%",
        imageWidth: "100%",
        imageHeight: "100%"
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri", "patternUnits", "patternWidth", "patternHeight", "imageX", "imageY", "imageWidth", "imageHeight"));
    }
    static parse(str) {
      var content2 = str.split("(")[1].split(")")[0];
      var [url, props] = content2.trim().split("#");
      if (!props) {
        return new SVGImageResource({ url });
      }
      var [
        patternUnits,
        patternWidth,
        patternHeight,
        imageX,
        imageY,
        imageWidth,
        imageHeight
      ] = props.split(",");
      return new SVGImageResource({
        patternUnits,
        patternWidth,
        patternHeight,
        imageX,
        imageY,
        imageWidth,
        imageHeight,
        url
      });
    }
    isUrl() {
      return true;
    }
    static isImageFile(fileExt) {
      return IMAGE_LIST.includes(fileExt);
    }
    toString() {
      var json = this.json;
      var {
        patternUnits,
        patternWidth,
        patternHeight,
        imageX,
        imageY,
        imageWidth,
        imageHeight,
        url
      } = json;
      var string = [
        patternUnits,
        patternWidth,
        patternHeight,
        imageX,
        imageY,
        imageWidth,
        imageHeight
      ].join(",").trim();
      return `url(${url}#${string})`;
    }
    toSVGString(id, item = {}) {
      var {
        patternUnits,
        patternWidth,
        patternHeight,
        imageX,
        imageY,
        imageWidth,
        imageHeight
      } = this.json;
      const localPatternWidth = editor.Length.parse(patternWidth);
      const localPatternHeight = editor.Length.parse(patternHeight);
      const localImageX = editor.Length.parse(imageX);
      const localImageY = editor.Length.parse(imageY);
      const localImageWidth = editor.Length.parse(imageWidth);
      const localImageHeight = editor.Length.parse(imageHeight);
      const width2 = item.width ? localPatternWidth.toPx(item.width).value : localPatternWidth;
      const height = item.height ? localPatternHeight.toPx(item.height).value : localPatternHeight;
      return `
  <pattern ${OBJECT_TO_PROPERTY({ id, patternUnits, width: width2, height })} >
    <image xlink:href="${this.json.datauri || this.json.url}" ${OBJECT_TO_PROPERTY({
        x: localImageX.toPx(item.width).value,
        y: localImageY.toPx(item.height).value,
        width: localImageWidth.toPx(item.width).value,
        height: localImageHeight.toPx(item.height).value,
        preserveAspectRatio: "none"
      })} />
  </pattern>
      `;
    }
    toFillValue(id) {
      return `url(#${id})`;
    }
  }
  class SVGGradient extends Gradient {
    toString() {
      return "";
    }
    toSVGString() {
      return "";
    }
    toFillValue() {
      return "";
    }
  }
  const SpreadMethodList$1 = [
    SpreadMethodType.PAD,
    SpreadMethodType.REFLECT,
    SpreadMethodType.REPEAT
  ];
  class SVGLinearGradient extends SVGGradient {
    convert(json) {
      json.spreadMethod = SpreadMethodList$1.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
      return json;
    }
    getDefaultObject(obj2) {
      return super.getDefaultObject(__spreadValues({
        type: GradientType.LINEAR,
        x1: editor.Length.parse("0%"),
        y1: editor.Length.parse("50%"),
        x2: editor.Length.parse("100%"),
        y2: editor.Length.parse("50%"),
        spreadMethod: SpreadMethodType.PAD
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("x1", "y1", "x2", "y2", "spreadMethod"));
    }
    toString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = this.getColorString();
      var { x1, y1, x2, y2, spreadMethod } = this.json;
      var opt = [x1, y1, x2, y2, spreadMethod].join(" ");
      var result = `${this.json.type}(${opt}, ${colorString})`;
      return result;
    }
    toSVGString(id) {
      var { x1, y1, x2, y2, spreadMethod } = this.json;
      return `
      <linearGradient 
        id="${id}"
        x1="${x1}"
        x2="${x2}"
        y1="${y1}"
        y2="${y2}"
        spreadMethod="${spreadMethod}"
      >
        ${SVGLinearGradient.makeColorStepList(this.colorsteps).map((it) => `
        <stop offset="${it.percent}%" stop-color="${it.color}"/>
      `).join("")}
      </linearGradient>
    `;
    }
    toFillValue(id) {
      return `url(#${id})`;
    }
    static parse(str) {
      const result = parseOneValue(str);
      var opt = {};
      const [options2, ...colors2] = result.parameters;
      const list = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD) {
          if (SpreadMethodList$1.includes(it.matchedString)) {
            opt.spreadMethod = it.matchedString;
          }
        } else {
          list.push(it);
        }
      });
      var [
        x1 = editor.Length.percent(0),
        y1 = editor.Length.percent(50),
        x2 = editor.Length.percent(100),
        y2 = editor.Length.percent(50)
      ] = list.map((it) => it.parsed);
      opt = __spreadProps(__spreadValues({}, opt), {
        x1,
        y1,
        x2,
        y2
      });
      const colorsteps = SVGLinearGradient.parseColorSteps(colors2);
      return new SVGLinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
    }
  }
  const RadialTypeList = [RadialGradientType.CIRCLE, RadialGradientType.ELLIPSE];
  const SpreadMethodList = [
    SpreadMethodType.PAD,
    SpreadMethodType.REFLECT,
    SpreadMethodType.REPEAT
  ];
  class SVGRadialGradient extends SVGGradient {
    convert(json) {
      json.spreadMethod = SpreadMethodList.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
      return json;
    }
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: GradientType.RADIAL,
        radialType: RadialGradientType.CIRCLE,
        x1: editor.Length.parse("50%"),
        y1: editor.Length.parse("50%"),
        x2: editor.Length.parse("100%"),
        y2: editor.Length.parse("50%"),
        x3: editor.Length.parse("50%"),
        y3: editor.Length.parse("100%"),
        spreadMethod: SpreadMethodType.PAD
      }, obj2));
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "x1", "y1", "x2", "y2", "x3", "y3", "spreadMethod"));
    }
    toString() {
      if (this.colorsteps.length === 0)
        return "";
      var colorString = this.getColorString();
      var { radialType, x1, y1, x2, y2, x3, y3, spreadMethod } = this.json;
      var opt = [radialType, x1, y1, x2, y2, x3, y3, spreadMethod].join(" ").trim();
      var result = `${this.json.type}(${opt}, ${colorString})`;
      return result;
    }
    getGradientAngle(contentBox = {}) {
      var { x1, y1, x2, y2 } = this.json;
      const newX1 = x1.toPx(contentBox.width);
      const newY1 = y1.toPx(contentBox.height);
      const newX2 = x2.toPx(contentBox.width);
      const newY2 = y2.toPx(contentBox.height);
      const angle = calculateAngle360(newX2.value - newX1.value, newY2.value - newY1.value) + 180;
      return angle % 360;
    }
    toSVGString(id, contentBox = {}) {
      var {
        x1: cx,
        y1: cy,
        x2,
        y2,
        x3,
        y3,
        spreadMethod,
        radialType
      } = this.json;
      const newX1 = cx.toPx(contentBox.width);
      const newY1 = cy.toPx(contentBox.height);
      const newX2 = x2.toPx(contentBox.width);
      const newY2 = y2.toPx(contentBox.height);
      var dist$1 = dist([newX1.value, newY1.value, 0], [newX2.value, newY2.value, 0]);
      var angle = this.getGradientAngle(contentBox);
      const view = create$5();
      multiply$2(view, view, fromTranslation$1([], [newX1.value, newY1.value]));
      multiply$2(view, view, fromRotation$1([], degreeToRadian(angle)));
      if (radialType === RadialGradientType.ELLIPSE) {
        const newX3 = x3.toPx(contentBox.width);
        const newY3 = y3.toPx(contentBox.height);
        var dist2 = dist([newX1.value, newY1.value, 0], [newX3.value, newY3.value, 0]);
        multiply$2(view, view, fromScaling$1([], [1, dist2 / dist$1]));
      }
      const gradientTransform = `matrix(${view[0]}, ${view[1]}, ${view[3]}, ${view[4]}, ${view[6]}, ${view[7]})`;
      return `
<radialGradient ${OBJECT_TO_PROPERTY({
        id,
        cx: 0,
        cy: 0,
        r: dist$1,
        spreadMethod,
        gradientUnits: "userSpaceOnUse",
        gradientTransform
      })} >
    ${SVGRadialGradient.makeColorStepList(this.colorsteps).map((it) => `
      <stop offset="${it.percent}%" stop-color="${it.color}"/>
    `).join("")}
</radialGradient>
`;
    }
    toFillValue(id) {
      return `url(#${id})`;
    }
    static parse(str) {
      const result = parseOneValue(str);
      var opt = {};
      const [options2, ...colors2] = result.parameters;
      const list = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD) {
          if (RadialTypeList.includes(it.matchedString)) {
            opt.radialType = it.matchedString;
          } else if (SpreadMethodList.includes(it.matchedString)) {
            opt.spreadMethod = it.matchedString;
          }
        } else {
          list.push(it);
        }
      });
      var [
        x1 = editor.Length.percent(50),
        y1 = editor.Length.percent(50),
        x2 = editor.Length.percent(100),
        y2 = editor.Length.percent(50),
        x3 = editor.Length.percent(50),
        y3 = editor.Length.percent(100)
      ] = list.map((it) => it.parsed);
      opt = __spreadProps(__spreadValues({}, opt), {
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      });
      const colorsteps = SVGRadialGradient.parseColorSteps(colors2);
      return new SVGRadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
    }
  }
  class SVGStaticGradient extends SVGGradient {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "static-gradient",
        colorsteps: [
          new ColorStep({ color: "red", percent: 0, index: 0 }),
          new ColorStep({ color: "red", percent: 100, index: 1 })
        ]
      });
    }
    toCloneObject() {
      return __spreadProps(__spreadValues({}, super.toCloneObject()), {
        static: true
      });
    }
    static create(color = "transparent") {
      return new SVGStaticGradient({
        colorsteps: [
          new ColorStep({ color, percent: 0, index: 0 }),
          new ColorStep({ color, percent: 100, index: 0 })
        ]
      });
    }
    setColor(color) {
      this.colorsteps.forEach((it) => {
        it.color = color;
      });
    }
    toString() {
      var color = this.json.colorsteps[0].color;
      return color;
    }
    toSVGString() {
      return "";
    }
    toFillValue() {
      return this.toString();
    }
  }
  class SVGFill extends PropertyItem {
    addImageResource(imageResource) {
      this.clear("image-resource");
      return this.addItem("image-resource", imageResource);
    }
    addGradient(gradient2) {
      return this.addImageResource(gradient2);
    }
    setImageUrl(data) {
      if (!data.images)
        return;
      if (!data.images.length)
        return;
      this.reset({
        type: "image",
        image: SVGFill.createImage(data.images[0])
      });
    }
    static createImage(url) {
      return new SVGLImageResource({ url });
    }
    setGradient(data) {
      this.reset({
        type: data.type,
        image: SVGFill.createGradient(data, this.json.image)
      });
    }
    static createGradient(data, gradient2) {
      const colorsteps = data.colorsteps || gradient2.colorsteps;
      let json = gradient2.toJSON();
      delete json.itemType;
      delete json.type;
      switch (data.type) {
        case GradientType.LINEAR:
          return new SVGLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
        case GradientType.RADIAL:
          return new SVGRadialGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
        default:
          return new SVGStaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      }
    }
    get image() {
      return this.json.image;
    }
    set image(image2) {
      this.json.image = image2;
    }
    static parse(obj2) {
      return new SVGFill(obj2);
    }
    static parseImage(str = "") {
      const result = parseOneValue(str);
      let image2 = null;
      if (!result) {
        return SVGStaticGradient.create(str || "transparent");
      }
      switch (result.func) {
        case GradientType.LINEAR:
          image2 = SVGLinearGradient.parse(result.matchedString);
          break;
        case GradientType.RADIAL:
          image2 = SVGRadialGradient.parse(result.matchedString);
          break;
        case GradientType.URL:
          image2 = SVGImageResource.parse(result.matchedString);
          break;
        default:
          image2 = SVGStaticGradient.create(result.matchedString);
          break;
      }
      return image2;
    }
    static changeImageType(options2) {
      switch (options2.type) {
        case GradientType.LINEAR:
          return new SVGLinearGradient(options2);
        case GradientType.RADIAL:
          return new SVGRadialGradient(options2);
        case "image-resource":
        case GradientType.URL:
          return new SVGImageResource(options2);
        default:
          return new SVGStaticGradient(options2);
      }
    }
  }
  const expectedProperties = [
    "appearance",
    "border",
    "borderRadius",
    "backgroundImage",
    "backdropFilter",
    "clipPath",
    "pattern",
    "boxShadow",
    "layout",
    "transform",
    "transformOrigin",
    "perspective",
    "perspectiveOrigin",
    "backdropFilter",
    "boxModel"
  ];
  const expectedPropertiesKeys = {};
  expectedProperties.forEach((key) => {
    expectedPropertiesKeys[key] = true;
  });
  class SVGModel extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "svg",
        name: "New SVG",
        elementType: "svg",
        overflow: "visible",
        stroke: "black",
        strokeWidth: 1,
        fill: "transparent",
        fillOpacity: 1,
        fillRule: "nonzero",
        textAnchor: "start",
        strokeLinecap: "",
        strokeLinejoin: "",
        strokeDasharray: [],
        strokeDashoffset: 0
      }, obj2));
    }
    get stroke() {
      return this.get("stroke");
    }
    set stroke(value) {
      this.set("stroke", value);
    }
    get strokeWidth() {
      return this.get("strokeWidth");
    }
    set strokeWidth(value) {
      this.set("strokeWidth", value);
    }
    get fill() {
      return this.get("fill");
    }
    set fill(value) {
      this.set("fill", value);
    }
    get fillOpacity() {
      return this.get("fillOpacity");
    }
    set fillOpacity(value) {
      this.set("fillOpacity", value);
    }
    get fillRule() {
      return this.get("fillRule");
    }
    set fillRule(value) {
      this.set("fillRule", value);
    }
    get textAnchor() {
      return this.get("textAnchor");
    }
    set textAnchor(value) {
      this.set("textAnchor", value);
    }
    get strokeDasharray() {
      return this.get("strokeDasharray");
    }
    set strokeDasharray(value) {
      this.set("strokeDasharray", value);
    }
    get strokeDashoffset() {
      return this.get("strokeDashoffset");
    }
    set strokeDashoffset(value) {
      this.set("strokeDashoffset", value);
    }
    get strokeLinejoin() {
      return this.get("strokeLinejoin");
    }
    set strokeLinejoin(value) {
      this.set("strokeLinejoin", value);
    }
    get strokeLinecap() {
      return this.get("strokeLinecap");
    }
    set strokeLinecap(value) {
      this.set("strokeLinecap", value);
    }
    get isDragSelectable() {
      return this.isBooleanItem === false;
    }
    get isBooleanItem() {
      return Boolean(this.parent.is("boolean-path"));
    }
    editable(editablePropertyName) {
      if (expectedPropertiesKeys[editablePropertyName]) {
        return false;
      }
      switch (editablePropertyName) {
        case "svg-item":
          return true;
      }
      return super.editable(editablePropertyName);
    }
    getDefaultTitle() {
      return "SVG";
    }
    isSVG() {
      return true;
    }
    hasPoint(x, y) {
      const fill = this.fill;
      const fillOpacity = this.fillOpacity;
      const strokeWidth = this.strokeWidth;
      const isTransparent = fill === "transparent" || fillOpacity === 0 || Color__namespace.parse(fill).a === 0;
      const isZeroStroke = strokeWidth === 0;
      if (isTransparent) {
        return this.isPointInStroke(x, y);
      } else if (!isTransparent && !isZeroStroke) {
        return this.isPointInStroke(x, y) || this.isPointInFill(x, y);
      } else if (!isTransparent && isZeroStroke) {
        return this.isPointInFill(x, y);
      }
      return false;
    }
    isPointInFill(x, y) {
      const svgEl = this.getCache("svgElement");
      const pathEl = this.getCache("pathElement");
      if (pathEl) {
        const [localX, localY] = this.invertPoint([x, y, 0]);
        const point2 = svgEl.createSVGPoint();
        Object.assign(point2, { x: localX, y: localY });
        return pathEl.isPointInFill(point2);
      }
      return false;
    }
    isPointInStroke(x, y) {
      const svgEl = this.getCache("svgElement");
      const pathEl = this.getCache("pathElement");
      if (pathEl) {
        const [localX, localY] = this.invertPoint([x, y, 0]);
        const point2 = svgEl.createSVGPoint();
        Object.assign(point2, { x: localX, y: localY });
        return pathEl.isPointInStroke(point2);
      }
      return false;
    }
    convertStrokeToPath(distX = 10, distY = 10) {
      const attrs = this.attrs("name", "width", "parentId", "height", "x", "y", "transform", "stroke");
      attrs.fill = attrs.stroke;
      delete attrs.stroke;
      return __spreadProps(__spreadValues({
        itemType: "svg-path",
        "fill-rule": "evenodd"
      }, attrs), {
        x: editor.Length.parse(attrs.x).add(distX),
        y: editor.Length.parse(attrs.y).add(distY)
      });
    }
    toSVGPath() {
      const attrs = this.toCloneObject();
      delete attrs.id;
      delete attrs.itemType;
      return __spreadProps(__spreadValues({}, attrs), {
        d: this.d
      });
    }
    createFragmentMatrix(field) {
      const value = this.get(field);
      const image2 = SVGFill.parseImage(value);
      const backRect = {
        x: 0,
        y: 0,
        width: this.screenWidth,
        height: this.screenHeight
      };
      const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
      const result = {
        backRect,
        backVerties,
        absoluteMatrix: this.absoluteMatrix,
        image: image2
      };
      let newX1, newY1, newX2, newY2, newX3, newY3;
      switch (image2.type) {
        case GradientType.RADIAL:
          newX1 = image2.x1.toPx(backRect.width);
          newY1 = image2.y1.toPx(backRect.height);
          newX2 = image2.x2.toPx(backRect.width);
          newY2 = image2.y2.toPx(backRect.height);
          newX3 = image2.x3.toPx(backRect.width);
          newY3 = image2.y3.toPx(backRect.height);
          const tempStartPoint = [newX1.value, newY1.value, 0];
          const tempEndPoint = [newX2.value, newY2.value, 0];
          const tempShapePoint = [newX3.value, newY3.value, 0];
          var [newStartPoint, newEndPoint, newShapePoint] = vertiesMap([tempStartPoint, tempEndPoint, tempShapePoint], this.absoluteMatrix);
          result.endPoint = newEndPoint;
          result.startPoint = newStartPoint;
          result.shapePoint = newShapePoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const offset = it.toLength();
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
            };
          });
          break;
        case GradientType.LINEAR:
          newX1 = image2.x1.toPx(backRect.width);
          newY1 = image2.y1.toPx(backRect.height);
          newX2 = image2.x2.toPx(backRect.width);
          newY2 = image2.y2.toPx(backRect.height);
          var [newStartPoint, newEndPoint] = vertiesMap([
            [newX1.value, newY1.value, 0],
            [newX2.value, newY2.value, 0]
          ], this.absoluteMatrix);
          result.endPoint = newEndPoint;
          result.startPoint = newStartPoint;
          result.areaStartPoint = clone(newStartPoint);
          result.areaEndPoint = clone(newEndPoint);
          result.colorsteps = image2.colorsteps.map((it) => {
            const offset = it.toLength();
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
            };
          });
          break;
      }
      return result;
    }
  }
  class PathModel extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "svg-path",
        name: "New Path",
        strokeWidth: 1,
        d: "",
        totalLength: 0
      }, obj2));
    }
    enableHasChildren() {
      return false;
    }
    reset(json, context = { origin: "*" }) {
      const isChanged = super.reset(json, context);
      if (this.hasChangedField("d")) {
        this.cachePath = new PathParser(this.d);
        this.cacheWidth = this.width;
        this.cacheHeight = this.height;
      }
      return isChanged;
    }
    refreshMatrixCache() {
      super.refreshMatrixCache();
      if (this.hasChangedField("d")) {
        this.addCache("pathString", new PathParser(this.get("d")));
        this.addCache("pathWidth", this.width);
        this.addCache("pathHeight", this.height);
      } else if (this.hasChangedField("width", "height")) {
        this.d = this.getCache("pathString").clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
        this.manager.setChanged("reset", this.id, { d: this.d });
      }
    }
    setCache() {
      super.setCache();
      this.addCache("pathString", new PathParser(this.get("d")));
      this.addCache("pathWidth", this.width);
      this.addCache("pathHeight", this.height);
    }
    get d() {
      if (!this.get("d")) {
        return null;
      }
      if (!this.hasCache("pathString")) {
        this.addCache("pathString", new PathParser(this.get("d")));
        this.addCache("pathWidth", this.width);
        this.addCache("pathHeight", this.height);
      }
      return this.getCache("pathString").clone().scale(this.width / this.getCache("pathWidth"), this.height / this.getCache("pathHeight")).d;
    }
    set d(value) {
      this.set("d", value);
    }
    getDefaultTitle() {
      return "Path";
    }
  }
  class BooleanPathModel extends PathModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "boolean-path",
        name: "New Boolean Path",
        strokeWidth: 1,
        d: "",
        booleanOperation: "none"
      }, obj2));
    }
    get booleanOperation() {
      return this.get("booleanOperation");
    }
    set booleanOperation(value) {
      this.set("booleanOperation", value);
    }
    enableHasChildren() {
      return true;
    }
    reset(json, context = { origin: "*" }) {
      var _a;
      const isChanged = super.reset(json, context);
      if (!this.cachePath) {
        this.setCache();
      }
      if (this.hasChangedField("changedChildren", "booleanOperation")) {
        if (this.children.length === 1) {
          const newPath = this.layers[0].absolutePath().d;
          this.d = this.invertPath(newPath).d;
          this.setCache();
          this.modelManager.setChanged("reset", this.id, { d: newPath });
        } else if (this.booleanOperation !== "none") {
          if (((_a = this.children) == null ? void 0 : _a.length) >= 2) {
            if (this.modelManager.editor.pathKitManager.has()) {
              const paths = this.layers.filter((it) => it.d);
              if (paths.length >= 2) {
                const newPath = this.doBooleanOperation();
                this.d = newPath;
                this.setCache();
                this.modelManager.setChanged("reset", this.id, { d: newPath });
              } else {
                this.d = void 0;
                this.removeCache();
                this.modelManager.setChanged("reset", this.id, { d: void 0 });
              }
            }
          }
        }
      }
      return isChanged;
    }
    get resizableWitChildren() {
      return true;
    }
    startToCacheChildren() {
      this.cachedSize = {
        width: this.width,
        height: this.height
      };
      this.cachedLayerMatrix = this.layers.map((item) => {
        item.startToCacheChildren();
        return {
          item,
          matrix: item.matrix
        };
      });
    }
    recoverChildren() {
      const obj2 = {
        width: this.width,
        height: this.height
      };
      const scaleX = obj2.width / this.cachedSize.width;
      const scaleY = obj2.height / this.cachedSize.height;
      this.cachedLayerMatrix.forEach(({ item, matrix }) => {
        item.reset({
          x: item.x.changeUnitValue(matrix.x * scaleX, obj2.width),
          y: item.y.changeUnitValue(matrix.y * scaleY, obj2.height),
          width: item.width.changeUnitValue(matrix.width * scaleX, obj2.width),
          height: item.height.changeUnitValue(matrix.height * scaleY, obj2.height)
        });
        item.recoverChildren();
      });
    }
    getFieldValueByBooleanOperation(field) {
      const layers = this.layers;
      if (layers.length === 0) {
        return;
      } else if (layers.length === 1) {
        return layers[0][field];
      }
      const op = this.booleanOperation;
      switch (op) {
        case BooleanOperation.DIFFERENCE:
          return layers[1][field];
      }
      return layers[0][field];
    }
    get fill() {
      return this.getFieldValueByBooleanOperation("fill");
    }
    get stroke() {
      return this.getFieldValueByBooleanOperation("stroke");
    }
    setCache() {
      super.setCache();
      this.cachePath = new PathParser(this.d);
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    removeCache() {
      super.removeCache();
      this.cachePath = void 0;
      this.cacheWidth = void 0;
      this.cacheHeight = void 0;
    }
    getDefaultTitle() {
      return "Path";
    }
    doBooleanOperation() {
      const op = this.booleanOperation;
      switch (op) {
        case BooleanOperation.INTERSECTION:
          return this.intersection();
        case BooleanOperation.UNION:
          return this.union();
        case BooleanOperation.DIFFERENCE:
          return this.difference();
        case BooleanOperation.REVERSE_DIFFERENCE:
          return this.reverseDifference();
        case BooleanOperation.XOR:
          return this.xor();
      }
      return "";
    }
    getPathList() {
      return this.layers.map((it) => it.absolutePath().d);
    }
    intersection() {
      const [first, ...rest] = this.getPathList();
      const newPath = rest.reduce((path1, path2) => {
        return this.modelManager.editor.pathKitManager.intersection(path1, path2);
      }, first);
      return this.invertPath(newPath).d;
    }
    union() {
      const [first, ...rest] = this.getPathList();
      const newPath = rest.reduce((path1, path2) => {
        return this.modelManager.editor.pathKitManager.union(path1, path2);
      }, first);
      return this.invertPath(newPath).d;
    }
    difference() {
      const [first, ...rest] = this.getPathList();
      const newPath = rest.reduce((path1, path2) => {
        return this.modelManager.editor.pathKitManager.difference(path1, path2);
      }, first);
      return this.invertPath(newPath).d;
    }
    reverseDifference() {
      const [first, ...rest] = this.getPathList();
      const newPath = rest.reduce((path1, path2) => {
        return this.modelManager.editor.pathKitManager.reverseDifference(path1, path2);
      }, first);
      return this.invertPath(newPath).d;
    }
    xor() {
      const [first, ...rest] = this.getPathList();
      const newPath = rest.reduce((path1, path2) => {
        return this.modelManager.editor.pathKitManager.xor(path1, path2);
      }, first);
      return this.invertPath(newPath).d;
    }
  }
  class CircleLayer extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "circle",
        name: "New Circle",
        borderRadius: "100%"
      }, obj2));
    }
    getDefaultTitle() {
      return "Circle";
    }
  }
  class ImageLayer extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "image",
        name: "New Image",
        elementType: "image",
        src: ""
      }, obj2));
    }
    get src() {
      return this.get("src");
    }
    set src(value) {
      this.set("src", value);
    }
    get naturalWidth() {
      return this.get("naturalWidth");
    }
    set naturalWidth(value) {
      this.set("naturalWidth", value);
    }
    get naturalHeight() {
      return this.get("naturalHeight");
    }
    set naturalHeight(value) {
      this.set("naturalHeight", value);
    }
    enableHasChildren() {
      return false;
    }
    getDefaultTitle() {
      return "Image";
    }
    resize() {
      this.reset({
        width: this.naturalWidth.clone(),
        height: this.naturalHeight.clone()
      });
    }
  }
  class PolygonModel extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "polygon",
        name: "New Polygon",
        strokeWidth: 1,
        count: 3
      }, obj2));
    }
    get count() {
      return this.get("count");
    }
    set count(value) {
      this.set("count", value);
    }
    convert(json) {
      json = super.convert(json);
      if (json.count)
        json.count = +json.count;
      return json;
    }
    enableHasChildren() {
      return false;
    }
    get editablePath() {
      return false;
    }
    get d() {
      const { width: width2, height, count } = this;
      return PathParser.makePolygon(width2, height, count).d;
    }
    getDefaultTitle() {
      return "Polygon";
    }
    isPointInPath(point2) {
      const localPoint = transformMat4([], point2, this.absoluteMatrixInverse);
      return this.cachePath.isPointInPath({ x: localPoint[0], y: localPoint[1] }, this.strokeWidth || 0);
    }
  }
  class AssetModel extends BaseModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        comments: [],
        colors: [],
        gradients: [],
        svgfilters: [],
        svgimages: [],
        keyframes: [],
        images: [],
        imageKeys: [],
        videos: [],
        videoKeys: [],
        audios: []
      }, obj2));
    }
    get comments() {
      return this.get("comments");
    }
    get colors() {
      return this.get("colors");
    }
    get gradients() {
      return this.get("gradients");
    }
    get svgfilters() {
      return this.get("svgfilters");
    }
    get svgimages() {
      return this.get("svgimages");
    }
    get keyframes() {
      return this.get("keyframes");
    }
    get videos() {
      return this.get("videos");
    }
    get images() {
      return this.get("images");
    }
    set images(value) {
      this.set("images", value);
    }
    get imageKeys() {
      return this.get("imageKeys");
    }
    get videoKeys() {
      return this.get("videoKeys");
    }
    addKeyframe(keyframe2) {
      this.keyframes.push(keyframe2);
      return keyframe2;
    }
    createKeyframe(data = {}) {
      return this.addKeyframe(new Keyframe(__spreadValues({
        checked: true
      }, data)));
    }
    removeKeyframe(removeIndex) {
      this.removePropertyList(this.keyframes, removeIndex);
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortKeyframe(startIndex, targetIndex) {
      this.sortItem(this.keyframes, startIndex, targetIndex);
    }
    updateKeyframe(index2, data = {}) {
      this.keyframes[+index2].reset(data);
    }
    toKeyframeString(isAnimate = false) {
      return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
    }
    copyPropertyList(arr, index2) {
      var copyObject = __spreadValues({}, arr[index2]);
      arr.splice(index2, 0, copyObject);
    }
    removePropertyList(arr, removeIndex) {
      arr.splice(removeIndex, 1);
    }
    removeColor(removeIndex) {
      this.removePropertyList(this.colors, removeIndex);
    }
    copyColor(index2) {
      this.copyPropertyList(this.colors, index2);
    }
    sortColor(startIndex, targetIndex) {
      this.sortItem(this.colors, startIndex, targetIndex);
    }
    setColorValue(index2, value = {}) {
      this.colors[index2] = __spreadValues(__spreadValues({}, this.colors[index2]), value);
    }
    getColorIndex(index2) {
      return this.colors[index2];
    }
    getColor(name) {
      return this.colors.filter((item) => item.name === name)[0];
    }
    addColor(obj2) {
      this.colors.push(obj2);
      return obj2;
    }
    createColor(data = {}) {
      return this.addColor(data);
    }
    removeImage(removeIndex) {
      this.removePropertyList(this.images, removeIndex);
      this.refreshImageKeys();
    }
    copyImage(index2) {
      this.copyPropertyList(this.images, index2);
      this.refreshImageKeys();
    }
    sortImage(startIndex, targetIndex) {
      this.sortItem(this.images, startIndex, targetIndex);
    }
    setImageValue(index2, value = {}) {
      this.images[index2] = __spreadValues(__spreadValues({}, this.images[index2]), value);
      this.refreshImageKeys();
    }
    getImageValueById(id, defaultValue = "") {
      const image2 = this.imageKeys[id];
      if (!image2)
        return id || defaultValue;
      return image2.local;
    }
    getImageDataURIById(id) {
      const image2 = this.imageKeys[id];
      if (!image2)
        return void 0;
      return image2.original;
    }
    refreshImageKeys() {
      let imageKeys = {};
      this.images.forEach((it) => {
        imageKeys[it.id] = it;
      });
      this.reset({
        imageKeys
      });
    }
    addImage(obj2) {
      this.images.push(obj2);
      this.refreshImageKeys();
      return obj2;
    }
    createImage(data = {}) {
      return this.addImage(data);
    }
    removeVideo(removeIndex) {
      this.removePropertyList(this.videos, removeIndex);
      this.refreshVideoKeys();
    }
    copyVideo(index2) {
      this.copyPropertyList(this.videos, index2);
      this.refreshVideoKeys();
    }
    sortVideo(startIndex, targetIndex) {
      this.sortItem(this.videos, startIndex, targetIndex);
    }
    setVideoValue(index2, value = {}) {
      this.videos[index2] = __spreadValues(__spreadValues({}, this.videos[index2]), value);
    }
    getVideoValueById(id) {
      const video2 = this.videoKeys[id];
      if (!video2)
        return void 0;
      return video2.local;
    }
    refreshVideoKeys() {
      let videoKeys = {};
      this.videos.forEach((it) => {
        videoKeys[it.id] = it;
      });
      this.reset({
        videoKeys
      });
    }
    addVideo(obj2) {
      this.videos.push(obj2);
      this.refreshVideoKeys();
      return obj2;
    }
    createVideo(data = {}) {
      return this.addVideo(data);
    }
    removeGradient(removeIndex) {
      this.removePropertyList(this.gradients, removeIndex);
    }
    copyGradient(index2) {
      this.copyPropertyList(this.gradients, index2);
    }
    sortGradient(startIndex, targetIndex) {
      this.sortItem(this.gradients, startIndex, targetIndex);
    }
    setGradientValue(index2, value) {
      this.gradients[index2] = __spreadValues(__spreadValues({}, this.gradients[index2]), value);
    }
    getGradientIndex(index2) {
      return this.gradients[index2];
    }
    getGradient(name) {
      return this.gradients.filter((item) => item.name === name)[0];
    }
    addGradient(obj2 = {}) {
      this.gradients.push(obj2);
      return obj2;
    }
    createGradient(data = {}) {
      return this.addGradient(data);
    }
    getSVGFilterIndex(id) {
      var _a;
      var filter2 = this.svgfilters.map((it, index2) => {
        return { id: it.id, index: index2 };
      }).filter((it) => {
        return it.id === id;
      });
      return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
    }
    removeSVGFilter(removeIndex) {
      this.removePropertyList(this.svgfilters, removeIndex);
    }
    copySVGFilter(index2) {
      this.copyPropertyList(this.svgfilters, index2);
    }
    sortSVGFilter(startIndex, targetIndex) {
      this.sortItem(this.svgfilters, startIndex, targetIndex);
    }
    setSVGFilterValue(index2, value) {
      this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
    }
    addSVGFilter(obj2 = {}) {
      this.svgfilters.push(obj2);
      var index2 = this.svgfilters.length - 1;
      return index2;
    }
    createSVGFilter(data = {}) {
      return this.addSVGFilter(data);
    }
    getSVGImageIndex(id) {
      var filter2 = this.svgimages.map((it, index2) => {
        return { id: it.id, index: index2 };
      }).filter((it) => {
        return it.id === id;
      })[0];
      return filter2 ? filter2.index : -1;
    }
    removeSVGImage(removeIndex) {
      this.removePropertyList(this.svgimages, removeIndex);
    }
    copySVGImage(index2) {
      this.copyPropertyList(this.svgimages, index2);
    }
    sortSVGImage(startIndex, targetIndex) {
      this.sortItem(this.svgimages, startIndex, targetIndex);
    }
    setSVGImageValue(index2, value) {
      this.svgimages[index2] = __spreadValues(__spreadValues({}, this.svgimages[index2]), value);
    }
    addSVGImage(obj2 = {}) {
      this.svgimages.push(obj2);
      var index2 = this.svgimages.length - 1;
      return index2;
    }
    createSVGImage(data = {}) {
      return this.addSVGImage(data);
    }
  }
  const identity = create$4();
  class Project extends AssetModel {
    getDefaultTitle() {
      return "New Project";
    }
    get isAbsolute() {
      return false;
    }
    get parent() {
      return null;
    }
    get nestedAngle() {
      return 0;
    }
    toRootVariableCSS() {
      var obj2 = {};
      this.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
        var [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    }
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "project",
        name: "new Project",
        description: "",
        rootVariable: ""
      }, obj2));
    }
    get description() {
      return this.get("description");
    }
    set description(value) {
      this.set("description", value);
    }
    get rootVariable() {
      return this.get("rootVariable");
    }
    set rootVariable(value) {
      this.set("rootVariable", value);
    }
    get artboards() {
      return (this.layers || []).filter((it) => it.is("artboard"));
    }
    get offsetX() {
      return 0;
    }
    get offsetY() {
      return 0;
    }
    get screenWidth() {
      return 0;
    }
    get screenHeight() {
      return 0;
    }
    isLayoutItem() {
      return false;
    }
    hasLayout() {
      return false;
    }
    getAbsoluteMatrix() {
      return create$4();
    }
    getTransformMatrix() {
      return create$4();
    }
    resetMatrix(childItem) {
      const [x, y] = getTranslation([], calculateMatrix(childItem.absoluteMatrix, childItem.localMatrixInverse));
      childItem.reset({
        x,
        y
      });
    }
    get rectVerties() {
      var _a;
      return ((_a = this.layers) == null ? void 0 : _a.length) ? itemsToRectVerties(this.layers) : null;
    }
    get absoluteMatrix() {
      return identity;
    }
    get absoluteMatrixInverse() {
      return identity;
    }
    get contentBox() {
      return {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      };
    }
  }
  class RectLayer extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "rect",
        name: "New Rect"
      }, obj2));
    }
    getDefaultTitle() {
      return "Rect";
    }
  }
  var isNdarray$2 = function(arr) {
    if (!arr)
      return false;
    if (!arr.dtype)
      return false;
    var re = new RegExp("function View[0-9]+d(:?" + arr.dtype + ")+");
    return re.test(String(arr.constructor));
  };
  var isNdarrayLike$3 = function(arr) {
    if (!arr)
      return false;
    return arr.data !== void 0 && Array.isArray(arr.shape) && arr.offset !== void 0 && arr.stride !== void 0;
  };
  var isArrayLike$5 = function isArrayLike2(data) {
    return Array.isArray(data) || ArrayBuffer.isView(data);
  };
  var isNdarray$1 = isNdarray$2;
  var isNdarrayLike$2 = isNdarrayLike$3;
  var isArrayLike$4 = isArrayLike$5;
  function inferType$5(x) {
    if (!x) {
      return void 0;
    }
    if (isNdarray$1(x) || isNdarrayLike$2(x)) {
      if (x.dtype === "generic") {
        return inferType$5.GENERIC_NDARRAY;
      }
      return inferType$5.NDARRAY;
    } else {
      if (isArrayLike$4(x)) {
        return inferType$5.ARRAY_OF_ARRAYS;
      }
      throw new Error("Unhandled data type. Got type: " + typeof x);
    }
  }
  inferType$5.ARRAY_OF_ARRAYS = "Arr";
  inferType$5.NDARRAY = "Nd";
  inferType$5.GENERIC_NDARRAY = "GenNd";
  inferType$5.PACKED = "PackArr";
  var inferType_1 = inferType$5;
  var isArrayLike$3 = isArrayLike$5;
  function capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
  }
  var cacheKey = function(nurbs2, debug, checkBounds, pointType, weightType, knotType) {
    var d;
    var degreeParts = [];
    var hasAnyKnots = false;
    for (d = 0; d < nurbs2.splineDimension; d++) {
      var hasKnots = isArrayLike$3(nurbs2.knots) && isArrayLike$3(nurbs2.knots[d]);
      if (hasKnots)
        hasAnyKnots = true;
      degreeParts.push("Deg" + nurbs2.degree[d] + (hasKnots ? "" : "Uniform") + capitalize(nurbs2.boundary[d]));
    }
    var parts = [
      [
        hasAnyKnots ? "NU" : "",
        nurbs2.weights ? "RBS" : "BS"
      ].join("") + nurbs2.dimension + "D",
      degreeParts.join("_")
    ];
    if (pointType) {
      parts.push(pointType + "Pts");
    }
    if (weightType) {
      parts.push(weightType + "Wts");
    }
    if (knotType) {
      parts.push(knotType + "Kts");
    }
    if (debug) {
      parts.push("debug");
    }
    if (checkBounds) {
      parts.push("chk");
    }
    return parts.join("_");
  };
  var createVariable$1 = function createVariable2(name, nurbs2) {
    return function(i, period) {
      if (i !== void 0 && !Array.isArray(i))
        i = [i];
      var dimAccessors = [];
      for (var j = 0; j < i.length; j++) {
        dimAccessors.push(createVariable2.sum(i[j]));
      }
      if (period) {
        for (i = 0; i < dimAccessors.length; i++) {
          if (period[i] === void 0)
            continue;
          dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
        }
      }
      return name + dimAccessors.join("_");
    };
  };
  createVariable$1.sum = function(parts) {
    parts = Array.isArray(parts) ? parts : [parts];
    parts = parts.filter(function(part) {
      return part !== void 0 && part !== 0;
    });
    if (parts.length === 0)
      parts.push(0);
    return parts.join(" + ");
  };
  var variable$3 = createVariable$1;
  var inferType$4 = inferType_1;
  var createVariable = variable$3;
  function wrapAccessor(callback) {
    return function(i, period) {
      if (i !== void 0 && !Array.isArray(i))
        i = [i];
      var dimAccessors = [];
      for (var j = 0; j < i.length; j++) {
        dimAccessors.push(createVariable.sum(i[j]));
      }
      if (period) {
        for (i = 0; i < dimAccessors.length; i++) {
          if (period[i] === void 0)
            continue;
          dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
        }
      }
      return callback(dimAccessors);
    };
  }
  function createAccessor(name, data) {
    var i;
    if (!data)
      return void 0;
    switch (inferType$4(data)) {
      case inferType$4.ARRAY_OF_ARRAYS:
        return wrapAccessor(function(accessors) {
          return name + "[" + accessors.join("][") + "]";
        });
      case inferType$4.GENERIC_NDARRAY:
        return wrapAccessor(function(accessors) {
          return name + ".get(" + accessors.join(",") + ")";
        });
      case inferType$4.NDARRAY:
        return wrapAccessor(function(accessors) {
          var code = [name + "Offset"];
          for (i = 0; i < accessors.length; i++) {
            code.push(name + "Stride" + i + " * (" + accessors[i] + ")");
          }
          return name + "[" + code.join(" + ") + "]";
        });
      case inferType$4.PACKED:
      default:
        return void 0;
    }
  }
  var createAccessors$1 = function(nurbs2) {
    var accessors = {};
    var accessor;
    accessor = createAccessor("x", nurbs2.points);
    if (accessor)
      accessors.point = accessor;
    accessor = createAccessor("w", nurbs2.weights);
    if (accessor)
      accessors.weight = accessor;
    accessor = createAccessor("k", nurbs2.knots);
    if (accessor)
      accessors.knot = accessor;
    return accessors;
  };
  var args = [];
  var tmp = [];
  var numericalDerivative$1 = function numericalDerivative2(out, order, dimension) {
    if (order !== 1) {
      throw new Error("Numerical derivative not implemented for order n = " + order + ".");
    }
    var i;
    var h = arguments[this.splineDimension + 3] === void 0 ? 1e-4 : arguments[this.splineDimension + 3];
    args.length = this.splineDimension;
    for (i = 0; i < this.splineDimension; i++) {
      args[i + 1] = arguments[i + 3];
    }
    var domain = this.domain;
    var k0 = domain[dimension][0];
    var k1 = domain[dimension][1];
    var tm, tp, T;
    var t0 = args[dimension + 1];
    var dt = (k1 - k0) * h;
    if (this.boundary[dimension] === "closed") {
      T = k1 - k0;
      tm = k0 + (t0 - k0 - dt + T) % T;
      tp = k0 + (t0 - k0 + dt + T) % T;
      dt *= 2;
    } else {
      tm = Math.min(k1, Math.max(k0, t0 - dt));
      tp = Math.min(k1, Math.max(k0, t0 + dt));
      dt = tp - tm;
    }
    args[dimension + 1] = tm;
    args[0] = tmp;
    this.evaluate.apply(null, args);
    args[dimension + 1] = tp;
    args[0] = out;
    this.evaluate.apply(null, args);
    for (i = 0; i < this.dimension; i++) {
      out[i] = (out[i] - tmp[i]) / dt;
    }
    return out;
  };
  var ndloop$2 = function ndloop2(n, callback) {
    for (var m = 1, k = 0, i = []; k < n.length; k++) {
      m *= Array.isArray(n[k]) ? n[k][1] - n[k][0] : n[k];
      i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
    }
    for (var ptr = 0; ptr < m; ptr++) {
      callback(i.slice());
      for (k = n.length - 1; k >= 0; k--) {
        if (i[k] === (Array.isArray(n[k]) ? n[k][1] : n[k]) - 1) {
          i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
        } else {
          i[k]++;
          break;
        }
      }
    }
  };
  var inferType$3 = inferType_1;
  var accessorPreamble$3 = function(nurbs2, variableName, propertyName, data) {
    var i;
    var code = [];
    switch (inferType$3(data)) {
      case inferType$3.NDARRAY:
        code.push("  var " + variableName + " = " + propertyName + ".data;");
        code.push("  var " + variableName + "Offset = " + propertyName + ".offset;");
        for (i = 0; i < data.dimension; i++) {
          code.push("  var " + variableName + "Stride" + i + " = " + propertyName + ".stride[" + i + "];");
        }
        break;
      case inferType$3.ARRAY_OF_ARRAYS:
        code.push("  var " + variableName + " = " + propertyName + ";");
    }
    return code.join("\n");
  };
  var isNdarrayLike$1 = isNdarrayLike$3;
  var sizeGetter$3 = function(data, dataVariableName, dimension) {
    if (!data) {
      return "this.size[" + dimension + "]";
    } else if (isNdarrayLike$1(data)) {
      return dataVariableName + ".shape[" + dimension + "]";
    } else {
      var str = dataVariableName;
      for (var i = 0; i < dimension; i++) {
        str += "[0]";
      }
      return str + ".length";
    }
  };
  var ndloop$1 = ndloop$2;
  var variable$2 = variable$3;
  var accessorPreamble$2 = accessorPreamble$3;
  var inferType$2 = inferType_1;
  var isArrayLike$2 = isArrayLike$5;
  var sizeGetter$2 = sizeGetter$3;
  var evaluatorCache = {};
  var codeCache = {};
  var evaluate = function(cacheKey2, nurbs2, accessors, debug, checkBounds, isBasis, derivative) {
    var splineDimension = nurbs2.splineDimension;
    var i, j, n, m, d, kvar;
    var points = nurbs2.points;
    var degree = nurbs2.degree;
    var weights = nurbs2.weights;
    var hasWeights = weights !== void 0;
    var knots = nurbs2.knots;
    var spaceDimension = nurbs2.dimension;
    var boundary = nurbs2.boundary;
    if (derivative !== void 0 && derivative !== null) {
      if (!Array.isArray(derivative)) {
        derivative = [derivative];
      }
      var totalDerivativeOrder = 0;
      for (i = 0; i < splineDimension; i++) {
        if (derivative[i] === void 0)
          derivative[i] = 0;
        totalDerivativeOrder += derivative[i];
      }
      if (hasWeights && totalDerivativeOrder > 1) {
        throw new Error("Analytical derivative not implemented for rational b-splines with order n = " + totalDerivativeOrder + ".");
      }
    }
    if (isBasis)
      cacheKey2 = "Basis" + cacheKey2;
    if (derivative)
      cacheKey2 = "Der" + derivative.join("_") + "_" + cacheKey2;
    var cachedEvaluator = evaluatorCache[cacheKey2];
    if (debug) {
      var logger = typeof debug === "function" ? debug : console.log;
    }
    if (cachedEvaluator) {
      if (debug) {
        logger(codeCache[cacheKey2]);
      }
      return cachedEvaluator.bind(nurbs2);
    }
    var code = [];
    var functionName = "evaluate" + cacheKey2;
    var pointAccessor = accessors.point;
    if (isBasis) {
      pointAccessor = function(src, period) {
        var terms = [];
        for (var i2 = 0; i2 < src.length; i2++) {
          var accessor = src[i2];
          var terms2 = [];
          for (var j2 = 0; j2 < accessor.length; j2++) {
            if (accessor[j2] !== 0)
              terms2.push(accessor[j2]);
          }
          accessor = terms2.join(" + ");
          if (period[i2]) {
            accessor = "(" + accessor + " + " + period[i2] + ") % " + period[i2];
          }
          terms.push(accessor + " === " + indexVar(i2));
        }
        return "((" + terms.join(" && ") + ") ? 1 : 0)";
      };
    }
    var weightAccessor = accessors.weight;
    var knotAccessor = accessors.knot;
    var knotVar = variable$2("k");
    var pointVar = variable$2("x");
    var weightVar = variable$2("w");
    var indexVar = variable$2("i");
    var tVar = variable$2("t");
    var domainVar = debug ? "domain" : "d";
    var sizeVar = variable$2(debug ? "size" : "s");
    var knotIndex = variable$2(debug ? "knotIndex" : "j");
    var allDimensionUniform = true;
    for (d = 0; d < splineDimension; d++) {
      if (isArrayLike$2(knots) && isArrayLike$2(knots[d])) {
        allDimensionUniform = false;
      }
    }
    function line2(str) {
      code.push("  " + (str || ""));
    }
    function debugLine(str) {
      if (debug)
        line2(str);
    }
    if (isBasis) {
      var indexArgs = [];
    }
    var parameterArgs = [];
    for (i = 0; i < splineDimension; i++) {
      if (isBasis) {
        indexArgs.push(indexVar([i]));
      }
      parameterArgs.push(tVar([i]));
    }
    code.push("function " + functionName + " (" + (isBasis ? "" : "out, ") + parameterArgs.join(", ") + (isBasis ? ", " + indexArgs.join(", ") : "") + ") {");
    line2("var h, m, a, b;");
    if (checkBounds) {
      line2("var " + domainVar + " = this.domain;");
      line2("for (var i = 0; i < this.splineDimension; i++) {");
      line2("  a = arguments[i + 1];");
      line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
      line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
      line2("  }");
      line2("}");
    }
    for (d = 0; d < splineDimension; d++) {
      line2("var " + sizeVar(d) + " = " + sizeGetter$2(points, "this.points", d) + ";");
    }
    code.push(accessorPreamble$2(nurbs2, "x", "this.points", points));
    if (hasWeights) {
      code.push(accessorPreamble$2(nurbs2, "w", "this.weights", weights));
    }
    if (!allDimensionUniform) {
      code.push(accessorPreamble$2(nurbs2, "k", "this.knots", knots));
    }
    function ternary(cond, a, b) {
      return "(" + cond + ") ? (" + a + ") : (" + b + ")";
    }
    var hasKnots = [];
    for (d = 0; d < splineDimension; d++) {
      switch (inferType$2(knots)) {
        case inferType$2.NDARRAY:
          hasKnots[d] = true;
          break;
        case inferType$2.ARRAY_OF_ARRAYS:
          hasKnots[d] = isArrayLike$2(knots[d]);
          break;
      }
    }
    for (d = 0; d < splineDimension; d++) {
      if (hasKnots[d]) {
        debugLine("\n  // Bisect to locate the knot interval in dimension " + d + "\n");
        line2("var " + knotIndex(d) + " = 0;");
        line2("h = " + sizeVar(d) + ";");
        line2("while(h > " + knotIndex(d) + " + 1) {");
        line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
        line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
        line2("  else " + knotIndex(d) + " = m;");
        line2("}");
        debugLine("\n  // Fetch knots for dimension " + d + "\n");
        for (i = -degree[d] + 1; i <= degree[d]; i++) {
          if (boundary[d] === "closed") {
            if (i < 0) {
              line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " < " + -i, knotAccessor([d, 0]) + " + " + knotAccessor([d, [sizeVar(d), knotIndex(d), i]]) + " - " + knotAccessor([d, [sizeVar(d)]]), knotAccessor([d, [knotIndex(d), i]])) + ";");
            } else if (i > 0) {
              line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " + " + i + " > " + sizeVar(d), knotAccessor([d, sizeVar(d)]) + " + " + knotAccessor([d, i + " + " + knotIndex(d) + " - " + sizeVar(d)]) + " - " + knotAccessor([d, 0]), knotAccessor([d, [knotIndex(d), i]])) + ";");
            } else {
              line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
            }
          } else {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
          }
        }
      } else {
        debugLine("\n  // Directly compute knot interval for dimension " + d + "\n");
        if (boundary[d] === "closed") {
          line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
        } else {
          line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
          line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
          line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
        }
        debugLine("\n  // Compute and clamp knots for dimension " + d + "\n");
        for (i = -degree[d] + 1; i <= degree[d]; i++) {
          kvar = knotVar([d, i + degree[d] - 1]);
          line2("var " + kvar + " = " + knotIndex(d) + " + " + i + ";");
        }
        if (boundary[d] === "clamped") {
          for (i = -degree[d] + 1; i <= degree[d]; i++) {
            kvar = knotVar([d, i + degree[d] - 1]);
            if (i < 0) {
              line2("if (" + kvar + " < " + degree[d] + ") " + kvar + " = " + degree[d] + ";");
            }
            if (i > 0) {
              line2("if (" + kvar + " > " + sizeVar(d) + ") " + kvar + " = " + sizeVar(d) + ";");
            }
          }
        }
        if (boundary[d] === "closed") {
          debugLine("\n  // Wrap the B-Spline parameter for closed boundary");
          line2(tVar(d) + " %= " + sizeVar(d) + ";");
        }
      }
    }
    for (d = 0, n = []; d < splineDimension; d++) {
      n[d] = degree[d] + 1;
    }
    if (hasWeights) {
      debugLine("\n  // Fetch weights\n");
      ndloop$1(n, function(dst) {
        var readIdx = [];
        var period = [];
        for (var d2 = 0; d2 < splineDimension; d2++) {
          readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
          if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
            period[d2] = sizeVar(d2);
        }
        line2("var " + weightVar(dst) + " = " + weightAccessor(readIdx, period) + ";");
      });
    }
    if (debug) {
      if (hasWeights) {
        line2("\n  // Fetch points and project into homogeneous (weighted) coordinates\n");
      } else {
        line2("\n  // Fetch points\n");
      }
    }
    ndloop$1(n, function(dst) {
      var readIdx = [];
      var period = [];
      for (var d2 = 0; d2 < splineDimension; d2++) {
        readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
        if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
          period[d2] = sizeVar(d2);
      }
      if (isBasis) {
        if (hasWeights) {
          line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
        } else {
          line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + ";");
        }
      } else {
        for (d2 = 0; d2 < spaceDimension; d2++) {
          var dstWithDim = dst.concat(d2);
          readIdx[splineDimension] = d2;
          if (hasWeights) {
            line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
          } else {
            line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + ";");
          }
        }
      }
    });
    debugLine("\n");
    debugLine("// Perform De Boor's algorithm");
    for (d = n.length - 1; d >= 0; d--) {
      n[d] = [degree[d], degree[d] + 1];
      for (i = 0; i < degree[d]; i++) {
        debugLine("\n  // Degree " + degree[d] + " evaluation in dimension " + d + ", step " + (i + 1) + "\n");
        for (j = degree[d]; j > i; j--) {
          var isDerivative = derivative && degree[d] - i - derivative[d] <= 0;
          if (isDerivative) {
            line2("m = 1 / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
            if (hasWeights) {
              line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") * m;");
              line2("b = 1 - a;");
            }
          } else {
            line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
            line2("b = 1 - a;");
          }
          if (hasWeights) {
            ndloop$1(n, function(ii) {
              var ij = ii.slice();
              var ij1 = ii.slice();
              ij[d] = j;
              ij1[d] = j - 1;
              if (isDerivative && hasWeights)
                line2("h = " + weightVar(ij) + ";");
              line2(weightVar(ij) + " = b * " + weightVar(ij1) + " + a * " + weightVar(ij) + ";");
            });
          }
          ndloop$1(n, function(ii) {
            var weightFactor, pt1, pt2;
            var ij = ii.slice();
            var ij1 = ii.slice();
            ij[d] = j;
            ij1[d] = j - 1;
            if (isDerivative) {
              var derivCoeff = i + 1;
              if (isBasis) {
                weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
                pt1 = pointVar(ij) + (hasWeights ? " / h" : "");
                pt2 = pointVar(ij1) + (hasWeights ? " / " + weightVar(ij1) : "");
                line2(pointVar(ij) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
              } else {
                var ijWithDimension = ij.slice();
                var ij1WithDimension = ij1.slice();
                for (m = 0; m < spaceDimension; m++) {
                  ijWithDimension[splineDimension] = ij1WithDimension[splineDimension] = m;
                  weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
                  pt1 = pointVar(ijWithDimension) + (hasWeights ? " / h" : "");
                  pt2 = pointVar(ij1WithDimension) + (hasWeights ? " / " + weightVar(ij1) : "");
                  line2(pointVar(ijWithDimension) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
                }
              }
            } else {
              if (isBasis) {
                line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
              } else {
                for (m = 0; m < spaceDimension; m++) {
                  ij[splineDimension] = ij1[splineDimension] = m;
                  line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
                }
              }
            }
          });
          debugLine("\n");
        }
      }
    }
    if (debug) {
      if (hasWeights) {
        line2("\n  // Project back from homogeneous coordinates and return final output\n");
      } else {
        line2("\n  // Return final output\n");
      }
    }
    if (isBasis) {
      if (hasWeights) {
        line2("return " + pointVar(degree) + " / " + weightVar(degree) + ";");
      } else {
        line2("return " + pointVar(degree) + ";");
      }
    } else {
      for (d = 0; d < spaceDimension; d++) {
        if (hasWeights) {
          line2("out[" + d + "] = " + pointVar(degree.concat([d])) + " / " + weightVar(degree) + ";");
        } else {
          line2("out[" + d + "] = " + pointVar(degree.concat([d])) + ";");
        }
      }
    }
    if (!isBasis) {
      line2("return out;");
    }
    code.push("}");
    if (debug) {
      var codeStr = code.join("\n");
      logger(codeStr);
      codeCache[cacheKey2] = codeStr;
    }
    var evaluator = new Function([code.join("\n"), "; return ", functionName].join(""))();
    evaluatorCache[cacheKey2] = evaluator;
    return evaluator.bind(nurbs2);
  };
  var transformerCache = {};
  var accessorPreamble$1 = accessorPreamble$3;
  var sizeGetter$1 = sizeGetter$3;
  var variable$1 = variable$3;
  var transform = function createTransform2(cacheKey2, nurbs2, accessors, debug) {
    var i, j, iterator, iterators, terms, n, rvalue, lvalue;
    var cachedTransformer = transformerCache[cacheKey2];
    if (cachedTransformer) {
      return cachedTransformer.bind(nurbs2);
    }
    var code = [];
    var functionName = "transform" + cacheKey2;
    code.push("function " + functionName + "(m) {");
    code.push("var i, w;");
    code.push(accessorPreamble$1(nurbs2, "x", "this.points", nurbs2.points));
    var sizeVar = variable$1(debug ? "size" : "s");
    for (i = 0; i < nurbs2.splineDimension; i++) {
      code.push("var " + sizeVar(i) + " = " + sizeGetter$1(nurbs2.points, "this.points", i) + ";");
    }
    iterators = [];
    for (i = 0; i < nurbs2.splineDimension; i++) {
      iterator = "i" + i;
      iterators.push(iterator);
      code.push("for (" + iterator + " = " + sizeVar(i) + "- 1; " + iterator + " >= 0; " + iterator + "--) {");
    }
    for (i = 0; i < nurbs2.dimension; i++) {
      code.push("x" + i + " = " + accessors.point(iterators.concat([i])));
    }
    terms = [];
    for (i = 0; i < nurbs2.dimension; i++) {
      terms.push("m[" + ((nurbs2.dimension + 1) * (i + 1) - 1) + "] * x" + i);
    }
    terms.push("m[" + ((nurbs2.dimension + 1) * (nurbs2.dimension + 1) - 1) + "]");
    code.push("var w = (" + terms.join(" + ") + ") || 1.0;");
    for (i = 0; i < nurbs2.dimension; i++) {
      terms = [];
      n = nurbs2.dimension;
      for (j = 0; j < n; j++) {
        terms.push("m[" + (j * (n + 1) + i) + "] * x" + j);
      }
      terms.push("m[" + (j * (n + 1) + i) + "]");
      lvalue = accessors.point(iterators.concat([i]));
      rvalue = "(" + terms.join(" + ") + ") / w";
      code.push(lvalue + " = " + rvalue + ";");
    }
    for (i = nurbs2.splineDimension - 1; i >= 0; i--) {
      code.push("}");
    }
    code.push("return this;");
    code.push("}");
    var transform2 = new Function([code.join("\n"), "; return ", functionName].join(""))();
    if (debug)
      console.log(code.join("\n"));
    transformerCache[cacheKey2] = transform2;
    return transform2.bind(nurbs2);
  };
  var ndloop = ndloop$2;
  var variable = variable$3;
  var accessorPreamble = accessorPreamble$3;
  var inferType$1 = inferType_1;
  var isArrayLike$1 = isArrayLike$5;
  var sizeGetter = sizeGetter$3;
  var supportCache = {};
  var support = function(cacheKey2, nurbs2, accessors, debug, checkBounds) {
    var cachedSupport = supportCache[cacheKey2];
    if (cachedSupport) {
      return cachedSupport.bind(nurbs2);
    }
    var degree = nurbs2.degree;
    var knots = nurbs2.knots;
    var splineDimension = nurbs2.splineDimension;
    var boundary = nurbs2.boundary;
    var i, n, d;
    var code = [];
    var functionName = "support" + cacheKey2;
    var knotAccessor = accessors.knot;
    var tVar = variable("t");
    var domainVar = debug ? "domain" : "d";
    var sizeVar = variable(debug ? "size" : "s");
    var knotIndex = variable(debug ? "knotIndex" : "i");
    var allDimensionUniform = true;
    for (d = 0; d < splineDimension; d++) {
      if (isArrayLike$1(knots) && isArrayLike$1(knots[d])) {
        allDimensionUniform = false;
      }
    }
    function line2(str) {
      code.push("  " + (str || ""));
    }
    var parameterArgs = [];
    for (i = 0; i < splineDimension; i++) {
      parameterArgs.push(tVar([i]));
    }
    code.push("function " + functionName + " (out, " + parameterArgs.join(", ") + ") {");
    var c = 0;
    function pushSupport(args2, period) {
      if (period === void 0) {
        line2("out[" + c++ + "] = " + args2.join(" + ") + ";");
      } else {
        line2("out[" + c++ + "] = (" + args2.join(" + ") + " + " + period + ") % " + period + ";");
      }
    }
    line2("var h, m;");
    line2("var c = 0;");
    if (checkBounds) {
      line2("var " + domainVar + " = this.domain;");
      line2("for (var i = 0; i < this.splineDimension; i++) {");
      line2("  a = arguments[i + 1];");
      line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
      line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
      line2("  }");
      line2("}");
    }
    for (d = 0; d < splineDimension; d++) {
      line2("var " + sizeVar(d) + " = " + sizeGetter(nurbs2.points, "this.points", d) + ";");
    }
    if (!allDimensionUniform) {
      code.push(accessorPreamble(nurbs2, "k", "this.knots", knots));
    }
    var hasKnots = [];
    for (d = 0; d < splineDimension; d++) {
      switch (inferType$1(knots)) {
        case inferType$1.NDARRAY:
          hasKnots[d] = true;
          break;
        case inferType$1.ARRAY_OF_ARRAYS:
          hasKnots[d] = isArrayLike$1(knots[d]);
          break;
      }
    }
    for (d = 0; d < splineDimension; d++) {
      if (hasKnots[d]) {
        line2("var " + knotIndex(d) + " = 0;");
        line2("h = " + sizeVar(d) + ";");
        line2("while(h > " + knotIndex(d) + " + 1) {");
        line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
        line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
        line2("  else " + knotIndex(d) + " = m;");
        line2("}");
      } else {
        if (boundary[d] === "closed") {
          line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
        } else {
          line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
          line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
          line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
        }
      }
    }
    for (d = 0, n = []; d < splineDimension; d++) {
      n[d] = degree[d] + 1;
    }
    ndloop(n, function(dst) {
      var readIdx = [];
      var period = [];
      for (var d2 = 0; d2 < splineDimension; d2++) {
        readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
        if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
          period[d2] = sizeVar(d2);
      }
      for (d2 = 0; d2 < splineDimension; d2++) {
        pushSupport(readIdx[d2], period[d2]);
      }
    });
    line2("out.length = " + c + ";");
    line2("return out;");
    code.push("}");
    if (debug)
      console.log(code.join("\n"));
    var evaluator = new Function([code.join("\n"), "; return ", functionName].join(""))();
    supportCache[cacheKey2] = evaluator;
    return evaluator.bind(nurbs2);
  };
  var inferType = inferType_1;
  var computeCacheKey = cacheKey;
  var isNdarray = isNdarray$2;
  var isNdarrayLike = isNdarrayLike$3;
  var createAccessors = createAccessors$1;
  var numericalDerivative = numericalDerivative$1;
  var isArrayLike = isArrayLike$5;
  var createEvaluator = evaluate;
  var createTransform = transform;
  var createSupport = support;
  var BOUNDARY_TYPES = {
    open: "open",
    closed: "closed",
    clamped: "clamped"
  };
  function isBlank(x) {
    return x === void 0 || x === null;
  }
  function parseNURBS(points, degree, knots, weights, boundary, opts) {
    var i, dflt;
    if (points && !isArrayLike(points) && !isNdarray(points)) {
      opts = points;
      this.debug = points.debug;
      this.checkBounds = !!points.checkBounds;
      this.weights = points.weights;
      this.knots = points.knots;
      this.degree = points.degree;
      this.boundary = points.boundary;
      this.points = points.points;
      Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
    } else {
      opts = opts || {};
      this.weights = weights;
      this.knots = knots;
      this.degree = degree;
      this.points = points;
      this.boundary = boundary;
      this.debug = opts.debug;
      this.checkBounds = !!opts.checkBounds;
      Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
    }
    var pointType = inferType(this.points);
    var weightType = inferType(this.weights);
    var knotType = inferType(this.knots);
    if (this.points) {
      switch (pointType) {
        case inferType.GENERIC_NDARRAY:
        case inferType.NDARRAY:
          Object.defineProperties(this, {
            splineDimension: {
              value: this.points.shape.length - 1,
              writable: false,
              configurable: true
            },
            dimension: {
              value: this.points.shape[this.points.shape.length - 1],
              writable: false,
              configurable: true
            },
            size: {
              get: function() {
                return this.points.shape.slice(0, this.points.shape.length - 1);
              },
              set: function() {
                throw new Error("Cannot assign to read only property 'size'");
              },
              configurable: true
            }
          });
          break;
        case inferType.ARRAY_OF_ARRAYS:
          var splineDimension = 0;
          var size = this.size || [];
          size.length = 0;
          for (var ptr = this.points; isArrayLike(ptr[0]); ptr = ptr[0]) {
            splineDimension++;
            size.push(ptr.length);
          }
          if (splineDimension === 0) {
            throw new Error("Expected an array of points");
          }
          Object.defineProperties(this, {
            splineDimension: {
              value: splineDimension,
              writable: false,
              configurable: true
            },
            dimension: {
              value: ptr.length,
              writable: false,
              configurable: true
            },
            size: {
              get: function() {
                var size2 = [];
                size2.length = 0;
                for (var i2 = 0, ptr2 = this.points; i2 < this.splineDimension; i2++, ptr2 = ptr2[0]) {
                  size2[i2] = ptr2.length;
                }
                return size2;
              },
              set: function() {
                throw new Error("Cannot assign to read only property 'size'");
              },
              configurable: true
            }
          });
          break;
        case inferType.PACKED:
        default:
          throw new Error("Expected either a packed array, array of arrays, or ndarray of points");
      }
    } else {
      if (this.size === void 0 || this.size === null) {
        throw new Error("Either points or a control hull size must be provided.");
      }
      if (!isArrayLike(this.size)) {
        Object.defineProperty(this, "size", {
          value: [this.size],
          writable: true,
          configurable: true
        });
      }
      if (this.size.length === 0) {
        throw new Error("`size` must be a number or an array of length at least one.");
      }
      Object.defineProperties(this, {
        splineDimension: {
          value: this.size.length,
          writable: false,
          configurable: true
        },
        dimension: {
          value: 0,
          writable: false,
          configurable: true
        }
      });
    }
    if (isArrayLike(this.degree)) {
      for (i = 0; i < this.splineDimension; i++) {
        if (isBlank(this.degree[i])) {
          throw new Error("Missing degree in dimension " + (i + 1));
        }
      }
    } else {
      var hasBaseDegree = !isBlank(this.degree);
      var baseDegree = isBlank(this.degree) ? 2 : this.degree;
      this.degree = [];
      for (i = 0; i < this.splineDimension; i++) {
        if (this.size[i] <= baseDegree) {
          if (hasBaseDegree) {
            throw new Error("Expected at least " + (baseDegree + 1) + " points for degree " + baseDegree + " spline in dimension " + (i + 1) + " but got only " + this.size[i]);
          } else {
            this.degree[i] = this.size[i] - 1;
          }
        } else {
          this.degree[i] = baseDegree;
        }
      }
    }
    dflt = typeof this.boundary !== "string" ? "open" : this.boundary;
    if (!BOUNDARY_TYPES[dflt]) {
      throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt);
    }
    this.boundary = isArrayLike(this.boundary) ? this.boundary : [];
    this.boundary.length = this.splineDimension;
    for (i = 0; i < this.splineDimension; i++) {
      this.boundary[i] = isBlank(this.boundary[i]) ? dflt : this.boundary[i];
      if (!BOUNDARY_TYPES[dflt]) {
        throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt + " for dimension " + (i + 1));
      }
    }
    switch (knotType) {
      case inferType.ARRAY_OF_ARRAYS:
        if (isArrayLike(this.knots) && this.knots.length > 0 && !isArrayLike(this.knots[0])) {
          this.knots = [this.knots];
        }
        for (i = 0; i < this.splineDimension; i++) {
          if (this.size[i] <= this.degree[i]) {
            throw new Error("Expected at least " + (this.degree[i] + 1) + " points in dimension " + (i + 1) + " but got " + this.size[i] + ".");
          }
          if (isArrayLike(this.knots[i])) {
            if (this.boundary[i] !== "closed" && this.knots[i].length !== this.degree[i] + this.size[i] + 1) {
              throw new Error("Expected " + (this.degree[i] + this.size[i] + 1) + " knots in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
            } else if (this.boundary[i] === "closed" && this.knots[i].length !== this.size[i] + 1) {
              var canBeFudged = this.knots[i].length === this.size[i] + this.degree[i] + 1;
              if (!canBeFudged) {
                throw new Error("Expected " + (this.size[i] + 1) + " knots for closed spline in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
              }
            }
          }
        }
        break;
    }
    var newCacheKey = computeCacheKey(this, this.debug, this.checkBounds, pointType, weightType, knotType);
    if (newCacheKey !== this.__cacheKey) {
      this.__cacheKey = newCacheKey;
      var accessors = createAccessors(this);
      this.evaluate = createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, false);
      this.transform = createTransform(this.__cacheKey, this, accessors, this.debug);
      this.support = createSupport(this.__cacheKey, this, accessors, this.debug, this.checkBounds);
      this.evaluator = function(derivativeOrder, isBasis) {
        return createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, isBasis, derivativeOrder);
      };
    }
    this.numericalDerivative = numericalDerivative.bind(this);
    return this;
  }
  function domainGetter() {
    var sizeArray;
    var ret = [];
    var ptr = this.points;
    if (!ptr) {
      sizeArray = this.size;
    } else if (isNdarrayLike(ptr)) {
      sizeArray = ptr.shape;
    }
    for (var d = 0; d < this.splineDimension; d++) {
      var size = sizeArray ? sizeArray[d] : ptr.length;
      var p = this.degree[d];
      var isClosed = this.boundary[d] === "closed";
      if (this.knots && this.knots[d]) {
        var k = this.knots[d];
        ret[d] = [k[isClosed ? 0 : p], k[size]];
      } else {
        ret[d] = [isClosed ? 0 : p, size];
      }
      if (ptr)
        ptr = ptr[0];
    }
    return ret;
  }
  function nurbs(points, degree, knots, weights, boundary, opts) {
    var ctor = function(points2, degree2, knots2, weights2, boundary2, opts2) {
      parseFcn(points2, degree2, knots2, weights2, boundary2, opts2);
      return ctor;
    };
    var parseFcn = parseNURBS.bind(ctor);
    Object.defineProperty(ctor, "domain", {
      get: domainGetter
    });
    parseFcn(points, degree, knots, weights, boundary, opts);
    return ctor;
  }
  var nurbs_1 = nurbs;
  class SplineModel extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "spline",
        name: "New Spline",
        strokeWidth: 1,
        points: [],
        traceCount: 100,
        degree: 2,
        boundary: "clamped"
      }, obj2));
    }
    get points() {
      return this.get("points");
    }
    set points(value) {
      this.set("points", value);
    }
    get degree() {
      return this.get("degree");
    }
    set degree(value) {
      this.set("degree", value);
    }
    get traceCount() {
      return this.get("traceCount");
    }
    set traceCount(value) {
      this.set("traceCount", value);
    }
    get boundary() {
      return this.get("boundary");
    }
    set boundary(value) {
      this.set("boundary", value);
    }
    enableHasChildren() {
      return false;
    }
    refreshMatrixCache() {
      super.refreshMatrixCache();
      if (this.hasChangedField("points", "boundary")) {
        this.setCache();
      } else if (this.hasChangedField("width", "height")) {
        if (!this.cachePath) {
          this.setCache();
        }
        this.points = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).verties;
        this.modelManager.setChanged("reset", this.id, {
          points: this.points
        });
      }
    }
    setCache() {
      super.setCache();
      this.cachePath = PathParser.makePathByVerties(this.points);
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    get editablePath() {
      let { width: width2, height, points } = this;
      if (!points || points.length == 0) {
        points = [
          [0, height],
          [0, 0],
          [width2, 0],
          [width2, height]
        ];
      }
      return this.absolutePath(PathParser.makePathByVerties(points).d).d;
    }
    recoverEditablePath(d) {
      const points = this.invertPath(d).verties;
      const pathData = this.updatePath(this.getPath(points));
      delete pathData.d;
      return __spreadValues({
        points
      }, pathData);
    }
    get d() {
      return this.getPath(this.points, this.boundary);
    }
    getPath(points, boundary) {
      let { width: width2, height } = this;
      if (!points) {
        points = this.points;
      }
      if (!boundary) {
        boundary = this.boundary;
      }
      if (!points || points.length == 0) {
        points = [
          [0, height],
          [0, 0],
          [width2, 0],
          [width2, height]
        ];
      }
      const curve = nurbs_1({
        points,
        degree: points.length - 2,
        boundary
      });
      const pt = [];
      const verties = [];
      const traceCount = (points.length - 1) * 100;
      const unit = 1 / traceCount;
      const d0 = curve.domain[0][0];
      const d1 = curve.domain[0][1];
      for (var t = 0; t <= 1; t += unit) {
        curve.evaluate(pt, d0 + (d1 - d0) * t);
        verties.push(clone(pt));
      }
      return PathParser.makePathByVerties(verties, false).round(1e3).d;
    }
    getDefaultTitle() {
      return "BSpline";
    }
  }
  class StarModel extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "star",
        name: "New Star",
        strokeWidth: 1,
        isCurve: false,
        count: 5,
        radius: 0.5,
        tension: 0.5
      }, obj2));
    }
    get count() {
      return this.get("count");
    }
    set count(value) {
      this.set("count", value);
    }
    get radius() {
      return this.get("radius");
    }
    set radius(value) {
      this.set("radius", value);
    }
    get tension() {
      return this.get("tension");
    }
    set tension(value) {
      this.set("tension", value);
    }
    get isCurve() {
      return this.get("isCurve");
    }
    convert(json) {
      json = super.convert(json);
      if (json.count)
        json.count = +json.count;
      if (json.radius)
        json.radius = +json.radius;
      if (json.tension)
        json.tension = +json.tension;
      return json;
    }
    enableHasChildren() {
      return false;
    }
    get d() {
      const { width: width2, height, count, radius, tension, isCurve } = this;
      let newPath = "";
      if (isCurve) {
        newPath = PathParser.makeCurvedStar(width2, height, count, radius, tension).d;
      } else {
        newPath = PathParser.makeStar(width2, height, count, radius).d;
      }
      return newPath;
    }
    getDefaultTitle() {
      return "Star";
    }
  }
  class SVGTextItem extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "svg-text",
        name: "New Text",
        totalLength: 0,
        fill: "rgba(0, 0, 0, 1)",
        text: "Insert a text",
        fontWeight: editor.Length.number(100),
        textLength: editor.Length.em(0),
        lengthAdjust: "spacingAndGlyphs"
      }, obj2));
    }
    get text() {
      return this.get("text");
    }
    set text(value) {
      this.set("text", value);
    }
    get textLength() {
      return this.get("textLength");
    }
    set textLength(value) {
      this.set("textLength", value);
    }
    get lengthAdjust() {
      return this.get("lengthAdjust");
    }
    set lengthAdjust(value) {
      this.set("lengthAdjust", value);
    }
    enableHasChildren() {
      return false;
    }
    convert(json) {
      json = super.convert(json);
      json.textLength = editor.Length.parse(json.textLength);
      return json;
    }
    getDefaultTitle() {
      return "Text";
    }
  }
  class SVGTextPathItem extends SVGModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "svg-textpath",
        name: "New TextPath",
        d: "",
        totalLength: 0,
        fill: "rgba(0, 0, 0, 1)",
        text: "Insert a text",
        textLength: editor.Length.em(0),
        lengthAdjust: "spacingAndGlyphs",
        startOffset: editor.Length.em(0)
      }, obj2));
    }
    get d() {
      if (!this.get("d")) {
        return null;
      }
      if (!this.cachePath) {
        this.cachePath = new PathParser(this.get("d"));
        this.cacheWidth = this.width;
        this.cacheHeight = this.height;
      }
      return this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
    }
    set d(value) {
      this.set("d", value);
    }
    get text() {
      return this.get("text");
    }
    set text(value) {
      this.set("text", value);
    }
    get textLength() {
      return this.get("textLength");
    }
    set textLength(value) {
      this.set("textLength", value);
    }
    get lengthAdjust() {
      return this.get("lengthAdjust");
    }
    set lengthAdjust(value) {
      this.set("lengthAdjust", value);
    }
    get startOffset() {
      return this.get("startOffset");
    }
    set startOffset(value) {
      this.set("startOffset", value);
    }
    enableHasChildren() {
      return false;
    }
    refreshMatrixCache() {
      super.refreshMatrixCache();
      if (this.hasChangedField("d")) {
        this.cachePath = new PathParser(this.get("d"));
        this.cacheWidth = this.width;
        this.cacheHeight = this.height;
      } else if (this.hasChangedField("width", "height")) {
        this.d = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
        this.modelManager.setChanged("reset", this.id, { d: this.d });
      }
    }
    convert(json) {
      json = super.convert(json);
      json.textLength = editor.Length.parse(json.textLength);
      json.startOffset = editor.Length.parse(json.startOffset);
      return json;
    }
    getDefaultTitle() {
      return "TextPath";
    }
  }
  class Component extends LayerModel {
    is(...itemType) {
      if (itemType.includes("component")) {
        return true;
      }
      return super.is(...itemType);
    }
    getProps() {
      return [];
    }
    static createComponent({
      iconString,
      title = "Unknown Title",
      attrs = {},
      enableHasChildren = false
    }) {
      return class extends Component {
        getIcon() {
          return iconString;
        }
        getDefaultObject() {
          return super.getDefaultObject(__spreadValues({
            itemType: "NewComponent",
            name: "New Component"
          }, attrs));
        }
        enableHasChildren() {
          return enableHasChildren || false;
        }
        getDefaultTitle() {
          return title;
        }
      };
    }
  }
  const DEFAULT_TEMPLATE = `
  <svg>
    <rect width="100%" height="100%" fill="black" />
  </svg>
`;
  class TemplateModel extends Component {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "template",
        name: "New Template",
        engine: "dom",
        template: DEFAULT_TEMPLATE,
        params: []
      }, obj2));
    }
    get template() {
      return this.get("template");
    }
    set template(value) {
      this.set("template", value);
    }
    get params() {
      return this.get("params");
    }
    set params(value) {
      this.set("params", value);
    }
    get engine() {
      return this.get("engine");
    }
    set engine(value) {
      this.set("engine", value);
    }
    enableHasChildren() {
      return false;
    }
    getDefaultTitle() {
      return "Template";
    }
    editable(editablePropertyName) {
      switch (editablePropertyName) {
        case "font":
          return true;
      }
      return super.editable(editablePropertyName);
    }
  }
  class TextModel extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "text",
        name: "New Text",
        elementType: "p",
        content: ""
      }, obj2));
    }
    get content() {
      return this.get("content");
    }
    set content(value) {
      this.set("content", value);
    }
    enableHasChildren() {
      return false;
    }
    getDefaultTitle() {
      return "Text";
    }
    editable(editablePropertyName) {
      switch (editablePropertyName) {
        case "svg-item":
        case "transform":
        case "transformOrigin":
        case "perspective":
        case "perspectiveOrigin":
        case "layout":
          return false;
        case "font":
        case "fontSpacing":
        case "textStyle":
        case "textShadow":
        case "textFill":
        case "textClip":
        case "backgroundImage":
        case "box-model":
        case "border":
        case "borderRadius":
        case "backdropFilter":
        case "pattern":
          return true;
      }
      return super.editable(editablePropertyName);
    }
  }
  function defaultItems(editor2) {
    editor2.registerItem("project", Project);
    editor2.registerItem("artboard", ArtBoard);
    editor2.registerItem("rect", RectLayer);
    editor2.registerItem("circle", CircleLayer);
    editor2.registerItem("image", ImageLayer);
    editor2.registerItem("text", TextModel);
    editor2.registerItem("boolean-path", BooleanPathModel);
    editor2.registerItem("svg-path", PathModel);
    editor2.registerItem("svg-text", SVGTextItem);
    editor2.registerItem("svg-textpath", SVGTextPathItem);
    editor2.registerItem("template", TemplateModel);
    editor2.registerItem("polygon", PolygonModel);
    editor2.registerItem("star", StarModel);
    editor2.registerItem("spline", SplineModel);
  }
  var texture = `
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000">
    <path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>
</svg>
`;
  var TextureView$1 = "";
  const cssPatterns = [
    {
      itemType: "circle",
      name: "base",
      attrs: {
        backgroundColor: "#ececec"
      }
    },
    {
      itemType: "circle",
      name: "base",
      attrs: {
        backgroundColor: "black"
      }
    },
    {
      itemType: "circle",
      name: "base",
      attrs: {
        backgroundColor: "red"
      }
    },
    {
      itemType: "circle",
      name: "base",
      attrs: {
        backgroundImage: `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `
      }
    },
    {
      itemType: "circle",
      name: "base",
      attrs: {
        backgroundImage: `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `,
        border: `
      border:10px solid black;
    `
      }
    }
  ];
  class CSSTextureView extends editor.EditorElement {
    template() {
      return `
      <div class="pattern-list css-pattern-list" ref="$css-list"></div>
    `;
    }
    [sapa.LOAD("$css-list")]() {
      return cssPatterns.map((it, index2) => {
        const svg = this.$editor.renderer("svg").render(this.$model.createModel(__spreadValues({
          itemType: it.itemType,
          width: 70,
          height: 70
        }, it.attrs), false));
        return `<div class="pattern-item" data-index="${index2}"><div class="preview">${svg}</div></div>`;
      });
    }
    [sapa.CLICK("$css-list .pattern-item")](e) {
      const index2 = +e.$dt.data("index");
      const pattern = cssPatterns[index2];
      e.$dt.onlyOneClass("selected");
      this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
    }
  }
  const svgPatterns = [
    {
      itemType: "svg-path",
      name: "path",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        d: PathParser.makeRect(0, 0, 80, 80).d
      }
    },
    {
      itemType: "svg-path",
      name: "line",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        d: PathParser.makeLine(0, 0, 80, 80).d
      }
    },
    {
      itemType: "svg-path",
      name: "line 2",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        d: PathParser.makeLine(0, 80, 80, 0).d
      }
    },
    {
      itemType: "svg-path",
      name: "circle",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makeCircle(0, 0, 80, 80).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 3",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 3,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 3).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 4",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 4,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 4).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 4",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 5,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 5).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 4",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 6,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 6).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 4",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 7,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 7).d
      }
    },
    {
      itemType: "polygon",
      name: "polygon - 4",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        count: 12,
        originWidth: 80,
        originHeight: 80,
        d: PathParser.makePolygon(80, 80, 12).d
      }
    },
    {
      itemType: "star",
      name: "star - 5",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        originWidth: 80,
        originHeight: 80,
        count: 5,
        radius: 0.5,
        d: PathParser.makeStar(80, 80, 5, 0.5).d
      }
    },
    {
      itemType: "star",
      name: "curved star - 5",
      attrs: {
        backgroundColor: "transparent",
        stroke: "black",
        "stroke-width": 2,
        fill: "#ececec",
        originWidth: 80,
        originHeight: 80,
        count: 5,
        radius: 0.5,
        d: PathParser.makeCurvedStar(80, 80, 5, 0.5).d
      }
    }
  ];
  class SVGTextureView extends editor.EditorElement {
    template() {
      return `
      <div class="pattern-list svg-pattern-list" ref="$svg-list"></div>
    `;
    }
    [sapa.LOAD("$svg-list")]() {
      return svgPatterns.map((it, index2) => {
        let d = it.attrs.d;
        if (d) {
          const path = PathParser.fromSVGString(d);
          if (it.attrs.originWidth) {
            path.scale(60 / it.attrs.originWidth, 60 / it.attrs.originHeight);
          } else {
            const rect2 = path.rect();
            path.scale(70 / rect2.width, 70 / rect2.height);
          }
          d = path.d;
        }
        const svg = this.$editor.renderer("svg").render(this.$model.createModel(__spreadProps(__spreadValues({
          itemType: it.itemType,
          width: 80,
          height: 80
        }, it.attrs), {
          d
        }), false));
        return `<div class="pattern-item" data-index="${index2}"><div class="preview">${svg}</div></div>`;
      });
    }
    [sapa.CLICK("$svg-list .pattern-item")](e) {
      const index2 = +e.$dt.data("index");
      const pattern = svgPatterns[index2];
      e.$dt.onlyOneClass("selected");
      this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
    }
  }
  class TextureView extends editor.EditorElement {
    template() {
      const isItemMode = this.$config.get("editor.design.mode") === "item";
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--texture"
      }, /* @__PURE__ */ sapa.createElementJsx(editor.Tabs, {
        ref: "$tab",
        selectedValue: isItemMode ? "svg" : "css",
        onchange: (value) => {
          this.$config.set("inspector.selectedValue", value);
        }
      }, isItemMode ? "" : /* @__PURE__ */ sapa.createElementJsx(editor.TabPanel, {
        value: "css",
        title: "CSS"
      }, /* @__PURE__ */ sapa.createElementJsx("object", {
        refClass: "CSSTextureView",
        ref: "$css"
      })), /* @__PURE__ */ sapa.createElementJsx(editor.TabPanel, {
        value: "svg",
        title: "SVG"
      }, /* @__PURE__ */ sapa.createElementJsx("object", {
        refClass: "SVGTextureView",
        ref: "$svg"
      }))));
    }
  }
  function defaultPatterns(editor2) {
    editor2.registerElement({
      TextureView,
      CSSTextureView,
      SVGTextureView
    });
    editor2.registerUI("leftbar.tab", {
      TextureView: {
        value: "texture",
        title: "Texture",
        icon: texture,
        designMode: ["design", "item"]
      }
    });
    editor2.registerUI("leftbar.tab.texture", {
      TextureView
    });
  }
  var DepthProperty$1 = "";
  class OrderDown extends MenuItem {
    getIconString() {
      return "to_back";
    }
    getTitle() {
      return "To Back";
    }
    clickButton() {
      this.commands.executeCommand("send.backward", "send backward", this.$context.selection.current);
    }
  }
  class OrderFirst extends MenuItem {
    getIconString() {
      return "to_front";
    }
    getTitle() {
      return "To First";
    }
    clickButton() {
      this.$commands.executeCommand("send.back", "send back", this.$context.selection.current);
    }
  }
  class OrderLast extends MenuItem {
    getIconString() {
      return "to_back";
    }
    getTitle() {
      return "To Last";
    }
    clickButton() {
      this.$commands.executeCommand("bring.front", "bring front", this.$context.selection.current);
    }
  }
  class OrderTop extends MenuItem {
    getIconString() {
      return "to_front";
    }
    getTitle() {
      return "To Front";
    }
    clickButton() {
      this.commands.executeCommand("bring.forward", "bring forward", this.$context.selection.current);
    }
  }
  class DepthProperty extends editor.BaseProperty {
    components() {
      return {
        OrderTop,
        OrderDown,
        OrderFirst,
        OrderLast
      };
    }
    getTitle() {
      return this.$i18n("alignment.property.title");
    }
    isHideHeader() {
      return true;
    }
    getBody() {
      return `
      <div class="elf--depth-item">
        ${sapa.createComponent("OrderTop")}
        ${sapa.createComponent("OrderDown")}
        ${sapa.createComponent("OrderFirst")}
        ${sapa.createComponent("OrderLast")}
      </div>
    `;
    }
  }
  function depth(editor2) {
    editor2.registerUI("inspector.tab.style", {
      DepthProperty
    });
  }
  var ExportProperty$1 = "";
  class ExportProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("export.property.title");
    }
    isFirstShow() {
      return true;
    }
    getClassName() {
      return "elf--export-property";
    }
    getBody() {
      return `
        <div class='export-item svg'>
          <label>SVG</label>
          <button ref='$svg'>${editor.iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div>
        <div class='export-item png'>
          <label>PNG</label>
          <button ref='$png'>${editor.iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div> 
      `;
    }
    [sapa.CLICK("$svg")]() {
      this.$commands.emit("downloadSVG");
    }
    [sapa.CLICK("$png")]() {
      this.$commands.emit("downloadPNG");
    }
  }
  function exportResource(editor2) {
    editor2.registerUI("inspector.tab.style", {
      ExportProperty
    });
  }
  var FillEditorView$1 = "";
  const spreadMethodList = [
    SpreadMethodType.PAD,
    SpreadMethodType.REFLECT,
    SpreadMethodType.REPEAT
  ];
  const TOOL_SIZE$1 = 20;
  class FillBaseEditor extends editor.EditorElement {
    initializeData() {
      const current = this.$context.selection.current;
      this.state.currentMatrix = current.matrix;
      this.state.imageResult = current.createFragmentMatrix(this.state.key);
      this.state.originalResult = current.createFragmentMatrix(this.state.key);
    }
  }
  class FillTimingStepEditor extends FillBaseEditor {
    [sapa.POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
      this.$el.toggleClass("dragging", true);
      this.initializeData();
      const colorStepIndex = +e.$dt.data("colorstep-index");
      this.localColorStep = this.state.imageResult.image.colorsteps[colorStepIndex];
      this.localColorStepTimingCount = this.localColorStep.timing.count;
      this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
    }
    moveStepPoint(dx, dy) {
      const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
      switch (this.localColorStep.timing.name) {
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.STEPS:
          this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
          break;
        default:
          this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
          break;
      }
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${this.state.imageResult.image}`
      }));
    }
    makeTimingString(timing) {
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.EASE:
        case TimingFunction.EASE_IN:
        case TimingFunction.EASE_OUT:
        case TimingFunction.EASE_IN_OUT:
          return `${timing.name}`;
        default:
          return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
      }
    }
    moveEndStepPoint(dx, dy) {
      if (dx === 0 && dy === 0) {
        const { timing } = this.localColorStep;
        switch (timing.name) {
          case TimingFunction.STEPS:
            this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
            this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
              [this.state.key]: `${this.state.imageResult.image}`
            }));
            break;
          case TimingFunction.LINEAR:
            break;
          case TimingFunction.PATH:
            this.emit("showComponentPopup", {
              title: "Path Editor",
              width: 400,
              inspector: [
                {
                  key: "path",
                  editor: "path",
                  editorOptions: {
                    height: 160
                  },
                  defaultValue: timing.d
                }
              ],
              changeEvent: (key, value) => {
                this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
                this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                  [this.state.key]: `${this.state.imageResult.image}`
                }));
              }
            });
            break;
          default:
            this.emit("showComponentPopup", {
              title: "Cubic Bezier",
              width: 220,
              inspector: [
                {
                  key: "timing",
                  editor: "cubic-bezier",
                  editorOptions: {
                    isAnimating: false
                  },
                  defaultValue: this.makeTimingString(timing)
                }
              ],
              changeEvent: (key, value) => {
                this.localColorStep.timing = parseOneValue(value).parsed;
                this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                  [this.state.key]: `${this.state.imageResult.image}`
                }));
              }
            });
            this.$el.toggleClass("dragging", false);
            return;
        }
      }
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${this.state.imageResult.image}`
      }));
      this.$el.toggleClass("dragging", false);
    }
  }
  class FillColorstepEditor extends FillTimingStepEditor {
    [sapa.KEYUP("$el .colorstep")](e) {
      const index2 = +e.$dt.data("index");
      switch (e.code) {
        case "Delete":
        case "Backspace":
          this.removeStep(index2);
          break;
        case "BracketRight":
          this.sortToRight(index2);
          break;
        case "BracketLeft":
          this.sortToLeft(index2);
          break;
        case "Equal":
          this.appendColorStep(index2);
          break;
        case "Minus":
          this.prependColorStep(index2);
          break;
      }
    }
    removeStep(currentIndex) {
      const image2 = this.state.imageResult.image;
      image2.removeColorStepByIndex(currentIndex);
      this.updateColorStepStatus(image2, -1);
    }
    sortToRight() {
      const image2 = this.state.imageResult.image;
      image2.sortToRight();
      this.updateColorStepStatus(image2, -1);
    }
    sortToLeft() {
      const image2 = this.state.imageResult.image;
      image2.sortToLeft();
      this.updateColorStepStatus(image2, -1);
    }
    appendColorStep(currentIndex) {
      const nextIndex = currentIndex + 1;
      const image2 = this.state.imageResult.image;
      const currentColorStep = image2.colorsteps[currentIndex];
      const nextColorStep = image2.colorsteps[nextIndex];
      let newIndex = -1;
      if (!nextColorStep) {
        if (currentColorStep.percent !== 100) {
          newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
        }
      } else {
        newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
      }
      this.updateColorStepStatus(image2, newIndex);
    }
    prependColorStep(currentIndex) {
      const prevIndex = currentIndex - 1;
      const image2 = this.state.imageResult.image;
      const currentColorStep = image2.colorsteps[currentIndex];
      const prevColorStep = image2.colorsteps[prevIndex];
      let newIndex = -1;
      if (!prevColorStep) {
        if (currentColorStep.percent !== 0) {
          newIndex = image2.insertColorStep(currentColorStep.percent);
        }
      } else {
        newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
      }
      this.updateColorStepStatus(image2, newIndex);
    }
    [sapa.POINTERSTART("$el .point") + MOVE("movePoint") + END("moveEndPoint")](e) {
      this.$el.toggleClass("dragging", true);
      this.initializeData();
      const result = this.state.imageResult;
      this.pointTarget = e.$dt.data("type");
      this.startPoint = this.$viewport.applyVertex(result.startPoint);
      this.endPoint = this.$viewport.applyVertex(result.endPoint);
      this.dist = dist(this.startPoint, this.endPoint);
      if (result.shapePoint) {
        this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
        this.shapeDist = dist(this.startPoint, this.shapePoint);
      }
    }
    calculateNextPoint(nextPoint) {
      if (this.$config.get("bodyEvent").shiftKey) {
        let tempStartPoint, tempEndPoint;
        if (this.pointTarget === "start") {
          tempStartPoint = this.endPoint;
          tempEndPoint = nextPoint;
        } else {
          tempStartPoint = this.startPoint;
          tempEndPoint = nextPoint;
        }
        const newDist = subtract([], tempEndPoint, tempStartPoint);
        let newAngle = calculateAngle360(newDist[0], newDist[1]) - 90;
        newAngle = (newAngle + 360) % 360;
        newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
        nextPoint = vertiesMap([add([], tempStartPoint, [0, -this.dist, 0])], calculateRotationOriginMat4(newAngle, tempStartPoint))[0];
      }
      return nextPoint;
    }
    moveShapePoint(dx, dy) {
      const targetPoint = this.shapePoint;
      const nextPoint = this.calculateNextPoint(add([], targetPoint, [dx, dy, 0]));
      const width2 = this.state.currentMatrix.width;
      const height = this.state.currentMatrix.height;
      const image2 = this.state.imageResult.image;
      let newX, newY;
      switch (image2.type) {
        case GradientType.RADIAL:
          const dist$1 = dist(this.startPoint, nextPoint);
          const lastPoint = lerp([], this.startPoint, this.shapePoint, dist$1 / this.shapeDist);
          const [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(lastPoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX = editor.Length.makePercent(worldPosition[0], width2);
          newY = editor.Length.makePercent(worldPosition[1], height);
          image2.reset({
            x3: newX,
            y3: newY
          });
          break;
      }
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${this.state.imageResult.image}`
      }));
    }
    movePoint(dx, dy) {
      if (this.pointTarget === "shape") {
        return this.moveShapePoint(dx, dy);
      }
      const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
      let nextPoint = this.calculateNextPoint(add([], targetPoint, [dx, dy, 0]));
      var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
      const width2 = this.state.currentMatrix.width;
      const height = this.state.currentMatrix.height;
      const image2 = this.state.imageResult.image;
      switch (image2.type) {
        case GradientType.RADIAL:
          var newX, newY, newX2, newY2, newX3, newY3;
          if (this.pointTarget === "start") {
            newX = image2.x1.isPercent() ? editor.Length.makePercent(worldPosition[0], width2) : editor.Length.px(worldPosition[0]);
            newY = image2.y1.isPercent() ? editor.Length.makePercent(worldPosition[1], height) : editor.Length.px(worldPosition[1]);
            const nextEndPoint = this.calculateNextPoint(add([], this.endPoint, [dx, dy, 0]));
            const [newEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextEndPoint)], this.state.currentMatrix.absoluteMatrixInverse);
            newX2 = image2.x2.isPercent() ? editor.Length.makePercent(newEndPosition[0], width2) : editor.Length.px(newEndPosition[0]);
            newY2 = image2.y2.isPercent() ? editor.Length.makePercent(newEndPosition[1], height) : editor.Length.px(newEndPosition[1]);
            const nextShapePoint = this.calculateNextPoint(add([], this.shapePoint, [dx, dy, 0]));
            const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
            newX3 = image2.x3.isPercent() ? editor.Length.makePercent(newShapePosition[0], width2) : editor.Length.px(newShapePosition[0]);
            newY3 = image2.y3.isPercent() ? editor.Length.makePercent(newShapePosition[1], height) : editor.Length.px(newShapePosition[1]);
            image2.reset({
              x1: newX,
              y1: newY,
              x2: newX2,
              y2: newY2,
              x3: newX3,
              y3: newY3
            });
          } else if (this.pointTarget === "end") {
            if (this.$config.get("bodyEvent").altKey) {
              const dist$1 = dist(this.startPoint, nextPoint);
              nextPoint = lerp([], this.startPoint, this.endPoint, dist$1 / this.dist);
              var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
            }
            newX = editor.Length.makePercent(worldPosition[0], width2);
            newY = editor.Length.makePercent(worldPosition[1], height);
            image2.reset({
              x2: newX,
              y2: newY
            });
            const lastDist = dist(this.startPoint, nextPoint);
            const unitVector = lerp([], this.startPoint, nextPoint, 1 / lastDist);
            const nextShapePoint = lerp([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], image2.radialType === RadialGradientType.CIRCLE ? lastDist : this.shapeDist);
            const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
            newX3 = editor.Length.makePercent(newShapePosition[0], width2);
            newY3 = editor.Length.makePercent(newShapePosition[1], height);
            image2.reset({
              x3: newX3,
              y3: newY3
            });
          }
          break;
        case GradientType.LINEAR:
          var newX, newY;
          if (this.pointTarget === "start") {
            newX = image2.x1.isPercent() ? editor.Length.makePercent(worldPosition[0], width2) : editor.Length.px(worldPosition[0]);
            newY = image2.y1.isPercent() ? editor.Length.makePercent(worldPosition[1], height) : editor.Length.px(worldPosition[1]);
            image2.reset({
              x1: newX,
              y1: newY
            });
          } else if (this.pointTarget === "end") {
            newX = image2.x2.isPercent() ? editor.Length.makePercent(worldPosition[0], width2) : editor.Length.px(worldPosition[0]);
            newY = image2.y2.isPercent() ? editor.Length.makePercent(worldPosition[1], height) : editor.Length.px(worldPosition[1]);
            image2.reset({
              x2: newX,
              y2: newY
            });
          }
          break;
      }
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${this.state.imageResult.image}`
      }));
    }
    moveEndPoint(dx, dy) {
      const image2 = this.state.imageResult.image;
      const width2 = this.state.currentMatrix.width;
      const height = this.state.currentMatrix.height;
      if (dx === 0 && dy === 0) {
        switch (image2.type) {
          case GradientType.RADIAL:
            if (this.pointTarget === "start") {
              switch (image2.radialType) {
                case RadialGradientType.CIRCLE:
                  image2.reset({
                    radialType: RadialGradientType.ELLIPSE
                  });
                  break;
                case RadialGradientType.ELLIPSE:
                  const lastDist = dist(this.startPoint, this.endPoint);
                  const unitVector = lerp([], this.startPoint, this.endPoint, 1 / lastDist);
                  const nextShapePoint = lerp([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], lastDist);
                  const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
                  const x3 = editor.Length.makePercent(newShapePosition[0], width2);
                  const y3 = editor.Length.makePercent(newShapePosition[1], height);
                  image2.reset({
                    radialType: RadialGradientType.CIRCLE,
                    x3,
                    y3
                  });
                  break;
              }
              break;
            }
          default:
            const index2 = spreadMethodList.findIndex((it) => image2.spreadMethod === it);
            const nextIndex = (index2 + 1) % spreadMethodList.length;
            image2.reset({
              spreadMethod: spreadMethodList[nextIndex]
            });
            break;
        }
      }
      this.emit("updateFillEditor", image2);
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${image2}`
      }));
    }
    [sapa.POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
      this.$el.toggleClass("dragging", true);
      this.state.hoverColorStep = null;
      this.initializeData();
      const $colorstep = e.$dt;
      this.$targetIndex = +$colorstep.data("index");
      if (e.altKey) {
        this.removeStep(this.$targetIndex);
        this.state.altKey = true;
        return;
      }
      const result = this.state.imageResult;
      switch (result.image.type) {
        case GradientType.RADIAL:
        case GradientType.LINEAR:
          this.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.endPoint = this.$viewport.applyVertex(result.endPoint);
          const x = +$colorstep.data("x");
          const y = +$colorstep.data("y");
          this.screenXY = [x, y, 0];
          const dist2 = subtract([], this.endPoint, this.startPoint);
          const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
          this.rotateInverse = calculateRotationOriginMat4(-angle, this.startPoint);
          break;
      }
    }
    moveColorStep(dx, dy) {
      if (this.state.altKey)
        return;
      const nextPoint = add([], this.screenXY, [dx, dy, 0]);
      const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
      const result = this.state.imageResult;
      let newDist = 0;
      let baseDist = 0;
      switch (result.image.type) {
        case GradientType.RADIAL:
        case GradientType.LINEAR:
          var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
          var baseDefaultDist = Math.abs(s - e);
          if (n < s) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else if (n > e) {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            newDist = (n - s) / baseDefaultDist * 100;
          }
          newDist = Math.max(0, Math.min(100, newDist));
          baseDist = baseDefaultDist;
          break;
      }
      const image2 = this.state.imageResult.image;
      image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      const nextImage = this.state.originalResult.image;
      nextImage.colorsteps = image2.colorsteps.map((it) => {
        return it;
      });
      nextImage.sortColorStep();
      this.emit("updateFillEditor", nextImage, targetColorStep);
      this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
        [this.state.key]: `${nextImage}`
      }));
    }
    moveEndColorStep(dx, dy) {
      if (this.state.altKey) {
        this.state.altKey = false;
        return;
      }
      if (dx === 0 && dy === 0) {
        const image2 = this.state.imageResult.image;
        image2.colorsteps[this.$targetIndex].toggleTiming();
        const targetColorStep = {
          color: image2.colorsteps[this.$targetIndex].color,
          percent: image2.colorsteps[this.$targetIndex].percent
        };
        this.emit("updateFillEditor", image2, targetColorStep);
        this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
          [this.state.key]: `${image2}`
        }));
      }
      this.$el.toggleClass("dragging", false);
    }
    updateColorStepStatus(image2, index2) {
      this.initializeData();
      const { color, percent } = image2.colorsteps[index2] || {};
      this.emit("updateFillEditor", image2, { color, percent });
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        [this.state.key]: `${image2}`
      }));
      this.state.hoverColorStep = null;
    }
    [sapa.POINTERSTART("$el .area-line")]() {
      const image2 = this.state.originalResult.image;
      const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
      this.updateColorStepStatus(image2, index2);
    }
    [sapa.POINTEROUT("$el .area-line")]() {
      if (this.state.hoverColorStep) {
        this.state.hoverColorStep = null;
        this.refresh();
      }
    }
    [sapa.POINTERMOVE("$el .area-line")](evt) {
      const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
      const image2 = this.state.originalResult.image;
      let baseStartPoint, baseEndPoint, baseNextPoint;
      switch (image2.type) {
        case GradientType.LINEAR:
        case GradientType.RADIAL:
          [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
          var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
          var baseDefaultDist = Math.abs(s - e);
          var newDist;
          if (n < s) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else if (n > e) {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            newDist = (n - s) / baseDefaultDist * 100;
          }
          this.state.hoverColorStep = image2.pickColorStep(newDist);
          break;
      }
      this.refresh();
    }
  }
  class FillEditorView extends FillColorstepEditor {
    initState() {
      return {
        key: "",
        value: "",
        isShow: false
      };
    }
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--fill-editor-view"
      });
    }
    updateData() {
      this.trigger(this.state.onchange, this.state.key, this.state.value);
    }
    refresh() {
      if (this.state.isShow) {
        this.load();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.DEBOUNCE(100)]() {
      if (this.$context.selection.current) {
        if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "fill", "stroke")) {
          this.refresh();
        }
      }
    }
    [sapa.SUBSCRIBE("showFillEditorView")](params = {}) {
      this.setState({
        key: params.key,
        isShow: true,
        onchange: params.onchange
      });
      this.$el.show();
      this.$context.commands.emit("push.mode.view", "FillEditorView");
    }
    [sapa.SUBSCRIBE("hideFillEditorView")]() {
      this.setState({
        key: "",
        isShow: false,
        onchange: null
      });
      this.$el.hide();
      this.$commands.emit("pop.mode.view", "FillEditorView");
    }
    makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
          });
        case TimingFunction.PATH:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).translate(startX, startY).d
          });
        default:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
          });
      }
    }
    makeTimingCircle(colorstepIndex, current, prev) {
      const prevStickScreenXY = prev.stickScreenXYInEnd;
      const stickScreenXY = current.stickScreenXYInStart;
      const { timing, timingCount } = current;
      let pos;
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timing.count));
        default:
          pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timingCount));
      }
    }
    makeTimingArea(colorstepIndex, current, prev, size) {
      const prevStickScreenXY = prev.stickScreenXYInEnd;
      const stickScreenXY = current.stickScreenXYInStart;
      return /* @__PURE__ */ sapa.createElementJsx("g", {
        class: "timing-area"
      }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "timing-path",
        d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
      }), this.makeTimingCircle(colorstepIndex, current, prev, size));
    }
    makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
      const size = TOOL_SIZE$1;
      const dist2 = subtract([], endPoint, startPoint);
      const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, colorsteps.map((it, index2) => {
        if (index2 === 0)
          return "";
        return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE$1);
      }), colorsteps.map((it, index2) => {
        return /* @__PURE__ */ sapa.createElementJsx("g", {
          transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
        }, /* @__PURE__ */ sapa.createElementJsx("rect", {
          id: it.id,
          "data-index": index2,
          class: "colorstep",
          x: it.stickScreenXY[0],
          y: it.stickScreenXY[1],
          width: size,
          height: size,
          fill: it.color,
          tabIndex: -1,
          "data-x": it.screenXY[0],
          "data-y": it.screenXY[1]
        }), this.makeTimingLine(it.timing, size, it.stickScreenXY[0], it.stickScreenXY[1]));
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "start",
        cx: startPoint[0],
        cy: startPoint[1]
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "end",
        cx: endPoint[0],
        cy: endPoint[1]
      }), shapePoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "shape",
        cx: shapePoint[0],
        cy: shapePoint[1]
      }), newHoverColorStepPoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "hover-colorstep",
        r: "5",
        cx: newHoverColorStepPoint[0],
        cy: newHoverColorStepPoint[1],
        fill: this.state.hoverColorStep.color
      }));
    }
    makeStickPoint(colorsteps, startPoint, endPoint) {
      const size = TOOL_SIZE$1;
      const dist2 = subtract([], endPoint, startPoint);
      const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
      const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
      const rotateInverseInverse = invert([], rotateInverse);
      return colorsteps.map((it) => {
        it.screenXY = this.$viewport.applyVertex(it.pos);
        const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
        [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
          [newScreenXY[0] - size / 2, newScreenXY[1] - size * 1.5, 0],
          [
            newScreenXY[0] - size / 2,
            newScreenXY[1] - size * 1.5 + size / 2,
            0
          ],
          [
            newScreenXY[0] + size / 2,
            newScreenXY[1] - size * 1.5 + size / 2,
            0
          ]
        ], rotateInverseInverse);
        return it;
      });
    }
    makeRadialCenterPoint(result) {
      let startPoint, endPoint, shapePoint, colorsteps;
      startPoint = this.$viewport.applyVertex(result.startPoint);
      endPoint = this.$viewport.applyVertex(result.endPoint);
      shapePoint = this.$viewport.applyVertex(result.shapePoint);
      colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
      let newHoverColorStepPoint = null;
      if (this.state.hoverColorStep) {
        newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
      }
      return /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "gradient-editor-area"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "area-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "start-end-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
        class: "normal-line"
      }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint));
    }
    makeLinearCenterPoint(result) {
      let startPoint, endPoint, colorsteps;
      startPoint = this.$viewport.applyVertex(result.startPoint);
      endPoint = this.$viewport.applyVertex(result.endPoint);
      colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
      let newHoverColorStepPoint = null;
      if (this.state.hoverColorStep) {
        newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
      }
      return /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "gradient-editor-area"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
            M ${startPoint[0]} ${startPoint[1]}
            L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "area-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "start-end-line"
      }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
    }
    makeCenterPoint(result) {
      const { image: image2 } = result;
      switch (image2.type) {
        case GradientType.LINEAR:
          return this.makeLinearCenterPoint(result);
        case GradientType.RADIAL:
          return this.makeRadialCenterPoint(result);
      }
      return "";
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      if (!this.state.isShow)
        return "";
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const result = current.createFragmentMatrix(this.state.key);
      this.state.result = result;
      this.state.originalResult = current.createFragmentMatrix(this.state.key);
      const image2 = result.image;
      let angle, dist2;
      switch (image2.type) {
        case GradientType.LINEAR:
          this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
          dist2 = subtract([], this.state.endPoint, this.state.startPoint);
          angle = calculateAngle360(dist2[0], dist2[1]) - 180;
          this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
          break;
        case GradientType.RADIAL:
          this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
          this.state.shapePoint = this.$viewport.applyVertex(result.shapePoint);
          dist2 = subtract([], this.state.endPoint, this.state.startPoint);
          angle = calculateAngle360(dist2[0], dist2[1]) - 180;
          this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
          break;
      }
      return /* @__PURE__ */ sapa.createElementJsx("div", null, this.makeCenterPoint(result));
    }
  }
  function fillEditorView(editor2) {
    editor2.registerUI("canvas.view", {
      FillEditorView
    });
  }
  var FilterProperty$1 = "";
  const filter_list$1 = [
    "blur",
    "grayscale",
    "hue-rotate",
    "invert",
    "brightness",
    "contrast",
    "drop-shadow",
    "opacity",
    "saturate",
    "sepia",
    "svg"
  ];
  class FilterProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("filter.property.title");
    }
    hasKeyframe() {
      return true;
    }
    isFirstShow() {
      return true;
    }
    afterRender() {
      this.show();
    }
    getKeyframeProperty() {
      return "filter";
    }
    getTitleClassName() {
      return "filter";
    }
    getBodyClassName() {
      return "no-padding";
    }
    getBody() {
      return `<div class='full filter-property' ref='$body'></div>`;
    }
    getTools() {
      return `
      <select class='filter-select' ref="$filterSelect">      
      </select>
      <button type="button" ref="$add" title="add Filter">${editor.iconUse("add")}</button>
    `;
    }
    [sapa.CLICK("$add")]() {
      var filterType = this.refs.$filterSelect.value;
      this.children.$filterEditor.trigger("add", filterType);
    }
    [sapa.LOAD("$filterSelect")]() {
      var list = filter_list$1.map((it) => {
        return { title: this.$i18n(`filter.property.${it}`), value: it };
      });
      var svgFilterList = this.getSVGFilterList();
      var totalList = [];
      if (svgFilterList.length) {
        totalList = [...list, { title: "-------", value: "" }, ...svgFilterList];
      } else {
        totalList = [...list];
      }
      return totalList.map((it) => {
        var { title, value } = it;
        return `<option value='${value}'>${title}</option>`;
      });
    }
    getSVGFilterList() {
      var current = this.$context.selection.currentProject;
      var arr = [];
      if (current) {
        arr = current.svgfilters.map((it) => {
          var id = it.id;
          return {
            title: `svg - #${id}`,
            value: id
          };
        });
      }
      return arr;
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current || {};
      var value = current.filter;
      return sapa.createComponent("FilterEditor", {
        ref: "$filterEditor",
        key: "filter",
        value: sapa.clone(value),
        onchange: "changeFilterEditor"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
      this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.packByValue({
        [key]: sapa.clone(filter2)
      }));
    }
    get editableProperty() {
      return "filter";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow") + sapa.DEBOUNCE(100)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("refreshSVGArea") + sapa.DEBOUNCE(100)]() {
      this.load("$filterSelect");
    }
  }
  function filter(editor2) {
    editor2.registerUI("inspector.tab.style", {
      FilterProperty
    });
  }
  function font(editor$1) {
    editor$1.registerUI("inspector.tab.style", {
      FontProperty: editor.ObjectProperty.create({
        title: editor$1.$i18n("font.property.title"),
        editableProperty: "font",
        preventUpdate: true
      })
    });
    editor$1.registerInspector("font", (current) => {
      return [
        {
          key: "font-family",
          editor: "SelectEditor",
          editorOptions: {
            compact: true,
            label: "font_download",
            options: [
              "",
              "Arial",
              "Arial Black",
              "Times New Roman",
              "Times",
              "Courier New",
              "Courier",
              "Verdana",
              "Georgia",
              "Palatino",
              "Garamond",
              "Bookman",
              "Tahoma",
              "Trebuchet MS",
              "Impact",
              "Comic Sans MS",
              "serif",
              "sans-serif",
              "monospace",
              "cursive",
              "fantasy",
              "system-ui"
            ]
          },
          defaultValue: current.fontFamily || ""
        },
        {
          type: "column",
          size: [1, 1],
          gap: 10,
          columns: [
            {
              key: "font-size",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "format_size",
                compact: true,
                min: 8,
                max: 1e3,
                step: 1
              },
              defaultValue: editor.Length.parse(current.fontSize).value,
              convert: (key, value) => editor.Length.px(value)
            },
            {
              key: "padding",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "padding",
                compact: true,
                min: 8,
                max: 1e3,
                step: 1
              },
              defaultValue: editor.Length.parse(current.paddingTop).value,
              convert: (key, value) => editor.Length.px(value)
            }
          ]
        },
        {
          type: "column",
          size: [1, 1],
          columns: [
            {
              key: "color",
              editor: "ColorViewEditor",
              editorOptions: {
                compact: true
              },
              defaultValue: current.color || "#000"
            },
            {
              key: "font-weight",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "format_bold",
                compact: true,
                min: 100,
                max: 900,
                step: 100
              },
              defaultValue: current.fontWeight || 400
            }
          ]
        },
        {
          type: "column",
          size: [1, 1, 1],
          gap: 10,
          columns: [
            {
              key: "text-indent",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "format_indent",
                min: -100,
                max: 100,
                step: 1,
                compact: true
              },
              defaultValue: editor.Length.parse(current.textIndent).value,
              convert: (key, value) => editor.Length.px(value)
            },
            {
              key: "line-height",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "format_line_spacing",
                min: 0,
                max: 10,
                step: 0.01,
                compact: true
              },
              defaultValue: current.lineHeight || 1.2
            },
            {
              key: "letter-spacing",
              editor: "NumberInputEditor",
              editorOptions: {
                label: "space",
                min: -100,
                max: 100,
                step: 1,
                compact: true
              },
              defaultValue: editor.Length.parse(current.letterSpacing).value,
              convert: (key, value) => editor.Length.px(value)
            }
          ]
        }
      ];
    });
  }
  var FillEditor$1 = "";
  class FillEditor extends editor.EditorElement {
    initState() {
      var _a;
      const image2 = SVGFill.parseImage(this.props.value || "transparent") || SVGStaticGradient.create();
      const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
      this.$context.selection.selectColorStep(id);
      if (id) {
        this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      }
      return {
        cachedRect: null,
        index: +(this.props.index || 0),
        value: this.props.value,
        image: image2
      };
    }
    setValue(value) {
      this.setState({
        cachedRect: null,
        image: SVGFill.parseImage(value)
      }, false);
      this.refresh();
    }
    template() {
      return `
        <div class='elf--fill-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>               
            <div class='sub-editor' ref='$subEditor'> 
                <div data-editor='patternUnits'>
                  ${sapa.createComponent("SelectEditor", {
        label: "Pattern",
        ref: "$patternUnits",
        options: ["userSpaceOnUse"],
        key: "patternUnits",
        onchange: "changeKeyValue"
      })}
                </div>                  
                                                                                                                                
            </div>            
        </div>
      `;
    }
    getImageFieldValue(image2, field) {
      var value = image2[field];
      if (sapa.isUndefined(value)) {
        switch (field) {
          case "cx":
          case "cy":
          case "r":
          case "fx":
          case "fy":
            return "50%";
          case "x1":
          case "y1":
          case "y2":
          case "fr":
          case "imageX":
          case "imageY":
            return "0%";
          case "x2":
          case "patternWidth":
          case "patternHeight":
          case "imageWidth":
          case "imageHeight":
            return "100%";
        }
      }
      return value;
    }
    [sapa.CHANGE("$file")](e) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        [...e.target.files].forEach((item) => {
          this.$commands.emit("updateImageAssetItem", item, (local) => {
            this.trigger("setImageUrl", local);
          });
        });
      }
    }
    refreshFieldValue() {
      this.children.$cx.setValue(this.state.image.cx);
      this.children.$cy.setValue(this.state.image.cy);
      this.children.$r.setValue(this.state.image.r);
      this.children.$fx.setValue(this.state.image.fx);
      this.children.$fy.setValue(this.state.image.fy);
      this.children.$fr.setValue(this.state.image.fr);
      this.children.$patternUnits.setValue(this.state.image.patternUnits);
      this.children.$patternWidth.setValue(this.state.image.patternWidth);
      this.children.$patternHeight.setValue(this.state.image.patternHeight);
      this.children.$imageX.setValue(this.state.image.imageX);
      this.children.$imageY.setValue(this.state.image.imageY);
      this.children.$imageWidth.setValue(this.state.image.imageWidth);
      this.children.$imagenHeight.setValue(this.state.image.imageHeight);
    }
    getFieldValue(field) {
      return editor.Length.parse(this.getImageFieldValue(this.state.image, field));
    }
    getRectRate(rect2, x, y) {
      var { width: width2, height, x: rx, y: ry } = rect2;
      if (rx > x) {
        x = rx;
      } else if (rx + width2 < x) {
        x = rx + width2;
      }
      if (ry > y) {
        y = ry;
      } else if (ry + height < y) {
        y = ry + height;
      }
      var left = editor.Length.makePercent(x - rx, width2);
      var top = editor.Length.makePercent(y - ry, height);
      return { left, top };
    }
    [sapa.SUBSCRIBE_SELF("changeTabType")](type) {
      var _a, _b;
      const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
      const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
      if (colorsteps.length === 1) {
        colorsteps.push(colorsteps[0]);
      }
      if (oldType === GradientType.STATIC) {
        if (colorsteps.length === 0) {
          colorsteps.push(colorsteps[0], colorsteps[0]);
        } else if (colorsteps.length === 1) {
          colorsteps.push(colorsteps[0]);
        }
      }
      var url = type === "image-resource" ? this.state.image.url : this.state.url;
      this.state.image = SVGFill.changeImageType({
        type,
        url,
        colorsteps,
        spreadMethod: this.state.image.spreadMethod
      });
      this.refresh();
      this.updateData();
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      this.state.image.reset({
        [key]: value
      });
      this.updateData();
    }
    [sapa.SUBSCRIBE("changeColorStepOffset")](key, value) {
      if (this.currentStep) {
        this.currentStep.percent = value.value;
        this.state.image.sortColorStep();
        this.refresh();
        this.updateData();
      }
    }
    [sapa.CLICK("$back")](e) {
      var rect2 = this.refs.$stepList.rect();
      var minX = rect2.x;
      var maxX = rect2.right;
      var x = e.xy.x;
      if (x < minX)
        x = minX;
      else if (x > maxX)
        x = maxX;
      var percent = (x - minX) / rect2.width * 100;
      this.state.image.insertColorStep(percent);
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
    [sapa.BIND("$el")]() {
      var type = this.state.image.type;
      if (type === "url") {
        type = "image-resource";
      }
      return {
        "data-selected-editor": type
      };
    }
    [sapa.BIND("$stepList")]() {
      return {
        style: {
          "background-image": this.getLinearGradient()
        }
      };
    }
    [sapa.LOAD("$stepList")]() {
      var colorsteps = this.state.image.colorsteps || [];
      return colorsteps.map((it) => {
        var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
        return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>
        <div class='arrow'></div>
      </div>`;
      });
    }
    removeStep(id) {
      this.state.image.removeColorStep(id);
      this.refresh();
      this.updateData();
    }
    selectStep(id) {
      this.state.id = id;
      this.$context.selection.selectColorStep(id);
      if (this.state.image.colorsteps) {
        this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
        this.parent.trigger("selectColorStep", this.currentStep.color);
      }
      this.refresh();
    }
    [sapa.KEYUP("$el .step")](e) {
      const id = e.$dt.data("id");
      switch (e.code) {
        case "Delete":
        case "Backspace":
          this.removeStep(id);
          break;
        case "BracketRight":
          this.sortToRight(id);
          break;
        case "BracketLeft":
          this.sortToLeft(id);
          break;
        case "Equal":
          this.appendColorStep(id);
          break;
        case "Minus":
          this.prependColorStep(id);
          break;
      }
    }
    sortToRight(id) {
      this.state.image.sortToRight();
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    sortToLeft(id) {
      this.state.image.sortToLeft();
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    appendColorStep(id) {
      const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
      const nextIndex = currentIndex + 1;
      const currentColorStep = this.state.image.colorsteps[currentIndex];
      const nextColorStep = this.state.image.colorsteps[nextIndex];
      if (!nextColorStep) {
        if (currentColorStep.percent !== 100) {
          this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
        }
      } else {
        this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
      }
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    doFocus(id) {
      this.nextTick(() => {
        this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
      }, 100);
    }
    prependColorStep(id) {
      const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
      const prevIndex = currentIndex - 1;
      const currentColorStep = this.state.image.colorsteps[currentIndex];
      const prevColorStep = this.state.image.colorsteps[prevIndex];
      if (!prevColorStep) {
        if (currentColorStep.percent !== 0) {
          this.state.image.insertColorStep(currentColorStep.percent);
        }
      } else {
        this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
      }
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    [sapa.POINTERSTART("$stepList .step") + MOVE() + END()](e) {
      var id = e.$dt.attr("data-id");
      if (e.altKey) {
        this.removeStep(id);
        return false;
      } else {
        e.$dt.focus();
        this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
        this.selectStep(id);
        this.startXY = e.xy;
        this.cachedStepListRect = this.refs.$stepList.rect();
      }
    }
    getStepListRect() {
      return this.cachedStepListRect;
    }
    move(dx) {
      var rect2 = this.getStepListRect();
      var minX = rect2.x;
      var maxX = rect2.right;
      var x = this.startXY.x + dx;
      if (x < minX)
        x = minX;
      else if (x > maxX)
        x = maxX;
      var percent = (x - minX) / rect2.width * 100;
      if (this.$config.get("bodyEvent").shiftKey) {
        percent = Math.floor(percent);
      }
      this.currentStep.percent = percent;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
    end(dx, dy) {
      if (dx === 0 && dy === 0) {
        if (this.isSelectedColorStep) {
          if (this.currentStep) {
            this.currentStep.cut = !this.currentStep.cut;
            this.refresh();
            this.updateData();
          }
        }
      }
      this.doFocus(this.state.id);
    }
    getLinearGradient() {
      var { image: image2 } = this.state;
      return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
    }
    [sapa.SUBSCRIBE_SELF("setColorStepColor")](color) {
      if (this.state.image.type === "static-gradient") {
        this.state.image.setColor(color);
        this.refresh();
        this.updateData();
      } else {
        if (this.currentStep) {
          this.currentStep.color = color;
          this.refresh();
          this.updateData();
        }
      }
    }
    [sapa.SUBSCRIBE("setImageUrl")](url, datauri) {
      if (this.state.image) {
        this.state.url = url;
        this.state.image.reset({ url, datauri });
        this.refresh();
        this.updateData();
      }
    }
    updateData(data = {}) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.state.image.toString());
    }
  }
  var GradientPickerPopup$1 = "";
  class GradientPickerPopup extends editor.BasePopup {
    getTitle() {
      var _a;
      return sapa.createComponent("SelectEditor", {
        ref: "$select",
        value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
        onchange: "changeTabType",
        options: [
          {
            value: GradientType.STATIC,
            text: "Static"
          },
          {
            value: GradientType.LINEAR,
            text: "Linear Gradient"
          },
          {
            value: GradientType.RADIAL,
            text: "Radial Gradient"
          },
          {
            value: GradientType.CONIC,
            text: "Conic Gradient"
          },
          {
            value: GradientType.REPEATING_LINEAR,
            text: "Repeating Linear Gradient"
          },
          {
            value: GradientType.REPEATING_RADIAL,
            text: "Repeating Radial Gradient"
          },
          {
            value: GradientType.REPEATING_CONIC,
            text: "Repeating Conic Gradient"
          },
          {
            value: GradientType.URL,
            text: "Image"
          }
        ]
      });
    }
    initialize() {
      super.initialize();
      this.selectedTab = "static-gradient";
    }
    getClassName() {
      return "fill-picker-popup";
    }
    getBody() {
      var _a, _b;
      return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${sapa.createComponent("EmbedColorPicker", {
        ref: "$color",
        onchange: "changeColor"
      })}
          </div>
          <div class='assetpicker'>
            ${sapa.createComponent("ImageSelectEditor", {
        ref: "$image",
        key: "image",
        value: (_b = this.state.image) == null ? void 0 : _b.url,
        onchange: "changeImageUrl"
      })}
            ${sapa.createComponent("ImageAssetPicker", {
        ref: "$asset",
        onchange: "changeImageUrl"
      })}
          </div>
        </div>
      </div>
     
    `;
    }
    getColorString() {
      var value = "";
      if (this.state.image instanceof Gradient) {
        value = this.state.image.getColorString();
      }
      return value;
    }
    getCurrentColor() {
      return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
    }
    [sapa.BIND("$body")]() {
      var _a;
      return {
        "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
      };
    }
    [sapa.LOAD("$gradientEditor") + sapa.DOMDIFF]() {
      var _a;
      if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
        return "";
      }
      return sapa.createComponent("GradientEditor", {
        ref: "$g",
        value: `${this.state.image ? this.state.image.toString() : ""}`,
        index: this.state.selectColorStepIndex,
        onchange: "changeGradientEditor"
      });
    }
    [sapa.SUBSCRIBE("updateGradientEditor")](data, targetColorStep) {
      this.state.image = sapa.isString(data) ? BackgroundImage.parseImage(data) : data;
      this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
      this.children.$color.setValue(targetColorStep.color);
      this.refresh();
    }
    [sapa.SUBSCRIBE_SELF("changeGradientEditor")](data) {
      this.state.image = sapa.isString(data) ? BackgroundImage.parseImage(data) : data;
      this.updateTitle();
      this.updateData();
    }
    [sapa.SUBSCRIBE_SELF("changeTabType")](key, type) {
      this.children.$g.trigger("changeTabType", type);
      this.refs.$body.attr("data-selected-editor", type);
    }
    [sapa.SUBSCRIBE_SELF("changeColor")](color) {
      this.children.$g.trigger("setColorStepColor", color);
    }
    [sapa.SUBSCRIBE_SELF("changeImageUrl")](key, url) {
      if (this.state.image) {
        this.state.image.reset({
          url
        });
        this.trigger("changeGradientEditor", this.state.image);
      }
    }
    updateTitle() {
      this.children.$select.setValue(this.state.image.type);
    }
    [sapa.SUBSCRIBE("showGradientPickerPopup")](data, params, rect2) {
      data.changeEvent = data.changeEvent || "changeFillPopup";
      data.image = data.gradient;
      data.params = params;
      this.showByRect(this.makeRect(248, 560, rect2));
      this.setState(data);
      this.updateTitle();
      this.emit("showGradientEditorView", {
        index: data.index
      });
    }
    [sapa.SUBSCRIBE("hideGradientickerPopup")]() {
      this.hide();
      this.emit("hideGradientEditorView");
    }
    onClose() {
      this.emit("hideGradientEditorView");
    }
    [sapa.SUBSCRIBE("selectColorStep")](color) {
      this.children.$color.setValue(color);
    }
    [sapa.SUBSCRIBE("changeColorStep")](data = {}) {
      this.state.image.reset(__spreadValues({}, data));
      this.updateData();
    }
    load(...args2) {
      if (this.$el.isShow()) {
        super.load(...args2);
      }
    }
    getValue() {
      return `${this.state.image}`;
    }
    updateData() {
      this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
    }
  }
  class FillPickerPopup extends editor.BasePopup {
    getTitle() {
      var _a;
      return sapa.createComponent("SelectEditor", {
        ref: "$select",
        value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
        onchange: "changeTabType",
        options: [
          {
            value: GradientType.STATIC,
            text: "Static"
          },
          {
            value: GradientType.LINEAR,
            text: "Linear Gradient"
          },
          {
            value: GradientType.RADIAL,
            text: "Radial Gradient"
          },
          {
            value: GradientType.URL,
            text: "Image"
          }
        ]
      });
    }
    initState() {
      return {
        image: SVGStaticGradient.create()
      };
    }
    initialize() {
      super.initialize();
      this.selectedTab = "static-gradient";
    }
    getClassName() {
      return "fill-picker-popup";
    }
    getBody() {
      var _a, _b;
      return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${sapa.createComponent("EmbedColorPicker", {
        ref: "$color",
        onchange: "changeColor"
      })}    
          </div>
          <div class='assetpicker'>
            ${sapa.createComponent("ImageSelectEditor", {
        ref: "$image",
        key: "image",
        value: (_b = this.state.image) == null ? void 0 : _b.url,
        onchange: "changeImageUrl"
      })}
            ${sapa.createComponent("ImageAssetPicker", {
        ref: "$asset",
        onchange: "changeImageUrl"
      })}
          </div>
        </div>
      </div>
     
    `;
    }
    [sapa.BIND("$body")]() {
      var _a;
      return {
        "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
      };
    }
    getColorString() {
      var value = "";
      if (this.state.image instanceof Gradient) {
        value = this.state.image.getColorString();
      }
      return value;
    }
    getCurrentColor() {
      return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
    }
    [sapa.LOAD("$gradientEditor")]() {
      var _a;
      if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
        return "";
      }
      return sapa.createComponent("FillEditor", {
        ref: "$g",
        value: `${this.state.image}`,
        index: this.state.selectColorStepIndex,
        onchange: "changeFillEditor"
      });
    }
    [sapa.SUBSCRIBE("updateFillEditor")](data, targetColorStep = void 0) {
      this.state.image = sapa.isString(data) ? SVGFill.parseImage(data) : data;
      if (targetColorStep) {
        this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
        this.children.$color.setValue(targetColorStep.color);
      }
      this.refresh();
    }
    [sapa.SUBSCRIBE_SELF("changeFillEditor")](data) {
      this.state.image = sapa.isString(data) ? SVGFill.parseImage(data) : data;
      this.updateTitle();
      this.updateData();
    }
    [sapa.SUBSCRIBE_SELF("changeTabType")](key, type) {
      this.children.$g.trigger("changeTabType", type);
      this.refs.$body.attr("data-selected-editor", type);
    }
    [sapa.SUBSCRIBE_SELF("changeColor")](color) {
      this.children.$g.trigger("setColorStepColor", color);
    }
    [sapa.SUBSCRIBE_SELF("changeImageUrl")](url) {
      if (this.state.image) {
        this.state.image.reset({
          url
        });
        this.trigger("changeFillEditor", this.state.image);
      }
    }
    updateTitle() {
      this.children.$select.setValue(this.state.image.type);
    }
    [sapa.SUBSCRIBE("showFillPickerPopup")](data, params, rect2) {
      data.changeEvent = data.changeEvent || "changeFillPopup";
      data.params = params;
      this.showByRect(this.makeRect(248, 560, rect2));
      this.setState(data);
      this.updateTitle();
      if (data.image.isGradient()) {
        this.trigger("selectColorStep", data.image.colorsteps[0].color);
      }
      this.emit("showFillEditorView", {
        key: data.key
      });
    }
    [sapa.SUBSCRIBE("hideFillPickerPopup")]() {
      this.hide();
      this.emit("hideFillEditorView");
    }
    onClose() {
      this.emit("hideFillEditorView");
    }
    [sapa.SUBSCRIBE("selectColorStep")](color) {
      this.children.$color.setValue(color);
    }
    [sapa.SUBSCRIBE("changeColorStep")](data = {}) {
      this.state.image.reset(__spreadValues({}, data));
      this.updateData();
    }
    load(...args2) {
      if (this.$el.isShow()) {
        super.load(...args2);
      }
    }
    getValue() {
      return `${this.state.image}`;
    }
    updateData() {
      this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
    }
  }
  var FillSingleEditor$1 = "";
  class FillSingleEditor extends editor.EditorElement {
    initState() {
      return {
        index: this.props.index,
        label: this.props.label,
        simple: this.props.simple === "true" ? true : false,
        image: SVGFill.parseImage(this.props.value || this.props.image || "transparent")
      };
    }
    get fillId() {
      return this.id + "fill";
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.modifyValue(opt);
    }
    modifyValue() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.state.index);
    }
    getValue() {
      return this.state.image.toString();
    }
    setValue(value) {
      this.setState({
        image: SVGFill.parseImage(value)
      });
    }
    [sapa.BIND("$fillView")]() {
      var image2 = this.state.image;
      if (!image2)
        return { innerHTML: "" };
      return {
        innerHTML: image2.toSVGString(this.fillId, {
          width: 20,
          height: 20,
          sizeType: "percent"
        })
      };
    }
    [sapa.BIND("$fillColor")]() {
      var image2 = this.state.image;
      if (!image2)
        return { fill: "transparent" };
      return {
        fill: image2.toFillValue(this.fillId)
      };
    }
    [sapa.BIND("$colors")]() {
      var image2 = this.state.image;
      if (!image2)
        return { fill: "transparent" };
      var colors2 = image2.type != "url" ? `${image2.colorsteps[0].color}` : "transparent";
      if ([GradientType.LINEAR, GradientType.RADIAL].includes(image2.type)) {
        colors2 = image2.colorsteps.map((it) => {
          return `<span class='color' style='background-color: ${it.color}' title='${it.color}'></span>`;
        }).join("");
      }
      return {
        innerHTML: `<div> ${colors2} </div>`
      };
    }
    template() {
      var { label, simple } = this.state;
      var hasLabel = label ? "has-label" : "";
      return `
            <div class='elf--fill-single-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class="area">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>

                            <svg class='color-view' ref='$miniView'>
                                <defs ref='$fillView'></defs>
                                <rect x="0" y="0" width="100%" height="100%" ref='$fillColor' fill='url(#${this.fillId})' />
                            </svg>
                        </div>
                    </div>
                    <div class='colors ${simple ? "simple" : ""}' ref='$colors'></div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK()]() {
      this.viewGradientPopup();
    }
    viewGradientPopup() {
      this.emit("showFillPickerPopup", {
        instance: this,
        key: this.props.key,
        changeEvent: "changeFillSingle",
        image: this.state.image
      }, null, this.$el.rect());
    }
    [sapa.SUBSCRIBE("changeFillSingle")](image2) {
      this.updateData({ image: SVGFill.parseImage(image2) });
      this.refresh();
    }
  }
  var GradientSingleEditor$1 = "";
  class GradientSingleEditor extends editor.EditorElement {
    initState() {
      return {
        index: this.props.index,
        image: this.props.image,
        color: "rgba(0, 0, 0, 1)"
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.modifyValue(opt);
    }
    modifyValue(value) {
      this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
    }
    setValue(obj2) {
      this.setState(__spreadValues({}, obj2));
    }
    [sapa.BIND("$miniView")]() {
      const project2 = this.$context.selection.currentProject;
      let image2;
      if (this.state.image.type === GradientType.URL) {
        const imageUrl = project2.getImageValueById(this.state.image.url);
        image2 = this.state.image.toString(imageUrl);
      } else {
        image2 = this.state.image.toCSSString();
      }
      return {
        style: {
          "background-image": image2
        }
      };
    }
    template() {
      return `
            <div class='elf--gradient-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK("$preview")]() {
      this.viewGradientPopup();
    }
    viewGradientPopup() {
      this.emit("showGradientPickerPopup", {
        instance: this,
        changeEvent: "changeGradientSingle",
        index: this.state.index,
        gradient: this.state.image
      }, null, this.$el.rect());
    }
    [sapa.SUBSCRIBE("changeGradientSingle")](image2) {
      var _a;
      image2 = BackgroundImage.parseImage(image2);
      const currentImage = (_a = this.$context.selection.current.getBackgroundImage(this.state.index)) == null ? void 0 : _a.image;
      switch (currentImage.type) {
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          image2.reset({
            radialPosition: currentImage.radialPosition || ["50%", "50%"],
            radialType: currentImage.radialType || RadialGradientType.CIRCLE
          });
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          image2.reset({
            angle: currentImage.angle || 0,
            radialPosition: currentImage.radialPosition || ["50%", "50%"]
          });
          break;
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
        case GradientType.STATIC:
          image2.reset({
            angle: currentImage.angle || 0
          });
          break;
      }
      this.updateData({ image: image2 });
      this.refresh();
    }
  }
  function gradient(editor2) {
    editor2.registerElement({
      FillSingleEditor,
      FillEditor,
      GradientSingleEditor
    });
    editor2.registerAlias({
      "fill-single": "FillSingleEditor",
      fill: "FillEditor",
      "gradient-single": "GradientSingleEditor"
    });
    editor2.registerUI("popup", {
      FillPickerPopup,
      GradientPickerPopup
    });
  }
  var GradientEditorView$1 = "";
  var radialTypeList = [
    "circle",
    "circle farthest-corner",
    "circle closest-side",
    "circle closest-corner",
    "circle farthest-side",
    "ellipse",
    "ellipse farthest-corner",
    "ellipse closest-side",
    "ellipse closest-corner",
    "ellipse farthest-side"
  ];
  var repeatTypeList = [
    "no-repeat",
    "repeat",
    "repeat-x",
    "repeat-y",
    "space",
    "round"
  ];
  const TOOL_SIZE = 20;
  class GradientBaseEditor extends editor.EditorElement {
    initializeData() {
      const value = this.$context.selection.current.backgroundImage;
      const cssValue = STRING_TO_CSS(value);
      this.state.backgroundImages = BackgroundImage.parseStyle(cssValue);
      this.state.backImages = BackgroundImage.parseStyle(cssValue);
      const current = this.$context.selection.current;
      this.state.gradient = this.state.backImages[this.state.index];
      this.state.contentBox = current.contentBox;
      this.state.backgroundImageMatrix = current.createBackgroundImageMatrix(this.state.index);
    }
    updateData() {
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        backgroundImage: value
      }));
    }
  }
  class GradientTimingStepEditor extends GradientBaseEditor {
    [sapa.POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
      this.$el.toggleClass("dragging", true);
      this.initializeData();
      const colorStepIndex = +e.$dt.data("colorstep-index");
      this.localColorStep = this.state.backgroundImages[this.state.index].image.colorsteps[colorStepIndex];
      this.localColorStepTimingCount = this.localColorStep.timing.count;
      this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
    }
    moveStepPoint(dx, dy) {
      const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
      switch (this.localColorStep.timing.name) {
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.STEPS:
          this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
          break;
        default:
          this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
          break;
      }
      this.updateData();
    }
    makeTimingString(timing) {
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.EASE:
        case TimingFunction.EASE_IN:
        case TimingFunction.EASE_OUT:
        case TimingFunction.EASE_IN_OUT:
          return `${timing.name}`;
        default:
          return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
      }
    }
    moveEndStepPoint(dx, dy) {
      if (dx === 0 && dy === 0) {
        const { timing } = this.localColorStep;
        switch (timing.name) {
          case TimingFunction.STEPS:
            this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
            break;
          case TimingFunction.LINEAR:
            break;
          case TimingFunction.PATH:
            this.emit("showComponentPopup", {
              title: "Path Editor",
              width: 400,
              inspector: [
                {
                  key: "path",
                  editor: "path",
                  editorOptions: {
                    height: 160
                  },
                  defaultValue: timing.d
                }
              ],
              changeEvent: (key, value) => {
                this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
                this.updateData();
              }
            });
            break;
          default:
            this.emit("showComponentPopup", {
              title: "Cubic Bezier",
              width: 220,
              inspector: [
                {
                  key: "timing",
                  editor: "cubic-bezier",
                  editorOptions: {
                    isAnimating: false
                  },
                  defaultValue: this.makeTimingString(timing)
                }
              ],
              changeEvent: (key, value) => {
                this.localColorStep.timing = parseOneValue(value).parsed;
                this.updateData();
              }
            });
            this.$el.toggleClass("dragging", false);
            return;
        }
      }
      this.updateData();
      this.$el.toggleClass("dragging", false);
    }
  }
  class GradientResizer extends GradientTimingStepEditor {
    [sapa.POINTERSTART("$el .resizer") + sapa.LEFT_BUTTON + MOVE("calculateMovedResizer") + END("calculateMovedEndResizer") + sapa.PREVENT](e) {
      this.state.$target = e.$dt;
      this.$el.toggleClass("dragging", true);
      this.initializeData();
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.isShiftKey = e.shiftKey;
    }
    calculateMovedResizer() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const currentVertex = clone(this.initMousePoint);
      const nextVertex = targetMousePoint;
      const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
      const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
      const realDist = subtract([], nextResult, currentResult);
      const { backRect: rect2 } = this.state.backgroundImageMatrix;
      const backgroundImage2 = this.state.gradient;
      const backRect = backgroundImage2.recoverOffset(rect2.x, rect2.y, this.state.contentBox, realDist[0], realDist[1], {
        shiftKey: this.$config.get("bodyEvent").shiftKey
      });
      this.state.backgroundImages[this.state.index].reset({
        x: backRect.x,
        y: backRect.y,
        width: backRect.width,
        height: backRect.height
      });
      this.updateData();
    }
    calculateMovedEndResizer() {
      this.updateData();
      this.$el.toggleClass("dragging", false);
    }
    [sapa.POINTERSTART("$el .back-rect") + sapa.LEFT_BUTTON + MOVE("calculateMovedRect") + END("calculateMovedEndRect") + sapa.PREVENT](e) {
      this.state.$target = e.$dt;
      this.initializeData();
      this.initMousePoint = this.$viewport.getWorldPosition(e);
    }
    calculateMovedRect() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const currentVertex = clone(this.initMousePoint);
      const nextVertex = targetMousePoint;
      const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
      const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
      const realDist = subtract([], nextResult, currentResult);
      const { backRect: rect2 } = this.state.backgroundImageMatrix;
      const backgroundImage2 = this.state.gradient;
      const backRect = backgroundImage2.recoverOffset(rect2.x + realDist[0], rect2.y + realDist[1], this.state.contentBox);
      this.state.backgroundImages[this.state.index].reset({
        x: backRect.x,
        y: backRect.y
      });
      this.updateData();
    }
    calculateMovedEndRect(dx, dy) {
      if (dx == 0 && dy === 0) {
        const index2 = repeatTypeList.indexOf(this.state.gradient.repeat);
        this.state.backgroundImages[this.state.index].repeat = repeatTypeList[(index2 + 1) % repeatTypeList.length];
      }
      this.updateData();
    }
  }
  class GradientRotateEditor extends GradientResizer {
    [sapa.POINTERSTART("$el .gradient-angle .rotate") + sapa.LEFT_BUTTON + MOVE("calculateMovedAngle") + END("calculatedMovedEndAngle") + sapa.PREVENT](e) {
      this.state.$target = e.$dt;
      this.initializeData();
      this.$el.toggleClass("dragging", true);
      this.state.centerX = +this.state.$target.data("center-x");
      this.state.centerY = +this.state.$target.data("center-y");
      this.state.startX = +this.state.$target.attr("cx");
      this.state.startY = +this.state.$target.attr("cy");
      this.state.$target.toggleClass("moved");
    }
    calculateMovedAngle(dx, dy) {
      const center = [this.state.centerX, this.state.centerY, 0];
      const point2 = [this.state.startX, this.state.startY, 0];
      const dist2 = [dx, dy, 0];
      const distAngle = calculateAngleForVec3(point2, center, dist2);
      let newAngle = Math.floor(this.state.gradient.image.angle + distAngle);
      if (this.$config.get("bodyEvent").shiftKey) {
        newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
      }
      this.state.backgroundImages[this.state.index].image.angle = newAngle;
      this.updateData();
    }
    calculatedMovedEndAngle() {
      this.state.$target.toggleClass("moved");
      this.$el.toggleClass("dragging", false);
      this.updateData();
    }
  }
  class GradientColorstepEditor extends GradientRotateEditor {
    [sapa.KEYUP("$el .colorstep")](e) {
      const index2 = +e.$dt.data("index");
      switch (e.code) {
        case "Delete":
        case "Backspace":
          this.removeStep(index2);
          break;
        case "BracketRight":
          this.sortToRight(index2);
          break;
        case "BracketLeft":
          this.sortToLeft(index2);
          break;
        case "Equal":
          this.appendColorStep(index2);
          break;
        case "Minus":
          this.prependColorStep(index2);
          break;
      }
    }
    removeStep(currentIndex) {
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      image2.removeColorStepByIndex(currentIndex);
      this.updateColorStepStatus(image2, -1);
    }
    sortToRight() {
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      image2.sortToRight();
      this.updateColorStepStatus(image2, -1);
    }
    sortToLeft() {
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      image2.sortToLeft();
      this.updateColorStepStatus(image2, -1);
    }
    appendColorStep(currentIndex) {
      const nextIndex = currentIndex + 1;
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      const currentColorStep = image2.colorsteps[currentIndex];
      const nextColorStep = image2.colorsteps[nextIndex];
      let newIndex = -1;
      if (!nextColorStep) {
        if (currentColorStep.percent !== 100) {
          newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
        }
      } else {
        newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
      }
      this.updateColorStepStatus(image2, newIndex);
    }
    prependColorStep(currentIndex) {
      const prevIndex = currentIndex - 1;
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      const currentColorStep = image2.colorsteps[currentIndex];
      const prevColorStep = image2.colorsteps[prevIndex];
      let newIndex = -1;
      if (!prevColorStep) {
        if (currentColorStep.percent !== 0) {
          newIndex = image2.insertColorStep(currentColorStep.percent);
        }
      } else {
        newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
      }
      this.updateColorStepStatus(image2, newIndex);
    }
    [sapa.POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
      this.$el.toggleClass("dragging", true);
      this.state.hoverColorStep = null;
      this.initializeData();
      const $colorstep = e.$dt;
      this.$targetIndex = +$colorstep.data("index");
      if (e.altKey) {
        this.removeStep(this.$targetIndex);
        this.state.altKey = true;
        return;
      }
      const result = this.state.backgroundImageMatrix;
      switch (result.backgroundImage.image.type) {
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          this.centerPosition = this.$viewport.applyVertex(result.centerPosition);
          this.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.endPoint = this.$viewport.applyVertex(result.endPoint);
          this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
          this.rotateInverse = calculateRotationOriginMat4(-this.state.gradient.image.angle, this.centerPosition);
          break;
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
          this.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.endPoint = this.$viewport.applyVertex(result.endPoint);
          this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
          const dist2 = subtract([], this.endPoint, this.startPoint);
          const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
          this.rotateInverse = calculateRotationOriginMat4(-angle, this.centerPosition);
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
          this.startPoint = this.$viewport.applyVertex(result.shapePoint);
          this.newStartPoint = subtract([], this.startPoint, this.centerPosition);
          this.newStartAngle = calculateAngle360(this.newStartPoint[0], this.newStartPoint[1]);
          const x = +$colorstep.data("x");
          const y = +$colorstep.data("y");
          this.screenXY = [x, y, 0];
          this.endPoint = this.$viewport.applyVertex(result.endPoint);
          this.rotateInverse = create$4();
          break;
      }
    }
    moveColorStep(dx, dy) {
      if (this.state.altKey)
        return;
      const nextPoint = add([], this.screenXY, [dx, dy, 0]);
      const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
      const result = this.state.backgroundImageMatrix;
      let newDist = 0;
      let baseDist = 0;
      switch (result.backgroundImage.image.type) {
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
          var baseDefaultDist = Math.abs(s - e);
          if (s < n) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else if (e > n) {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            var distStart = Math.abs(s - n);
            var distEnd = Math.abs(e - n);
            newDist = distStart / (distEnd + distStart) * 100;
          }
          newDist = Math.max(0, Math.min(100, newDist));
          baseDist = dist(this.startPoint, this.endPoint);
          break;
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
          var baseDefaultDist = Math.abs(s - e);
          if (n < s) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else if (n > e) {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            newDist = (n - s) / baseDefaultDist * 100;
          }
          newDist = Math.max(0, Math.min(100, newDist));
          baseDist = dist(this.startPoint, this.endPoint);
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          const newNextPoint = subtract([], nextPoint, this.centerPosition);
          let nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
          if (this.$config.get("bodyEvent").shiftKey) {
            nextAngle -= nextAngle % this.$config.get("fixed.gradient.angle");
          }
          let newAngle = nextAngle - this.newStartAngle;
          newDist = newAngle / 360 * 100;
          newDist = (newDist + 100) % 100;
          baseDist = 100;
          break;
      }
      const image2 = this.state.gradient.image;
      image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      const nextImage = this.state.backgroundImages[this.state.index].image;
      nextImage.colorsteps = image2.colorsteps.map((it) => {
        return it;
      });
      nextImage.sortColorStep();
      this.emit("updateGradientEditor", nextImage, targetColorStep);
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        backgroundImage: value
      }));
    }
    moveEndColorStep(dx, dy) {
      if (this.state.altKey) {
        this.state.altKey = false;
        return;
      }
      if (dx === 0 && dy === 0) {
        const image2 = this.state.backgroundImages[this.state.index].image;
        image2.colorsteps[this.$targetIndex].toggleTiming();
        const targetColorStep = {
          color: image2.colorsteps[this.$targetIndex].color,
          percent: image2.colorsteps[this.$targetIndex].percent
        };
        this.emit("updateGradientEditor", image2, targetColorStep);
        var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
        this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
          backgroundImage: value
        }));
      }
      this.$el.toggleClass("dragging", false);
    }
    updateColorStepStatus(image2, index2) {
      this.initializeData();
      const { color, percent } = image2.colorsteps[index2] || {};
      this.emit("updateGradientEditor", image2, { color, percent });
      this.state.backgroundImages[this.state.index].image = image2;
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        backgroundImage: value
      }));
      this.state.hoverColorStep = null;
    }
    [sapa.POINTERSTART("$el .area-line")]() {
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
      this.updateColorStepStatus(image2, index2);
    }
    [sapa.POINTEROUT("$el .area-line")]() {
      if (this.state.hoverColorStep) {
        this.state.hoverColorStep = null;
        this.refresh();
      }
    }
    [sapa.POINTERMOVE("$el .area-line")](evt) {
      const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
      const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
      let baseStartPoint, baseEndPoint, baseNextPoint;
      switch (image2.type) {
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
          var newDist = 0;
          var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
          var baseDefaultDist = Math.abs(s - e);
          if (s < n) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else if (e > n) {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            const distStart = Math.abs(s - n);
            const distEnd = Math.abs(e - n);
            newDist = distStart / (distEnd + distStart) * 100;
          }
          this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
          break;
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          [baseStartPoint, baseEndPoint, baseNextPoint] = [
            this.state.startPoint,
            this.state.endPoint,
            nextPoint
          ];
          var newDist = 0;
          var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
          var baseDefaultDist = Math.abs(s - e);
          if (n < s) {
            newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
          } else {
            newDist = Math.abs(n - s) / baseDefaultDist * 100;
          }
          this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          const newStartPoint = subtract([], this.state.startPoint, this.state.centerPosition);
          const newNextPoint = subtract([], nextPoint, this.state.centerPosition);
          const startAngle = calculateAngle360(newStartPoint[0], newStartPoint[1]);
          const nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
          var newDist = (nextAngle - startAngle) / 360 * 100;
          this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
          break;
      }
      this.refresh();
    }
  }
  class GradientEditorView extends GradientColorstepEditor {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--gradient-editor-view"
      });
    }
    [sapa.POINTERSTART("$el .point") + sapa.LEFT_BUTTON + MOVE("calculateMovedElement") + END("calculateMovedEndElement") + sapa.PREVENT](e) {
      this.$el.toggleClass("dragging", true);
      this.initializeData();
      const result = this.state.backgroundImageMatrix;
      this.pointTarget = e.$dt.data("type");
      this.startPoint = this.$viewport.applyVertex(result.startPoint);
      this.endPoint = this.$viewport.applyVertex(result.endPoint);
      if (result.shapePoint) {
        this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
      }
    }
    calculateMovedElement(dx, dy) {
      const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
      let nextPoint = add([], targetPoint, [dx, dy, 0]);
      var [localPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.$context.selection.current.absoluteMatrixInverse);
      const backgroundImage2 = this.state.gradient;
      const backRect = backgroundImage2.getOffset(this.state.contentBox);
      const image2 = this.state.gradient.image;
      switch (image2.type) {
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          if (this.pointTarget === "start") {
            const newX = localPosition[0] - backRect.x;
            const newY = localPosition[1] - backRect.y;
            this.state.backgroundImages[this.state.index].image.radialPosition = [
              editor.Length.makePercent(newX, backRect.width),
              editor.Length.makePercent(newY, backRect.height)
            ];
            this.updateData();
          } else if (this.pointTarget === "end") {
            var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
            var [localEndPosition] = vertiesMap([
              this.$viewport.applyVertexInverse(add([], this.endPoint, [dx, 0, 0]))
            ], this.$context.selection.current.absoluteMatrixInverse);
            var [localShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(this.shapePoint)], this.$context.selection.current.absoluteMatrixInverse);
            const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
            const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
            if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
              this.state.backgroundImages[this.state.index].image.radialSize = [
                editor.Length.px(Math.abs(newEndX))
              ];
            } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
              this.state.backgroundImages[this.state.index].image.radialSize = [
                editor.Length.makePercent(Math.abs(newEndX), backRect.width),
                editor.Length.makePercent(Math.abs(newShapeY), backRect.height)
              ];
            }
            this.updateData();
          } else if (this.pointTarget === "shape") {
            var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
            var [localShapePosition] = vertiesMap([
              this.$viewport.applyVertexInverse(add([], this.shapePoint, [0, dy, 0]))
            ], this.$context.selection.current.absoluteMatrixInverse);
            var [localEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.endPoint)], this.$context.selection.current.absoluteMatrixInverse);
            const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
            const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
            if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
              this.state.backgroundImages[this.state.index].image.radialSize = [
                editor.Length.px(Math.abs(newShapeY))
              ];
            } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
              this.state.backgroundImages[this.state.index].image.radialSize = [
                editor.Length.makePercent(Math.abs(newEndX), backRect.width),
                editor.Length.makePercent(Math.abs(newShapeY), backRect.height)
              ];
            }
            this.updateData();
          }
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          if (this.pointTarget === "start") {
            const newX = localPosition[0] - backRect.x;
            const newY = localPosition[1] - backRect.y;
            this.state.backgroundImages[this.state.index].image.radialPosition = [
              editor.Length.makePercent(newX, backRect.width),
              editor.Length.makePercent(newY, backRect.height)
            ];
            this.updateData();
          }
          break;
      }
    }
    calculateMovedEndElement(dx, dy) {
      if (dx == 0 && dy === 0) {
        if (this.pointTarget === "start") {
          switch (this.state.gradient.type) {
            case GradientType.RADIAL:
            case GradientType.REPEATING_RADIAL:
              const findKey = `${this.state.gradient.image.radialType} ${this.state.gradient.image.radialSize}`.trim();
              const index2 = radialTypeList.indexOf(findKey);
              const [radialType, radialSize] = radialTypeList[(index2 + 1) % radialTypeList.length].split(" ");
              const image2 = this.state.backgroundImages[this.state.index].image;
              image2.radialType = radialType;
              image2.radialSize = radialSize;
              break;
          }
        }
      }
      this.updateData();
      this.$el.toggleClass("dragging", false);
    }
    refresh() {
      if (this.state.isShow) {
        this.load();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.DEBOUNCE(10)]() {
      if (this.$context.selection.current) {
        if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "backgroundImage", "border", "padding", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom")) {
          this.refresh();
        }
      }
    }
    [sapa.SUBSCRIBE("showGradientEditorView")]({ index: index2 }) {
      this.state.index = index2;
      this.$el.show();
      this.state.isShow = true;
      this.refresh();
      this.$commands.emit("recoverCursor");
      this.$context.commands.emit("push.mode.view", "GradientEditorView");
    }
    [sapa.SUBSCRIBE("hideGradientEditorView")]() {
      this.$el.hide();
      this.state.isShow = false;
      this.$commands.emit("pop.mode.view", "GradientEditorView");
    }
    makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
          });
        case TimingFunction.PATH:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).d
          });
        default:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
          });
      }
    }
    makeConicTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
      const half = width2 / 2;
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + 0 - half}           
        `
          });
        case TimingFunction.PATH:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(-half, width2).d
          });
        default:
          return /* @__PURE__ */ sapa.createElementJsx("path", {
            class: "timing",
            d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          C 
            ${startX + timing.x1 * width2 - half} ${startY + width2 - timing.y1 * width2 - half} 
            ${startX + timing.x2 * width2 - half} ${startY + width2 - timing.y2 * width2 - half}  
            ${startX + width2 - half} ${startY + 0 - half}
        `
          });
      }
    }
    makeTimingCircle(colorstepIndex, current, prev) {
      const prevStickScreenXY = prev.stickScreenXYInEnd;
      const stickScreenXY = current.stickScreenXYInStart;
      const { timing, timingCount } = current;
      let pos;
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timing.count));
        default:
          pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timingCount));
      }
    }
    makeConicTimingCircle(startPoint, colorstepIndex, current, prev) {
      const prevStickScreenXY = prev.stickScreenXY;
      const stickScreenXY = current.stickScreenXY;
      const { timing, timingCount } = current;
      const dist$1 = dist(prevStickScreenXY, startPoint);
      const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint));
      const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint));
      let nextAngle = this.getRealAngle(prevAngle + (angle - prevAngle) / 2);
      const bigArc = Math.abs(angle - prevAngle) % 360 >= 180 ? 1 : 0;
      if (bigArc) {
        nextAngle -= 180;
      }
      var [pos] = vertiesMap([lerp([], startPoint, add([], startPoint, [-1, 0, 0]), dist$1)], calculateRotationOriginMat4(nextAngle, startPoint));
      switch (timing.name) {
        case TimingFunction.LINEAR:
          return ``;
        case TimingFunction.STEPS:
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timing.count));
        default:
          return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("circle", {
            class: "step-point",
            "data-colorstep-index": colorstepIndex,
            cx: pos[0],
            cy: pos[1],
            r: 7
          }), /* @__PURE__ */ sapa.createElementJsx("text", {
            x: pos[0],
            y: pos[1],
            dy: 4,
            "text-anchor": "middle"
          }, timingCount));
      }
    }
    makeTimingArea(colorstepIndex, current, prev, size) {
      const prevStickScreenXY = prev.stickScreenXYInEnd;
      const stickScreenXY = current.stickScreenXYInStart;
      return /* @__PURE__ */ sapa.createElementJsx("g", {
        class: "timing-area"
      }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "timing-path",
        d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
      }), this.makeTimingCircle(colorstepIndex, current, prev, size));
    }
    getRealAngle(angle) {
      return angle < 0 ? 360 + angle : angle;
    }
    makeConicTimingArea(startPoint, colorstepIndex, current, prev, size, dist2, startAngle) {
      const prevStickScreenXY = prev.stickScreenXY;
      const stickScreenXY = current.stickScreenXY;
      const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint)) + startAngle;
      const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint)) + startAngle;
      const nextAngle = 360 - prevAngle;
      const nextAngle2 = angle;
      const bigArc = Math.abs(nextAngle + nextAngle2) % 360 >= 180 ? 1 : 0;
      return /* @__PURE__ */ sapa.createElementJsx("g", {
        class: "timing-area"
      }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "timing-path",
        d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              A ${dist2} ${dist2} 0 ${bigArc} 1 ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
      })), this.makeConicTimingCircle(startPoint, colorstepIndex, current, prev, dist2));
    }
    makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
      const size = TOOL_SIZE;
      const dist2 = subtract([], endPoint, startPoint);
      const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, colorsteps.map((it, index2) => {
        if (index2 === 0)
          return "";
        return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE);
      }), colorsteps.map((it, index2) => {
        return /* @__PURE__ */ sapa.createElementJsx("g", {
          transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
        }, /* @__PURE__ */ sapa.createElementJsx("rect", {
          id: it.id,
          "data-index": index2,
          class: "colorstep",
          x: it.stickScreenXY[0],
          y: it.stickScreenXY[1],
          width: size,
          height: size,
          fill: it.color,
          tabIndex: -1,
          "data-x": it.screenXY[0],
          "data-y": it.screenXY[1]
        }), this.makeTimingLine(it.timing, size, it.stickScreenXY[0], it.stickScreenXY[1]));
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "start",
        cx: startPoint[0],
        cy: startPoint[1]
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "end",
        cx: endPoint[0],
        cy: endPoint[1]
      }), shapePoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "shape",
        cx: shapePoint[0],
        cy: shapePoint[1]
      }), newHoverColorStepPoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "hover-colorstep",
        r: "5",
        cx: newHoverColorStepPoint[0],
        cy: newHoverColorStepPoint[1],
        fill: this.state.hoverColorStep.color
      }));
    }
    makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, dist2, startAngle) {
      const size = TOOL_SIZE;
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, colorsteps.map((it, index2) => {
        if (index2 === 0)
          return "";
        return this.makeConicTimingArea(startPoint, index2, it, colorsteps[index2 - 1], TOOL_SIZE, dist2, startAngle);
      }), colorsteps.map((it, index2) => {
        const angle = calculateAngle360(...subtract([], it.screenXY, startPoint)) - 180;
        return /* @__PURE__ */ sapa.createElementJsx("g", {
          transform: `rotate(${angle} ${it.screenXY[0]} ${it.screenXY[1]})`
        }, /* @__PURE__ */ sapa.createElementJsx("rect", {
          id: it.id,
          "data-index": index2,
          class: "colorstep",
          x: it.screenXY[0] - size / 2,
          y: it.screenXY[1] - size / 2,
          width: size,
          height: size,
          fill: it.color,
          tabIndex: -1,
          "data-x": it.screenXY[0],
          "data-y": it.screenXY[1]
        }), this.makeConicTimingLine(it.timing, size, it.screenXY[0], it.screenXY[1], startAngle));
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "start",
        cx: startPoint[0],
        cy: startPoint[1]
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "end",
        cx: endPoint[0],
        cy: endPoint[1]
      }), shapePoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "point",
        "data-type": "shape",
        cx: shapePoint[0],
        cy: shapePoint[1]
      }), newHoverColorStepPoint && /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "hover-colorstep",
        r: "5",
        cx: newHoverColorStepPoint[0],
        cy: newHoverColorStepPoint[1],
        fill: this.state.hoverColorStep.color
      }));
    }
    makeGradientRect(result) {
      const boxPosition = this.$viewport.applyVerties(result.backVerties);
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "gradient-rect"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", null, /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "back-rect",
        d: `
                    M ${boxPosition[0][0]} ${boxPosition[0][1]}
                    L ${boxPosition[1][0]} ${boxPosition[1][1]}
                    L ${boxPosition[2][0]} ${boxPosition[2][1]}
                    L ${boxPosition[3][0]} ${boxPosition[3][1]}
                    Z
                `
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "resizer",
        "data-direction": "bottom-right",
        style: {
          left: editor.Length.px(boxPosition[2][0]),
          top: editor.Length.px(boxPosition[2][1])
        }
      }));
    }
    makeCenterPoint(result) {
      const { image: image2 } = result.backgroundImage;
      switch (image2.type) {
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          return this.makeLinearCenterPoint(result);
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          return this.makeRadialCenterPoint(result);
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          return this.makeConicCenterPoint(result);
      }
      return "";
    }
    makeConicCenterPoint(result) {
      const { image: image2 } = result.backgroundImage;
      let centerPosition, centerStick;
      let startPoint, endPoint, shapePoint, colorsteps;
      centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
      startPoint = this.$viewport.applyVertex(result.startPoint);
      endPoint = this.$viewport.applyVertex(result.endPoint);
      shapePoint = this.$viewport.applyVertex(result.shapePoint);
      let lastDist = dist(startPoint, endPoint) / 2;
      if (lastDist < 50) {
        lastDist = 50;
      }
      colorsteps = result.colorsteps.map((it) => {
        it.screenXY = this.$viewport.applyVertex(it.pos);
        const pointDist = dist(it.screenXY, startPoint);
        if (pointDist < lastDist) {
          it.screenXY = lerp([], startPoint, lerp([], startPoint, it.screenXY, 1 / pointDist), lastDist + 20);
        } else if (pointDist > lastDist) {
          it.screenXY = lerp([], startPoint, it.screenXY, (lastDist + 20) / pointDist);
        }
        it.stickScreenXY = clone(it.screenXY);
        const dist$1 = subtract([], it.screenXY, startPoint);
        it.angle = calculateAngle360(dist$1[0], dist$1[1]);
        return it;
      });
      centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
      const stickPoint = this.$viewport.applyVertex(result.shapePoint);
      centerStick = lerp([], centerPosition, lerp([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 50);
      const targetStick = lerp([], centerStick, centerPosition, 1);
      let newHoverColorStepPoint = null;
      if (this.state.hoverColorStep) {
        const hoverAngle = this.state.hoverColorStep.percent * 3.6;
        const originDist = dist(centerPosition, shapePoint);
        [newHoverColorStepPoint] = vertiesMap([
          lerp([], centerPosition, shapePoint, (lastDist + 20) / originDist)
        ], calculateRotationOriginMat4(hoverAngle, centerPosition));
      }
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "gradient-position center",
        "data-radial-type": image2.radialType,
        style: {
          left: editor.Length.px(centerPosition[0]),
          top: editor.Length.px(centerPosition[1])
        }
      }), /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "gradient-angle"
      }, /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "size",
        cx: startPoint[0],
        cy: startPoint[1],
        r: lastDist
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "area-line",
        cx: startPoint[0],
        cy: startPoint[1],
        r: lastDist
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "stick",
        d: `
                M ${targetStick[0]} ${targetStick[1]}
                L ${centerStick[0]} ${centerStick[1]}
            `
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "rotate",
        cx: centerStick[0],
        cy: centerStick[1],
        r: "7",
        "data-center-x": centerPosition[0],
        "data-center-y": centerPosition[1]
      }), this.makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, lastDist + 20, image2.angle)));
    }
    makeRadialCenterPoint(result) {
      let colorsteps, startPoint, endPoint, shapePoint;
      startPoint = this.$viewport.applyVertex(result.startPoint);
      endPoint = this.$viewport.applyVertex(result.endPoint);
      shapePoint = this.$viewport.applyVertex(result.shapePoint);
      colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
      let newHoverColorStepPoint = null;
      if (this.state.hoverColorStep) {
        newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
      }
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "gradient-radial-line"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "area-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "start-end-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
        class: "shape-line"
      }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint)));
    }
    makeStickPoint(colorsteps, startPoint, endPoint) {
      const size = TOOL_SIZE;
      const dist2 = subtract([], endPoint, startPoint);
      const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
      const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
      const rotateInverseInverse = invert([], rotateInverse);
      return colorsteps.map((it) => {
        it.screenXY = this.$viewport.applyVertex(it.pos);
        const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
        [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
          [newScreenXY[0] - size / 2, newScreenXY[1] - size * 1.5, 0],
          [
            newScreenXY[0] - size / 2,
            newScreenXY[1] - size * 1.5 + size / 2,
            0
          ],
          [
            newScreenXY[0] + size / 2,
            newScreenXY[1] - size * 1.5 + size / 2,
            0
          ]
        ], rotateInverseInverse);
        return it;
      });
    }
    makeLinearCenterPoint(result) {
      let centerPosition, centerStick, startPoint, endPoint, areaStartPoint, areaEndPoint, colorsteps;
      startPoint = this.$viewport.applyVertex(result.startPoint);
      endPoint = this.$viewport.applyVertex(result.endPoint);
      areaStartPoint = this.$viewport.applyVertex(result.areaStartPoint);
      areaEndPoint = this.$viewport.applyVertex(result.areaEndPoint);
      centerPosition = this.$viewport.applyVertex(result.centerPosition);
      colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
      const lastDist = dist(centerPosition, endPoint);
      const [stickPoint] = vertiesMap([endPoint], calculateRotationOriginMat4(90, lerp([], startPoint, endPoint, 0.5)));
      centerStick = lerp([], centerPosition, lerp([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 20);
      const targetStick = lerp([], centerStick, centerPosition, 20 / (lastDist + 20));
      let newHoverColorStepPoint = null;
      if (this.state.hoverColorStep) {
        newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
      }
      return /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "gradient-angle"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "stick",
        d: `
              M ${targetStick[0]} ${targetStick[1]}
              L ${centerStick[0]} ${centerStick[1]}
          `
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "size",
        cx: centerPosition[0],
        cy: centerPosition[1],
        r: dist(centerPosition, startPoint)
      }), /* @__PURE__ */ sapa.createElementJsx("circle", {
        class: "rotate",
        cx: centerStick[0],
        cy: centerStick[1],
        r: "7",
        "data-center-x": centerPosition[0],
        "data-center-y": centerPosition[1]
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${areaStartPoint[0]} ${areaStartPoint[1]}
              L ${areaEndPoint[0]} ${areaEndPoint[1]}
          `,
        class: "area-line"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
        class: "start-end-line"
      }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const result = current.createBackgroundImageMatrix(this.state.index);
      this.state.lastBackgroundMatrix = result;
      const image2 = result.backgroundImage.image;
      switch (image2.type) {
        case GradientType.LINEAR:
        case GradientType.REPEATING_LINEAR:
          this.state.centerPosition = this.$viewport.applyVertex(result.centerPosition);
          this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
          this.state.rotateInverse = calculateRotationOriginMat4(-1 * result.backgroundImage.image.angle, this.state.centerPosition);
          break;
        case GradientType.RADIAL:
        case GradientType.REPEATING_RADIAL:
          this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
          this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
          this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
          break;
        case GradientType.CONIC:
        case GradientType.REPEATING_CONIC:
          this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
          this.state.startPoint = this.$viewport.applyVertex(result.shapePoint);
          break;
      }
      return /* @__PURE__ */ sapa.createElementJsx("div", null, this.makeGradientRect(result), image2.type === GradientType.STATIC || image2.type === GradientType.IMAGE ? null : this.makeCenterPoint(result));
    }
  }
  function gradientEditorView(editor2) {
    editor2.registerUI("canvas.view", {
      GradientEditorView
    });
  }
  var GuideLineView$1 = "";
  const line = (source, target, className = "base-line") => {
    return `<line x1="${source[0]}" y1="${source[1]}" x2="${target[0]}" y2="${target[1]}" class='${className}' />`;
  };
  const hLineByPoint = (target, source) => {
    return line(target, source);
  };
  const vLineByPoint = (target, source) => {
    return line(target, source);
  };
  const rect = (rectVerties) => {
    return `<path class="base-rect" fill="none" stroke-width="1" stroke="red" stroke-dasharray="2 2" d="${PathParser.makeRect(rectVerties[0][0], rectVerties[0][1], dist(rectVerties[0], rectVerties[1]), dist(rectVerties[0], rectVerties[3])).d}" />`;
  };
  const point = (target, dist2, direction) => {
    if (direction === "left") {
      return `<path class="arrow" d="M ${target[0] + dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2} "/>`;
    }
    if (direction === "right") {
      return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] - dist2} ${target[1] + dist2}" />`;
    }
    if (direction === "up") {
      return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] + dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2}" />`;
    }
    if (direction === "down") {
      return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] - dist2}" />`;
    }
    return `<path stroke-width="1" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0] + dist2} ${target[1] + dist2} M ${target[0] - dist2} ${target[1] + dist2} L ${target[0] + dist2} ${target[1] - dist2}" />`;
  };
  class GuideLineView extends editor.EditorElement {
    template() {
      return `<svg class='elf--guide-line-view' ref="$guide" width="100%" height="100%" ></svg>`;
    }
    initState() {
      return {
        list: []
      };
    }
    [sapa.BIND("$guide")]() {
      const line2 = this.createGuideLine(this.state.list);
      return {
        svgDiff: `<svg>${line2}</svg>`
      };
    }
    createLayerLine() {
      return "";
    }
    filterGuideLine(list) {
      list = list.filter(Boolean);
      return list;
    }
    createGuideLine(list) {
      var images = [];
      var texts = [];
      list = this.filterGuideLine(list);
      for (var i = 0, len2 = list.length; i < len2; i++) {
        const [
          source,
          target,
          axis,
          dist$1,
          newTarget,
          sourceVerties,
          targetVerties
        ] = list[i];
        const localDist = dist(source, target);
        const localSourceVertex = this.$viewport.applyVertex(source);
        const localTargetVertex = this.$viewport.applyVertex(target);
        let localNewTargetVertex;
        if (newTarget) {
          localNewTargetVertex = this.$viewport.applyVerties([newTarget])[0];
        }
        if (axis === "x") {
          if (localDist > 0) {
            images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
          }
          if (localNewTargetVertex) {
            images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
          }
        }
        if (axis === "y") {
          if (localDist > 0) {
            images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
          }
          if (localNewTargetVertex) {
            images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
          }
        }
        if (axis === "x") {
          images.push(hLineByPoint(localTargetVertex, localSourceVertex));
        }
        if (axis === "y") {
          images.push(vLineByPoint(localTargetVertex, localSourceVertex));
        }
        if (this.state.hasVerties) {
          images.push(point(localSourceVertex, 3, "vertex"));
          images.push(point(localTargetVertex, 3, "vertex"));
        }
        if (sourceVerties) {
          if (this.$context.selection.isOne && this.$editor.isPointerDown || this.$context.selection.isMany && !this.$editor.isPointerMove) {
            images.push(rect(this.$viewport.applyVerties(sourceVerties)));
          }
        }
        if (targetVerties) {
          images.push(rect(this.$viewport.applyVerties(targetVerties)));
        }
      }
      return [...images, ...texts].join("");
    }
    removeGuideLine() {
      this.setState({
        list: []
      });
    }
    setGuideLine(list, hasVerties = false) {
      this.setState({
        list,
        hasVerties
      });
    }
    refreshSmartGuides(targetVertiesList) {
      if (this.$context.selection.isEmpty)
        return;
      const sourceVerties = toRectVerties(this.$context.selection.verties);
      let targetList;
      if (targetVertiesList) {
        targetList = targetVertiesList.map((it) => toRectVerties(it));
      } else {
        const targets = this.$context.snapManager.snapTargetLayers.map((target) => {
          const rectVerties = toRectVerties(target.verties);
          return {
            targetVerties: rectVerties,
            dist: dist(rectVerties[4], sourceVerties[4])
          };
        });
        targets.sort((a, b) => {
          return a.dist - b.dist;
        });
        targetList = targets.map((target) => target.targetVerties);
      }
      const xList = targetList.map((targetVerties) => makeGuidePoint(sourceVerties, targetVerties));
      xList.sort((a, b) => {
        return a[3] - b[3];
      });
      const list = [xList[0], xList[1]].filter(Boolean);
      this.setGuideLine(list);
    }
    refreshSmartGuidesForVerties(dist2 = 0) {
      let verties = this.$context.selection.verties;
      if (verties.length) {
        verties = [
          ...verties,
          lerp([], verties[0], verties[1], 0.5),
          lerp([], verties[1], verties[2], 0.5),
          lerp([], verties[2], verties[3], 0.5),
          lerp([], verties[3], verties[0], 0.5)
        ];
      }
      const guides = this.$context.snapManager.findGuide(verties, dist2);
      this.setGuideLine(guides, true);
    }
    [sapa.SUBSCRIBE("removeGuideLine", REFRESH_SELECTION)]() {
      this.removeGuideLine();
    }
    [sapa.SUBSCRIBE("refreshGuideLineByTarget")](targetVertiesList = []) {
      return this.refreshSmartGuides(targetVertiesList);
    }
    get currentDistWithScale() {
      return 1 / this.$viewport.scale;
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION_TOOL)]() {
      this.refreshSmartGuidesForVerties(this.currentDistWithScale);
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS)]() {
      const expect = this.$context.selection.hasChangedField("d", "clip-path");
      if (!expect) {
        this.refreshSmartGuidesForVerties(this.currentDistWithScale);
      }
    }
  }
  function guideLineView(editor2) {
    editor2.registerUI("canvas.view", {
      GuideLineView
    });
  }
  var HistoryProperty$1 = "";
  class HistoryProperty extends editor.BaseProperty {
    afterRender() {
      this.show();
    }
    getTitle() {
      return "History";
    }
    getBody() {
      return `
      <div class="elf--history-list-view" ref='$body'></div>
    `;
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      return this.$editor.context.history.map((it, index2) => {
        if (it === "-") {
          return `<div class='divider'>-</div>`;
        }
        return `
        <div class='history-item'>
          <span>${index2 === this.$editor.context.history.currentIndex ? editor.iconUse("arrowRight") : ""}</span>
          <span>${it.message}</span>
        </div>
      `;
      });
    }
    [sapa.SUBSCRIBE("refreshHistoryList")]() {
      this.refresh();
    }
  }
  function history(editor2) {
    editor2.registerUI("inspector.tab.history", {
      HistoryProperty
    });
  }
  var HoverView$1 = "";
  class HoverView extends editor.EditorElement {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--hover-view sepia(0.2)"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--hover-rect",
        ref: "$hoverRect"
      }));
    }
    checkModeView() {
      const e = this.$config.get("bodyEvent");
      if (!this.$viewport.checkInViewport(this.$viewport.getWorldPosition(e))) {
        return false;
      }
      const canvas = sapa.Dom.create(e.target).closest("elf--page-container");
      if (!canvas)
        return false;
      return this.$modeView.isCurrentMode(ViewModeType.CanvasView) && this.$stateManager.isPointerUp;
    }
    [sapa.CONFIG("bodyEvent") + sapa.IF("checkModeView")]() {
      var _a, _b, _c;
      if (this.$config.true("set.move.control.point")) {
        this.$context.selection.setHoverId("");
        this.renderHoverLayer();
        return;
      }
      const filteredList = this.$context.selection.filteredLayers;
      const point2 = this.$viewport.getWorldPosition(this.$config.get("bodyEvent"));
      const items = filteredList.filter((it) => it.hasPoint(point2[0], point2[1])).filter((it) => it.isNot("artboard"));
      let hoverItems = items;
      let id = (_a = hoverItems[0]) == null ? void 0 : _a.id;
      if (this.$context.selection.isEmpty) {
        id = (_b = hoverItems[0]) == null ? void 0 : _b.id;
      } else if (this.$context.selection.isOne) {
        const pathIds = this.$context.selection.current.pathIds;
        hoverItems = hoverItems.filter((it) => pathIds.includes(it.id) === false || it.id === this.$context.selection.current.id);
        id = (_c = hoverItems[0]) == null ? void 0 : _c.id;
      }
      if (!id) {
        this.$context.selection.setHoverId("");
        this.renderHoverLayer();
      } else {
        if (this.$context.selection.setHoverId(id)) {
          this.renderHoverLayer();
        }
      }
    }
    [sapa.CONFIG("set.move.control.point")]() {
      this.renderHoverLayer();
    }
    [sapa.SUBSCRIBE("refreshHoverView")](id) {
      if (this.$context.selection.setHoverId(id)) {
        this.renderHoverLayer();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
      this.$context.selection.setHoverId("");
      this.renderHoverLayer();
    }
    createVisiblePath(current) {
      if (!current.is("boolean-path")) {
        return "";
      }
      const newPath = current.absolutePath();
      newPath.transformMat4(this.$viewport.matrix);
      return `
        <svg overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
    }
    renderHoverLayer() {
      const items = this.$context.selection.hoverItems;
      if (items.length === 0) {
        this.refs.$hoverRect.updateDiff("");
      } else {
        const verties = items[0].verties;
        const line2 = this.createPointerLine(this.$viewport.applyVerties(verties));
        const offsetLine = this.createOffsetLine();
        this.refs.$hoverRect.updateDiff(line2 + offsetLine);
      }
    }
    getOffsetVerties(current, parent) {
      const currentVerties = current.verties;
      const parentVerties = parent.verties;
      const result = {};
      const left = this.$viewport.applyVerties([
        [
          currentVerties[0][0],
          lerp([], currentVerties[0], currentVerties[3], 0.5)[1],
          0
        ],
        [
          parentVerties[0][0],
          lerp([], currentVerties[0], currentVerties[3], 0.5)[1],
          0
        ]
      ]);
      var dist$1 = dist(...left);
      if (dist$1 > 0) {
        result.left = left;
      }
      const top = this.$viewport.applyVerties([
        [
          lerp([], currentVerties[0], currentVerties[1], 0.5)[0],
          currentVerties[1][1],
          0
        ],
        [
          lerp([], currentVerties[0], currentVerties[1], 0.5)[0],
          parentVerties[1][1],
          0
        ]
      ]);
      var dist$1 = dist(...top);
      if (dist$1 > 0) {
        result.top = top;
      }
      return result;
    }
    createOffsetLine() {
      const item = this.$context.selection.hoverItems[0] || this.$context.selection.current;
      if (!item || !item.parent) {
        return "";
      }
      if (item.parent && item.parent.is("project")) {
        return "";
      }
      if (this.$context.selection.isEmpty) {
        const offsetVerties = this.getOffsetVerties(item, item.parent);
        return `
            <svg overflow="visible">
                <path
                    class="offset-line"
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.right)}
                        ${vertiesToPath(offsetVerties.top)}
                        ${vertiesToPath(offsetVerties.bottom)}
                    "
                    />
            </svg>
            `;
      } else {
        const offsetVerties = this.getOffsetVerties(item, this.$context.selection.current);
        return `
            <svg overflow="visible">
                <path
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.top)}
                    "
                    stroke="red"
                    stroke-width="1"
                    stroke-dasharray="5, 10"
                    fill="none"
                    />
            </svg>
            `;
      }
    }
    createPointerLine(pointers) {
      if (pointers.length === 0)
        return "";
      pointers = pointers.filter((_, index2) => index2 < 4);
      return `<svg overflow="visible"><path class='line' d="${vertiesToPath(pointers)}" /></svg>`;
    }
  }
  function hoverView(editor2) {
    editor2.registerUI("canvas.view", {
      HoverView
    });
  }
  const image_size = [
    "",
    "100x100",
    "200x200",
    "300x300",
    "400x300",
    "900x600",
    "1024x762"
  ];
  class ImageProperty extends editor.BaseProperty {
    getClassName() {
      return "item";
    }
    getTitle() {
      return this.$i18n("image.property.title");
    }
    getBody() {
      return `<div ref='$body' style='padding-top: 3px;'></div>`;
    }
    getFooter() {
      return `
      <div>
        <label> ${this.$i18n("image.property.origin")} </label> 
        <span ref='$sizeInfo'></span> 
        <button type="button" ref='$resize'>${editor.iconUse("size")}</button>
      </div>
      <div>
        ${sapa.createComponent("SelectEditor", {
        ref: "$select",
        label: this.$i18n("image.property.size"),
        key: "size",
        value: "",
        options: image_size,
        onchange: "changeImageSize"
      })}

      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeImageSize")](key, value) {
      var [width2, height] = value.split("x").map((it) => it);
      this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
        width: width2,
        height
      }));
    }
    [sapa.CLICK("$resize")]() {
      var current = this.$context.selection.current;
      if (current) {
        this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
          width: (item) => item.naturalWidth,
          height: (item) => item.naturalHeight
        }));
      }
    }
    [sapa.BIND("$sizeInfo")]() {
      var current = this.$context.selection.current || {};
      return {
        innerHTML: `${this.$i18n("image.property.width")}: ${current.naturalWidth}, ${this.$i18n("image.property.height")}: ${current.naturalHeight}`
      };
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || {};
      var src = current.src || "";
      return sapa.createComponent("ImageSelectEditor", {
        ref: "$1",
        key: "src",
        value: src,
        onchange: "changeSelect"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value, info) {
      var current = this.$context.selection.current;
      if (current) {
        current.reset(__spreadValues({
          src: value
        }, info));
        this.bindData("$sizeInfo");
        this.$commands.executeCommand("setAttribute", "change image", this.$context.selection.packByValue(__spreadValues({
          src: value
        }, info)));
      }
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(["image"]);
    }
  }
  var ImageSelectEditor$1 = "";
  class ImageSelectEditor extends editor.EditorElement {
    initState() {
      return {
        key: this.props.key,
        value: this.props.value
      };
    }
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--image-select-editor",
        ref: "$body"
      });
    }
    getValue() {
      return this.state.value;
    }
    setValue(value) {
      this.setState({ value });
    }
    [sapa.LOAD("$body")]() {
      const project2 = this.$context.selection.currentProject;
      if (!project2)
        return;
      const imageUrl = project2.getImageValueById(this.state.value);
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "preview-container"
      }, imageUrl ? /* @__PURE__ */ sapa.createElementJsx("img", {
        src: imageUrl
      }) : null, /* @__PURE__ */ sapa.createElementJsx("input", {
        type: "file",
        ref: "$file",
        accept: "image/*"
      })), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "select-container"
      }, /* @__PURE__ */ sapa.createElementJsx("button", {
        type: "button",
        ref: "$select"
      }, this.$i18n("image.select.editor.button"))));
    }
    [sapa.CHANGE("$file")](e) {
      var files = [...e.target.files];
      if (files.length) {
        this.$commands.emit("updateImageAssetItem", files[0], (imageId) => {
          this.trigger("changeImageSelectEditor", imageId);
        });
      }
    }
    [sapa.CLICK("$select")]() {
      this.emit("showImageSelectPopup", {
        context: this,
        changeEvent: "changeImageSelectEditor",
        value: this.state.value
      });
    }
    [sapa.SUBSCRIBE("changeImageSelectEditor")](value) {
      this.updateData({ value });
      this.refresh();
    }
    updateData(data) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
    }
  }
  var ImageSelectPopup$1 = "";
  class ImageSelectPopup extends editor.BasePopup {
    getTitle() {
      return "Select a image";
    }
    getClassName() {
      return "compact";
    }
    initState() {
      return {
        value: ""
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.state.context.trigger(this.state.changeEvent, this.state.value, {
        width: this.state.width,
        height: this.state.height,
        naturalWidth: this.state.naturalWidth,
        naturalHeight: this.state.naturalHeight
      });
    }
    getBody() {
      return `<div class="elf--image-select-popup"><div class='box' ref='$imageBox'></div></div>`;
    }
    [sapa.LOAD("$imageBox") + sapa.DOMDIFF]() {
      return "";
    }
    [sapa.CLICK("$imageBox .image-item")](e) {
      var $img = e.$dt.$("img");
      this.updateData({
        value: $img.attr("data-id"),
        naturalWidth: $img.naturalWidth,
        naturalHeight: $img.naturalHeight,
        width: $img.naturalWidth,
        height: $img.naturalHeight
      });
      this.trigger("hideImageSelectPopup");
    }
    [sapa.SUBSCRIBE("showImageSelectPopup")](data, params) {
      this.setState({
        context: data.context,
        changeEvent: data.changeEvent,
        value: data.value,
        params
      }, false);
      this.refresh();
      this.show(500);
    }
    [sapa.SUBSCRIBE("hideImageSelectPopup")]() {
      this.hide();
    }
  }
  function image(editor2) {
    editor2.registerElement({
      ImageSelectEditor
    });
    editor2.registerUI("inspector.tab.style", {
      ImageProperty
    });
    editor2.registerUI("popup", {
      ImageSelectPopup
    });
  }
  class ImageAssetPicker extends editor.EditorElement {
    initState() {
      return {
        mode: "grid"
      };
    }
    template() {
      return `
      <div class='image-asset-picker'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.LOAD("$imageList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.currentProject || { images: [] };
      var images = current.images;
      var results = images.map((image2) => {
        return `
        <div class='image-item'>
          <div class='preview'>
            <img src="${image2.local}" />
          </div>
        </div>
      `;
      });
      return results;
    }
    [sapa.CLICK("$imageList .image-item")](e) {
      var $img = e.$dt.$("img");
      this.updateData($img.attr("src"));
    }
    updateData(localUrl) {
      this.parent.trigger(this.props.onchange, localUrl);
    }
    [sapa.SUBSCRIBE("addImageAsset")]() {
      this.refresh();
    }
  }
  function imageAsset(editor2) {
    editor2.registerElement({
      ImageAssetPicker
    });
  }
  function inspector(editor2) {
    editor2.context.config.set("inspector.selectedValue", "style");
    editor2.registerUI("inspector.tab", {
      Style: {
        title: editor2.$i18n("inspector.tab.title.design"),
        value: "style"
      },
      Transition: {
        title: editor2.$i18n("inspector.tab.title.transition"),
        value: "transition"
      },
      Code: {
        title: editor2.$i18n("inspector.tab.title.code"),
        value: "code"
      }
    });
  }
  var KeyframePopup$1 = "";
  class KeyframePopup extends editor.BasePopup {
    getTitle() {
      return this.$i18n("keyframe.popup.title");
    }
    initState() {
      return {
        name: "none",
        offsets: []
      };
    }
    updateData(opt) {
      this.setState(opt, false);
      this.emit("changeKeyframePopup", this.state);
    }
    getBody() {
      return `
    <div class='elf--keyframe-popup' ref='$popup'>
      <div class="box">
        ${this.templateForName()}
        ${this.templateForOffset()}
      </div>
    </div>`;
    }
    templateForOffset() {
      return `
      <div>
        ${sapa.createComponent("OffsetEditor", { ref: "$offsetEditor" })}
      </div>
    `;
    }
    templateForName() {
      return `
      <div class='name'>
        <label>Name</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.name}' ref='$name'/>
        </div>
      </div>
    `;
    }
    [sapa.INPUT("$name")](e) {
      if (this.refs.$name.value.match(/^[a-zA-Z0-9\b]+$/)) {
        this.updateData({ name: this.refs.$name.value });
      } else {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    getOffsetData() {
      var offsets = this.state.offsets.map((it) => it);
      return { offsets };
    }
    refresh() {
      this.refs.$name.val(this.state.name);
      this.emit("showOffsetEditor", this.getOffsetData());
    }
    [sapa.SUBSCRIBE("changeOffsetEditor")](data) {
      this.updateData(data);
    }
    [sapa.SUBSCRIBE("showKeyframePopup")](data) {
      this.setState(data);
      this.refresh();
      this.show(240);
    }
    [sapa.SUBSCRIBE("hideKeyframePopup")]() {
      this.$el.hide();
    }
  }
  var KeyframeProperty$1 = "";
  class KeyframeProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("keyframe.property.title");
    }
    getBody() {
      return `<div class='elf--keyframe-list' ref='$keyframeList'></div>`;
    }
    getTools() {
      return `
      <button type="button" ref="$add" title="add Filter">${editor.iconUse("add")}</button>
    `;
    }
    makeProperty(property) {
      var key = property.key;
      if (key === "x")
        key = "left";
      else if (key === "y")
        key = "top";
      return `
      <div class='offset-property-item'>
        <label>${key}:</label>
        <div class='value'>${property.value}</div>
      </div>
    `;
    }
    makeOffset(offset) {
      return `
      <div class='offset'>
        <label>${offset.offset}</label>
        <div class='properties'>
          ${offset.properties.map((p) => {
        return this.makeProperty(p);
      }).join("")}
        </div>        
      </div>
    `;
    }
    makeKeyframeTemplate(keyframe2, index2) {
      index2 = index2.toString();
      return `
      <div class='keyframe-item' data-selected-value='code' ref='$keyframeIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>${keyframe2.name}</div>
          <div class='tools'>
            <div class='group'>
              <button type="button" data-type='code'>${editor.iconUse("code")}</button>
            </div>
            <button type="button" class="del" 
            data-index="${index2}">${editor.iconUse("remove2")}</button>
          </div>
        </div>
        <div class='offset-list'>
          <div class='container'>
            ${keyframe2.offsets.map((o) => {
        return `
              <div class='offset' style='left: ${o.offset}; background-color: ${o.color}'></div>
              `;
      }).join("")}
          </div>
        </div>
        <div class='keyframe-code' data-type='code'>
          <pre>${JSON.stringify(keyframe2, null, 2)}</pre>
        </div>        
      </div>
    `;
    }
    [sapa.CLICK("$keyframeList .keyframe-item .title .group button[data-type]")](e) {
      var $keyframeItem = e.$dt.closest("keyframe-item");
      var index2 = +$keyframeItem.attr("data-index");
      var type = e.$dt.attr("data-type");
      var current = this.$context.selection.currentProject;
      if (!current)
        return;
      var currentKeyframe = current.keyframes[index2];
      if (currentKeyframe) {
        currentKeyframe.reset({
          selectedType: type
        });
      }
      $keyframeItem.attr("data-selected-value", type);
    }
    [sapa.CLICK("$keyframeList .keyframe-item .offset-list")](e) {
      var index2 = +e.$dt.closest("keyframe-item").attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.viewKeyframePicker(index2);
    }
    [sapa.CLICK("$keyframeList .del") + sapa.PREVENT](e) {
      var removeIndex = e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      const keyframes = current.keyframes || [];
      keyframes.splice(removeIndex, 1);
      this.$commands.executeCommand("setAttribute", "remove a keyframe", this.$context.selection.packByValue({
        keyframes: [...keyframes]
      }));
      this.nextTick(() => {
        this.refresh();
      }, 10);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refresh();
    }
    [sapa.LOAD("$keyframeList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      const keyframes = current.keyframes || [];
      return keyframes.map((keyframe2, index2) => {
        return this.makeKeyframeTemplate(keyframe2, index2);
      });
    }
    [sapa.CLICK("$add")]() {
      var current = this.$context.selection.current;
      if (current) {
        const keyframes = current.keyframes || [];
        keyframes.push({
          id: uuidShort(),
          checked: true,
          name: "Keyframe",
          offsets: []
        });
        this.$commands.executeCommand("setAttribute", "add keyframe", this.$context.selection.packByValue({
          keyframes: [...keyframes]
        }));
        this.nextTick(() => {
          this.refresh();
        }, 10);
      } else {
        window.alert("Please select a project.");
      }
    }
    viewKeyframePicker(index2) {
      if (typeof this.selectedIndex === "number") {
        this.selectItem(this.selectedIndex, false);
      }
      this.selectedIndex = +index2;
      this.selectItem(this.selectedIndex, true);
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.currentKeyframe = this.current.keyframes[this.selectedIndex];
      this.viewKeyframePropertyPopup();
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.getRef("$keyframeIndex", selectedIndex).addClass("selected");
      } else {
        this.getRef("$keyframeIndex", selectedIndex).removeClass("selected");
      }
      if (this.current) {
        this.current.keyframes.forEach((it, index2) => {
          it.selected = index2 === selectedIndex;
        });
      }
    }
    viewKeyframePropertyPopup() {
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.currentKeyframe = this.current.keyframes[this.selectedIndex];
      const back = this.currentKeyframe;
      const name = back.name;
      const offsets = back.offsets;
      this.emit("showKeyframePopup", {
        name,
        offsets
      });
    }
    [sapa.SUBSCRIBE("changeKeyframePopup")](data) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      const keyframes = current.keyframes || [];
      keyframes[this.selectedIndex] = data;
      this.$commands.executeCommand("setAttribute", "modify keyframe", this.$context.selection.packByValue({
        keyframes: [...keyframes]
      }));
      this.nextTick(() => {
        this.refresh();
      }, 10);
    }
  }
  class OffsetEditor extends editor.EditorElement {
    initState() {
      return {
        offsets: []
      };
    }
    updateData(opt) {
      this.setState(opt, false);
      this.modifyOffset();
    }
    modifyOffset() {
      this.emit("changeOffsetEditor", this.state);
    }
    template() {
      return `
    <div class='editor offset-editor' ref='$editor'>
        ${this.templateForOffset()}
        ${this.templateForOffsetInput()}
        ${this.templateForProperty()}        
    </div>`;
    }
    templateForOffsetInput() {
      return `
      <div class='offset-input' >
        <div class='title'>
          <label>Offset</label>
          <div class='tools'>
            ${sapa.createComponent("InputRangeEditor", {
        key: "offset",
        min: 0,
        max: 100,
        step: 0.01,
        value: editor.Length.percent(0),
        ref: "$offsetInput",
        units: "%",
        onchange: "changeRangeEditor"
      })}
          </div>
        </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE("changeRangeEditor")](key, value) {
      var offset = this.state.offsets[this.selectedIndex];
      if (offset) {
        offset.offset = sapa.clone(value);
        this.refresh();
        this.modifyOffset();
      }
    }
    templateForProperty() {
      return sapa.createComponent("CSSPropertyEditor", {
        ref: "$offsetPropertyEditor",
        "hide-refresh": true,
        onchange: "changeCSSPropertyEditor"
      });
    }
    templateForOffset() {
      return `<div class='offset' ref='$offset' data-selected-value="-1"></div>`;
    }
    makeOffset(offset, index2) {
      return `<div class='offset-item' style='left: ${offset.offset};' data-offset-index='${index2.toString()}'></div>`;
    }
    selectItem(selectedIndex) {
      if (sapa.isUndefined(selectedIndex)) {
        selectedIndex = -1;
        for (var i = 0, len2 = this.state.offsets.length; i < len2; i++) {
          if (this.state.offsets[i].selected) {
            selectedIndex = i;
            break;
          }
        }
        if (selectedIndex === -1) {
          selectedIndex = 0;
        }
      }
      this.getRef("$offset").attr("data-selected-value", selectedIndex);
      this.selectedIndex = selectedIndex;
      this.state.offsets.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
      var selectedList = this.state.offsets.filter((it) => it.selected);
      this.selectedOffsetItem = selectedList.length ? selectedList[0] : {};
      this.refreshOffsetInput();
    }
    refreshOffsetInput() {
      var offset = this.state.offsets[this.selectedIndex];
      if (offset) {
        this.children.$offsetInput.setValue(offset.offset);
      }
    }
    [sapa.LOAD("$offset") + sapa.DOMDIFF]() {
      return this.state.offsets.map((it, index2) => {
        return this.makeOffset(it, index2);
      });
    }
    isNotOffsetItem(e) {
      return !sapa.Dom.create(e.target).hasClass("offset-item") && !this.currentOffset;
    }
    [sapa.CLICK("$offset") + sapa.IF("isNotOffsetItem") + sapa.PREVENT](e) {
      this.baseOffsetWidth = this.refs.$offset.width();
      this.baseOffsetArea = this.refs.$offset.offset();
      var currentX = e.xy.x;
      var newOffset = editor.Length.percent((currentX - this.baseOffsetArea.left) / this.baseOffsetWidth * 100).round(100);
      this.state.offsets.push({
        offset: newOffset
      });
      this.selectItem(this.state.offsets.length - 1, true);
      this.refresh();
      this.modifyOffset();
    }
    refreshOffsetProperty() {
      this.emit("showCSSPropertyEditor", this.selectedOffsetItem.properties);
    }
    [sapa.POINTERSTART("$offset .offset-item") + MOVE("moveOffset") + END("endOffset")](e) {
      this.baseOffsetWidth = this.refs.$offset.width();
      this.baseOffsetArea = this.refs.$offset.offset();
      this.currentOffsetleft = editor.Length.parse(e.$dt.css("left"));
      this.currentOffset = e.$dt;
      this.currentOffsetIndex = +e.$dt.attr("data-offset-index");
      this.currentOffsetXY = e.xy;
      this.baseOffsetMin = this.baseOffsetArea.left;
      this.baseOffsetMax = this.baseOffsetArea.left + this.baseOffsetWidth;
      this.isRemoveOffset = false;
      if (e.altKey) {
        this.isRemoveOffset = true;
      } else {
        this.selectItem(this.currentOffsetIndex, true);
        this.refreshOffsetInput();
      }
    }
    moveOffset(dx) {
      if (this.isRemoveOffset)
        return;
      var currentX = this.currentOffsetXY.x + dx;
      if (currentX < this.baseOffsetMin) {
        currentX = this.baseOffsetMin;
      }
      if (currentX > this.baseOffsetMax) {
        currentX = this.baseOffsetMax;
      }
      var newOffset = editor.Length.percent((currentX - this.baseOffsetMin) / this.baseOffsetWidth * 100).round(100);
      this.state.offsets[this.currentOffsetIndex].offset = newOffset.value;
      this.currentOffset.css("left", newOffset);
      this.refreshOffsetInput();
      this.modifyOffset();
    }
    removeOffset(index2) {
      this.state.offsets.splice(index2, 1);
      this.selectItem(0);
      this.refresh();
      this.modifyOffset();
    }
    endOffset() {
      if (this.isRemoveOffset) {
        window.setTimeout(() => {
          this.currentOffset = null;
          this.removeOffset(this.currentOffsetIndex);
        }, 10);
      } else {
        window.setTimeout(() => {
          this.currentOffset = null;
          this.refreshOffsetInput();
          this.refreshOffsetProperty();
          this.modifyOffset();
        }, 10);
      }
    }
    refresh() {
      this.load();
      this.refreshOffsetProperty();
    }
    [sapa.SUBSCRIBE("showOffsetEditor")](data) {
      this.setState(data);
      this.selectItem();
      this.refresh();
    }
    [sapa.SUBSCRIBE("changeCSSPropertyEditor")](properties = []) {
      var offset = this.state.offsets[this.selectedIndex];
      if (offset) {
        offset.properties = [...properties];
      }
      this.modifyOffset();
    }
  }
  function keyframe(editor2) {
    editor2.registerElement({
      OffsetEditor
    });
    editor2.registerUI("inspector.tab.transition", {
      KeyframeProperty
    });
    editor2.registerUI("popup", {
      KeyframePopup
    });
  }
  var LayerAppendView$1 = "";
  class PathStringManager {
    constructor() {
      this.pathArray = [];
    }
    reset() {
      this.pathArray = [];
    }
    getPointString(values) {
      return values.map((v) => `${v.x} ${v.y}`).join(" ");
    }
    makeString(command, values = []) {
      this.pathArray.push(`${command} ${this.getPointString(values)}`);
      return this;
    }
    M(...values) {
      return this.makeString("M", values);
    }
    L(...values) {
      return this.makeString("L", values);
    }
    X(...values) {
      const dist2 = 3;
      const point2 = values[0];
      const topLeft = { x: point2.x - dist2, y: point2.y - dist2 };
      const topRight = { x: point2.x + dist2, y: point2.y - dist2 };
      const bottomLeft = { x: point2.x - dist2, y: point2.y + dist2 };
      const bottomRight = { x: point2.x + dist2, y: point2.y + dist2 };
      return this.M(topLeft).L(bottomRight).M(topRight).L(bottomLeft);
    }
    Q(...values) {
      return this.makeString("Q", values);
    }
    C(...values) {
      return this.makeString("C", values);
    }
    Z() {
      return this.makeString("Z");
    }
    get d() {
      return this.pathArray.join(" ").trim();
    }
    toString(className = "object") {
      return `<path d="${this.d}" class='${className}'/>`;
    }
  }
  class LayerAppendView extends editor.EditorElement {
    template() {
      return `
        <div class='elf--layer-append-view'>
            <div class='area' ref='$area'></div>
            <div class='area-rect' ref='$areaRect'></div>
            <div class='area-pointer' ref='$mousePointer'></div>
            <div class='area-pointer-view' ref='$mousePointerView'></div>            
            <input type='file' accept='image/*' multiple="true" ref='$file' class='embed-file-input'/>
            <input type='file' accept='video/*' multiple="true" ref='$video' class='embed-video-input'/>            
        </div>
        `;
    }
    initState() {
      return {
        dragStart: false,
        width: 0,
        height: 0,
        color: "black",
        fontSize: 30,
        showRectInfo: false,
        areaVerties: rectToVerties(0, 0, 0, 0),
        content: "Insert a text",
        pathManager: new PathStringManager(),
        rect: {},
        options: {},
        containerItem: void 0,
        patternInfo: {}
      };
    }
    get scale() {
      return this.$viewport.scale;
    }
    checkNotDragStart() {
      return Boolean(this.state.dragStart) === false;
    }
    [sapa.POINTERMOVE("$el") + sapa.IF("checkNotDragStart")](e) {
      const vertex = this.$viewport.getWorldPosition(e);
      const newVertex = this.$context.snapManager.checkPoint(vertex);
      if (equals$1(newVertex, vertex) === false) {
        this.state.target = newVertex;
        this.state.targetVertex = this.$viewport.applyVertex(this.state.target);
        this.state.targetPositionVertex = clone(this.state.target);
        this.state.targetGuides = this.$context.snapManager.findGuideOne([
          this.state.target
        ]);
      } else {
        this.state.target = floor([], vertex);
        this.state.targetVertex = floor([], this.$viewport.applyVertex(this.state.target));
        this.state.targetGuides = [];
        this.state.targetPositionVertex = null;
      }
      this.bindData("$mousePointer");
      this.bindData("$mousePointerView");
    }
    [sapa.POINTERSTART("$el") + MOVE() + END() + sapa.PREVENT + sapa.STOP](e) {
      this.initMousePoint = this.state.targetPositionVertex ? this.state.targetPositionVertex : this.$viewport.getWorldPosition(e);
      this.state.dragStart = true;
      this.state.color = "#C4C4C4";
      this.state.text = "";
      const minX = this.initMousePoint[0];
      const minY = this.initMousePoint[1];
      const verties = rectToVerties(minX, minY, 0, 0);
      this.state.areaVerties = this.$viewport.applyVerties(verties);
      this.bindData("$area");
      this.bindData("$areaRect");
    }
    createLayerTemplate(width2, height) {
      const { type, text: text2, color, inlineStyle } = this.state;
      switch (type) {
        case "artboard":
          return `<div class='draw-item' style='background-color: white; ${inlineStyle}'></div>`;
        case "rect":
          return `<div class='draw-item' style='background-color: ${color}; ${inlineStyle}'></div>`;
        case "circle":
          return `<div class='draw-item' style='background-color: ${color}; border-radius: 100%; ${inlineStyle}'></div>`;
        case "text":
        case "svg-text":
          return `
                <div 
                    class='draw-item' 
                    
                    style='font-size: 30px;outline: 1px solid blue;white-space:nowrap'
                >
                    <p contenteditable="true" style="margin:0px;display: inline-block;outline:none;" ></p>
                </div>`;
        case "svg-rect":
          return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeRect(0, 0, width2, height).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
        case "svg-circle":
          return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeCircle(0, 0, width2, height).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
        case "svg-path":
          const newD = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height / this.state.bboxRect.height).d;
          const options2 = this.state.options;
          return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height}" style="width:100%; height:100%;" overflow="visible">
                    <path   d="${newD}" 
                            stroke-width="${options2["stroke-width"] || 1}" 
                            stroke="${options2["stroke"] || "black"}" 
                            fill="${options2["fill"] || "transparent"}" 
                    />
                </svg>
            </div>
            `;
        case "polygon":
          const options22 = this.state.options;
          return `
                <div class='draw-item'>
                    <svg width="${width2}" height="${height}" style="width:100%; height:100%;" overflow="visible">
                        <path   d="${PathParser.makePolygon(width2, height, options22.count).d}" 
                                stroke-width="${options22["stroke-width"] || 1}" 
                                stroke="${options22["stroke"] || "black"}" 
                                fill="${options22["fill"] || "transparent"}" 
                        />
                    </svg>
                </div>
                `;
        case "star":
          const options3 = this.state.options;
          return `
                    <div class='draw-item'>
                        <svg width="${width2}" height="${height}" style="width:100%; height:100%;" overflow="visible">
                            <path   d="${PathParser.makeStar(width2, height, options3.count, options3.radius, options3.tension).d}" 
                                    stroke-width="${options3["stroke-width"] || 1}" 
                                    stroke="${options3["stroke"] || "black"}" 
                                    fill="${options3["fill"] || "transparent"}" 
                            />
                        </svg>
                    </div>
                    `;
        case "svg-textpath":
          return `
            <div class='draw-item' style='outline: 1px solid blue;'>
                <svg width="${width2}" height="${height}" style="width:100%; height:100%;font-size: ${height}px;" overflow="visible">
                    <defs>
                        <path id='layer-add-path' d="${PathStringManager.makeLine(0, height, width2, height)}" />
                    </defs>
                    <text>
                        <textPath 
                          xlink:href="#layer-add-path"
                          textLength="100%"
                          lengthAdjust="spacingAndGlyphs"
                          startOffset="0em"
                        >${text2}</textPath>
                    </text>
                </svg>
            </div>
            `;
        default:
          return `<div class='draw-item' style='outline: 1px solid blue; ${inlineStyle}'></div>`;
      }
    }
    [sapa.BIND("$area")]() {
      const { areaVerties } = this.state;
      const { left, top, width: width2, height } = vertiesToRectangle(areaVerties);
      return {
        style: {
          left,
          top,
          width: width2,
          height
        },
        innerHTML: this.createLayerTemplate(width2, height)
      };
    }
    [sapa.BIND("$areaRect")]() {
      const { areaVerties, showRectInfo } = this.state;
      const newVerties = this.$viewport.applyVertiesInverse(areaVerties);
      const { width: width2, height } = vertiesToRectangle(newVerties);
      return {
        style: {
          display: showRectInfo ? "inline-block" : "none",
          left: areaVerties[2][0],
          top: areaVerties[2][1]
        },
        innerHTML: `x: ${Math.round(newVerties[0][0])}, y: ${Math.round(newVerties[0][1])}, ${Math.round(width2)} x ${Math.round(height)}`
      };
    }
    [sapa.BIND("$mousePointerView")]() {
      const { showRectInfo } = this.state;
      const { target = create$3(), targetVertex = create$3() } = this.state;
      return {
        style: {
          display: !showRectInfo ? "inline-block" : "none",
          left: targetVertex[0] || -1e4,
          top: targetVertex[1] || -1e4
        },
        innerHTML: `x: ${Math.round(target[0])}, y: ${Math.round(target[1])}`
      };
    }
    makeMousePointer() {
      if (this.state.dragStart)
        return "";
      const { target } = this.state;
      if (!target)
        return "";
      const guides = (this.state.targetGuides || []).filter(Boolean);
      return `
        <svg width="100%" height="100%">
            ${guides.map((guide) => {
        this.state.pathManager.reset();
        guide = this.$viewport.applyVerties([guide[0], guide[1]]);
        return this.state.pathManager.M({ x: guide[0][0], y: guide[0][1] }).L({ x: guide[1][0], y: guide[1][1] }).X({ x: guide[0][0], y: guide[0][1] }).X({ x: guide[1][0], y: guide[1][1] }).toString("layer-add-snap-pointer");
      }).join("\n")}
        </svg>
    `;
    }
    [sapa.BIND("$mousePointer")]() {
      const html = this.makeMousePointer();
      return {
        innerHTML: html
      };
    }
    move() {
      const e = this.$config.get("bodyEvent");
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newMousePoint = this.$context.snapManager.checkPoint(targetMousePoint);
      if (equals$1(newMousePoint, targetMousePoint) === false) {
        this.state.target = newMousePoint;
        this.state.targetVertex = this.$viewport.applyVertex(newMousePoint);
        this.state.targetGuides = this.$context.snapManager.findGuideOne([newMousePoint]).filter(Boolean);
      } else {
        this.state.target = void 0;
        this.state.targetGuides = [];
      }
      const isShiftKey = e.shiftKey;
      const minX = Math.min(newMousePoint[0], this.initMousePoint[0]);
      const minY = Math.min(newMousePoint[1], this.initMousePoint[1]);
      const maxX = Math.max(newMousePoint[0], this.initMousePoint[0]);
      const maxY = Math.max(newMousePoint[1], this.initMousePoint[1]);
      let dx = maxX - minX;
      let dy = maxY - minY;
      if (isShiftKey) {
        dy = dx;
      }
      const verties = rectToVerties(minX, minY, dx, dy);
      this.state.areaVerties = this.$viewport.applyVerties(verties);
      this.state.showRectInfo = true;
      this.bindData("$area");
      this.bindData("$areaRect");
      this.bindData("$mousePointer");
      this.bindData("$mousePointerView");
    }
    end() {
      const isAltKey = this.$config.get("bodyEvent").altKey;
      let { color, content: content2, fontSize, areaVerties, patternInfo } = this.state;
      const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
      const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
      let { x, y, width: width2, height } = vertiesToRectangle(rectVerties);
      let hasArea = true;
      if (width2 === 0 && height === 0) {
        switch (this.state.type) {
          case "text":
            content2 = "";
            height.set(this.state.fontSize);
            hasArea = false;
            break;
          default:
            width2 = 100;
            height = 100;
            break;
        }
      }
      var rect2 = __spreadValues(__spreadValues({
        x: Math.floor(x),
        y: Math.floor(y),
        width: Math.floor(width2),
        height: Math.floor(height),
        backgroundColor: color,
        content: content2,
        fontSize
      }, patternInfo.attrs), this.state.options);
      switch (this.state.type) {
        case "text":
        case "svg-text":
        case "svg-textpath":
          delete rect2.backgroundColor;
          break;
        case "svg-path":
          rect2["d"] = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height / this.state.bboxRect.height).d;
          break;
        default:
          delete rect2["content"];
          break;
      }
      switch (this.state.type) {
        case "image":
          this.trigger("openImage", rect2, parentArtBoard);
          break;
        case "video":
          this.trigger("openVideo", rect2, parentArtBoard);
          break;
        case "audio":
          this.trigger("openAudio", rect2, parentArtBoard);
          break;
        case "text":
          if (hasArea) {
            rect2.fontSize = editor.Length.px(this.state.fontSize).floor();
          } else {
            const scaledFontSize = this.state.fontSize / this.$viewport.scale;
            const $drawItem = this.refs.$area.$(".draw-item > p");
            $drawItem.parent().css("height", `${scaledFontSize}px`);
            $drawItem.parent().css("font-size", `${scaledFontSize}px`);
            $drawItem.select();
            $drawItem.focus();
            return;
          }
          this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
          break;
        default:
          this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
          this.$config.set("editing.mode.itemType", "select");
          break;
      }
      if (!isAltKey) {
        this.trigger("hideLayerAppendView");
      }
      this.state.dragStart = false;
      this.state.showRectInfo = false;
      this.state.target = void 0;
      this.bindData("$areaRect");
    }
    [sapa.SUBSCRIBE("showLayerAppendView")](type, options2 = {}) {
      this.state.type = type;
      this.state.options = options2;
      this.state.isShow = true;
      this.refs.$area.empty();
      this.$el.show();
      this.$el.focus();
      this.$context.snapManager.clear();
      const model = this.$model.createModel(__spreadValues({
        itemType: type
      }, options2), false);
      this.state.inlineStyle = CSS_TO_STRING(this.$editor.renderer("html").toCSS(model, {
        top: true,
        left: true,
        width: true,
        height: true,
        transform: true,
        transformOrigin: true
      }));
      if (options2.d) {
        this.state.d = new PathParser(options2.d);
        this.state.bboxRect = this.state.d.rect();
      }
      this.$context.commands.emit("push.mode.view", "LayerAppendView");
    }
    [sapa.SUBSCRIBE("hideLayerAppendView")]() {
      if (this.$el.isShow()) {
        this.state.isShow = false;
        this.$el.hide();
        this.$commands.emit("pop.mode.view", "LayerAppendView");
      }
    }
    [sapa.SUBSCRIBE("hideAddViewLayer")]() {
      this.state.isShow = false;
      this.$el.hide();
    }
    isShow() {
      return this.state.isShow;
    }
    [sapa.KEYDOWN("document") + sapa.IF("isShow") + sapa.ESCAPE + sapa.ENTER]() {
    }
    [sapa.KEYUP("document") + sapa.IF("isShow") + sapa.ESCAPE + sapa.ENTER](e) {
      switch (this.state.type) {
        case "text":
          const $t = sapa.Dom.create(e.target);
          let { fontSize, areaVerties } = this.state;
          const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
          const { x, y } = vertiesToRectangle(rectVerties);
          const { width: width2, height } = $t.rect();
          const text2 = $t.text();
          if (text2.length === 0) {
            break;
          }
          const [[newWidth, newHeight, newFontSize]] = this.$viewport.applyScaleVertiesInverse([[width2, height, fontSize]]);
          const rect2 = {
            x,
            y,
            width: newWidth,
            height: newHeight,
            content: text2.trim(),
            "font-size": newFontSize
          };
          const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
          this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
          break;
      }
      this.state.dragStart = false;
      this.state.showRectInfo = false;
      this.state.target = null;
      this.bindData("$areaRect");
      this.trigger("hideLayerAppendView");
    }
    [sapa.CHANGE("$file")]() {
      this.refs.$file.files.forEach((item) => {
        this.$commands.emit("updateImage", item, this.state.rect, this.state.containerItem);
      });
    }
    [sapa.CHANGE("$video")]() {
      this.refs.$video.files.forEach((item) => {
        this.$commands.emit("updateVideo", item, this.state.rect, this.state.containerItem);
      });
    }
    [sapa.SUBSCRIBE("openImage")](rect2, containerItem) {
      this.state.rect = rect2;
      this.state.containerItem = containerItem;
      this.refs.$file.click();
    }
    [sapa.SUBSCRIBE("openVideo")](rect2, containerItem) {
      this.state.rect = rect2;
      this.state.containerItem = containerItem;
      this.refs.$video.click();
    }
    [sapa.SUBSCRIBE("setPatternInfo")](patternInfo) {
      this.state.patternInfo = patternInfo;
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.$context.snapManager.clear();
      this.bindData("$mousePointer");
      this.bindData("$mousePointerView");
    }
  }
  function layerAppendView(editor2) {
    editor2.registerUI("canvas.view", {
      LayerAppendView
    });
  }
  var LayerTreeProperty$1 = "";
  let osInfo = {
    name: void 0
  };
  function os() {
    if (osInfo.name === void 0) {
      if (window.navigator.appVersion.indexOf("Win") != -1)
        osInfo.name = "win";
      else if (window.navigator.appVersion.indexOf("Mac") != -1)
        osInfo.name = "mac";
      else if (window.navigator.appVersion.indexOf("X11") != -1)
        osInfo.name = "linux";
      else
        osInfo.name = "";
    }
    return osInfo.name;
  }
  const KEY_CODE = {
    backspace: 8,
    tab: 9,
    enter: 13,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    semicolon: 59,
    equals: 61,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    multiply: 106,
    add: 107,
    subtract: 109,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    f13: 124,
    f14: 125,
    f15: 126,
    f16: 127,
    f17: 128,
    f18: 129,
    f19: 130,
    comma: 188,
    ",": 188,
    period: 190,
    ".": 190,
    slash: 191,
    "/": 191,
    backquote: 192,
    "`": 192,
    openbracket: 219,
    "[": 219,
    backslash: 220,
    "\\": 220,
    closebracket: 221,
    "]": 221,
    quote: 222,
    "'": 222,
    altgr: 225
  };
  const keyAlias = {
    ARROWRIGHT: "\u2192",
    ARROWLEFT: "\u2190",
    ARROWUP: "\u2191",
    ARROWDOWN: "\u2192",
    BACKSPACE: "\u232B",
    CMD: "\u2318",
    SHIFT: "\u21E7",
    CTRL: "\u2303",
    ALT: "\u2325",
    ENTER: "\u21B5",
    ESC: "\u238B",
    TAB: "\u21E5",
    SPACE: "\u2423",
    CAPSLOCK: "\u21EA",
    DELETE: "\u2326",
    INSERT: "\u2324",
    HOME: "\u21F1",
    END: "\u21F2",
    PAGEUP: "\u21DE",
    PAGEDOWN: "\u21DF",
    PRINTSCREEN: "\u2399",
    SCROLLLOCK: "\u21DE",
    PAUSE: "\u23CF",
    NUMLOCK: "\u21EA",
    META: "\u2318",
    WINDOWS: "\u2318",
    CONTEXTMENU: "\u2325",
    COMMAND: "\u2318"
  };
  const OSName = os();
  const KeyStringMaker = (item, os2 = OSName) => {
    return (item[os2] || item.key).split("+").map((it) => it.trim()).map((it) => {
      const keyString = it.toUpperCase();
      return keyAlias[keyString] || keyString;
    }).join(" ");
  };
  const DRAG_START_CLASS = "drag-start";
  class LayerTreeProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("layer.tree.property.title");
    }
    getClassName() {
      return "full";
    }
    initState() {
      return {
        hideDragPointer: true,
        lastDragOverPosition: 0,
        lastDragOverOffset: 0,
        rootRect: { top: 0 },
        itemRect: { height: 0 }
      };
    }
    getBody() {
      return `
      <div class="elf--layer-list scrollbar" ref="$layerList"></div>
      <div class='drag-point' ref='$dragPointer'></div>
    `;
    }
    [sapa.BIND("$dragPointer")]() {
      var offset = this.state.lastDragOverOffset;
      var dist2 = this.state.itemRect.height / 3;
      var bound = {};
      if (this.state.lastDragOverOffset < dist2) {
        offset = 0;
        var top = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
        bound = {
          top,
          height: "1px",
          width: "100%",
          left: "0px"
        };
        this.state.lastDragOverItemDirection = "before";
      } else if (this.state.lastDragOverOffset > this.state.itemRect.height - dist2) {
        offset = this.state.itemRect.height;
        var top = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
        bound = {
          top,
          height: "1px",
          width: "100%",
          left: "0px"
        };
        this.state.lastDragOverItemDirection = "after";
      } else {
        const targetItem = this.$model.get(this.state.lastDragOverItemId);
        if (targetItem == null ? void 0 : targetItem.enableHasChildren()) {
          offset = 0;
          var top = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
          bound = {
            top,
            height: this.state.itemRect.height,
            width: "100%",
            left: "0px"
          };
          this.state.lastDragOverItemDirection = "self";
        }
      }
      bound.display = this.state.hideDragPointer ? "none" : "block";
      return {
        style: bound
      };
    }
    getIcon(item) {
      if (item.d) {
        return editor.iconUseForPath(item.d, {
          width: item.screenWidth,
          height: item.screenHeight,
          fill: "currentColor",
          stroke: "currentColor"
        });
      }
      if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
        if (item.isLayout("flex")) {
          return editor.iconUse("layout_flex");
        } else if (item.isLayout("grid")) {
          return editor.iconUse("layout_grid");
        }
        return editor.iconUse("layout_default");
      }
      return this.$icon.get(item.itemType, item);
    }
    makeLayerList(parentObject, depth2 = 0) {
      if (!parentObject.layers)
        return "";
      const layers = parentObject.layers;
      const data = [];
      for (var last = layers.length - 1; last > -1; last--) {
        var layer = layers[last];
        var selectedPathClass = this.$context.selection.hasPathOf(layer) ? "selected-path" : "";
        var selectedClass = this.$context.selection.check(layer) ? "selected" : "";
        var hovered = this.$context.selection.checkHover(layer) ? "hovered" : "";
        var name = layer.is("boolean-path") ? layer["boolean-operation"] : layer.name;
        if (layer.is("text")) {
          name = layer.text || layer.name;
        }
        var title = "";
        if (layer.hasLayout()) {
          title = this.$i18n("layer.tree.property.layout.title." + layer.layout);
        }
        const isHide = layer.isTreeItemHide();
        const depthPadding = depth2 * 20;
        const hasChildren = layer.hasChildren();
        const lock = this.$lockManager.get(layer.id);
        const visible = this.$visibleManager.get(layer.id);
        data[data.length] = `<div class='layer-item ${selectedClass} ${selectedPathClass} ${hovered}' data-is-group="${hasChildren}" data-depth="${depth2}" data-layout='${layer.layout}' data-layer-id='${layer.id}' data-is-hide="${isHide}"  draggable="true"><div class='detail'><label data-layout-title='${title}' style='padding-left: ${editor.Length.px(depthPadding)}' ><div class='folder ${layer.collapsed ? "collapsed" : ""}'>${hasChildren ? editor.iconUse("arrow_right") : ""}</div><span class='icon' data-item-type="${layer.itemType}">${this.getIcon(layer)}</span><span class='name'>${name}</span></label><div class="tools"><button type="button" class="lock" data-lock="${lock}" title='Lock'>${lock ? editor.iconUse("lock") : editor.iconUse("lock_open")}</button><button type="button" class="visible" data-visible="${visible}" title='Visible'>${editor.iconUse("visible")}</button><button type="button" class="remove" title='Remove'>${editor.iconUse("remove2")}</button></div></div></div>${this.makeLayerList(layer, depth2 + 1)}`;
      }
      return data.join("");
    }
    [sapa.SUBSCRIBE("refreshContent")]() {
      this.refresh();
    }
    [sapa.LOAD("$layerList") + sapa.DOMDIFF]() {
      var project2 = this.$context.selection.currentProject;
      if (!project2)
        return "";
      return [
        this.makeLayerList(project2, 0),
        `
        <div class='layer-item ' data-depth="0" data-is-last="true">
        </div>
      `
      ];
    }
    [sapa.DRAGSTART("$layerList .layer-item")](e) {
      var layerId = e.$dt.attr("data-layer-id");
      e.$dt.addClass(DRAG_START_CLASS);
      e.dataTransfer.setData("layer/id", layerId);
      this.state.rootRect = this.refs.$layerList.rect();
      this.state.itemRect = e.$dt.rect();
      this.setState({
        hideDragPointer: false
      }, false);
      this.bindData("$dragPointer");
    }
    [sapa.DRAGEND("$layerList .layer-item")]() {
      this.setState({
        hideDragPointer: true
      }, false);
      this.bindData("$dragPointer");
      this.refs.$layerList.$$(`.${DRAG_START_CLASS}`).forEach((it) => {
        it.removeClass(DRAG_START_CLASS);
      });
    }
    [sapa.DRAGOVER(`$layerList .layer-item:not(.${DRAG_START_CLASS})`) + sapa.PREVENT](e) {
      var targetLayerId = e.$dt.attr("data-layer-id");
      this.state.lastDragOverItemId = targetLayerId;
      this.state.lastDragOverPosition = e.$dt.rect().top;
      this.state.lastDragOverOffset = e.offsetY;
      this.bindData("$dragPointer");
    }
    [sapa.DROP(`$layerList .layer-item:not(.${DRAG_START_CLASS})`)](e) {
      var targetLayerId = e.$dt.attr("data-layer-id");
      var sourceLayerId = e.dataTransfer.getData("layer/id");
      if (targetLayerId === sourceLayerId)
        return;
      var targetItem = this.$model.get(targetLayerId);
      var sourceItem = this.$model.get(sourceLayerId);
      if ((targetItem == null ? void 0 : targetItem.enableHasChildren()) === false)
        return;
      if (targetItem && targetItem.hasParent(sourceItem.id))
        return;
      switch (this.state.lastDragOverItemDirection) {
        case "self":
          this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.APPEND_CHILD);
          break;
        case "before":
          this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_BEFORE);
          break;
        case "after":
          this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_AFTER);
          break;
      }
      this.nextTick(() => {
        this.$commands.emit("recoverBooleanPath");
        this.$context.selection.select(sourceItem);
        this.setState({
          hideDragPointer: true
        });
      }, 10);
    }
    [sapa.DOUBLECLICK("$layerList .layer-item")](e) {
      this.startInputEditing(e.$dt.$(".name"));
    }
    modifyDoneInputEditing(input, event) {
      if (KEY_CODE.enter === event.keyCode) {
        this.endInputEditing(input, () => {
          var id2 = input.closest("layer-item").attr("data-layer-id");
          var text3 = input.text();
          this.$commands.executeCommand("setAttribute", "change name", {
            [id2]: {
              name: text3
            }
          });
        });
      } else {
        var id = input.closest("layer-item").attr("data-layer-id");
        var text2 = input.text();
        this.$commands.executeCommand("setAttribute", "change name", {
          [id]: {
            name: text2
          }
        });
      }
    }
    [sapa.KEYDOWN("$layerList .layer-item .name") + sapa.STOP](e) {
      this.modifyDoneInputEditing(e.$dt, e);
    }
    [sapa.FOCUSOUT("$layerList .layer-item .name") + sapa.PREVENT + sapa.STOP](e) {
      this.modifyDoneInputEditing(e.$dt, { keyCode: KEY_CODE.enter });
    }
    selectLayer(layer) {
      if (layer) {
        this.$context.selection.select(layer);
      }
      this.refresh();
    }
    addLayer(layer) {
      if (layer) {
        this.$context.selection.select(layer);
        this.$commands.emit("refreshArtboard");
      }
    }
    [sapa.CLICK("$add")]() {
      this.$commands.emit("newComponent", "rect", {
        backgroundColor: "#ececec",
        width: 200,
        height: 100
      });
    }
    [sapa.CLICK("$layerList .layer-item label .name")](e) {
      var $item = e.$dt.closest("layer-item");
      $item.onlyOneClass("selected");
      var id = $item.attr("data-layer-id");
      this.$context.selection.select(id);
      this.$commands.emit("history.refreshSelection");
    }
    [sapa.CLICK("$layerList .layer-item label .folder")](e) {
      var $item = e.$dt.closest("layer-item");
      var id = $item.attr("data-layer-id");
      var item = this.$model.get(id);
      item.reset({
        collapsed: !item.collapsed
      });
      this.refresh();
    }
    [sapa.CLICK("$layerList .layer-item .visible")](e) {
      var $item = e.$dt.closest("layer-item");
      var id = $item.attr("data-layer-id");
      this.$visibleManager.toggle(id);
      var visible = this.$visibleManager.get(id);
      e.$dt.attr("data-visible", visible);
      this.emit("refreshVisibleView");
    }
    [sapa.CLICK("$layerList .layer-item .remove")](e) {
      var $item = e.$dt.closest("layer-item");
      var id = $item.attr("data-layer-id");
      this.$commands.executeCommand("removeLayer", "remove a layer", [id]);
      this.nextTick(() => {
        this.refresh();
      }, 1e3);
    }
    [sapa.CLICK("$layerList .layer-item .lock")](e) {
      var $item = e.$dt.closest("layer-item");
      var id = $item.attr("data-layer-id");
      this.$lockManager.toggle(id);
      var lastLock = this.$lockManager.get(id);
      e.$dt.attr("data-lock", lastLock);
      if (lastLock) {
        this.$context.selection.removeById(id);
      }
    }
    [sapa.SUBSCRIBE("changeHoverItem")]() {
      this.refs.$layerList.$$(".hovered").forEach((it) => {
        it.removeClass("hovered");
      });
      if (this.$context.selection.hoverItems.length) {
        var selector2 = this.$context.selection.hoverItems.map((it) => {
          return `[data-layer-id="${it.id}"]`;
        }).join(",");
        this.refs.$layerList.$$(selector2).forEach((it) => {
          it.addClass("hovered");
        });
      }
    }
    [sapa.SUBSCRIBE_SELF("changeSelection")](isSelection = false) {
      if (isSelection && this.refs.$layerList) {
        this.refs.$layerList.$$(".selected").forEach((it) => {
          it.removeClass("selected");
        });
        this.refs.$layerList.$$(".selected-path").forEach((it) => {
          it.removeClass("selected-path");
        });
        var selector2 = this.$context.selection.items.map((it) => {
          return `[data-layer-id="${it.id}"]`;
        }).join(",");
        if (selector2) {
          this.refs.$layerList.$$(selector2).forEach((it) => {
            it.addClass("selected");
            var item = this.$context.selection.itemKeys[it.attr("data-layer-id")];
            if (item.is("svg-path", "svg-polygon")) {
              it.$(".icon").html(this.getIcon(item));
            }
          });
        }
      }
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION, "refreshAllCanvas")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("refreshLayerTreeView") + sapa.THROTTLE(100)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("changeItemLayout")]() {
      this.refresh();
    }
    [sapa.CONFIG("bodyEvent")]() {
      const $target = sapa.Dom.create(this.$config.get("bodyEvent").target);
      const $layerItem = $target.closest("layer-item");
      if ($layerItem) {
        this.emit("refreshHoverView", $layerItem.data("layer-id"));
      }
    }
  }
  function layerTree(editor2) {
    editor2.registerElement({
      LayerTreeProperty
    });
  }
  var conic = {
    title: "Conic",
    key: "conic",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        var x = randomNumber(45, 55);
        var y = randomNumber(45, 55);
        var angle = randomNumber(0, 360);
        return {
          gradient: `conic-gradient(from ${angle}deg at ${x}% ${y}%, ${ColorStep.createColorStep(2, 360, "deg")})`
        };
      });
    }
  };
  const angle_list$2 = ["0deg", "45deg", "90deg"];
  var linear = {
    title: "Linear",
    key: "linear",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `linear-gradient(${randomItem(...angle_list$2)}, ${ColorStep.createColorStep(2)})`
        };
      });
    }
  };
  var radial = {
    title: "Radial",
    key: "radial",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        var shape = "circle";
        return {
          gradient: `radial-gradient(${shape}, ${ColorStep.createColorStep(2)})`
        };
      });
    }
  };
  var randomConic = {
    title: "Random Conic",
    key: "random-conic",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `conic-gradient(from 0deg at 50% 50%, ${ColorStep.createColorStep(10, 360, "deg")})`
        };
      });
    }
  };
  const angle_list$1 = ["0deg", "45deg", "90deg"];
  var randomLinear = {
    title: "Random Linear",
    key: "random-linear",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `linear-gradient(${randomItem(...angle_list$1)}, ${ColorStep.createColorStep(10)})`
        };
      });
    }
  };
  var randomRadial = {
    title: "Random Radial",
    key: "random-radial",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `radial-gradient(circle, ${ColorStep.createColorStep(10)})`
        };
      });
    }
  };
  var repeatConic = {
    title: "Repeat Conic",
    key: "repeat-conic",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `repeating-conic-gradient(from 0deg at 0% 50%, ${ColorStep.createRepeatColorStep(10, "10deg")})`
        };
      });
    }
  };
  const angle_list = ["0deg", "45deg", "90deg"];
  var repeatLinear = {
    title: "Repeat Linear",
    key: "repeat-linear",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        return {
          gradient: `repeating-linear-gradient(${randomItem(...angle_list)}, ${ColorStep.createRepeatColorStep(2, "10px")})`
        };
      });
    }
  };
  var repeatRadial = {
    title: "Repeat Radial",
    key: "repeat-radial",
    execute: function(count = 42) {
      return repeat(count).map(() => {
        var shape = "circle";
        return {
          gradient: `repeating-radial-gradient(${shape}, ${ColorStep.createRepeatColorStep(3, "6px")})`
        };
      });
    }
  };
  var gradients = [
    linear,
    randomLinear,
    repeatLinear,
    radial,
    randomRadial,
    repeatRadial,
    conic,
    randomConic,
    repeatConic
  ];
  var GradientAssetsProperty$1 = "";
  const options = gradients.map((it) => {
    return { value: it.key, text: it.title };
  });
  class GradientAssetsProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("gradient.asset.property.title");
    }
    initState() {
      return {
        mode: "grid",
        preset: "linear"
      };
    }
    getTools() {
      return `<div ref="$tools"></div>`;
    }
    [sapa.LOAD("$tools")]() {
      return sapa.createComponent("SelectEditor", {
        ref: "$preset",
        key: "preset",
        value: this.state.preset,
        options,
        onchange: "changePreset"
      });
    }
    [sapa.SUBSCRIBE_SELF("changePreset")](key, value) {
      this.setState({
        [key]: value
      });
    }
    getClassName() {
      return "elf--gradient-assets-property";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.show();
    }
    getBody() {
      return `
      <div class='property-item gradient-assets'>
        <div class='gradient-list' ref='$gradientList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.DRAGSTART("$gradientList .gradient-item")](e) {
      const gradient2 = e.$dt.attr("data-gradient");
      e.dataTransfer.effectAllowed = "copy";
      e.dataTransfer.setData("text/gradient", gradient2);
    }
    [sapa.LOAD("$gradientList")]() {
      var preset = gradients.find((it) => it.key === this.state.preset);
      if (!preset) {
        return "";
      }
      var results = preset.execute().map((item, index2) => {
        return `<div class='gradient-item' data-index="${index2}" data-gradient='${item.gradient}' data-custom="${item.custom}">
          <div class='preview' title="${item.gradient}" draggable="true">
            <div class='gradient-view' style='background-image: ${item.gradient};'></div>
          </div>
        </div>`;
      });
      if (preset.edit) {
        results.push(`<div class='add-gradient-item'><butto type="button">${editor.iconUse("add")}</button></div>`);
      }
      return results;
    }
    executeGradient(callback, isRefresh = true, isEmit = true) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
        if (isRefresh)
          this.refresh();
        if (isEmit)
          this.emit("refreshGradientAssets");
      } else {
        window.alert("Please select a project.");
      }
    }
    [sapa.CLICK("$gradientList .add-gradient-item")]() {
      this.executeGradient((project2) => {
        project2.createGradient({
          gradient: Gradient.random(),
          name: "",
          variable: ""
        });
      });
    }
    [sapa.CLICK("$gradientList .preview")](e) {
      var $item = e.$dt.closest("gradient-item");
      var gradient2 = $item.attr("data-gradient");
      this.$commands.emit("drop.asset", { gradient: gradient2 });
    }
  }
  var ImageAssetsProperty$1 = "";
  function revokeObjectUrl(url) {
    window.URL.revokeObjectURL(url);
  }
  class ImageAssetsProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("image.asset.property.title");
    }
    initState() {
      return {
        mode: "grid"
      };
    }
    getClassNamef() {
      return "elf--image-assets-property";
    }
    afterRender() {
      this.show();
    }
    getBody() {
      return `
      <div class='property-item image-assets'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.LOAD("$imageList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.currentProject || { images: [] };
      var images = current.images;
      var results = images.map((image2, index2) => {
        return `
        <div class='image-item' data-index="${index2}">
          <div class='preview' draggable="true">
            <img src="${image2.local}" />
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${editor.iconUse("copy")}</button>          
            <button type="button" class='remove'>${editor.iconUse("remove")}</button>
          </div>
        </div>
      `;
      });
      return `
      <div class='loaded-list'>
        ${results.join("")}
        <div class='add-image-item'>
          <input type='file' accept='image/*' ref='$file' />
          <button type="button">${editor.iconUse("add")}</button>
        </div>        
      </div>

    `;
    }
    executeImage(callback, isRefresh = true, isEmit = true) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
        if (isRefresh)
          this.refresh();
        if (isEmit)
          this.emit("refreshImageAssets");
      } else {
        window.alert("Please select a project.");
      }
    }
    [sapa.DRAGSTART("$imageList .preview img")](e) {
      var index2 = +e.$dt.closest("image-item").attr("data-index");
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        var imageInfo = project2.images[index2];
        e.dataTransfer.setData("image/info", imageInfo.local);
      }
    }
    [sapa.CHANGE("$imageList .add-image-item input[type=file]")](e) {
      this.executeImage(() => {
        [...e.target.files].forEach((item) => {
          this.$commands.emit("updateImageAssetItem", item);
        });
      });
    }
    [sapa.CLICK("$imageList .remove")](e) {
      var $item = e.$dt.closest("image-item");
      var index2 = +$item.attr("data-index");
      this.executeImage((project2) => {
        project2.removeImage(index2);
        revokeObjectUrl($item.$(".preview img").attr("src"));
      });
    }
    [sapa.CLICK("$imageList .copy")](e) {
      var $item = e.$dt.closest("image-item");
      var index2 = +$item.attr("data-index");
      this.executeImage((project2) => {
        project2.copyImage(index2);
      });
    }
    [sapa.SUBSCRIBE("addImageAsset")]() {
      this.refresh();
    }
  }
  var check = {
    key: "check",
    title: "Check",
    execute: function() {
      return [
        { pattern: `check(20px 20px, 10px 10px, black, transparent)` },
        { pattern: `check(40px 40px, 20px 20px, black, transparent)` },
        { pattern: `check(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
        { pattern: `check(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
        { pattern: `check(100px 100px, 50px 50px, #DCF3DC, transparent)` },
        { pattern: `check(200px 200px, 100px 100px, #102C45, transparent)` }
      ];
    }
  };
  var crossdot = {
    key: "cross-dot",
    title: "Cross Dot",
    execute: function() {
      return [
        {
          pattern: `cross-dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)`
        },
        {
          pattern: `cross-dot(40px 40px, 20px 20px, #DDB104, #FEF0BC, normal, 4px)`
        },
        {
          pattern: `cross-dot(60px 60px, 30px 30px, #35DB92, #DCF9EC, normal, 6px)`
        }
      ];
    }
  };
  var diagonalLine = {
    key: "diagonal-line",
    title: "Diagonal Line",
    execute: function() {
      return [
        {
          pattern: `diagonal-line(10px 10px, 45deg, #B7C4CD, white, normal, 1px)`
        },
        {
          pattern: `diagonal-line(25px 25px, 90deg, #DDB104, #FEF0BC, normal, 2px)`
        },
        {
          pattern: `diagonal-line(50px 50px, 135deg, #35DB92, #DCF9EC, normal, 3px)`
        }
      ];
    }
  };
  var dot = {
    key: "dot",
    title: "Dot",
    execute: function() {
      return [
        { pattern: `dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)` },
        { pattern: `dot(40px 40px, 20px 20px, #E7393F, #FEF0BC, normal, 2px)` },
        { pattern: `dot(60px 60px, 30px 30px, #E7393F, black, normal, 3px)` },
        { pattern: `dot(80px 80px, 40px 40px, #B7C4CD, white, normal, 4px)` }
      ];
    }
  };
  var grid = {
    key: "grid",
    title: "Grid",
    execute: function() {
      return [
        { pattern: `grid(20px 20px, 10px 10px, black, transparent)` },
        { pattern: `grid(40px 40px, 20px 20px, black, transparent)` },
        { pattern: `grid(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
        { pattern: `grid(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
        { pattern: `grid(100px 100px, 50px 50px, #DCF3DC, transparent)` },
        { pattern: `grid(200px 200px, 100px 100px, #102C45, transparent)` }
      ];
    }
  };
  var horizontalLine = {
    key: "horizontal-line",
    title: "Horizontal Line",
    execute: function() {
      return [
        { pattern: `horizontal-line(10px 10px, 0, #B7C4CD, white, normal, 1px)` },
        {
          pattern: `horizontal-line(25px 25px, 0, #DDB104, #FEF0BC, normal, 2px)`
        },
        {
          pattern: `horizontal-line(50px 50px, 0, #35DB92, #DCF9EC, normal, 3px)`
        }
      ];
    }
  };
  var verticalLine = {
    key: "vertical-line",
    title: "Vertical Line",
    execute: function() {
      return [
        { pattern: `vertical-line(10px 10px, 0px, #B7C4CD, white, normal, 1px)` },
        {
          pattern: `vertical-line(25px 25px, 0px, #DDB104, #FEF0BC, normal, 2px)`
        },
        {
          pattern: `vertical-line(50px 50px, 0px, black, rgba(231,57,63,0.9), normal, 1px)`
        }
      ];
    }
  };
  var patterns = [
    check,
    grid,
    dot,
    crossdot,
    diagonalLine,
    verticalLine,
    horizontalLine
  ];
  var PatternAssetsProperty$1 = "";
  class PatternAssetsProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("pattern.asset.property.title");
    }
    initState() {
      return {
        mode: "grid",
        preset: "check"
      };
    }
    getTools() {
      const options2 = sapa.variable(patterns.map((it) => {
        return { value: it.key, text: it.title };
      }));
      return sapa.createComponent("SelectEditor", {
        ref: "$assets",
        key: "preset",
        value: this.state.preset,
        options: options2,
        onchange: "changePreset"
      });
    }
    [sapa.SUBSCRIBE_SELF("changePreset")](key, value) {
      this.setState({
        [key]: value
      });
    }
    getClassName() {
      return "elf--pattern-assets-property";
    }
    get editableProperty() {
      return "pattern";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100) + sapa.IF("checkShow")]() {
    }
    getBody() {
      return `
      <div class='property-item pattern-assets'>
        <div class='pattern-list' ref='$patternList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.DRAGSTART("$patternList .pattern-item")](e) {
      const pattern = e.$dt.attr("data-pattern");
      e.dataTransfer.effectAllowed = "copy";
      e.dataTransfer.setData("text/pattern", pattern);
    }
    [sapa.LOAD("$patternList")]() {
      var preset = patterns.find((it) => it.key === this.state.preset);
      if (!preset) {
        return "";
      }
      var results = preset.execute().map((item, index2) => {
        const cssText = CSS_TO_STRING(Pattern.toCSS(item.pattern));
        return `<div class='pattern-item' data-index="${index2}" data-pattern="${item.pattern}">
          <div class='preview' title="${item.title}" draggable="true">
            <div class='pattern-view' style='${cssText}'></div>
          </div>
        </div>`;
      });
      return results;
    }
    [sapa.CLICK("$patternList .pattern-item")](e) {
      const pattern = e.$dt.attr("data-pattern");
      if (this.$modeView.isCurrentMode(ViewModeType.CanvasView)) {
        this.$commands.emit("addBackgroundImagePattern", pattern);
      } else {
        this.emit("setPatternAsset", pattern);
      }
    }
  }
  var VideoAssetsProperty$1 = "";
  class VideoAssetsProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("video.asset.property.title");
    }
    initState() {
      return {
        mode: "grid"
      };
    }
    getClassName() {
      return "elf--video-assets-property";
    }
    afterRender() {
      this.show();
    }
    getBody() {
      return `
      <div class='property-item video-assets'>
        <div class='video-list' ref='$videoList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.LOAD("$videoList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.currentProject || { videos: [] };
      var videos = current.videos;
      var results = videos.map((video2, index2) => {
        return `
        <div class='video-item' data-index="${index2}">
          <div class='preview' draggable="true">
            <img src="${video2.local}" />
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${editor.iconUse("copy")}</button>          
            <button type="button" class='remove'>${editor.iconUse("remove")}</button>
          </div>
        </div>
      `;
      });
      return `
      <div class='loaded-list'>
        ${results.join("")}
        <div class='add-video-item'>
          <input type='file' accept='video/*' ref='$file' />
          <button type="button">${editor.iconUse("add")}</button>
        </div>        
      </div>

    `;
    }
    executeVideo(callback, isRefresh = true, isEmit = true) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
        if (isRefresh)
          this.refresh();
        if (isEmit)
          this.emit("refreshVideoAssets");
      } else {
        window.alert("Please select a project.");
      }
    }
    [sapa.DRAGSTART("$videoList .preview img")](e) {
      var index2 = +e.$dt.closest("video-item").attr("data-index");
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        var videoInfo = project2.videos[index2];
        e.dataTransfer.setData("video/info", videoInfo.local);
      }
    }
    [sapa.CHANGE("$videoList .add-video-item input[type=file]")](e) {
      this.executeVideo(() => {
        [...e.target.files].forEach((item) => {
          this.emit("updateVideoAssetItem", item);
        });
      });
    }
    [sapa.CLICK("$videoList .remove")](e) {
      var $item = e.$dt.closest("video-item");
      var index2 = +$item.attr("data-index");
      this.executeVideo((project2) => {
        project2.removeVideo(index2);
        revokeObjectUrl($item.$(".preview img").attr("src"));
      });
    }
    [sapa.CLICK("$videoList .copy")](e) {
      var $item = e.$dt.closest("video-item");
      var index2 = +$item.attr("data-index");
      this.executeVideo((project2) => {
        project2.copyVideo(index2);
      });
    }
    [sapa.SUBSCRIBE("addVideoAsset")]() {
      this.refresh();
    }
  }
  sapa.registElement({ VideoAssetsProperty });
  class AssetItems extends editor.EditorElement {
    template() {
      return `
      <div class='asset-items'>
        ${this.$injectManager.generate("asset")}
      </div>
    `;
    }
  }
  var CustomAssets$1 = "";
  class CustomAssets extends editor.EditorElement {
    template() {
      return `
      <div class='elf--custom-assets'>
        <div class='custom-assets-tools'>
          <div class='title'><label>Custom Assets</label></div>
          <div class='tools'>
            <button type="button" ref='$addCustomAsset'>${editor.iconUse("add")}</button>
          </div>
        </div>
        <div class='elf--asset-list' ref='$list'></div>
      </div>
    `;
    }
    async [sapa.LOAD("$list")]() {
      const data = await this.$storageManager.getCustomAssetList();
      return data.map((it) => {
        return `
        <div class='asset-preview' draggable="true" data-preview-id="${it.id}">
          <div class='thumbnail'><img src='${it.preview}' /></div>
          <div class='tools'>
            <div class='title'>${it.component.name}</div>
            <div class='buttons'>
              <button type="button" class='remove-asset-preview' title="remove asset" data-preview-id="${it.id}">${editor.iconUse("remove")}</button>
            </div>
          </div>
        </div>
      `;
      });
    }
    async [sapa.CLICK("$list .remove-asset-preview")](e) {
      if (window.confirm(this.$i18n("app.confirm.message.artboard.items.removeCustomAsset"))) {
        const id = e.$dt.data("preview-id");
        await this.$storageManager.removeCustomAsset(id);
        this.refresh();
      }
    }
    [sapa.DRAGSTART("$list .asset-preview")](e) {
      const id = e.$dt.data("preview-id");
      e.dataTransfer.effectAllowed = "copy";
      e.dataTransfer.setData("text/asset", id);
    }
    [sapa.CLICK("$addCustomAsset")]() {
      this.$commands.emit("savePNG", async (datauri) => {
        await this.$storageManager.saveCustomAsset(datauri);
        this.refresh();
      });
    }
  }
  var LibraryItems$1 = "";
  class LibraryItems extends editor.EditorElement {
    template() {
      return `
      <div class='elf--library-items'>
        <div>
          ${sapa.createComponent("TextEditor", {
        label: "Search",
        key: "search",
        onchange: this.subscribe((key, value) => {
          this.broadcast("search", value);
        }, 300)
      })}
        </div>
        ${this.$injectManager.generate("library")}
      </div>
    `;
    }
  }
  var ObjectItems$1 = "";
  class ObjectItems extends editor.EditorElement {
    template() {
      return `
        <div class="object-items">
          <div>
            ${sapa.createComponent("ProjectProperty")}
          </div>
          <div>
            ${sapa.createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
    }
  }
  function layertab(editor$1) {
    editor$1.context.config.set("layertab.selectedValue", "layer");
    editor$1.registerUI("layertab.tab", {
      Layer: {
        title: editor$1.$i18n("app.tab.title.layers"),
        icon: editor.iconUse("layers"),
        value: "layer"
      },
      Library: {
        title: editor$1.$i18n("app.tab.title.libraries"),
        icon: editor.iconUse("auto_awesome"),
        value: "library"
      },
      Asset: {
        title: editor$1.$i18n("app.tab.title.assets"),
        icon: editor.iconUse("apps"),
        value: "asset"
      },
      Component: {
        title: editor$1.$i18n("app.tab.title.components"),
        icon: editor.iconUse("plugin"),
        value: "component"
      }
    });
    editor$1.registerUI("layertab.tab.layer", {
      ObjectItems
    });
    editor$1.registerUI("layertab.tab.library", {
      LibraryItems
    });
    editor$1.registerUI("layertab.tab.asset", {
      AssetItems
    });
    editor$1.registerUI("layertab.tab.component", {
      CustomAssets
    });
    editor$1.registerUI("asset", {
      GradientAssetsProperty,
      PatternAssetsProperty,
      ImageAssetsProperty,
      VideoAssetsProperty
    });
  }
  var DefaultLayoutItemProperty$1 = "";
  class DefaultLayoutItemProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("default.layout.item.property.title.constraints");
    }
    getClassName() {
      return "elf--default-layout-item-property";
    }
    getBody() {
      return `
        <div class='property-item' ref='$body'>
          <div class="constraints">
            <div ref="$constraintsInfo"></div>
            <div ref="$constraintsInfoInput"></div>
          </div>
        </div>
      `;
    }
    [sapa.LOAD("$constraintsInfo") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current;
      const h = (current == null ? void 0 : current["constraints-horizontal"]) || Constraints.MIN;
      const v = (current == null ? void 0 : current["constraints-vertical"]) || Constraints.MIN;
      return `
      <div class="constraints-box">

        <!-- Horizontal -->
        <div class='item' data-value='min' data-selected="${h === Constraints.MIN || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='max' data-selected="${h === Constraints.MAX || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='center' data-selected="${h === Constraints.CENTER}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>

        <!-- Vertical -->
        <div class='item' data-value='min' data-selected="${v === Constraints.MIN || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='max' data-selected="${v === Constraints.MAX || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='center' data-selected="${v === Constraints.CENTER}" data-key='${ConstraintsDirection.VERTICAL}'></div>            
        <div class="rect"></div>
      </div>
    `;
    }
    [sapa.LOAD("$constraintsInfoInput")]() {
      var current = this.$context.selection.current;
      const hasLayout = current == null ? void 0 : current.hasLayout();
      return `
      <div>
        ${sapa.createComponent("SelectEditor", {
        ref: "$constraintsHorizontal",
        key: "constraints-horizontal",
        value: (current == null ? void 0 : current["constraints-horizontal"]) || "min",
        label: editor.iconUse("width"),
        compact: true,
        options: [
          { value: "min", text: "Left" },
          { value: "max", text: "Right" },
          { value: "stretch", text: "Left and Right", disabled: hasLayout },
          { value: "center", text: "Center" },
          { value: "scale", text: "Scale", disabled: hasLayout }
        ],
        onchange: "changeConstraints"
      })}
      </div>

      <div>
        ${sapa.createComponent("SelectEditor", {
        ref: "$constraintsVertical",
        key: "constraints-vertical",
        value: (current == null ? void 0 : current["constraints-vertical"]) || "min",
        label: editor.iconUse("height"),
        compact: true,
        options: [
          { value: "min", text: "Top" },
          { value: "max", text: "Bottom" },
          { value: "stretch", text: "Top and Bottom", disabled: hasLayout },
          { value: "center", text: "Center" },
          { value: "scale", text: "Scale", disabled: hasLayout }
        ],
        onchange: "changeConstraints"
      })}
      </div>
    `;
    }
    [sapa.CLICK("$constraintsInfo .item")](e) {
      const [value, key] = e.$dt.attrs("data-value", "data-key");
      const current = this.$context.selection.current;
      if (!current)
        return;
      current.changeConstraints(key, value, e.shiftKey);
      this.trigger("changeConstraints", key, current[key]);
    }
    [sapa.SUBSCRIBE_SELF("changeConstraints")](key, value) {
      this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
        [key]: value
      }));
      this.nextTick(() => {
        this.refresh();
      }, 100);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(() => {
        var current = this.$context.selection.current;
        return current && current.isInDefault() && current.parent.isNot("project");
      });
    }
  }
  var FlexGrowToolView$1 = "";
  class FlexGrowToolView extends editor.EditorElement {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--flex-grow-tool-view"
      });
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      return this.$context.selection.map((item) => {
        const parentItem = item.parent;
        if (!parentItem)
          return;
        if (parentItem.is("project"))
          return;
        if (parentItem.isLayout(Layout.FLEX) === false)
          return;
        return parentItem.layers.map((child) => {
          const verties = this.$viewport.applyVerties(child.verties);
          const center = verties[4];
          let flexGrow = 0;
          let size = child.screenWidth || 0;
          const parentLayoutDirection = parentItem == null ? void 0 : parentItem.flexDirection;
          if (parentLayoutDirection === FlexDirection.ROW) {
            if (child.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
              flexGrow = child.flexGrow || 1;
            }
            size = child.screenWidth;
          } else if (parentLayoutDirection === FlexDirection.COLUMN) {
            if (child.resizingVertical === ResizingMode.FILL_CONTAINER) {
              flexGrow = child.flexGrow || 1;
            }
            size = child.screenHeight;
          }
          return /* @__PURE__ */ sapa.createElementJsx("div", {
            class: "flex-grow-item",
            style: {
              left: editor.Length.px(center[0]),
              top: editor.Length.px(center[1])
            },
            "data-flex-item-id": child.id,
            "data-parent-direction": parentLayoutDirection,
            "data-flex-grow": flexGrow
          }, /* @__PURE__ */ sapa.createElementJsx("span", {
            class: "size"
          }, Math.floor(size)), " ", /* @__PURE__ */ sapa.createElementJsx("span", {
            class: "grow"
          }, flexGrow || "x"));
        }).join("");
      });
    }
    [sapa.POINTERSTART("$el .flex-grow-item") + MOVE() + END()](e) {
      const [id, grow] = e.$dt.attrs("data-flex-item-id", "data-flex-grow");
      this.setState({
        id,
        grow: +grow
      }, false);
    }
    getFlexGrow(parentLayoutDirection, item, grow, dx, dy) {
      let flexGrow = grow;
      if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
        flexGrow = grow + Math.floor(dx / 10);
      } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
        flexGrow = grow + Math.floor(dy / 10);
      }
      flexGrow = Math.max(1, flexGrow);
      return flexGrow;
    }
    move(dx, dy) {
      const { id, grow } = this.state;
      const item = this.$editor.get(id);
      if (!item)
        return;
      const parentItem = item.parent;
      if (!parentItem)
        return;
      const parentLayoutDirection = parentItem.flexDirection;
      let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
      this.$commands.emit("setAttribute", {
        [id]: {
          flexGrow
        }
      });
    }
    end(dx, dy) {
      const { id, grow } = this.state;
      const item = this.$editor.get(id);
      if (!item)
        return;
      const parentItem = item.parent;
      if (!parentItem)
        return;
      const parentLayoutDirection = parentItem.flexDirection;
      let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
      if (dx === 0 && dy === 0) {
        if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal !== ResizingMode.FILL_CONTAINER) {
          this.$commands.executeCommand("setAttribute", "change self resizing", {
            [id]: {
              flexGrow: 1,
              resizingHorizontal: ResizingMode.FILL_CONTAINER
            }
          });
        } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical !== ResizingMode.FILL_CONTAINER) {
          this.$commands.executeCommand("setAttribute", "change self resizing", {
            [id]: {
              flexGrow: 1,
              resizingVertical: ResizingMode.FILL_CONTAINER
            }
          });
        }
      } else {
        this.$commands.executeCommand("setAttribute", "change self resizing", {
          [id]: {
            flexGrow
          }
        });
      }
      this.nextTick(() => {
        this.refresh();
      }, 10);
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.THROTTLE(100)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.THROTTLE(1)]() {
      this.refresh();
    }
    [sapa.CONFIG("set.move.control.point")]() {
      this.refresh();
    }
  }
  var FlexLayoutEditor$1 = "";
  class FlexLayoutEditor extends editor.EditorElement {
    initialize() {
      super.initialize();
      this.directionOptions = this.getDirectionOptions();
      this.wrapOptions = this.getWrapOptions();
      this.justifyContentOptions = this.getJustifyContentOptions();
      this.alignItemsOptions = this.getAlignItemsOptions();
    }
    getDirectionOptions() {
      return this.makeOptionsFunction("row,column");
    }
    getWrapOptions() {
      return this.makeOptionsFunction("nowrap,wrap");
    }
    getJustifyContentOptions() {
      return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around");
    }
    getAlignItemsOptions() {
      return this.makeOptionsFunction("flex-start,flex-end,center,baseline,stretch");
    }
    getAlignContentOptions() {
      return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around,stretch");
    }
    makeOptionsFunction(options2) {
      return options2.split(",").map((it) => {
        return { value: it, text: this.$i18n("flex.layout.editor." + it) };
      });
    }
    initState() {
      return __spreadValues({}, this.props.value);
    }
    setValue(value) {
      this.setState(__spreadValues({}, value));
    }
    getValue() {
      return this.state;
    }
    modifyData(key, value) {
      this.parent.trigger(this.props.onchange, key, value);
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const realPaddingTop = Math.min(current.paddingTop || 0, 50);
      const realPaddingLeft = Math.min(current.paddingLeft || 0, 50);
      const realPaddingRight = Math.min(current.paddingRight || 0, 50);
      const realPaddingBottom = Math.min(current.paddingBottom || 0, 50);
      const padding = `padding-top:${realPaddingTop}px;padding-left: ${realPaddingLeft}px;padding-right:${realPaddingRight}px;padding-bottom: ${realPaddingBottom}px;`;
      return `<div class='flex-layout-item'><div class="grid-2"><div>${sapa.createComponent("SelectIconEditor", {
        key: "flexDirection",
        ref: "$flexDirection",
        value: this.state.flexDirection || FlexDirection.ROW,
        options: this.directionOptions,
        icons: ["east", "south"],
        onchange: "changeKeyValue"
      })}</div><div>${sapa.createComponent("NumberInputEditor", {
        compact: true,
        ref: "$flex-gap",
        label: editor.iconUse("space"),
        key: "gap",
        value: this.state.gap,
        min: 0,
        max: 100,
        step: 1,
        onchange: "changeKeyValue"
      })}</div><div>${sapa.createComponent("NumberInputEditor", {
        compact: true,
        label: editor.iconUse("padding"),
        key: "padding",
        ref: "$padding",
        value: current.paddingTop,
        min: 0,
        max: 100,
        step: 1,
        onchange: "changePadding"
      })}</div><div>${sapa.createComponent("ToggleButton", {
        compact: true,
        key: "flexWrap",
        ref: "$wrap",
        size: 30,
        checkedValue: "wrap",
        value: this.state.flexWrap || FlexWrap.NOWRAP,
        toggleLabels: [editor.iconUse("wrap"), editor.iconUse("wrap")],
        toggleValues: [FlexWrap.NOWRAP, FlexWrap.WRAP],
        onchange: "changeKeyValue"
      })}</div></div></div>
  <div class="select-flex-direction">
      <div>
          <div class="flex-group-padding">            
              <div class="padding-top" style="height: ${current.paddingTop}px"></div>
              <div class="padding-left" style="width: ${current.paddingLeft}px"></div>
              <div class="padding-right" style="width: ${current.paddingRight}px"></div>
              <div class="padding-bottom" style="height: ${current.paddingBottom}px"></div>
          </div>
          <div class="flex-group" style="
                  --flex-group-gap: ${Math.floor(this.state.gap / 10)}px;
                  --flex-group-padding: ${realPaddingTop}px;
                  ${padding};
                  flex-direction: ${this.state.flexDirection};
                  flex-wrap: ${this.state.flexWrap};
                  justify-content:${this.state.justifyContent};
                  align-items: ${this.state.alignItems};
                  align-content:${this.state.alignContent};
          ">
              ${[1, 2, 3].map(() => {
        return `
                      <div class="flex-direction" data-value="${this.state.flexDirection}" style="flex-direction: ${this.state.flexDirection};align-items: ${this.state.alignItem};">
                          <div class="flex-direction-item" data-index="1"></div>
                          <div class="flex-direction-item" data-index="2"></div>
                          <div class="flex-direction-item" data-index="3"></div>
                      </div>
                  `;
      }).join("\n")}
          </div>
          <div class="flex-group-tool"  style="${padding};">
              <div class="tool-area"  
                  data-direction="${this.state.flexDirection}"  
                  data-justify-content="${this.state.justifyContent}"
                  data-align-items="${this.state.alignItems}"
                  data-align-content="${this.state.alignContent}"                            
                  style="
                      --flex-group-gap: ${Math.floor(this.state["gap"] / 10)}px;
                      --flex-group-padding: ${realPaddingTop}px;
                  "
              >
                  <div class="tool-area-item" data-index="1" data-justify-content="flex-start" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="2"  data-justify-content="center" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="3"  data-justify-content="flex-end" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="4"  data-justify-content="flex-start" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="5"  data-justify-content="center" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="6"  data-justify-content="flex-end" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="7"  data-justify-content="flex-start" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="8"  data-justify-content="center" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="9"  data-justify-content="flex-end" data-align-items="flex-end"></div>                            
              </div>
          </div>
      </div>
  </div>

  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.justify-content")}</div>
      ${sapa.createComponent("SelectIconEditor", {
        key: "justifyContent",
        ref: "$justify",
        value: this.state.justifyContent || JustifyContent.FLEX_START,
        options: this.justifyContentOptions,
        icons: [
          "start",
          "end",
          "horizontal_align_center",
          "horizontal_distribute",
          "justify_content_space_around"
        ],
        onchange: "changeKeyValue"
      })}
  </div>
  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.align-items")}</div>            
      ${sapa.createComponent("SelectIconEditor", {
        key: "alignItems",
        ref: "$alignItems",
        value: this.state.alignItems || AlignItems.FLEX_START,
        options: this.alignItemsOptions,
        icons: [
          "vertical_align_top",
          "vertical_align_bottom",
          "vertical_align_center",
          "vertical_align_baseline",
          "vertical_align_stretch"
        ],
        onchange: "changeKeyValue"
      })}
  </div>
        `;
    }
    template() {
      return `<div class='flex-layout-editor' ref='$body' ></div>`;
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      this.setState({
        [key]: value
      }, false);
      this.modifyData(key, value);
      this.refresh();
    }
    [sapa.SUBSCRIBE_SELF("changePadding")](key, value) {
      this.setState({
        [key]: value
      }, false);
      this.modifyData(key, {
        paddingTop: value,
        paddingLeft: value,
        paddingRight: value,
        paddingBottom: value
      });
      this.refresh();
    }
    [sapa.CLICK("$body .tool-area-item")](e) {
      const $target = e.$dt;
      const [justifyContent, alignItems] = $target.attrs("data-justify-content", "data-align-items", "data-align-content");
      if (this.state.justifyContent === JustifyContent.SPACE_BETWEEN) {
        this.setState({
          alignItems
        }, false);
        this.modifyData("alignItems", alignItems);
      } else if (this.state.justifyContent === JustifyContent.SPACE_AROUND) {
        this.setState({
          alignItems
        }, false);
        this.modifyData("align-item", alignItems);
      } else {
        this.setState({
          justifyContent,
          alignItems
        }, false);
        this.modifyData("justifyContent", justifyContent);
        this.modifyData("alignItems", alignItems);
      }
      this.refresh();
    }
  }
  var GridBoxEditor$1 = "";
  const REG_CSS_UNIT = /(auto)|(repeat\([^)]*\))|(([\d.]+)(px|pt|fr|r?em|deg|vh|vw|%))/gi;
  class GridBoxEditor extends editor.EditorElement {
    getLayoutItemOptions() {
      return "none,auto,repeat,length".split(",").map((it) => {
        return { value: it, text: this.$i18n(`grid.box.editor.${it}`) };
      });
    }
    initState() {
      return {
        label: this.props.label,
        list: this.parseValue(this.props.value)
      };
    }
    setValue(value) {
      this.setState({
        list: this.parseValue(value)
      });
    }
    parseValue(value) {
      let arr = null;
      var target = [];
      while ((arr = REG_CSS_UNIT.exec(value)) !== null) {
        var text2 = arr[0];
        if (text2 === "auto") {
          target.push({ type: "auto", count: 0, value: "0px" });
        } else if (text2.includes("repeat")) {
          var tempArray = text2.split("repeat(")[1].split(")");
          tempArray.pop();
          let [count, ...size] = tempArray.join("").split(",");
          target.push({ type: "repeat", count, value: size.join(", ") });
        } else {
          target.push({ type: "length", count: 1, value: text2 });
        }
      }
      return target;
    }
    getValue() {
      return this.state.list.map((it) => {
        if (it.type === "repeat") {
          return `repeat(${it.count}, ${it.value})`;
        } else if (it.type === "auto" || it.type === "none") {
          return it.type;
        } else {
          return it.value;
        }
      }).join(" ");
    }
    modifyData() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
    }
    makeItem(it, index2) {
      return `
            <div class='item' data-repeat-type='${it.type}' data-index='${index2}' >
                <div class='repeat'>
                    ${sapa.createComponent("SelectEditor", {
        ref: `$${index2}-type`,
        compact: true,
        options: this.getLayoutItemOptions(),
        key: "type",
        value: it.type || "auto",
        params: index2,
        onchange: "changeKeyValue"
      })}
                </div>
                <div class='count'>
                    ${sapa.createComponent("NumberInputEditor", {
        compact: true,
        ref: `$${index2}-count`,
        key: "count",
        value: it.count,
        params: index2,
        max: 1e3,
        onchange: "changeKeyValue"
      })}
                </div>                
                <div class='value'>
                    ${sapa.createComponent("InputRangeEditor", {
        ref: `$${index2}-value`,
        compact: true,
        key: "value",
        value: it.value,
        params: index2,
        units: ["auto", "fr", "px", "em", "%"],
        onchange: "changeKeyValue"
      })}
                </div>
                <div class='tools'>
                    <button type="button" class='copy'>${editor.iconUse("copy")}</button>                
                    <button type="button" class='remove'>${editor.iconUse("remove2")}</button>
                </div>
            </div>
        `;
    }
    [sapa.LOAD("$list")]() {
      return this.state.list.map((it, index2) => {
        return this.makeItem(it, index2);
      });
    }
    template() {
      return `
            <div class='elf--grid-box-editor' ref='$body' >
                <div class='grid-box-editor-item'>
                    <div class='item header'>
                        <div class='repeat'>
                            <label>${this.state.label} </label>
                            <button type='button' ref='$add'>${editor.iconUse("add")}</button>
                        </div>
                        <div class='count'>${this.$i18n("grid.box.editor.count")}</div>
                        <div class='value'>${this.$i18n("grid.box.editor.value")}</div>
                        <div class='tools'></div>
                    </div>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK("$list .remove")](e) {
      var index2 = +e.$dt.closest("item").attr("data-index");
      this.state.list.splice(index2, 1);
      this.refresh();
      this.modifyData();
    }
    [sapa.CLICK("$list .copy")](e) {
      var index2 = +e.$dt.closest("item").attr("data-index");
      var newObj = sapa.clone(this.state.list[index2]);
      this.state.list.splice(index2, 0, newObj);
      this.refresh();
      this.modifyData();
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.SUBSCRIBE("add")]() {
      this.state.list.push({ type: "auto", count: 0, value: "0px" });
      this.refresh();
      this.modifyData();
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
      var index2 = +params;
      var item = this.state.list[index2];
      if (item) {
        if (key === "type") {
          this.refs.$list.$(`[data-index="${index2}"]`).attr("data-repeat-type", value);
        }
        item[key] = value;
      }
      this.modifyData();
    }
  }
  class GridGapEditor extends editor.EditorElement {
    initState() {
      return {
        label: this.props.label,
        value: this.parseValue(this.props.value)
      };
    }
    setValue(value) {
      this.setState({
        list: this.parseValue(value)
      });
    }
    parseValue(value) {
      return editor.Length.parse(value);
    }
    getValue() {
      return this.state.value;
    }
    modifyData() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
    }
    makeItem() {
      return `
            <div class='item'>
                <div class='value'>
                    ${sapa.createComponent("InputRangeEditor", {
        label: this.state.label,
        wide: true,
        ref: "$value",
        key: "value",
        value: this.state.value,
        max: 500,
        units: ["px", "em", "%"],
        onchange: "changeKeyValue"
      })}
                </div>
            </div>
        `;
    }
    [sapa.LOAD("$list")]() {
      return this.makeItem();
    }
    template() {
      return `
            <div class='grid-gap-editor' ref='$body' >
                <div class='grid-gap-editor-item'>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      this.state.value = value;
      this.modifyData();
    }
  }
  var GridGrowToolView$1 = "";
  class Grid {
    static parseStyle(value) {
      const units = [];
      parseValue(value).forEach((it) => {
        switch (it.func) {
          case FuncType.REPEAT:
            for (var i = 0, len2 = it.parsed.count; i < len2; i++) {
              units.push(it.parsed.length);
            }
            break;
          case FuncType.LENGTH:
            units.push(it.parsed);
            break;
          case FuncType.KEYWORD:
            units.push(it.matchedString);
            break;
        }
      });
      return units;
    }
    static join(values = []) {
      return values.join(" ");
    }
  }
  class GridGrowBaseView extends editor.EditorElement {
    updateRows(current, newRows) {
      const data = {};
      current.layers.forEach((it) => {
        data[it.id] = {
          gridRowStart: Math.max(1, Math.min(newRows.length, it.gridRowStart)),
          gridRowEnd: Math.min(newRows.length + 1, it.gridRowEnd)
        };
      });
      this.$commands.executeCommand("setAttribute", "change grid rows", __spreadProps(__spreadValues({}, data), {
        [current.id]: {
          gridTemplateRows: Grid.join(newRows)
        }
      }));
    }
    updateColumns(current, newColumns) {
      const data = {};
      current.layers.forEach((it) => {
        data[it.id] = {
          gridColumnStart: Math.max(1, Math.min(newColumns.length, it.gridColumnStart)),
          gridColumnEnd: Math.min(newColumns.length + 1, it.gridColumnEnd)
        };
      });
      this.$commands.executeCommand("setAttribute", "change grid columns", __spreadProps(__spreadValues({}, data), {
        [current.id]: {
          gridTemplateColumns: Grid.join(newColumns)
        }
      }));
    }
    updateColumnGap(current, columnGap) {
      this.$commands.executeCommand("setAttribute", "change grid column gap", {
        [current.id]: {
          gridColumnGap: `${columnGap}`
        }
      });
    }
    updateRowGap(current, rowGap) {
      this.$commands.executeCommand("setAttribute", "change grid row gap", {
        [current.id]: {
          gridRowGap: `${rowGap}`
        }
      });
    }
    createNewGridItems(arr) {
      let newArr = [];
      if (arr.length === 0) {
        newArr = [editor.Length.fr(1)];
      } else {
        newArr = [...arr, arr[arr.length - 1]];
      }
      return newArr;
    }
    copyNewGridItems(arr, index2) {
      return [...arr.slice(0, index2 + 1), ...arr.slice(index2)];
    }
    getScaleDist(num) {
      return num / this.$viewport.scale;
    }
  }
  class GridGrowClickEventView extends GridGrowBaseView {
    checkTargetLayer() {
      const current = this.getGridTargetLayer();
      if (!current)
        return false;
      if (current.isLayout(Layout.GRID) === false)
        return false;
      return true;
    }
    [sapa.CLICK("$grid .column-plus") + sapa.IF("checkTargetLayer")]() {
      const info = this.getGridLayoutInformation();
      this.updateColumns(info.current, this.createNewGridItems(info.columns));
    }
    [sapa.CLICK("$grid .row-plus") + sapa.IF("checkTargetLayer")]() {
      const info = this.getGridLayoutInformation();
      this.updateRows(info.current, this.createNewGridItems(info.rows));
    }
    [sapa.CLICK("$grid .column-delete") + sapa.IF("checkTargetLayer")](e) {
      const info = this.getGridLayoutInformation();
      if (info.columns.length < 2) {
        this.alert("Alert", "Columns can not be less than one.", 2e3);
        return;
      }
      const index2 = +e.$dt.data("index");
      const newColumns = [
        ...info.columns.slice(0, index2),
        ...info.columns.slice(index2 + 1)
      ];
      this.updateColumns(info.current, newColumns);
    }
    [sapa.CLICK("$grid .column-add") + sapa.IF("checkTargetLayer")](e) {
      const info = this.getGridLayoutInformation();
      const index2 = +e.$dt.data("index");
      this.updateColumns(info.current, this.copyNewGridItems(info.columns, index2), index2 + 1);
    }
    [sapa.CLICK("$grid .row-add") + sapa.IF("checkTargetLayer")](e) {
      const info = this.getGridLayoutInformation();
      const index2 = +e.$dt.data("index");
      this.updateRows(info.current, this.copyNewGridItems(info.rows, index2));
    }
    [sapa.CLICK("$grid .row-delete") + sapa.IF("checkTargetLayer")](e) {
      const info = this.getGridLayoutInformation();
      if (info.rows.length < 2) {
        this.alert("Alert", "Rows can not be less than one.", 2e3);
        return;
      }
      const index2 = +e.$dt.data("index");
      const newRows = [
        ...info.rows.slice(0, index2),
        ...info.rows.slice(index2 + 1)
      ];
      this.updateRows(info.current, newRows);
    }
  }
  class GridGrowDragEventView extends GridGrowClickEventView {
    [sapa.POINTERSTART("$gridGap .gap-tool.column-gap") + sapa.IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveColumnGap") + END("moveEndColumnGap")](e) {
      const info = this.getGridLayoutInformation();
      this.current = info.current;
      this.columnGap = info.columnGap;
      this.lastColumnGap = info.columnGap;
      this.initMousePosition = this.$viewport.getWorldPosition(e);
    }
    updateGapPointer(gap) {
      const screenPosition = this.$viewport.applyVertex(this.$viewport.getWorldPosition());
      this.refs.$pointer.text(`${gap}`);
      this.refs.$pointer.css({
        left: editor.Length.px(screenPosition[0]),
        top: editor.Length.px(screenPosition[1] + 20)
      });
    }
    moveFirstColumnGap() {
      this.refs.$pointer.show();
      this.updateGapPointer(this.columnGap);
    }
    moveColumnGap() {
      const targetPosition = this.$viewport.getWorldPosition();
      const newDist = subtract([], targetPosition, this.initMousePosition);
      const stepRate = newDist[0] / this.getScaleDist(100);
      const columnGap = this.columnGap;
      let newColumnGap = columnGap;
      if (columnGap instanceof editor.Length) {
        if (columnGap.isPercent()) {
          newColumnGap = editor.Length.percent(Math.max(columnGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
        } else if (columnGap.isPx() || columnGap.isEm()) {
          newColumnGap = editor.Length.px(Math.max(columnGap.value + stepRate * this.getScaleDist(100), 0)).floor();
        }
      }
      this.lastColumnGap = newColumnGap;
      this.updateColumnGap(this.current, newColumnGap);
      this.updateGapPointer(this.lastColumnGap);
    }
    moveEndColumnGap() {
      const targetPosition = this.$viewport.getWorldPosition();
      const realDistance = dist(targetPosition, this.initMousePosition);
      if (realDistance < 1) {
        if (this.lastColumnGap.isPx() || this.lastColumnGap.isEm()) {
          this.lastColumnGap = editor.Length.makePercent(this.lastColumnGap.value, this.current.screenWidth);
        } else {
          this.lastColumnGap = this.lastColumnGap.toPx(this.current.screenWidth);
        }
      }
      this.updateColumnGap(this.current, this.lastColumnGap);
      this.refs.$pointer.hide();
    }
    [sapa.POINTERSTART("$gridGap .gap-tool.row-gap") + sapa.IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveRowGap") + END("moveEndRowGap")](e) {
      const info = this.getGridLayoutInformation();
      this.current = info.current;
      this.rowGap = info.rowGap;
      this.lastColumnGap = info.rowGap;
      this.initMousePosition = this.$viewport.getWorldPosition(e);
    }
    moveRowGap() {
      const targetPosition = this.$viewport.getWorldPosition();
      const newDist = subtract([], targetPosition, this.initMousePosition);
      const stepRate = newDist[1] / this.getScaleDist(100);
      const rowGap = this.rowGap;
      let newRowGap = rowGap;
      console.log(rowGap);
      if (rowGap instanceof editor.Length) {
        if (rowGap.isPercent()) {
          newRowGap = editor.Length.percent(Math.max(rowGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
        } else if (rowGap.isPx() || rowGap.isNumber()) {
          newRowGap = editor.Length.px(Math.max(rowGap.value + stepRate * this.getScaleDist(100), 0)).floor();
        }
      }
      this.lastRowGap = newRowGap;
      this.updateRowGap(this.current, newRowGap);
      this.updateGapPointer(this.lastRowGap);
    }
    moveEndRowGap() {
      const targetPosition = this.$viewport.getWorldPosition();
      const realDistance = dist(targetPosition, this.initMousePosition);
      if (realDistance < 1) {
        if (!this.lastRowGap) {
          this.lastRowGap = editor.Length.px(0);
        }
        if (this.lastRowGap.isPx() || this.lastRowGap.isNumber()) {
          this.lastRowGap = editor.Length.makePercent(this.lastRowGap.value, this.current.screenHeight);
        } else {
          this.lastRowGap = this.lastRowGap.toPx(this.current.screenHeight);
        }
      }
      this.updateRowGap(this.current, this.lastRowGap);
      this.refs.$pointer.hide();
    }
    [sapa.POINTERSTART("$grid .grid-item-tool.column .item") + MOVE("moveColumn") + END("moveEndColumn")](e) {
      const index2 = +e.$dt.data("index");
      const info = this.getGridLayoutInformation();
      this.current = info.current;
      this.columns = info.columns;
      this.selectedColumnIndex = index2;
      this.selectedColumnWidth = info.columns[index2];
      this.initMousePosition = this.$viewport.getWorldPosition(e);
    }
    moveColumn() {
      const targetPosition = this.$viewport.getWorldPosition();
      const newDist = subtract([], targetPosition, this.initMousePosition);
      const stepRate = newDist[0] / this.getScaleDist(100);
      const columnWidth = this.selectedColumnWidth;
      if (columnWidth instanceof editor.Length) {
        if (columnWidth.isPercent()) {
          var newWidth = Math.max(columnWidth.value + stepRate * this.getScaleDist(5), 1);
          this.columns[this.selectedColumnIndex] = editor.Length.percent(newWidth).round(1e3);
        } else if (columnWidth.isPx() || columnWidth.isNumber()) {
          var newWidth = Math.max(10, columnWidth.value + stepRate * this.getScaleDist(100));
          this.columns[this.selectedColumnIndex] = editor.Length.px(newWidth).floor();
        } else if (columnWidth.isFr()) {
          var newWidth = Math.max(columnWidth.value + Math.floor(newDist[0] / this.getScaleDist(20)) * 0.25, 0.25);
          this.columns[this.selectedColumnIndex] = editor.Length.fr(newWidth);
        } else {
          var newWidth = Math.max(columnWidth.value + stepRate * 1, 10);
          this.columns[this.selectedColumnIndex] = new editor.Length(newWidth, columnWidth.unit);
        }
        this.updateColumns(this.current, this.columns);
      }
    }
    changedColumnSize() {
      const info = this.getGridLayoutInformation();
      const index2 = this.selectedColumnIndex;
      const width2 = this.selectedColumnWidth;
      if (width2 instanceof editor.Length) {
        if (width2.isPercent()) {
          this.columns[index2] = editor.Length.fr(1);
        } else if (width2.isPx() || width2.isNumber()) {
          this.columns[index2] = editor.Length.makePercent(width2.value, info.current.screenWidth).round(1e3);
        } else if (width2.isFr()) {
          this.columns[index2] = "auto";
        }
      } else if (width2 === "auto") {
        const { items } = this.state.lastGridInfo;
        const column = items.find((it) => it.column === index2 + 1);
        this.columns[index2] = editor.Length.px(column.rect.width).floor();
      }
    }
    moveEndColumn() {
      const targetPosition = this.$viewport.getWorldPosition();
      const realDistance = dist(targetPosition, this.initMousePosition);
      if (realDistance < 1) {
        this.changedColumnSize();
      }
      this.updateColumns(this.current, this.columns);
    }
    [sapa.POINTERSTART("$grid .grid-item-tool.row .item") + MOVE("moveRow") + END("moveEndRow")](e) {
      const index2 = +e.$dt.data("index");
      const info = this.getGridLayoutInformation();
      this.current = info.current;
      this.rows = info.rows;
      this.selectedRowIndex = index2;
      this.selectedRowHeight = info.rows[index2];
      this.initMousePosition = this.$viewport.getWorldPosition(e);
    }
    moveRow() {
      const targetPosition = this.$viewport.getWorldPosition();
      const newDist = subtract([], targetPosition, this.initMousePosition);
      const stepRate = newDist[1] / this.getScaleDist(30);
      const rowHeight = this.selectedRowHeight;
      if (rowHeight instanceof editor.Length) {
        if (rowHeight.isPercent()) {
          var newHeight = Math.max(rowHeight.value - stepRate * this.getScaleDist(5), 1);
          this.rows[this.selectedRowIndex] = editor.Length.percent(newHeight).round(1e3);
        } else if (rowHeight.isPx() || rowHeight.isNumber()) {
          var newHeight = Math.max(10, rowHeight.value - stepRate * this.getScaleDist(100));
          this.rows[this.selectedRowIndex] = editor.Length.px(newHeight).floor();
        } else if (rowHeight.isFr()) {
          var newHeight = Math.max(rowHeight.value + Math.floor(newDist[1] / this.getScaleDist(20)) * 0.25, 0.25);
          this.rows[this.selectedRowIndex] = editor.Length.fr(newHeight);
        } else {
          var newHeight = Math.max(rowHeight.value - stepRate * 1, 10);
          this.rows[this.selectedRowIndex] = new editor.Length(newHeight, rowHeight.unit);
        }
        this.updateRows(this.current, this.rows);
      }
    }
    changedRowSize() {
      const info = this.getGridLayoutInformation();
      const index2 = this.selectedRowIndex;
      const height = this.selectedRowHeight;
      if (height instanceof editor.Length) {
        if (height.isPercent()) {
          this.rows[index2] = editor.Length.fr(1);
        } else if (height.isPx() || height.isNumber()) {
          this.rows[index2] = editor.Length.makePercent(height.value, info.current.screenHeight).round(1e3);
        } else if (height.isFr()) {
          this.rows[index2] = "auto";
        }
      } else if (height === "auto") {
        const { items } = this.state.lastGridInfo;
        const row = items.find((it) => it.row === index2 + 1);
        this.rows[index2] = editor.Length.px(row.rect.height).floor();
      }
    }
    moveEndRow() {
      const targetPosition = this.$viewport.getWorldPosition();
      const realDistance = dist(targetPosition, this.initMousePosition);
      if (realDistance < 1) {
        this.changedRowSize();
      }
      this.updateRows(this.current, this.rows);
    }
  }
  class GridGrowToolView extends GridGrowDragEventView {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--grid-grow-tool-view"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "layout-rect",
        ref: "$grid"
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "layout-rect blank-tool",
        ref: "$gridGap"
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "layout-pointer",
        ref: "$pointer"
      }));
    }
    [sapa.BIND("$el")]() {
      var _a;
      const current = this.getGridTargetLayer();
      return {
        "data-drag-target-item": Boolean(this.$context.selection.dragTargetItem),
        "data-grid-layout-own": ((_a = this.$context.selection.current) == null ? void 0 : _a.id) === (current == null ? void 0 : current.id),
        style: {
          display: current ? "block" : "none"
        }
      };
    }
    [sapa.BIND("$grid")]() {
      const current = this.getGridTargetLayer();
      if (!current)
        return "";
      if (current.isLayout(Layout.GRID) === false)
        return "";
      const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
      const info = this.getGridLayoutInformation();
      const [paddingTop, paddingRight, paddingBottom, paddingLeft] = this.getScaledInformation([
        editor.Length.px(info.current.paddingTop),
        editor.Length.px(info.current.paddingRight),
        editor.Length.px(info.current.paddingBottom),
        editor.Length.px(info.current.paddingLeft)
      ]);
      const columns = this.getScaledInformation(info.columns);
      const rows = this.getScaledInformation(info.rows);
      const columnGap = this.getScaledLength(info.columnGap);
      const rowGap = this.getScaledLength(info.rowGap);
      const origin = subtract([], current.verties[1], current.verties[0]);
      const angle = calculateAngle360(origin[0], origin[1]) - 180;
      return {
        style: {
          display: "grid",
          "grid-template-columns": Grid.join(columns),
          "grid-template-rows": Grid.join(rows),
          "grid-column-gap": columnGap,
          "grid-row-gap": rowGap,
          left: editor.Length.px(rect2.left),
          top: editor.Length.px(rect2.top),
          width: editor.Length.px(rect2.width),
          height: editor.Length.px(rect2.height),
          "padding-top": paddingTop,
          "padding-right": paddingRight,
          "padding-bottom": paddingBottom,
          "padding-left": paddingLeft,
          "transform-origin": "left top",
          transform: `rotate(${angle}deg)`
        }
      };
    }
    [sapa.BIND("$gridGap")]() {
      const current = this.getGridTargetLayer();
      if (!current)
        return "";
      if (current.isLayout(Layout.GRID) === false)
        return "";
      const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
      const origin = subtract([], current.verties[1], current.verties[0]);
      const angle = calculateAngle360(origin[0], origin[1]) - 180;
      return {
        style: {
          left: editor.Length.px(rect2.left),
          top: editor.Length.px(rect2.top),
          width: editor.Length.px(rect2.width),
          height: editor.Length.px(rect2.height),
          "transform-origin": "left top",
          transform: `rotate(${angle}deg)`
        }
      };
    }
    getScaledInformation(arr) {
      return arr.map((it) => this.getScaledLength(it));
    }
    getScaledLength(it) {
      if (sapa.isString(it)) {
        return it;
      } else if (it instanceof editor.Length) {
        if (it.isPx() || it.isNumber()) {
          return it.clone().mul(this.$viewport.scale);
        }
      }
      return it;
    }
    getGridTargetLayer() {
      if (this.$context.selection.dragTargetItem) {
        return this.$context.selection.dragTargetItem;
      }
      const current = this.$context.selection.current;
      if (!current)
        return null;
      if (current.isLayout(Layout.GRID))
        return current;
      const parent = current.parent;
      if (parent && parent.is("project"))
        return null;
      if (parent && parent.isLayout(Layout.GRID))
        return parent;
      return null;
    }
    getParsedValue(it) {
      if (it === "auto") {
        return it;
      }
      return editor.Length.parse(it);
    }
    getGridLayoutInformation() {
      const current = this.getGridTargetLayer();
      const columns = Grid.parseStyle(current.gridTemplateColumns);
      const rows = Grid.parseStyle(current.gridTemplateRows);
      return {
        current,
        columns,
        columnGap: this.getParsedValue(current.gridColumnGap),
        rows,
        rowGap: this.getParsedValue(current.gridRowGap)
      };
    }
    afterLoadRendering(targetRef, refName) {
      this.trigger("refreshGridInformation", targetRef, refName);
    }
    [sapa.SUBSCRIBE_SELF("refreshGridInformation") + sapa.DEBOUNCE(10)](targetRef, refName) {
      const current = this.getGridTargetLayer();
      if (!current)
        return;
      if (current.isLayout(Layout.GRID) === false)
        return;
      if (refName !== "$grid")
        return;
      const info = this.getGridLayoutInformation();
      const scale2 = this.$viewport.scale;
      const items = targetRef.$$(".grid-item").map((it) => {
        const [row, column] = it.attrs("data-row", "data-column").map((it2) => +it2);
        const { x, y, width: width2, height } = it.offsetRect();
        const rect2 = {
          x: x / scale2,
          y: y / scale2,
          width: width2 / scale2,
          height: height / scale2
        };
        const verties = vertiesMap(rectToVerties(rect2.x, rect2.y, rect2.width, rect2.height), info.current.absoluteMatrix);
        const originVerties = verties.filter((_, index2) => index2 < 4);
        return {
          row,
          column,
          rect: rect2,
          info,
          verties,
          originVerties,
          originRect: vertiesToRectangle(originVerties)
        };
      });
      this.state.lastGridInfo = { info, items };
      this.load("$gridGap");
      this.$context.selection.updateGridInformation({
        info,
        items
      });
    }
    [sapa.LOAD("$gridGap") + sapa.DOMDIFF]() {
      const current = this.getGridTargetLayer();
      if (!current)
        return "";
      if (this.$config.true("set.move.control.point"))
        return "";
      if (!this.$context.selection.current)
        return "";
      const last = this.state.lastGridInfo;
      const scale2 = this.$viewport.scale;
      if (!last)
        return "";
      const { info, items } = last;
      const { columns, rows } = info;
      const result = [];
      const rowItems = items.filter((it) => it.column === 1);
      const columnItems = items.filter((it) => it.row === 1);
      const minY = Math.min(...rowItems.map((it) => it.verties[0][1]));
      const maxY = Math.max(...rowItems.map((it) => it.verties[2][1]));
      const h = maxY - minY;
      for (var columnIndex = 1, len2 = columns.length; columnIndex < len2 && columnItems.length; columnIndex++) {
        const prevCell = columnItems[columnIndex - 1];
        const cell = columnItems[columnIndex];
        const x = prevCell.rect.x + prevCell.rect.width;
        const w2 = cell.rect.x - x;
        const y = prevCell.rect.y;
        result.push({
          type: "column-gap",
          index: columnIndex,
          x,
          y,
          width: w2,
          height: h
        });
      }
      const minX = Math.min(...columnItems.map((it) => it.verties[0][0]));
      const maxX = Math.max(...columnItems.map((it) => it.verties[2][0]));
      const w = maxX - minX;
      for (var rowIndex = 1, len2 = rows.length; rowIndex < len2; rowIndex++) {
        const prevCell = rowItems[rowIndex - 1];
        const cell = rowItems[rowIndex];
        const y = prevCell.rect.y + prevCell.rect.height;
        const h2 = cell.rect.y - y;
        const x = prevCell.rect.x;
        result.push({
          type: "row-gap",
          index: rowIndex,
          x,
          y,
          width: w,
          height: h2
        });
      }
      return result.map((it) => {
        if (it.type === "column-gap") {
          return /* @__PURE__ */ sapa.createElementJsx("div", {
            class: "gap-tool column-gap",
            style: {
              left: editor.Length.px(it.x * scale2),
              top: editor.Length.px(it.y * scale2),
              width: editor.Length.px(Math.max(it.width * scale2, 5)),
              height: editor.Length.px(it.height * scale2)
            }
          });
        } else if (it.type === "row-gap") {
          return /* @__PURE__ */ sapa.createElementJsx("div", {
            class: "gap-tool row-gap",
            style: {
              left: editor.Length.px(it.x * scale2),
              top: editor.Length.px(it.y * scale2),
              height: editor.Length.px(Math.max(it.height * scale2, 5)),
              width: editor.Length.px(it.width * scale2)
            }
          });
        }
        return "";
      });
    }
    isSelectedColumn(index2) {
      const current = this.$context.selection.current;
      return current.gridColumnStart <= index2 && index2 < current.gridColumnEnd;
    }
    isSelectedRow(index2) {
      const current = this.$context.selection.current;
      return current.gridRowStart <= index2 && index2 < current.gridRowEnd;
    }
    [sapa.LOAD("$grid") + sapa.DOMDIFF]() {
      var _a;
      const current = this.getGridTargetLayer();
      if (!current)
        return "";
      if (current.isLayout(Layout.GRID) === false)
        return "";
      const info = this.getGridLayoutInformation();
      const totalCount = info.columns.length * info.rows.length;
      const isChild = ((_a = this.$context.selection.current) == null ? void 0 : _a.id) !== info.current.id;
      return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, Array.from(Array(info.columns.length).keys()).map((index2) => {
        const selected = isChild && this.isSelectedColumn(index2 + 1) ? "selected" : "";
        return /* @__PURE__ */ sapa.createElementJsx("div", {
          class: `grid-item-tool column ${selected}`,
          "data-index": index2,
          style: {
            "grid-column": `${index2 + 1} / span 1`,
            "grid-row": `1 / span 1`
          }
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "grid-item-tool-inner"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "item",
          "data-index": index2
        }, /* @__PURE__ */ sapa.createElementJsx("span", null, info.columns[index2])), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "drag-handle right"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "column-delete",
          "data-index": index2,
          title: `Delete ${info.columns[index2]}`
        }, editor.iconUse("close")), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "column-add",
          "data-index": index2,
          title: `Add ${info.columns[index2]}`
        }, editor.iconUse("add")))));
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "grid-item-tool append column-plus",
        style: {
          "grid-column": `${info.columns.length} / span 1`,
          "grid-row": `1 / span 1`
        }
      }, editor.iconUse("add")), Array.from(Array(info.rows.length).keys()).map((index2) => {
        const selected = isChild && this.isSelectedRow(index2 + 1) ? "selected" : "";
        return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: `grid-item-tool row ${selected}`,
          style: {
            "grid-row": `${index2 + 1} / span 1`,
            "grid-column": `1 / span 1`
          }
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "grid-item-tool-inner"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "item",
          "data-index": index2
        }, /* @__PURE__ */ sapa.createElementJsx("span", null, info.rows[index2])), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "drag-handle bottom"
        }, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "row-delete",
          "data-index": index2,
          title: `Delete ${info.rows[index2]}`
        }, editor.iconUse("close")), /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "row-add",
          "data-index": index2,
          title: `Add ${info.rows[index2]}`
        }, editor.iconUse("add"))))));
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "grid-item-tool append row-plus",
        style: {
          "grid-row": `${info.rows.length} / span 1`,
          "grid-column": `1 / span 1`
        }
      }, editor.iconUse("add")), Array.from(Array(totalCount).keys()).map((i) => {
        const column = i % info.columns.length;
        const row = Math.floor(i / info.columns.length);
        return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, /* @__PURE__ */ sapa.createElementJsx("div", {
          class: "grid-item",
          "data-row": row + 1,
          "data-column": column + 1,
          style: {
            "grid-column": `${column + 1} / span 1`,
            "grid-row": `${row + 1} / span 1`
          }
        }));
      }));
    }
    [sapa.SUBSCRIBE("refreshGridToolInfo")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS)]() {
      this.refresh();
    }
  }
  var GridLayoutEditor$1 = "";
  class GridLayoutEditor extends editor.EditorElement {
    modifyData(key, value) {
      this.parent.trigger(this.props.onchange, key, value);
    }
    template() {
      return `
            <div class='elf--grid-layout-editor' ref='$body' ></div>
        `;
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      if (current.isLayout(Layout.GRID) === false)
        return "";
      return `
            <div class="grid-layout-item">
            ${sapa.createComponent("NumberInputEditor", {
        wide: true,
        label: "grid padding",
        key: "padding",
        ref: "$padding",
        value: current.paddingTop,
        min: 0,
        max: 300,
        step: 1,
        onchange: "changePadding"
      })}
            </div>
            <div class='grid-layout-item'>
                ${sapa.createComponent("GridGapEditor", {
        label: this.$i18n("grid.layout.editor.column.gap"),
        ref: "$columnGap",
        key: "gridColumnGap",
        value: current.gridColumnGap || "",
        onchange: "changeKeyValue"
      })}
            </div>              
            <div class='grid-layout-item'>
                ${sapa.createComponent("GridGapEditor", {
        label: this.$i18n("grid.layout.editor.row.gap"),
        ref: "$rowGap",
        key: "gridRowGap",
        value: current.gridRowGap || "",
        onchange: "changeKeyValue"
      })}
            </div>
        `;
    }
    [sapa.SUBSCRIBE_SELF("changePadding")](key, value) {
      this.modifyData(key, {
        paddingTop: value,
        paddingLeft: value,
        paddingRight: value,
        paddingBottom: value
      });
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
      this.modifyData(key, value, params);
    }
  }
  var LayoutProperty$1 = "";
  class LayoutProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("layout.property.title");
    }
    getClassName() {
      return "elf--layout-property";
    }
    getBody() {
      return `
        <div ref='$layoutProperty'></div>
      `;
    }
    getTools() {
      return `
      <div ref='$layoutType'></div>
    `;
    }
    [sapa.LOAD("$layoutType")]() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      return sapa.createComponent("SelectIconEditor", {
        ref: "$layout",
        key: "layout",
        height: 24,
        value: current.layout,
        options: [Layout.DEFAULT, Layout.FLEX, Layout.GRID],
        icons: ["layout_default", "layout_flex", "layout_grid"],
        onchange: "changeLayoutType"
      });
    }
    [sapa.LOAD("$layoutProperty") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current || { layout: "default" };
      return `<div class='layout-list' ref='$layoutList'><div data-value='default' class='${current.layout === "default" ? "selected" : ""}'></div><div data-value='flex' class='${current.layout === "flex" ? "selected" : ""}'>${sapa.createComponent("FlexLayoutEditor", {
        ref: "$flex",
        key: "flex-layout",
        value: {
          flexDirection: current.flexDirection,
          flexWrap: current.flexWrap,
          justifyContent: current.justifyContent,
          alignItems: current.alignItems,
          alignContent: current.alignContent,
          gap: current.gap
        },
        onchange: "changeLayoutInfo"
      })}</div><div data-value='grid' class='${current.layout === "grid" ? "selected" : ""}'>${sapa.createComponent("GridLayoutEditor", {
        ref: "$grid",
        key: "grid-layout",
        value: current["grid-layout"] || "",
        onchange: "changeLayoutInfo"
      })}</div></div>`;
    }
    [sapa.SUBSCRIBE_SELF("changeLayoutInfo")](key, value) {
      if (key === "padding") {
        this.$commands.executeCommand("setAttribute", "change padding", this.$context.selection.packByValue(value));
      } else {
        this.$commands.executeCommand("setAttribute", "change layout info", this.$context.selection.packByValue({
          [key]: value
        }));
      }
      this.nextTick(() => {
        this.emit("refreshAllElementBoundSize");
      });
    }
    [sapa.SUBSCRIBE_SELF("changeLayoutType")](key, value) {
      this.$context.selection.reset(this.$context.selection.packByValue({
        [key]: value
      }));
      this.updateTitle();
      this.$commands.executeCommand("setAttribute", "change layout type", this.$context.selection.packByValue({
        [key]: value
      }));
      this.nextTick(() => {
        this.refresh();
      });
    }
    get editableProperty() {
      return "layout";
    }
    enableHasChildren() {
      return this.$context.selection.current.enableHasChildren();
    }
    updateTitle() {
      this.setTitle(this.$context.selection.current.layout + " Layout");
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow") + sapa.IF("enableHasChildren")]() {
      this.updateTitle();
      this.refresh();
    }
  }
  var ResizingItemProperty$1 = "";
  class ResizingItemProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("layout.property.resizing.self.title");
    }
    getClassName() {
      return "elf--resizing-item-property";
    }
    getBody() {
      return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
    }
    [sapa.LOAD("$resizingModeInfo") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current || {};
      const h = current.resizingHorizontal || ResizingMode.FIXED;
      const v = current.resizingVertical || ResizingMode.FIXED;
      return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="tool">
            <div class="vertical">
              <div class="vertical-top" data-key="resizingVertical">${editor.iconUse("keyboard_arrow_up")}</div>
              <div class="vertical-bottom" data-key="resizingVertical">${editor.iconUse("keyboard_arrow_down")}</div>
            </div>
            <div class="horizontal">
              <div class="horizontal-left" data-key="resizingHorizontal">${editor.iconUse("keyboard_arrow_left")}</div>
              <div class="horizontal-right" data-key="resizingHorizontal">${editor.iconUse("keyboard_arrow_right")}</div>
            </div>
          </div>         
          <div class="inner-rect"></div>
        </div>

      </div>
    `;
    }
    makeOptionsForHorizontal() {
      const options2 = [
        { value: ResizingMode.FIXED, text: "Fixed Width" },
        { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
      ];
      return options2;
    }
    makeOptionsForVertical() {
      const options2 = [
        { value: ResizingMode.FIXED, text: "Fixed Height" },
        { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
      ];
      return options2;
    }
    [sapa.LOAD("$resizingModeInfoInput") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current || {};
      this.setState({
        resizingHorizontal: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
        resizingVertical: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED
      }, false);
      return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${sapa.createComponent("SelectEditor", {
        ref: "$resizingHorizontal",
        key: "resizingHorizontal",
        value: this.state.resizingHorizontal,
        options: this.makeOptionsForHorizontal(),
        onchange: "changeResizingMode"
      })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${sapa.createComponent("SelectEditor", {
        ref: "$resizingVertical",
        key: "resizingVertical",
        value: this.state.resizingVertical,
        options: this.makeOptionsForVertical(),
        onchange: "changeResizingMode"
      })}
      </div>
    `;
    }
    [sapa.CLICK("$resizingModeInfo [data-key]")](e) {
      const key = e.$dt.data("key");
      const current = this.$context.selection.current;
      if (current[key] === ResizingMode.FIXED) {
        this.trigger("changeResizingMode", key, ResizingMode.FILL_CONTAINER);
      } else {
        this.trigger("changeResizingMode", key, ResizingMode.FIXED);
      }
    }
    [sapa.SUBSCRIBE_SELF("changeResizingMode")](key, value) {
      this.$commands.executeCommand("setAttribute", "apply self resizing", this.$context.selection.packByValue({
        [key]: value,
        flexGrow: 1
      }));
      this.nextTick(() => {
        this.refresh();
      }, 100);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(() => {
        var _a, _b;
        var current = this.$context.selection.current;
        return ((_a = current == null ? void 0 : current.parent) == null ? void 0 : _a.hasLayout()) && ((_b = current == null ? void 0 : current.parent) == null ? void 0 : _b.isLayout(Layout.GRID)) === false;
      });
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS)]() {
      const current = this.$context.selection.current;
      if (current && current.changedLayoutItem) {
        if (current.resizingHorizontal !== this.state.resizingHorizontal || current.resizingVertical !== this.state.resizingVertical) {
          this.refresh();
        }
      }
    }
  }
  var ResizingProperty$1 = "";
  class ResizingProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("layout.property.resizing.title");
    }
    getClassName() {
      return "elf--resizing-property";
    }
    getBody() {
      return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
    }
    [sapa.LOAD("$resizingModeInfo") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current || {};
      const h = current.resizingHorizontal || ResizingMode.FIXED;
      const v = current.resizingVertical || ResizingMode.FIXED;
      return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="vertical" data-key="resizingVertical">
            <div class="vertical-top">${editor.iconUse("keyboard_arrow_down")}</div>
            <div class="vertical-bottom">${editor.iconUse("keyboard_arrow_up")}</div>
          </div>
          <div class="horizontal" data-key="resizingHorizontal">
            <div class="horizontal-left">${editor.iconUse("keyboard_arrow_right")}</div>
            <div class="horizontal-right">${editor.iconUse("keyboard_arrow_left")}</div>
          </div>
          <div class="inner-rect"></div>
          <div class="inner-horizontal-rect"></div>
          <div class="inner-vertical-rect"></div>
        </div>
      </div>
    `;
    }
    makeOptionsForHorizontal() {
      const options2 = [
        { value: ResizingMode.FIXED, text: "Fixed Width" },
        { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
      ];
      return options2;
    }
    makeOptionsForVertical() {
      const options2 = [
        { value: ResizingMode.FIXED, text: "Fixed Height" },
        { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
      ];
      return options2;
    }
    [sapa.LOAD("$resizingModeInfoInput")]() {
      var current = this.$context.selection.current || {};
      return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${sapa.createComponent("SelectEditor", {
        ref: "$resizingHorizontal",
        key: "resizingHorizontal",
        value: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
        options: this.makeOptionsForHorizontal(),
        onchange: "changeResizingMode"
      })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${sapa.createComponent("SelectEditor", {
        ref: "$resizingVertical",
        key: "resizingVertical",
        value: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED,
        options: this.makeOptionsForVertical(),
        onchange: "changeResizingMode"
      })}
      </div>
    `;
    }
    [sapa.CLICK("$resizingModeInfo [data-key]")](e) {
      const key = e.$dt.data("key");
      const current = this.$context.selection.current;
      if (current[key] === ResizingMode.FIXED) {
        this.trigger("changeResizingMode", key, ResizingMode.HUG_CONTENT);
      } else {
        this.trigger("changeResizingMode", key, ResizingMode.FIXED);
      }
    }
    [sapa.SUBSCRIBE_SELF("changeResizingMode")](key, value) {
      this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
        [key]: value
      }));
      this.nextTick(() => {
        this.refresh();
      }, 100);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(() => {
        var current = this.$context.selection.current;
        return current && current.hasLayout();
      });
    }
  }
  function layout(editor2) {
    editor2.registerElement({
      FlexLayoutEditor,
      GridLayoutEditor,
      GridBoxEditor,
      GridGapEditor
    });
    editor2.registerUI("inspector.tab.style", {
      LayoutProperty,
      ResizingProperty,
      ResizingItemProperty,
      DefaultLayoutItemProperty
    });
    editor2.registerUI("canvas.view", {
      FlexGrowToolView,
      GridGrowToolView
    }, CanvasViewToolLevel.LAYOUT_TOOL);
  }
  var LineView$1 = "";
  class LineView extends editor.EditorElement {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--line-view sepia(0.2)"
      });
    }
    [sapa.CONFIG("vertical.line")]() {
      this.refresh();
    }
    [sapa.CONFIG("horizontal.line")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
      this.refresh();
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      return [
        ...this.$config.get("vertical.line").map((it, index2) => {
          const screen = this.$viewport.applyVertex([0, it, 0]);
          return /* @__PURE__ */ sapa.createElementJsx("div", {
            class: "vertical-line",
            "data-index": index2,
            style: `transform: translate3d(0px, ${screen[1]}px, 0px);`
          });
        }),
        ...this.$config.get("horizontal.line").map((it, index2) => {
          const screen = this.$viewport.applyVertex([it, 0, 0]);
          return /* @__PURE__ */ sapa.createElementJsx("div", {
            class: "horizontal-line",
            "data-index": index2,
            style: `transform: translate3d(${screen[0]}px, 0px, 0px);`
          });
        })
      ];
    }
    [sapa.POINTERSTART("$el .horizontal-line") + MOVE("moveHorizontalLine") + END("moveEndHorizontalLine")](e) {
      this.startIndex = +e.$dt.data("index");
      this.$context.snapManager.clear();
    }
    moveHorizontalLine() {
      const newPos = this.$context.snapManager.getWorldPosition();
      this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
    }
    moveEndHorizontalLine() {
      this.$commands.emit("recoverCursor");
    }
    [sapa.POINTERSTART("$el .vertical-line") + MOVE("moveVerticalLine") + END("moveEndVerticalLine")](e) {
      this.startIndex = +e.$dt.data("index");
      this.$context.snapManager.clear();
    }
    moveVerticalLine() {
      const newPos = this.$context.snapManager.getWorldPosition();
      this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
    }
    moveEndVerticalLine() {
      this.$commands.emit("recoverCursor");
    }
  }
  function lineView(editor2) {
    editor2.registerUI("canvas.view", {
      LineView
    });
  }
  function menus(editor$1) {
    editor$1.registerMenu("toolbar.logo", [
      {
        type: "dropdown",
        style: {
          padding: "12px 0px 12px 12px"
        },
        icon: `<div class="logo-item"><label class='logo'></label></div>`,
        items: [
          {
            title: "menu.item.fullscreen.title",
            command: "toggle.fullscreen",
            shortcut: "ALT+/"
          },
          {
            title: "menu.item.shortcuts.title",
            command: "showShortcutWindow"
          },
          "-",
          { title: "menu.item.export.title", command: "showExportView" },
          { title: "menu.item.download.title", command: "downloadJSON" },
          {
            title: "menu.item.save.title",
            command: "saveJSON",
            nextTick: () => {
              this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
            }
          },
          {
            title: "menu.item.language.title",
            items: [
              {
                title: "English",
                command: "setLocale",
                args: [Language.EN],
                checked: (editor2) => editor2.locale === Language.EN
              },
              {
                title: "Fran\xE7ais",
                command: "setLocale",
                args: [Language.FR],
                checked: (editor2) => editor2.locale === Language.FR
              },
              {
                title: "Korean",
                command: "setLocale",
                args: [Language.KO],
                checked: (editor2) => editor2.locale === Language.KO
              }
            ]
          },
          "-",
          {
            title: "elf document",
            items: [
              {
                type: "link",
                title: "Github",
                href: "https://github.com/easylogic/editor"
              },
              {
                type: "link",
                title: "Learn",
                href: "https://www.easylogic.studio"
              }
            ]
          }
        ]
      }
    ]);
    editor$1.registerMenu("toolbar.left", [
      {
        type: "button",
        icon: "navigation",
        events: ["config:editing.mode"],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.SELECT);
        },
        action: (editor2) => {
          editor2.context.commands.emit("addLayerView", "select");
          editor2.context.config.is("editing.mode.itemType", EditingMode.SELECT);
        }
      },
      {
        type: "button",
        icon: "artboard",
        events: ["config:editing.mode", "config:editing.mode.itemType"],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.APPEND) && editor2.context.config.is("editing.mode.itemType", "artboard");
        },
        action: (editor2) => {
          editor2.context.commands.emit("addLayerView", "artboard");
        }
      },
      {
        type: "dropdown",
        trigger: "over",
        icon: (editor$12, dropdown) => {
          var _a;
          return ((_a = dropdown.findItem(editor$12.context.config.get("editing.css.itemType"))) == null ? void 0 : _a.icon) || editor.iconUse("rect");
        },
        items: [
          {
            icon: editor.iconUse("rect"),
            title: "Rect Layer",
            key: "rect",
            command: "addLayerView",
            args: [
              "rect",
              {
                backgroundColor: "#ececec"
              }
            ],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "rect");
            },
            shortcut: KeyStringMaker({ key: "R" })
          },
          {
            icon: editor.iconUse("lens"),
            title: "Circle Layer",
            key: "circle",
            command: "addLayerView",
            args: ["circle"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "circle");
            },
            shortcut: KeyStringMaker({ key: "O" })
          },
          {
            icon: editor.iconUse("image"),
            title: "Image",
            key: "image",
            command: "addLayerView",
            args: ["image"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "image");
            },
            shortcut: KeyStringMaker({ key: "I" })
          },
          "-",
          {
            icon: editor.iconUse("video"),
            title: "Video",
            key: "video",
            command: "addLayerView",
            args: ["video"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "video");
            },
            shortcut: KeyStringMaker({ key: "V" })
          },
          {
            icon: editor.iconUse("iframe"),
            title: "IFrame",
            key: "iframe",
            command: "addLayerView",
            args: ["iframe"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "iframe");
            },
            shortcut: KeyStringMaker({ key: "F" })
          },
          {
            icon: editor.iconUse("rect"),
            title: "SampleLayer",
            key: "sample",
            command: "addLayerView",
            args: ["sample"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.css.itemType", "sample");
            }
          }
        ],
        events: [
          "config:editing.mode",
          "config:editing.mode.itemType",
          "config:editing.css.itemType"
        ],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.APPEND) && (editor2.context.config.is("editing.mode.itemType", "rect") || editor2.context.config.is("editing.mode.itemType", "circle") || editor2.context.config.is("editing.mode.itemType", "image") || editor2.context.config.is("editing.mode.itemType", "video") || editor2.context.config.is("editing.mode.itemType", "iframe"));
        },
        selectedKey: (editor2) => {
          return editor2.context.config.get("editing.css.itemType");
        }
      },
      {
        type: "dropdown",
        icon: (editor$12, dropdown) => {
          var _a;
          return ((_a = dropdown.findItem(editor$12.context.config.get("editing.draw.itemType"))) == null ? void 0 : _a.icon) || editor.iconUse("pentool");
        },
        items: [
          {
            icon: editor.iconUse("pentool"),
            title: "Pen",
            key: "path",
            command: "addLayerView",
            args: ["path"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.draw.itemType", "path");
            },
            shortcut: KeyStringMaker({ key: "P" })
          },
          {
            icon: editor.iconUse("brush"),
            title: "Pencil",
            key: "brush",
            command: "addLayerView",
            args: ["brush"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.draw.itemType", "brush");
            },
            shortcut: KeyStringMaker({ key: "B" })
          }
        ],
        events: [
          "config:editing.mode",
          "config:editing.mode.itemType",
          "config:editing.draw.itemType"
        ],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode.itemType", "path") || editor2.context.config.is("editing.mode.itemType", "draw");
        },
        selectedKey: (editor2) => {
          return editor2.context.config.get("editing.draw.itemType");
        }
      },
      {
        type: "dropdown",
        icon: (editor$12, dropdown) => {
          var _a;
          return ((_a = dropdown.findItem(editor$12.context.config.get("editing.svg.itemType"))) == null ? void 0 : _a.icon) || editor.iconUse("outline_rect");
        },
        items: [
          {
            icon: editor.iconUse("outline_rect"),
            title: "Rectangle",
            key: "svg-rect",
            command: "addLayerView",
            args: ["svg-rect"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "svg-rect");
            },
            shortcut: KeyStringMaker({ key: "Shift+R" })
          },
          {
            icon: editor.iconUse("outline_circle"),
            title: "Circle",
            key: "svg-circle",
            command: "addLayerView",
            args: ["svg-circle"],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "svg-circle");
            },
            shortcut: KeyStringMaker({ key: "Shift+O" })
          },
          {
            icon: editor.iconUse("polygon"),
            title: "Polygon",
            key: "svg-polygon",
            command: "addLayerView",
            args: [
              "polygon",
              {
                backgroundColor: "transparent"
              }
            ],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "polygon");
            },
            shortcut: KeyStringMaker({ key: "Shift+P" })
          },
          {
            icon: editor.iconUse("star"),
            title: "Star",
            key: "star",
            command: "addLayerView",
            args: [
              "star",
              {
                backgroundColor: "transparent"
              }
            ],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "star");
            },
            shortcut: KeyStringMaker({ key: "Shift+S" })
          },
          "-",
          {
            icon: editor.iconUse("smooth"),
            title: "Spline",
            key: "spline",
            command: "addLayerView",
            args: [
              "spline",
              {
                backgroundColor: "transparent"
              }
            ],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "spline");
            },
            shortcut: KeyStringMaker({ key: "Shift+L" })
          },
          {
            icon: editor.iconUse("text_rotate"),
            title: "TextPath",
            key: "svg-texpath",
            command: "addLayerView",
            args: [
              "svg-textpath",
              {
                backgroundColor: "transparent"
              }
            ],
            closable: true,
            nextTick: (editor2) => {
              editor2.context.config.set("editing.svg.itemType", "svg-textpath");
            },
            shortcut: KeyStringMaker({ key: "Shift+T" })
          }
        ],
        events: [
          "config:editing.mode",
          "config:editing.mode.itemType",
          "config:editing.svg.itemType"
        ],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.APPEND) && (editor2.context.config.is("editing.mode.itemType", "svg-rect") || editor2.context.config.is("editing.mode.itemType", "svg-circle") || editor2.context.config.is("editing.mode.itemType", "polygon") || editor2.context.config.is("editing.mode.itemType", "star") || editor2.context.config.is("editing.mode.itemType", "spline") || editor2.context.config.is("editing.mode.itemType", "svg-textpath"));
        },
        selectedKey: (editor2) => {
          return editor2.context.config.get("editing.svg.itemType");
        }
      },
      {
        type: "button",
        icon: "title",
        events: ["config:editing.mode", "config:editing.mode.itemType"],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.APPEND) && editor2.context.config.is("editing.mode.itemType", "text");
        },
        action: (editor2) => {
          editor2.context.commands.emit("addLayerView", "text");
        }
      },
      {
        type: "button",
        tooltip: "Handle",
        icon: "pantool",
        events: ["config:editing.mode"],
        selected: (editor2) => {
          return editor2.context.config.is("editing.mode", EditingMode.HAND);
        },
        action: (editor2) => {
          editor2.context.commands.emit("toggleHandTool");
        }
      }
    ]);
    editor$1.registerMenu("toolbar.right", [
      {
        type: "button",
        icon: (editor2) => {
          if (editor2.context.config.is("editor.theme", "dark")) {
            return "dark";
          } else {
            return "light";
          }
        },
        events: ["config:editor.theme"],
        action: (editor2) => {
          editor2.context.config.toggleWith("editor.theme", "light", "dark");
        }
      }
    ]);
  }
  var DrawManager$1 = "";
  class DrawManager extends editor.EditorElement {
    initState() {
      return {
        tolerance: 1,
        stroke: "black",
        "stroke-width": 2,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        msg: this.$i18n("path.manager.msg")
      };
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      var _a, _b;
      var current = this.$context.selection.current;
      if (current) {
        (_a = this.children.$stroke) == null ? void 0 : _a.setValue(current.stroke || "rgba(0, 0, 0, 1)");
        (_b = this.children.$strokeWidth) == null ? void 0 : _b.setValue(current.strokeWidth || editor.Length.number(1));
      }
    }
    [sapa.SUBSCRIBE("setColorAsset")]({ color }) {
      if (this.$el.isShow()) {
        this.setState({
          stroke: color
        }, false);
        this.children.$stroke.setValue(color);
        this.updateData({
          stroke: color
        });
      }
    }
    template() {
      return `
      <div class='elf--draw-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='DrawEditorDone' title='${this.$i18n("draw.manager.mode.modify")}' >Done</button>
        </div>      
        <div class='tools'>   
          <div >        
            <label data-tooltip="${this.$i18n("draw.manager.tolerance")}">Tolerance</label>       
            ${sapa.createComponent("NumberInputEditor", {
        ref: "$tolerance",
        key: "tolerance",
        value: 1,
        min: 0,
        max: 100,
        step: 0.01,
        unit: "number",
        onchange: "changeValue"
      })}
          </div>              
          <div >
            <label>${this.$i18n("svg.item.property.stroke")}</label>          
            ${sapa.createComponent("FillSingleEditor", {
        ref: "$stroke",
        simple: true,
        value: this.state.stroke,
        key: "stroke",
        onchange: "changeValue"
      })}
          </div>

          <div >
            <label>${this.$i18n("svg.item.property.strokeWidth")}</label>          
            ${sapa.createComponent("NumberInputEditor", {
        ref: "$strokeWidth",
        key: "strokeWidth",
        value: this.state["strokeWidth"],
        onchange: "changeValue"
      })}
          </div>      
          

          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineCap")}">Cap</label>          
            ${sapa.createComponent("SelectEditor", {
        ref: "$strokeLineCap",
        key: "strokeLinecap",
        value: this.state["strokeLinecap"],
        options: ["butt", "round", "square"],
        onchange: "changeValue"
      })}
          </div> 
          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineJoin")}">Join</label>          
            ${sapa.createComponent("SelectEditor", {
        ref: "$strokeLineJoin",
        key: "strokeLinejoin",
        value: this.state["strokeLinejoin"],
        options: ["miter", "bevel", "round"],
        onchange: "changeValue"
      })}
          </div>
        </div>
      </div>    
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeValue")](key, value) {
      this.updateData({
        [key]: value
      });
    }
    updateData(obj2 = {}) {
      this.setState(obj2, false);
      this.state.instance.trigger(this.state.changeEvent, obj2);
    }
    [sapa.SUBSCRIBE("changePathManager")](mode) {
      this.setState({ mode });
    }
    [sapa.SUBSCRIBE("showDrawManager")](obj2 = {}) {
      obj2.changeEvent = obj2.changeEvent || "changeDrawManager";
      this.setState(obj2);
      this.$el.show();
      this.emit("hidePathManager");
    }
    [sapa.SUBSCRIBE("hideDrawManager")]() {
      this.$el.hide();
    }
    [sapa.CLICK("$left button")](e) {
      var message = e.$dt.attr("data-value");
      this.emit(message);
    }
  }
  var PathDrawView$1 = "";
  const FIELDS$1 = [
    "fill",
    "fill-opacity",
    "stroke",
    "stroke-width",
    "stroke-linecap",
    "stroke-linejoin"
  ];
  class PathDrawView extends editor.EditorElement {
    initialize() {
      super.initialize();
      this.pathParser = new PathParser();
    }
    initState() {
      return {
        points: [],
        $target: null,
        fill: "transparent",
        stroke: "black",
        "fill-opacity": null,
        "stroke-width": 2,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        tolerance: 1
      };
    }
    [sapa.SUBSCRIBE("changeDrawManager")](obj2) {
      this.setState(__spreadValues({}, obj2), false);
    }
    get scale() {
      return this.$viewport.scale;
    }
    template() {
      return `
        <div class='elf--path-draw-view' tabIndex="-1">
            <div class='path-draw-container' ref='$view'></div>
        </div>`;
    }
    initRect(isForce = false) {
      if (!this.state.rect || isForce) {
        this.state.rect = this.$el.rect();
      }
    }
    [sapa.KEYUP("document") + sapa.IF("isShow") + sapa.ESCAPE + sapa.ENTER]() {
      this.trigger("hidePathDrawEditor");
    }
    [sapa.SUBSCRIBE("DrawEditorDone")]() {
      this.trigger("hidePathDrawEditor");
    }
    get totalPathLength() {
      if (!this.refs.$view)
        return 0;
      var $obj = this.refs.$view.$("path.object");
      if (!$obj)
        return 0;
      return $obj.totalLength;
    }
    makePathLayer() {
      var layer;
      const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance).smooth(30);
      newPath.transformMat4(this.$viewport.matrixInverse);
      const bbox = newPath.getBBox();
      const newWidth = distance$1(bbox[1], bbox[0]);
      const newHeight = distance$1(bbox[3], bbox[0]);
      newPath.translate(-bbox[0][0], -bbox[0][1]);
      const pathItem = {
        itemType: "svg-path",
        x: bbox[0][0],
        y: bbox[0][1],
        width: newWidth,
        height: newHeight,
        d: newPath.d,
        totalLength: this.totalPathLength
      };
      FIELDS$1.forEach((key) => {
        if (this.state[key])
          Object.assign(pathItem, { [key]: this.state[key] });
      });
      const containerItem = this.$context.selection.currentProject;
      layer = containerItem.appendChild(this.$editor.context.modelManager.createModel(pathItem));
      return layer;
    }
    addPathLayer() {
      var pathRect = this.getPathRect();
      if (pathRect.width !== 0 && pathRect.height !== 0) {
        var layer = this.makePathLayer(pathRect);
        if (layer) {
          this.emit("refreshAll");
        }
      }
    }
    changeMode(obj2) {
      this.setState(__spreadValues(__spreadValues({}, this.initState()), obj2), false);
    }
    getCurrentObject() {
      var current = this.state.current;
      if (!current) {
        return null;
      }
      return {
        current,
        d: current.d
      };
    }
    [sapa.SUBSCRIBE("showPathDrawEditor")](obj2 = {}) {
      this.changeMode(obj2);
      this.$el.show();
      this.$el.focus();
      this.emit("showDrawManager", {
        instance: this,
        fill: this.state.fill,
        stroke: this.state.stroke,
        "fill-opacity": this.state["fill-opacity"],
        "stroke-width": this.state["stroke-width"],
        "stroke-linecap": this.state["stroke-linecap"],
        "stroke-linejoin": this.state["stroke-linejoin"]
      });
      this.emit("hidePathEditor");
      this.$context.commands.emit("push.mode.view", "PathDrawView");
    }
    [sapa.SUBSCRIBE("initPathDrawEditor")]() {
      this.pathParser.reset("");
      this.refs.$view.empty();
    }
    [sapa.SUBSCRIBE("hidePathDrawEditor")]() {
      if (this.$el.isShow()) {
        this.trigger("initPathDrawEditor");
        this.$el.hide();
        this.emit("hideDrawManager");
        this.$commands.emit("pop.mode.view", "PathDrawView");
      }
    }
    [sapa.SUBSCRIBE("hideAddViewLayer")]() {
      this.$el.hide();
      this.emit("hideDrawManager");
    }
    getInnerId(postfix = "") {
      return "draw-manager-" + postfix;
    }
    get toFillSVG() {
      return SVGFill.parseImage(this.state.fill || "transparent").toSVGString(this.fillId);
    }
    get toStrokeSVG() {
      return SVGFill.parseImage(this.state.stroke || "black").toSVGString(this.strokeId);
    }
    get toDefInnerString() {
      return `
            ${this.toFillSVG}
            ${this.toStrokeSVG}
        `;
    }
    get toDefString() {
      var str = this.toDefInnerString.trim();
      return `
            <defs>
            ${str}
            </defs>
        `;
    }
    get fillId() {
      return this.getInnerId("fill");
    }
    get strokeId() {
      return this.getInnerId("stroke");
    }
    get toFillValue() {
      return SVGFill.parseImage(this.state.fill || "transparent").toFillValue(this.fillId);
    }
    get toStrokeValue() {
      return SVGFill.parseImage(this.state.stroke || "black").toFillValue(this.strokeId);
    }
    [sapa.BIND("$view")]() {
      const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance);
      return {
        innerHTML: `
            <svg width="100%" height="100%" class='svg-editor-canvas'>
                ${this.toDefString}
                <path 
                    class='object' 
                    fill="${this.toFillValue}"
                    stroke="${this.toStrokeValue}"
                    fill-opacity="${this.state["fill-opacity"]}"
                    stroke-width="${this.state["stroke-width"]}"
                    stroke-linecap="${this.state["stroke-linecap"]}"
                    stroke-linejoin="${this.state["stroke-linejoin"]}"
                    d="${newPath.d}" 
                />
            </svg>
            `
      };
    }
    renderPath() {
      this.bindData("$view");
    }
    [sapa.SUBSCRIBE("resizeEditor")]() {
      this.initRect(true);
    }
    getPathRect() {
      this.initRect(true);
      var $obj = this.refs.$view.$("path.object");
      var pathRect = { x: 0, y: 0, width: 0, height: 0 };
      if ($obj) {
        pathRect = $obj.rect();
        pathRect.x -= this.state.rect.x;
        pathRect.y -= this.state.rect.y;
      }
      return pathRect;
    }
    [sapa.POINTERSTART("$view") + MOVE() + END()](e) {
      this.initRect();
      this.state.altKey = false;
      this.state.startXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.state.points = [this.state.startXY];
    }
    move(dx, dy, eventType, pressure) {
      this.state.points.push({
        x: this.state.startXY.x + dx,
        y: this.state.startXY.y + dy,
        pressure
      });
      this.renderPath();
    }
    end() {
      this.addPathLayer();
      this.trigger("initPathDrawEditor");
    }
  }
  function pathDrawView(editor2) {
    editor2.registerUI("canvas.view", {
      PathDrawView
    });
    editor2.registerUI("page.subeditor.view", {
      DrawManager
    });
  }
  var PathEditorView$1 = "";
  class SegmentManager {
    constructor(viewport) {
      this.viewport = viewport;
      this.segmentList = [];
    }
    get hasViewport() {
      return Boolean(this.viewport);
    }
    reset() {
      this.segmentList = [];
      return this;
    }
    checkInViewport(point2) {
      if (!this.hasViewport)
        return true;
      const vertext = this.viewport.applyVertexInverse([point2.x, point2.y, 0]);
      return this.viewport.checkInViewport(vertext);
    }
    addLine(a, b) {
      if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
        return this;
      if (this.checkInViewport(a) || this.checkInViewport(b)) {
        this.segmentList.push({
          line: true,
          x1: a.x,
          y1: a.y,
          x2: b.x,
          y2: b.y
        });
      }
      return this;
    }
    addGuideLine(a, b) {
      if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
        return this;
      if (this.checkInViewport(a) || this.checkInViewport(b)) {
        this.segmentList.push({
          line: true,
          guide: true,
          x1: a.x,
          y1: a.y,
          x2: b.x,
          y2: b.y
        });
      }
      return this;
    }
    addDistanceLine(a, b) {
      if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
        return this;
      this.segmentList.push({
        line: true,
        distance: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
      return this;
    }
    addDistanceAngle(center, rx, ry, degree, last, line2) {
      this.segmentList.push({
        angle: true,
        rx,
        ry,
        line: line2,
        degree,
        center,
        last
      });
      return this;
    }
    addPoint(obj2, point2, index2, segment, selected = false) {
      if (this.checkInViewport(point2)) {
        this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
          cx: point2.x,
          cy: point2.y,
          selected,
          index: index2,
          segment,
          isFirst: point2.isFirst,
          isLast: point2.isLast,
          isSecond: point2.isSecond
        }));
      }
      return this;
    }
    addStartPoint(obj2, point2) {
      if (this.checkInViewport(point2)) {
        this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
          cx: point2.x,
          cy: point2.y,
          start: true
        }));
      }
      return this;
    }
    addCurvePoint(point2, index2, segment, selected = false) {
      if (this.checkInViewport(point2)) {
        this.segmentList.push({
          curve: true,
          cx: point2.x,
          cy: point2.y,
          index: index2,
          selected,
          segment,
          isFirst: point2.isFirst,
          isLast: point2.isLast,
          isSecond: point2.isSecond
        });
      }
      return this;
    }
    addText(point2, text2) {
      this.segmentList.push({
        type: "text",
        cx: point2.x,
        cy: point2.y,
        text: text2 + ""
      });
      return this;
    }
    toString() {
      this.segmentList.sort((a, b) => {
        if (a.line && !b.line) {
          return -1;
        } else if (!a.line && b.line) {
          return 1;
        }
        return 0;
      });
      return this.segmentList.map((it) => {
        if (it.angle) {
          return `
                <path stroke-width='1' 
                    data-distance='true'
                    fill="rgba(0,0,0,0.5)"
                    d="M ${it.center.x},${it.center.y} A ${it.rx} ${it.ry},${it.degree},0,0,${it.last.x} ${it.last.y} L${it.line.x} ${it.line.y} Z"
                />`;
        } else if (it.line) {
          return `
                <line stroke-width='1' 
                    data-segment="true"
                    data-is-last="${it.isLast}"                
                    data-guide='${it.guide}'
                    data-distance='${it.distance}'
                    x1='${it.x1}' x2='${it.x2}' y1='${it.y1}' y2='${it.y2}' 
                />`;
        } else if (it.text) {
          return "";
        } else if (it.curve && it.segment !== "startPoint") {
          return `
                <path stroke-width='1'
                    class='curve' 
                    ${it.selected && `data-selected="true"`}
                    ${it.isLast && `data-is-last="true"`}
                    ${it.isFirst && `data-is-first="true"`}
                    ${it.isSecond && `data-is-second="true"`}
                    title="${it.segment} curve"  
                    data-index='${it.index}'
                    data-segment-point='${it.segment}'
                    data-segment="true" 
                    d="M ${it.cx} ${it.cy - 4}L ${it.cx + 4} ${it.cy} L ${it.cx} ${it.cy + 4} L ${it.cx - 4} ${it.cy} Z"
                />`;
        } else if (it.start) {
          return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="Center"
                    data-start="true" 
                    tabIndex="-1"
                />`;
        } else {
          return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="${it.segment}"
                    data-is-last="${it.isLast}"
                    data-is-first="${it.isFirst}"
                    data-is-second="${it.isSecond}"
                    data-index='${it.index}' 
                    data-segment-point='${it.segment}' 
                    data-segment="true" 
                    tabIndex="-1"                    
                />`;
        }
      }).join("");
    }
  }
  const SEGMENT_DIRECTION$1 = ["startPoint", "endPoint", "reversePoint"];
  function calculateSnapPoint$1(points, sourceKey, target, distanceValue, dist2) {
    var checkedPointList = points.filter((p) => {
      if (!p)
        return false;
      return Math.abs(p[sourceKey] - target) <= dist2;
    }).map((p) => {
      return { dist: Math.abs(p[sourceKey] - target), point: p };
    });
    checkedPointList.sort((a, b) => {
      return a.dist < b.dist ? -1 : 1;
    });
    var point2 = null;
    if (checkedPointList.length) {
      point2 = checkedPointList[0].point;
      distanceValue += point2[sourceKey] - target;
    }
    return { point: point2, distanceValue };
  }
  function calculateMovePointSnap$1(points, moveXY, dist2) {
    var snapPointX = calculatePointDist$1(points, "x", moveXY.x, dist2);
    var snapPointY = calculatePointDist$1(points, "y", moveXY.y, dist2);
    var snapEndPoint = __spreadValues({}, moveXY);
    if (snapPointX) {
      snapEndPoint.x = snapPointX.x;
    }
    if (snapPointY) {
      snapEndPoint.y = snapPointY.y;
    }
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { snapPointList, moveXY: snapEndPoint };
  }
  function calculatePointDist$1(points, sourceKey, target, dist2) {
    var checkedPointList = [];
    var arr = SEGMENT_DIRECTION$1;
    points.filter((p) => p).forEach((p) => {
      arr.filter((key) => p[key]).forEach((key) => {
        var point2 = p[key];
        var tempDist = Math.abs(point2[sourceKey] - target);
        if (tempDist <= dist2) {
          checkedPointList.push({ dist: tempDist, point: point2 });
        }
      });
    });
    checkedPointList.sort((a, b) => {
      return a.dist > b.dist ? 1 : -1;
    });
    return checkedPointList.length ? checkedPointList[0].point : null;
  }
  function toPath$1(points, minX, minY, scale2 = 1) {
    var d = [];
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      if (current.command === "M") {
        d.push({ command: "M", values: [current.startPoint] });
      } else {
        var prevPoint = Point.getPrevPoint(points, index2);
        if (current.curve === false) {
          if (prevPoint.curve === false) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [prevPoint.endPoint, current.startPoint]
            });
          }
        } else {
          if (prevPoint.curve === false) {
            if (Point.isEqual(current.reversePoint, current.startPoint)) {
              d.push({ command: "L", values: [current.startPoint] });
            } else {
              d.push({
                command: "Q",
                values: [current.reversePoint, current.startPoint]
              });
            }
          } else {
            d.push({
              command: "C",
              values: [
                prevPoint.endPoint,
                current.reversePoint,
                current.startPoint
              ]
            });
          }
        }
      }
      if (current.close) {
        d.push({ command: "Z" });
      }
    }
    var dString = d.map((segment) => {
      return calculateRelativePosition$1(minX, minY, segment, scale2);
    }).join(" ");
    return {
      d: dString
    };
  }
  function calculateRelativePosition$1(minX, minY, segment, scale2 = 1) {
    var { command, values } = segment;
    switch (command) {
      case "Z":
        return "Z";
      default:
        var str = values.map((v) => {
          var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
          var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
          return `${tx} ${ty}`;
        }).join(" ");
        return `${command} ${str}`;
    }
  }
  function checkInArea$1(area2, point2) {
    if (area2.x2.value < point2.x) {
      return false;
    }
    if (area2.y2.value < point2.y) {
      return false;
    }
    if (area2.x.value > point2.x) {
      return false;
    }
    if (area2.y.value > point2.y) {
      return false;
    }
    return true;
  }
  class PathGenerator {
    static generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
      return toPath$1(points, minX, minY, scale2).d;
    }
    constructor(pathEditor) {
      this.pathEditor = pathEditor;
      this.pathStringManager = new PathStringManager();
      this.guideLineManager = new PathStringManager();
      this.segmentManager = new SegmentManager(this.pathEditor.$viewport);
      this.points = [];
      this.cachedSegmentKeys = {};
      this.initialize();
      this.initializeSelect();
    }
    initialize() {
      this.splitLines = [];
      this.guideLineManager.reset();
      this.segmentManager.reset();
      this.pathStringManager.reset();
    }
    initializeSelect(initPointList = []) {
      this.selectedPointKeys = {};
      this.selectedPointList = [];
      if (initPointList.length) {
        this.select(...initPointList.map((p) => {
          const checkedPoint = this.points[p.index][p.key];
          if (!checkedPoint)
            return void 0;
          return {
            x: checkedPoint.x,
            y: checkedPoint.y,
            key: p.key,
            index: checkedPoint.index
          };
        }).filter(Boolean));
      }
    }
    get state() {
      return this.pathEditor.state;
    }
    get clonePoints() {
      return [...this.points];
    }
    get length() {
      return this.points.length;
    }
    setPoints(points = []) {
      this.points = points;
      this.snapPointList = [];
      if (this.points.length === 0) {
        this.select();
        this.selectGroup(-1);
      }
    }
    selectInBox(box, isToggle = false) {
      var list = [];
      this.points.forEach((point2, index2) => {
        SEGMENT_DIRECTION$1.forEach((key) => {
          const p = point2[key];
          if (checkInArea$1(box, p)) {
            list.push({ x: p.x, y: p.y, key, index: index2 });
          }
        });
      });
      if (isToggle) {
        list = list.map((it) => {
          const selectedKey = this.makeSegmentKey(it);
          return __spreadProps(__spreadValues({}, it), {
            included: Boolean(this.selectedPointKeys[selectedKey])
          });
        });
        const includedList = list.filter((it) => it.included);
        const notIncludedList = list.filter((it) => !it.included);
        let uniqueList = [...this.selectedPointList];
        if (includedList.length) {
          uniqueList = this.selectedPointList.filter((it) => {
            const oldKey = this.makeSegmentKey(it);
            return Boolean(includedList.find((includeNode) => {
              return oldKey === this.makeSegmentKey(includeNode);
            })) === false;
          });
        }
        this.select(...uniqueList, ...notIncludedList);
      } else {
        this.select(...list);
      }
    }
    makeSegmentKey(p) {
      return `${p.key}_${p.index}`;
    }
    select(...list) {
      this.selectedPointKeys = {};
      this.selectedPointList = list.map(({ x, y, key, index: index2 }) => ({
        x,
        y,
        key,
        index: +index2
      }));
      list.forEach((it) => {
        var key = this.makeSegmentKey(it);
        this.selectedPointKeys[key] = true;
      });
    }
    convertPointsToSelectionList(points) {
      var list = [];
      points.forEach((point2) => {
        SEGMENT_DIRECTION$1.forEach((key) => {
          const { x, y } = point2[key];
          list.push({ x, y, key, index: point2.index });
        });
      });
      return list;
    }
    selectGroup(groupIndex) {
      const group = this.splitedGroupList[groupIndex];
      if (group) {
        this.select(...this.convertPointsToSelectionList(group.points));
      } else {
        this.select();
      }
    }
    getCacheSegmentKey(segmentKey, index2) {
      if (!this.cachedSegmentKeys[segmentKey]) {
        this.cachedSegmentKeys[segmentKey] = {};
      }
      if (!this.cachedSegmentKeys[segmentKey][index2]) {
        this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
          key: segmentKey,
          index: index2
        });
      }
      return this.cachedSegmentKeys[segmentKey][index2];
    }
    toggleSelect(key, index2) {
      if (this.points[index2]) {
        var point2 = this.points[index2][key];
        if (point2 && !this.isSelectedSegment(key, index2)) {
          this.select(...this.selectedPointList, {
            x: point2.x,
            y: point2.y,
            key,
            index: index2
          });
        } else {
          this.select(...this.selectedPointList.filter((it) => {
            return it.key !== key || it.index !== index2;
          }));
        }
      }
    }
    selectKeyIndex(key, index2) {
      if (this.points[index2]) {
        var point2 = this.points[index2][key];
        if (point2 && !this.isSelectedSegment(key, index2)) {
          this.select({ x: point2.x, y: point2.y, key, index: index2 });
        }
      }
    }
    reselect() {
      this.selectedPointList.filter(Boolean).forEach((it) => {
        var _a;
        var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
        if (point2) {
          it.x = point2.x;
          it.y = point2.y;
        }
      });
    }
    isSelectedSegment(segment, index2) {
      var key = this.getCacheSegmentKey(segment, index2);
      return this.selectedPointKeys[key];
    }
    commitTransformMatrix(point2, transformMatrix) {
      var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
      return { x: result[0], y: result[1] };
    }
    transformMat4(transformMatrix) {
      this.transformPoints.forEach((p, index2) => {
        var realPoint = this.points[index2];
        Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
        Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
        Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
      });
    }
    transform(type) {
      var { x, y, width: width2, height } = this.transformRect;
      var view = create$4();
      translate(view, view, [x, y, 0]);
      switch (type) {
        case "flipX":
          scale(view, view, [-1, 1, 1]);
          translate(view, view, [-width2, 0, 0]);
          break;
        case "flipY":
          scale(view, view, [1, -1, 1]);
          translate(view, view, [0, -height, 0]);
          break;
        case "flip":
          scale(view, view, [-1, -1, 1]);
          translate(view, view, [-width2, -height, 0]);
          break;
      }
      translate(view, view, [-x, -y, 0]);
      this.transformMat4(view);
    }
    initTransform(rect2) {
      this.transformRect = sapa.clone(rect2);
      this.transformPoints = this.clonePoints.map((p) => {
        return {
          startPoint: sapa.clone(p.startPoint),
          endPoint: sapa.clone(p.endPoint),
          reversePoint: sapa.clone(p.reversePoint)
        };
      });
    }
    setConnectedPoint(dx, dy) {
      var state = this.state;
      var x = state.dragXY.x + dx;
      var y = state.dragXY.y + dy;
      var endPoint = { x, y };
      var reversePoint = { x, y };
      if (state.dragPoints) {
        state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
      }
      var point2 = {
        startPoint: state.startPoint,
        endPoint,
        curve: !!state.dragPoints,
        reversePoint,
        connected: true,
        close: true
      };
      this.points.push(point2);
    }
    setLastPoint(startPoint) {
      var endPoint = sapa.clone(startPoint);
      var reversePoint = sapa.clone(startPoint);
      var point2 = {
        startPoint,
        endPoint,
        curve: false,
        reversePoint,
        connected: false,
        close: false
      };
      this.points.push(point2);
    }
    getPrevPoint(index2) {
      return Point.getPrevPoint(this.points, index2);
    }
    getIndexPoint(index2) {
      return Point.getIndexPoint(this.points, index2);
    }
    getNextPoint(index2) {
      return Point.getNextPoint(this.points, index2);
    }
    getConnectedPointList(index2) {
      return Point.getConnectedPointList(this.points, index2);
    }
    isFirst(segment) {
      return Point.isFirst(segment);
    }
    getLastPoint(index2) {
      return Point.getLastPoint(this.points, index2);
    }
    setCachePoint(index2, segmentKey) {
      var state = this.state;
      this.snapPointList = [];
      this.selectedIndex = index2;
      state.connectedPoint = this.getPrevPoint(index2);
      state.connectedPointList = sapa.clone(Point.getConnectedPointList(this.points, this.selectedIndex));
      if (state.connectedPoint && !state.connectedPoint.connected) {
        state.connectedPoint = null;
      }
      state.segment = this.getIndexPoint(index2);
      if (state.segment.connected) {
        state.connectedPoint = this.getNextPoint(index2);
      }
      var isFirstSegment = this.isFirst(state.segment);
      if (isFirstSegment) {
        var lastPoint = this.getLastPoint(index2);
        if (lastPoint.connected) {
          state.connectedPoint = lastPoint;
        }
      }
      state.segmentKey = segmentKey;
      state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
      state.originalSegment = sapa.clone(state.segment);
      if (state.connectedPoint) {
        state.originalConnectedPoint = sapa.clone(state.connectedPoint);
      }
      state.cachedPoints = [];
      this.points.filter((p) => p && p != state.segment).forEach((p) => {
        state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
      });
    }
    moveSegment(segmentKey, dx, dy, originSegment = void 0) {
      if (originSegment) {
        const segment = this.points[originSegment.index][segmentKey];
        segment.x = originSegment[segmentKey].x + dx;
        segment.y = originSegment[segmentKey].y + dy;
      } else {
        var state = this.state;
        var originPoint = state.originalSegment[segmentKey];
        var targetPoint = state.segment[segmentKey];
        if (originPoint) {
          targetPoint.x = originPoint.x + dx;
          targetPoint.y = originPoint.y + dy;
        }
      }
    }
    calculateToCurve(point2, nextPoint, prevPoint) {
      var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
      var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
      var dx = (nextPoint.startPoint.x - centerX) / 2;
      var dy = (nextPoint.startPoint.y - centerY) / 2;
      point2.endPoint = {
        x: point2.startPoint.x + dx,
        y: point2.startPoint.y + dy
      };
      point2.reversePoint = {
        x: point2.startPoint.x - dx,
        y: point2.startPoint.y - dy
      };
      return { dx, dy };
    }
    convertToCurve(index2) {
      var point2 = this.points[index2];
      if (point2.curve) {
        point2.curve = false;
        point2.reversePoint = sapa.clone(point2.startPoint);
        point2.endPoint = sapa.clone(point2.startPoint);
        if (point2.command === "M") {
          var lastPoint = Point.getPrevPoint(this.points, point2.index);
          if (lastPoint.connected) {
            lastPoint.curve = false;
            lastPoint.reversePoint = sapa.clone(lastPoint.startPoint);
            lastPoint.endPoint = sapa.clone(lastPoint.startPoint);
          }
        } else {
          var nextPoint = this.getNextPoint(index2);
          if (nextPoint && nextPoint.command === "M") {
            var firstPoint = nextPoint;
            firstPoint.curve = false;
            firstPoint.reversePoint = sapa.clone(firstPoint.startPoint);
            firstPoint.endPoint = sapa.clone(firstPoint.startPoint);
          }
        }
      } else {
        point2.curve = true;
        var prevPoint = this.getPrevPoint(index2);
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          nextPoint = this.getNextPoint(firstPoint.index);
          this.calculateToCurve(point2, nextPoint, prevPoint);
          firstPoint.curve = true;
          firstPoint.endPoint = sapa.clone(point2.endPoint);
          firstPoint.reversePoint = sapa.clone(point2.reversePoint);
        } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
          this.calculateToCurve(point2, nextPoint, prevPoint);
        } else if (!nextPoint && prevPoint) {
          var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
          var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
          point2.endPoint = {
            x: point2.startPoint.x + centerX,
            y: point2.startPoint.y + centerY
          };
          point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
        } else if (!prevPoint && nextPoint) {
          var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
          var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
          point2.endPoint = {
            x: point2.startPoint.x + centerX,
            y: point2.startPoint.y + centerY
          };
          point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
        }
      }
    }
    moveCurveSegment(segmentKey, dx, dy) {
      var state = this.state;
      this.moveSegment(segmentKey, dx, dy);
      var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
      state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
    }
    rotateSegmentTarget(segmentKey, target) {
      var state = this.state;
      if (state.originalSegment && state.segment) {
        var { x: cx, y: cy } = state.originalSegment.startPoint;
        var { x: rx, y: ry } = state.segment[segmentKey];
        var { x: tx, y: ty } = state.originalSegment[target];
        var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
        state.segment[target] = { x, y };
      }
    }
    rotateSegment(segmentKey) {
      this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
    }
    calculateSnap(segmentKey, dx, dy, dist2 = 1) {
      var state = this.state;
      var cachedPoints = state.cachedPoints;
      var original = state.originalSegment[segmentKey];
      if (!segmentKey) {
        return { dx, dy, snapPointList: [] };
      }
      var realX = original.x + dx;
      var realY = original.y + dy;
      var { point: snapPointX, distanceValue: dx } = calculateSnapPoint$1(cachedPoints, "x", realX, dx, dist2);
      var { point: snapPointY, distanceValue: dy } = calculateSnapPoint$1(cachedPoints, "y", realY, dy, dist2);
      var snapEndPoint = {
        x: original.x + dx,
        y: original.y + dy
      };
      var snapPointList = [];
      if (snapPointX) {
        snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
      }
      if (snapPointY) {
        snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
      }
      return { dx, dy, snapPointList };
    }
    copySegment(from, to) {
      to.startPoint = sapa.clone(from.startPoint);
      to.endPoint = sapa.clone(from.endPoint);
      to.reversePoint = sapa.clone(from.reversePoint);
    }
    get selectedLength() {
      return this.selectedPointList.length;
    }
    moveSelectedSegment(dx, dy) {
      if (this.selectedPointList.length > 0) {
        this.selectedPointList.forEach((it) => {
          var target = this.points[it.index][it.key];
          target.x = it.x + dx;
          target.y = it.y + dy;
        });
      } else if (this.selectedGroup) {
        this.moveSelectedGroup(dx, dy);
      }
    }
    moveSelectedGroup(dx, dy) {
      this.selectedGroup.points.forEach((it) => {
        const target = this.points[it.index];
        target.startPoint.x = it.startPoint.x + dx;
        target.startPoint.y = it.startPoint.y + dy;
        target.endPoint.x = it.endPoint.x + dx;
        target.endPoint.y = it.endPoint.y + dy;
        target.reversePoint.x = it.reversePoint.x + dx;
        target.reversePoint.y = it.reversePoint.y + dy;
      });
    }
    get selectedGroup() {
      return this.splitedGroupList[this.state.selectedGroupIndex];
    }
    get splitedGroupList() {
      return Point.getSplitedGroupList(this.points);
    }
    get groupList() {
      return Point.getGroupList(this.points);
    }
    getGroup(groupList, pointIndex) {
      return Point.getGroup(groupList, pointIndex);
    }
    get selectedGroupIndexList() {
      const groupIndexList = /* @__PURE__ */ new Set();
      const groupList = this.groupList;
      if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
        return groupList.map((group) => group.groupIndex);
      }
      const points = this.selectedPointList;
      points.forEach((it) => {
        const group = this.getGroup(groupList, it.index);
        if (group) {
          groupIndexList.add(group.groupIndex);
        }
      });
      return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
    }
    removeSelectedSegment() {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.removed = true;
      });
      const pointGroup = Point.splitPoints(this.points);
      const newPoints = Point.recoverPoints(pointGroup.map((points) => {
        return points.filter((p) => !p.startPoint.removed).map((p) => {
          if (p.endPoint.removed) {
            p.endPoint = sapa.clone(p.startPoint);
          }
          if (p.reversePoint.removed) {
            p.reversePoint = sapa.clone(p.startPoint);
          }
          if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
            p.command = "L";
            p.curve = false;
          }
          return p;
        });
      }));
      this.points = newPoints;
      this.select();
    }
    move(dx, dy, e) {
      var state = this.state;
      var { isCurveSegment, segmentKey, connectedPoint } = state;
      if (this.selectedPointList.length > 1) {
        this.moveSelectedSegment(dx, dy);
      } else if (this.selectedPointList.length === 1) {
        var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
        this.snapPointList = snapPointList || [];
        if (isCurveSegment) {
          if (e.shiftKey) {
            this.moveSegment(segmentKey, dx, dy);
            var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
            state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
          } else if (e.altKey) {
            this.moveSegment(segmentKey, dx, dy);
            this.rotateSegment(segmentKey);
          } else {
            this.moveSegment(segmentKey, dx, dy);
          }
        } else {
          this.moveSegment("startPoint", dx, dy);
          this.moveSegment("endPoint", dx, dy);
          this.moveSegment("reversePoint", dx, dy);
          if (!e.altKey) {
            state.connectedPointList.forEach((it) => {
              this.moveSegment("startPoint", dx, dy, it);
              this.moveSegment("endPoint", dx, dy, it);
              this.moveSegment("reversePoint", dx, dy, it);
            });
          }
        }
        connectedPoint && this.copySegment(state.segment, state.connectedPoint);
      } else if (this.state.selectedGroupIndex > -1) {
        this.moveSelectedGroup(dx, dy);
      }
    }
    moveEnd(dx, dy) {
      var state = this.state;
      var points = this.points;
      var x = state.dragXY.x + dx;
      var y = state.dragXY.y + dy;
      var endPoint = { x, y };
      var reversePoint = { x, y };
      if (state.dragPoints) {
        reversePoint = Point.getReversePoint(state.startPoint, endPoint);
      }
      points.push({
        command: state.clickCount === 0 ? "M" : "",
        startPoint: state.startPoint,
        endPoint,
        curve: !!state.dragPoints,
        reversePoint
      });
      state.startPoint = null;
      state.dragPoints = false;
      state.moveXY = null;
    }
    setPoint(obj2) {
      var p0 = obj2.first[0];
      var p1 = obj2.second[obj2.second.length - 1];
      var allPoints = this.clonePoints;
      var firstItem = Point.getPoint(allPoints, p0);
      var secondItem = Point.getPoint(allPoints, p1);
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
        {
          startPoint: obj2.first[3],
          reversePoint: obj2.first[2],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
      this.points = allPoints;
      return firstIndex + 1;
    }
    setPointQuard(obj2) {
      var p0 = obj2.first[0];
      var p1 = obj2.second[obj2.second.length - 1];
      var allPoints = this.clonePoints;
      var firstItem = Point.getPoint(allPoints, p0);
      var secondItem = Point.getPoint(allPoints, p1);
      if (firstItem.curve && secondItem.curve === false) {
        var newPoints = [
          __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
          {
            startPoint: obj2.first[2],
            reversePoint: obj2.first[1],
            curve: true,
            endPoint: obj2.second[1]
          }
        ];
        var firstIndex = Point.getIndex(allPoints, p0);
        allPoints.splice(firstIndex, 1, ...newPoints);
      } else {
        var newPoints = [
          __spreadValues({}, firstItem),
          {
            startPoint: obj2.first[2],
            reversePoint: obj2.first[1],
            curve: true,
            endPoint: obj2.second[1]
          },
          __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
        ];
        var firstIndex = Point.getIndex(allPoints, p0);
        allPoints.splice(firstIndex, 2, ...newPoints);
      }
      this.points = allPoints;
      return firstIndex + 1;
    }
    setPointLine(obj2) {
      var p0 = obj2.first[0];
      var allPoints = this.clonePoints;
      var newPoints = [
        {
          command: "L",
          startPoint: obj2.first[1],
          curve: false,
          endPoint: obj2.first[1],
          reversePoint: obj2.first[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex + 1, 0, ...newPoints);
      this.points = allPoints;
      return firstIndex + 1;
    }
    toPath(minX = 0, minY = 0, scale2 = 1) {
      return toPath$1(this.clonePoints, minX, minY, scale2);
    }
    makeSVGPath() {
      this.initialize();
      this.makePointGuide(this.points);
      this.makeMovePositionGuide();
      return this.toSVGString();
    }
    makeTriangleDistancePointGuide(first, second) {
      var minX = Math.min(first.startPoint.x, second.startPoint.x);
      var maxX = Math.max(first.startPoint.x, second.startPoint.x);
      var minY = Math.min(first.startPoint.y, second.startPoint.y);
      var maxY = Math.max(first.startPoint.y, second.startPoint.y);
      if (first.startPoint.x < second.startPoint.x && first.startPoint.y < second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
        var centerX = minX;
        var centerY = minY;
        var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
        var dist2 = 20;
        var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
        var last = getXYInCircle(angle, dist2, centerX, centerY);
        this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
      } else if (first.startPoint.x < second.startPoint.x && first.startPoint.y > second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y > second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
      } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y < second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      }
    }
    makeDistancePointGuide(prevPoint, current, nextPoint) {
      if (current.selected) {
        if (prevPoint) {
          this.makeTriangleDistancePointGuide(prevPoint, current);
        }
        if (nextPoint) {
          this.makeTriangleDistancePointGuide(current, nextPoint);
        }
      }
    }
    makeStartPointGuide(prevPoint, current, nextPoint, index2) {
      current.startPoint.isFirst = true;
      if (current.curve === false) {
        this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
        if (Point.isEqual(current.startPoint, current.endPoint) === false) {
          this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
        }
      }
    }
    makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected) {
      var mng = this.segmentManager;
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          if (isSiblingSelected === false) {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
          }
        }
      } else {
        if (prevPoint.curve === false) {
          if (isSiblingSelected === false) {
            if (Point.isEqual(current.reversePoint, current.startPoint)) {
              mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            } else {
              mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            }
          } else {
            if (Point.isEqual(current.reversePoint, current.startPoint)) {
              mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            } else {
              mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
              if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
                mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
              }
            }
          }
        } else {
          if (current.connected) {
            if (isSiblingSelected === false)
              ;
            else {
              mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
              if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
                mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
              }
              if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
                mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
              }
            }
          } else {
            if (isSiblingSelected === false) {
              mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            } else {
              mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
              if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
                mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
              }
              if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
                mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
              }
            }
          }
        }
      }
    }
    checkInViewport(point2) {
      const vertext = this.pathEditor.$viewport.applyVertexInverse([
        point2.x,
        point2.y,
        0
      ]);
      return this.pathEditor.$viewport.checkInViewport(vertext);
    }
    makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected) {
      const selected = isSiblingSelected ? "selected" : "";
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
              return;
            }
            this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
          } else {
            if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
              return;
            }
            this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
          }
        } else {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      }
    }
    makePointGuide(points) {
      for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
        var currentIndex = index2;
        var current = points[currentIndex];
        if (!current)
          continue;
        var nextPoint = Point.getNextPoint(points, index2);
        var prevPoint = Point.getPrevPoint(points, index2);
        if (prevPoint && prevPoint.command === "M") {
          if (current.startPoint) {
            current.startPoint.isSecond = true;
          }
        }
        if (current.startPoint) {
          if (nextPoint) {
            current.startPoint.isLast = nextPoint.command === "M";
          } else {
            current.startPoint.isLast = index2 === len2 - 1;
          }
        }
        current.selected = this.selectedIndex === index2;
        if (current.command === "M") {
          this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
        } else {
          var isSiblingSelected = Boolean(this.isSelectedSegment("endPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("startPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("reversePoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("endPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("startPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("reversePoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("endPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("startPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("reversePoint", current == null ? void 0 : current.index));
          this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected);
          this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected);
        }
        if (current.close) {
          this.pathStringManager.Z();
        }
      }
    }
    makeMovePositionGuide() {
      var state = this.state;
      var {
        startPoint,
        moveXY,
        dragPoints,
        snapPointList,
        isGroupSegment
      } = state;
      var points = this.points;
      if (moveXY) {
        snapPointList = snapPointList || [];
        var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap$1(points, moveXY, 3);
        snapPointList.push.apply(snapPointList, movePointSnapPointList);
        state.moveXY = newMoveXY;
        moveXY = newMoveXY;
        this.snapPointList = snapPointList;
        var prev = points[points.length - 1];
        if (dragPoints && !isGroupSegment) {
          if (!prev) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
            this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
          } else if (prev.curve) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
            this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
          } else if (prev.curve === false) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
            this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
          }
        } else {
          if (!prev)
            ;
          else if (prev.curve) {
            this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
            this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
          } else {
            if (!prev.close) {
              this.guideLineManager.M(prev.startPoint).L(moveXY);
              this.segmentManager.addPoint(false, prev.startPoint);
            }
          }
        }
      }
    }
    makeSnapLines() {
      var snapLines = [];
      if (this.snapPointList) {
        var snapPath = new PathStringManager();
        snapLines = this.snapPointList.map((snapPoint) => {
          snapPath.reset();
          return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
        });
      }
      return snapLines.join("");
    }
    makePathArea() {
      const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
        const d = PathGenerator.generatorPathString(points);
        const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
        return {
          points,
          startPointIndex,
          groupIndex,
          center: verties[4],
          d
        };
      });
      const pathCount = pathList.length;
      return `
            <g>
               ${pathList.map((it) => {
        const { center } = it;
        const [x, y] = center;
        const selected = this.state.selectedGroupIndex === it.groupIndex;
        return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
      }).join("")}
            </g>
        `;
    }
    toSVGString() {
      return `
        <svg width="100%" height="100%" class='svg-editor-canvas'>
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
    }
  }
  function xy$1([x, y]) {
    return { x, y };
  }
  const SegmentConvertor$1 = class extends editor.EditorElement {
    convertToCurve(index2) {
      this.pathGenerator.convertToCurve(index2);
      this.renderPath();
      this.refreshPathLayer();
    }
    isEditableSegment() {
      return this.state.disableCurve === false;
    }
    [sapa.DOUBLECLICK("$view [data-segment]") + sapa.IF("isEditableSegment") + sapa.PREVENT](e) {
      var index2 = +e.$dt.attr("data-index");
      this.convertToCurve(index2);
    }
    [sapa.DOUBLETAB("$view [data-segment]") + sapa.PREVENT + sapa.DELAY(300)](e) {
      var index2 = +e.$dt.attr("data-index");
      this.convertToCurve(index2);
    }
  };
  const PathCutter$1 = class extends SegmentConvertor$1 {
    calculatePointOnLine(d, clickPosition) {
      var parser = new PathParser(d);
      return parser.getClosedPoint(clickPosition);
    }
    [sapa.POINTERSTART("$view .split-path") + MOVE() + END()](e) {
      this.initRect();
      var parser = new PathParser(e.$dt.attr("d"));
      var clickPosition = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      var selectedSegmentIndex = -1;
      if (this.isMode("path")) {
        this.state.dragXY = clickPosition;
        this.state.startPoint = this.state.dragXY;
        this.pathGenerator.setLastPoint(this.state.startPoint);
        this.state.isSplitPath = true;
        this.renderPath();
        if (this.state.current) {
          this.refreshPathLayer();
        } else {
          this.addPathLayer();
          this.trigger("initPathEditorView");
        }
        return;
      } else {
        if (parser.segments[1].command === "C") {
          var points = [
            xy$1(parser.segments[0].values),
            xy$1(parser.segments[1].values.slice(0, 2)),
            xy$1(parser.segments[1].values.slice(2, 4)),
            xy$1(parser.segments[1].values.slice(4, 6))
          ];
          var curve = recoverBezier(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
        } else if (parser.segments[1].command === "Q") {
          var points = [
            xy$1(parser.segments[0].values),
            xy$1(parser.segments[1].values.slice(0, 2)),
            xy$1(parser.segments[1].values.slice(2, 4))
          ];
          var curve = recoverBezierQuard(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
        } else if (parser.segments[1].command === "L") {
          var points = [
            xy$1(parser.segments[0].values),
            xy$1(parser.segments[1].values.slice(0, 2))
          ];
          var curve = recoverBezierLine(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
          if (e.altKey) {
            this.pathGenerator.convertToCurve(selectedSegmentIndex);
          }
        }
        this.renderPath();
        this.refreshPathLayer();
        this.changeMode("segment-move");
        this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
        this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
      }
    }
  };
  const PathTransformEditor = class extends PathCutter$1 {
    [sapa.SUBSCRIBE("changePathTransform")](transformMoveType) {
      this.resetTransformZone();
      var { width: width2, height } = this.state.transformZoneRect;
      this.pathGenerator.initTransform(this.state.transformZoneRect);
      switch (transformMoveType) {
        case "flipX":
          this.pathGenerator.transform("flipX", width2, 0);
          break;
        case "flipY":
          this.pathGenerator.transform("flipY", 0, height);
          break;
        case "flip":
          this.pathGenerator.transform("flip", width2, height);
      }
      this.renderPath();
      this.refreshPathLayer();
    }
    [sapa.SUBSCRIBE("changePathUtil")](utilType) {
      if (utilType === "reverse") {
        const { d } = this.pathGenerator.toPath();
        const pathParser = new PathParser(d);
        pathParser.reverse(...this.pathGenerator.selectedGroupIndexList);
        pathParser.transformMat4(this.state.cachedMatrixInverse);
        this.refreshEditorView({ d: pathParser.d });
        this.updatePathLayer();
      }
    }
    [sapa.SUBSCRIBE("divideSegmentsByCount")](count) {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      const newPath = pathParser.divideSegmentByCount(count);
      newPath.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: newPath.d });
    }
  };
  const FIELDS = ["fill", "fill-opacity", "stroke", "stroke-width"];
  class PathEditorView extends PathTransformEditor {
    initialize() {
      super.initialize();
      this.pathParser = new PathParser();
      this.pathGenerator = new PathGenerator(this);
    }
    initState() {
      return {
        changeEvent: "updatePathItem",
        isShow: false,
        isControl: false,
        disableCurve: false,
        points: [],
        mode: "path",
        clickCount: 0,
        isSegment: false,
        isFirstSegment: false,
        current: null
      };
    }
    get scale() {
      return this.$viewport.scale;
    }
    template() {
      return `
        <div class='elf--path-editor-view' tabIndex="-1">
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
    }
    isShow() {
      return this.state.isShow;
    }
    initRect(isForce = false) {
      if (!this.state.rect || isForce) {
        this.state.rect = this.$el.rect();
      }
    }
    [sapa.SUBSCRIBE("PathEditorDone")]() {
      if (this.state.current) {
        this.refreshPathLayer();
        this.trigger("hidePathEditor");
      } else {
        this.addPathLayer();
      }
      if (!this.state.current && this.pathGenerator.length) {
        this.trigger("initPathEditorView");
      } else {
        this.trigger("hidePathEditor");
      }
    }
    [sapa.CLICK()]() {
      console.log("click");
    }
    [sapa.KEYUP("document") + sapa.IF("isShow") + sapa.ENTER]() {
      this.trigger("PathEditorDone");
    }
    [sapa.KEYUP("document") + sapa.IF("isShow") + sapa.ESCAPE]() {
      if (this.state.current) {
        this.refreshPathLayer();
      } else {
        this.addPathLayer();
      }
      this.trigger("hidePathEditor");
    }
    makePathLayer() {
      const pathString2 = this.pathGenerator.toPath().d;
      if (!pathString2) {
        return;
      }
      var layer;
      const newPath = new PathParser(pathString2);
      newPath.transformMat4(this.$viewport.matrixInverse);
      const bbox = newPath.getBBox();
      const newWidth = distance$1(bbox[1], bbox[0]);
      const newHeight = distance$1(bbox[3], bbox[0]);
      newPath.translate(-bbox[0][0], -bbox[0][1]);
      const pathItem = {
        itemType: "svg-path",
        x: bbox[0][0],
        y: bbox[0][1],
        width: newWidth,
        height: newHeight,
        d: newPath.d,
        fill: newPath.closed ? `#C4C4C4` : "transparent"
      };
      FIELDS.forEach((key) => {
        if (this.state[key]) {
          pathItem[key] = this.state[key];
        }
      });
      const containerItem = this.$context.selection.currentProject;
      layer = containerItem.appendChild(this.$editor.context.modelManager.createModel(pathItem));
      this.$commands.executeCommand("moveLayerToTarget", "add path", layer, this.$context.selection.currentProject);
      return layer;
    }
    updatePathLayer() {
      var { d } = this.pathGenerator.toPath();
      var parser = new PathParser(d);
      parser.transformMat4(this.$viewport.matrixInverse);
      this.emit(this.state.changeEvent, {
        d: parser.d,
        matrix: this.state.matrix,
        box: this.state.box
      });
    }
    addPathLayer() {
      this.changeMode("modify");
      var layer = this.makePathLayer();
      if (layer) {
        this.$config.set("editing.mode.itemType", "select");
        this.$context.selection.select(layer);
        this.trigger("hidePathEditor");
      }
    }
    changeMode(mode, obj2) {
      this.setState(__spreadValues({
        mode,
        clickCount: 0,
        moveXY: null
      }, obj2), false);
      if (obj2 == null ? void 0 : obj2.points) {
        this.pathGenerator.setPoints(obj2.points || []);
      }
      this.emit("changePathManager", this.state.mode);
    }
    [sapa.SUBSCRIBE("changePathManager")](obj2) {
      this.setState(__spreadProps(__spreadValues({}, obj2), { clickCount: 0 }), false);
      this.renderPath();
    }
    isMode(mode) {
      return this.state.mode === mode;
    }
    afterRender() {
      this.$el.hide();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      if (this.$el.isShow()) {
        const { d } = this.pathGenerator.toPath();
        const pathParser = new PathParser(d);
        pathParser.transformMat4(this.state.cachedMatrixInverse);
        this.refreshEditorView({ d: pathParser.d });
      }
    }
    refreshEditorView(obj2) {
      if (obj2 && obj2.d) {
        this.pathParser.reset(obj2.d);
        this.pathParser.transformMat4(this.$viewport.matrix);
        this.state.cachedMatrixInverse = this.$viewport.matrixInverse;
        this.pathGenerator.setPoints(this.pathParser.convertGenerator());
      }
      this.renderPath();
    }
    [sapa.SUBSCRIBE("showPathEditor")](mode = "path", obj2 = {}) {
      this.state.isShow = true;
      this.transformMode = mode;
      if (mode === "move") {
        obj2.current = null;
        obj2.points = [];
      }
      obj2.box = obj2.box || "canvas";
      this.changeMode(mode, obj2);
      this.refreshEditorView(obj2, true);
      this.$el.show();
      this.$el.focus();
      this.emit("showPathManager", { mode: this.state.mode });
      this.emit("hidePathDrawEditor");
      this.$context.commands.emit("push.mode.view", "PathEditorView");
    }
    [sapa.SUBSCRIBE("hidePathEditor")]() {
      if (this.$el.isShow()) {
        this.pathParser.reset("");
        this.pathGenerator.setPoints([]);
        this.setState(this.initState(), false);
        this.refs.$view.empty();
        this.$el.hide();
        this.emit("hidePathManager");
        this.$context.commands.emit("pop.mode.view", "PathEditorView");
        this.emit(REFRESH_SELECTION);
      }
    }
    [sapa.SUBSCRIBE("hideAddViewLayer")]() {
      this.state.isShow = false;
      this.state.isControl = false;
      this.pathParser.reset("");
      this.setState(this.initState(), false);
      this.refs.$view.empty();
      this.$el.hide();
      this.emit("hidePathManager");
    }
    [sapa.BIND("$view")]() {
      var _a;
      const path = this.state.isShow ? this.pathGenerator.makeSVGPath() : "";
      const strokeWidth = editor.Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
      return {
        class: {
          path: this.state.mode === "path",
          modify: this.state.mode === "modify",
          transform: this.state.mode === "transform",
          box: this.state.box === "box",
          canvas: this.state.box === "canvas",
          "segment-move": this.state.mode === "segment-move",
          "is-control": this.state.isControl,
          "has-one-stroke-width": strokeWidth === 1
        },
        htmlDiff: path
      };
    }
    [sapa.BIND("$splitCircle")]() {
      if (this.state.splitXY) {
        return {
          cx: this.state.splitXY.x,
          cy: this.state.splitXY.y,
          r: 5
        };
      } else {
        return {
          r: 0
        };
      }
    }
    refreshPathLayer() {
      this.updatePathLayer();
    }
    renderPath() {
      this.bindData("$view");
    }
    getPathRect() {
      this.initRect(true);
      const { d } = this.pathGenerator.toPath();
      return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
    }
    resetTransformZone() {
      var rect2 = this.getPathRect();
      this.state.transformZoneRect = rect2;
    }
    [sapa.POINTERMOVE("$view") + sapa.PREVENT](e) {
      this.initRect();
      if (this.isMode("path") && this.state.rect) {
        this.state.moveXY = {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        };
        this.state.altKey = e.altKey;
        this.renderPath();
      } else {
        var $target = sapa.Dom.create(e.target);
        var isSplitPath = $target.hasClass("split-path");
        if (isSplitPath) {
          this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
            x: e.xy.x - this.state.rect.x,
            y: e.xy.y - this.state.rect.y
          });
        } else {
          this.state.splitXY = null;
        }
        this.bindData("$splitCircle");
        this.state.altKey = false;
      }
    }
    [sapa.POINTERSTART("$view :not(.split-path)") + sapa.PREVENT + sapa.STOP + MOVE() + END()](e) {
      this.initRect();
      this.state.altKey = false;
      var isPathMode = this.isMode("path");
      this.$config.set("set.move.control.point", true);
      this.state.dragXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.$config.set("set.drag.path.area", false);
      var $target = sapa.Dom.create(e.target);
      if ($target.hasClass("svg-editor-canvas") && !isPathMode) {
        this.$config.set("set.drag.path.area", true);
        this.state.isGroupSegment = false;
        this.state.selectedGroupIndex = -1;
        this.state.selectedPointIndex = -1;
      } else {
        this.pathGenerator.reselect();
        this.state.isSegment = $target.attr("data-segment") === "true";
        this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
        this.state.isGroupSegment = $target.hasClass("path-area");
        if (this.state.isGroupSegment) {
          this.state.selectedGroupIndex = +$target.data("group-index");
          this.state.selectedPointIndex = +$target.data("point-index");
        } else {
          this.state.selectedGroupIndex = -1;
          this.state.selectedPointIndex = -1;
        }
      }
      if (isPathMode) {
        if (this.state.isFirstSegment) {
          var index2 = +$target.attr("data-index");
          this.state.startPoint = this.pathGenerator.points[index2].startPoint;
        } else {
          this.state.startPoint = this.state.dragXY;
        }
        this.state.dragPoints = false;
        this.state.endPoint = null;
      } else {
        if (this.state.isSegment) {
          this.changeMode("segment-move");
          var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
          const localIndex = +index2;
          if (e.shiftKey) {
            this.pathGenerator.toggleSelect(segmentKey, localIndex);
          } else {
            this.pathGenerator.setCachePoint(localIndex, segmentKey);
            this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
          }
          this.renderPath();
        } else if (this.state.isGroupSegment) {
          this.changeMode("segment-move");
          this.pathGenerator.selectGroup(this.state.selectedGroupIndex);
          this.renderPath();
        }
      }
    }
    move(dx, dy) {
      var e = this.$config.get("bodyEvent");
      if (this.$config.true("set.drag.path.area")) {
        this.renderSelectBox(this.state.dragXY, dx, dy);
      } else if (this.isMode("segment-move")) {
        this.pathGenerator.move(dx, dy, e);
        this.renderPath();
        this.updatePathLayer();
      } else if (this.isMode("path")) {
        const dist2 = getDist(dx, dy, 0, 0);
        if (dist2 >= 2) {
          this.state.dragPoints = e.altKey ? false : true;
        }
      }
    }
    renderSegment(callback) {
      if (this.pathGenerator.selectedLength) {
        this.pathGenerator.reselect();
        if (sapa.isFunction(callback))
          callback();
        this.renderPath();
        this.updatePathLayer();
      }
    }
    end(dx, dy) {
      var e = this.$config.get("bodyEvent");
      this.$config.set("set.move.control.point", false);
      if (this.state.isGroupSegment) {
        this.pathGenerator.select();
      }
      if (this.$config.true("set.drag.path.area")) {
        if (dx === 0 && dy === 0) {
          this.changeMode("modify");
          this.trigger("hidePathEditor");
        } else {
          this.changeMode("segment-move");
          this.pathGenerator.selectInBox(this.getSelectBox(), e.shiftKey);
          this.renderPath();
          this.hideSelectBox();
        }
      } else if (this.isMode("modify")) {
        this.pathGenerator.reselect();
      } else if (this.isMode("segment-move")) {
        this.changeMode("modify");
        this.pathGenerator.reselect();
        this.renderPath();
        this.updatePathLayer();
      } else if (this.isMode("path")) {
        if (this.state.isFirstSegment) {
          this.changeMode("modify");
          this.pathGenerator.setConnectedPoint(dx, dy);
          this.renderPath();
          if (this.state.current) {
            this.refreshPathLayer();
          } else {
            this.addPathLayer();
            this.trigger("initPathEditorView");
          }
        } else {
          if (this.state.isSplitPath)
            ;
          else {
            this.pathGenerator.moveEnd(dx, dy);
            this.state.clickCount++;
            this.renderPath();
            this.pathGenerator.reselect();
          }
        }
        this.state.isSplitPath = false;
      }
    }
    hideSelectBox() {
      this.refs.$segmentBox.css({
        left: -1e5
      });
    }
    renderSelectBox(startXY = null, dx = 0, dy = 0) {
      var obj2 = {
        left: startXY.x + (dx < 0 ? dx : 0),
        top: startXY.y + (dy < 0 ? dy : 0),
        width: Math.abs(dx),
        height: Math.abs(dy)
      };
      this.refs.$segmentBox.css(obj2);
    }
    getSelectBox() {
      var [x, y, width2, height] = this.refs.$segmentBox.styles("left", "top", "width", "height").map((it) => editor.Length.parse(it));
      var rect2 = {
        x,
        y,
        width: width2,
        height
      };
      rect2.x2 = rect2.x.value + rect2.width;
      rect2.y2 = rect2.y.value + rect2.height;
      return rect2;
    }
    [sapa.SUBSCRIBE("deleteSegment")]() {
      this.pathGenerator.reselect();
      this.pathGenerator.removeSelectedSegment();
      this.renderPath();
      this.updatePathLayer();
    }
    [sapa.SUBSCRIBE("moveSegment")](dx, dy) {
      this.pathGenerator.reselect();
      this.pathGenerator.moveSelectedSegment(dx, dy);
      this.renderPath();
      this.updatePathLayer();
    }
    [sapa.SUBSCRIBE("initPathEditorView")]() {
      this.pathParser.reset("");
      this.setState(this.initState(), false);
      this.state.isShow = true;
      this.refs.$view.empty();
      this.$el.focus();
    }
  }
  var PathManager$1 = "";
  const MODES = {
    "segment-move": "modify",
    modify: "modify",
    path: "path",
    transform: "transform",
    warp: "warp"
  };
  class PathManager extends editor.EditorElement {
    initState() {
      return {
        mode: "move",
        fill: null,
        stroke: null,
        "fill-opacity": null,
        "stroke-width": null,
        msg: this.$i18n("path.manager.msg")
      };
    }
    template() {
      return `
      <div class='elf--path-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='PathEditorDone' title='${this.$i18n("path.manager.mode.modify")}' >Done</button>
        </div>
        <div class='tools' ref='$mode' data-selected-value='${this.state.mode}'>
            <button type="button" data-value='modify' data-tooltip='${this.$i18n("path.manager.mode.modify")}' > ${editor.iconUse("device_hub")}</button>
            <button type="button" data-value='path' data-tooltip='${this.$i18n("path.manager.mode.path")}' > ${editor.iconUse("control_point")}</button>
            <button type="button" data-value='transform' data-tooltip='${this.$i18n("path.manager.mode.transform")}' > ${editor.iconUse("transform")}</button>             
        </div>
        <div class="split"></div>        
        <div class='tools' ref='$util'>
            <button type="button" data-value='reverse' data-tooltip='${this.$i18n("path.manager.mode.reverse")}' >${editor.iconUse("sync")}</button>
        </div>                        
        <div class='tools' ref='$flip'>
            <button type="button" data-value='flipX' data-tooltip='${this.$i18n("path.manager.mode.flipX")}'>${editor.iconUse("flip")}</button>
            <button type="button" data-value='flipY' data-tooltip='${this.$i18n("path.manager.mode.flipY")}'>${editor.iconUse("flip", "rotate(90 12 12)")}</button>
            <button type="button" data-value='flip' data-tooltip='${this.$i18n("path.manager.mode.flipOrigin")}'>${editor.iconUse("flip", "rotate(45 12 12)")}</button>
            <div class="split"></div>            
            <button type="button" data-value='2x' data-tooltip="divide segment by 2 times">2x</button>
            <button type="button" data-value='3x' data-tooltip="divide segment by 3 times">3x</button>            
        </div>
        <div class="subpath" style="display:none">
          <button type="button" data-value="path" data-pathtype="rect">${editor.iconUse("rect", "", { width: 24, height: 24 })}</button>
        </div>
      </div>    
    `;
    }
    [sapa.BIND("$mode")]() {
      return {
        "data-selected-value": MODES[this.state.mode]
      };
    }
    refresh() {
      this.bindData("$mode");
    }
    [sapa.CLICK("$flip button")](e) {
      var transformType = e.$dt.attr("data-value");
      if (transformType === "2x") {
        this.emit("divideSegmentsByCount", 2);
      } else if (transformType === "3x") {
        this.emit("divideSegmentsByCount", 3);
      } else {
        this.emit("changePathTransform", transformType);
      }
    }
    [sapa.CLICK("$util button")](e) {
      var utilType = e.$dt.attr("data-value");
      this.emit("changePathUtil", utilType);
    }
    [sapa.CLICK("$mode button")](e) {
      var mode = e.$dt.attr("data-value");
      this.updateData({
        mode
      });
      this.refresh();
    }
    [sapa.CLICK("$left button")](e) {
      var message = e.$dt.attr("data-value");
      this.emit(message);
    }
    updateData(obj2 = {}) {
      this.setState(obj2, false);
      this.emit(this.state.changeEvent, obj2);
    }
    [sapa.SUBSCRIBE("changePathManager")](mode) {
      this.setState({ mode });
    }
    [sapa.SUBSCRIBE("showPathManager")](obj2 = {}) {
      obj2.changeEvent = obj2.changeEvent || "changePathManager";
      this.setState(obj2);
      this.$el.show();
    }
    [sapa.SUBSCRIBE("hidePathManager")]() {
      this.$el.hide();
    }
  }
  function pathEditorView(editor2) {
    editor2.registerUI("canvas.view", {
      PathEditorView
    });
    editor2.registerUI("page.subeditor.view", {
      PathManager
    });
  }
  var PathToolProperty$1 = "";
  class PathToolProperty extends editor.BaseProperty {
    components() {
      return {
        LeftAlign,
        CenterAlign,
        RightAlign,
        TopAlign,
        MiddleAlign,
        BottomAlign,
        SameWidth,
        SameHeight
      };
    }
    getTitle() {
      return this.$i18n("alignment.property.title");
    }
    isHideHeader() {
      return true;
    }
    getBody() {
      return `
      <div class="elf--boolean-item" ref="$buttons">
        <div>
          <button type="button" data-command="convert.path.operation" data-args="union">${editor.iconUse("boolean_union", "", { width: 30, height: 30 })} Union</button>        
          <button type="button" data-command="convert.path.operation" data-args="intersection">${editor.iconUse("boolean_intersection", "", { width: 30, height: 30 })} Intersection</button>        
        </div>
        <div>
          <button type="button" data-command="convert.path.operation" data-args="difference">${editor.iconUse("boolean_difference", "", { width: 30, height: 30 })} Subtract</button>        
          <button type="button" data-command="convert.path.operation" data-args="xor">${editor.iconUse("boolean_xor", "", { width: 30, height: 30 })} Exclude</button>        
        </div>
        <div class="divider"></div>
        <!--div>
          <button type="button" data-command="convert.no.transform.path">${editor.iconUse("grid3x3", "", { width: 24, height: 24 })} No Transform</button>        
        </div-->
        <div>
          <button type="button" data-command="convert.simplify.path">${editor.iconUse("grid3x3", "", { width: 24, height: 24 })} Self Intersection</button>        
          <button type="button" data-command="convert.flatten.path">${editor.iconUse("flatten", "", { width: 24, height: 24 })} Flatten</button>                  
        </div>        
        <div>
          <!--<button type="button" data-command="convert.smooth.path">${editor.iconUse("smooth", "", { width: 24, height: 24 })} Smooth Path</button>-->                
          <button type="button" data-command="switch.path">${editor.iconUse("sync", "", { width: 30, height: 30 })} Switch path</button>                  
          <button type="button" data-command="convert.stroke.to.path">${editor.iconUse("outline_shape", "", { width: 24, height: 24 })} Outline Path</button> 
        </div>        
        <!--div>
          <button type="button" data-command="convert.polygonal.path">${editor.iconUse("highlight_at", "", { width: 24, height: 24 })} Polygonal</button>                
          <button type="button" data-command="convert.normalize.path">${editor.iconUse("stroke_to_path", "", { width: 24, height: 24 })} Normalize</button> 
        </div-->                
      </div>
    `;
    }
    [sapa.CLICK("$buttons button")](e) {
      const command = e.$dt.data("command");
      const args2 = e.$dt.data("args");
      if (command === "convert.smooth.path") {
        this.$commands.emit(command);
      } else {
        this.$commands.emit(command, args2);
      }
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refreshShow(() => {
        if (this.$context.selection.length === 1 && this.$context.selection.is("boolean-path"))
          return true;
        return this.$context.selection.is("svg-path", "polygon", "star");
      });
    }
  }
  function pathTool(editor2) {
    editor2.registerUI("inspector.tab.style", {
      PathToolProperty
    });
  }
  var PatternEditor$1 = "";
  class PatternEditor extends editor.EditorElement {
    initState() {
      return {
        hideLabel: this.props.hideLabel,
        value: this.props.value,
        patterns: this.parsePattern(this.props.value)
      };
    }
    parsePattern(str) {
      if (str === "undefined")
        return [];
      return Pattern.parseStyle(str);
    }
    setValue(value) {
      this.setState({
        value,
        patterns: this.parsePattern(value)
      });
    }
    template() {
      return `
            <div class='elf--pattern-editor' >
                <div class='pattern-list' ref='$patternList'></div>
            </div>
        `;
    }
    [sapa.LOAD("$patternList")]() {
      return this.state.patterns.map((it, index2) => {
        const selectedClass = it.selected ? "selected" : "";
        if (it.selected) {
          this.selectedIndex = index2;
        }
        return `
            <div class='pattern-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true'>
                ${sapa.createComponent("PatternSizeEditor", {
          key: "pattern-size",
          ref: `$bp${index2}`,
          type: it.type,
          x: it.x,
          y: it.y,
          width: it.width,
          height: it.height,
          index: index2,
          foreColor: it.foreColor,
          backColor: it.backColor,
          blendMode: it.blendMode,
          lineWidth: it.lineWidth,
          lineHeight: it.lineHeight,
          onchange: "changePatternSizeInfo"
        })}
                <div class='tools'>
                    <button type="button" class='remove' title='Remove a pattern' data-index='${index2}'>${editor.iconUse("remove")}</button>
                </div>
            </div>
            `;
      });
    }
    modifyPattern() {
      var value = Pattern.join(this.state.patterns);
      this.parent.trigger(this.props.onchange, this.props.key, value);
    }
    [sapa.SUBSCRIBE("add")](type = "check") {
      var pattern = patterns.find((it) => it.key === type);
      if (pattern) {
        const data = Pattern.parseStyle(pattern.execute()[0].pattern);
        this.state.patterns.push.apply(this.state.patterns, data);
        this.refresh();
        this.modifyPattern();
      }
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.DRAGSTART("$patternList .pattern-item")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$patternList .pattern-item") + sapa.PREVENT]() {
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortPattern(startIndex, targetIndex) {
      this.sortItem(this.state.patterns, startIndex, targetIndex);
    }
    [sapa.DROP("$patternList .pattern-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      this.selectItem(this.startIndex, true);
      this.sortPattern(this.startIndex, targetIndex);
      this.modifyPattern();
      this.refresh();
    }
    getCurrentPattern() {
      return this.state.patterns[this.selectedIndex];
    }
    [sapa.CLICK("$patternList .tools .remove")](e) {
      var removeIndex = +e.$dt.attr("data-index");
      this.state.patterns.splice(removeIndex, 1);
      this.modifyPattern();
      this.refresh();
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.refs[`fillIndex${selectedIndex}`].addClass("selected");
      } else {
        this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
      }
      this.state.patterns.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
    [sapa.SUBSCRIBE("changePatternSizeInfo") + sapa.DEBOUNCE(10)](key, value, index2) {
      var pattern = this.state.patterns[index2];
      pattern.reset(value);
      this.modifyPattern();
      this.refresh();
    }
  }
  var PatternInfoPopup$1 = "";
  class PatternInfoPopup extends editor.BasePopup {
    getClassName() {
      return "pattern-info-popup";
    }
    getTitle() {
      return this.$i18n("pattern.info.popup.title");
    }
    initState() {
      return {
        type: this.props.type || "grid",
        x: this.props.x || 0,
        y: this.props.y || 0,
        width: this.props.width || 0,
        height: this.props.height || 0,
        lineWidth: this.props.lineWidth || 1,
        lineHeight: this.props.lineHeight || 1,
        foreColor: this.props.foreColor || "black",
        backColor: this.props.backColor || "transparent",
        blendMode: this.props.blendMode || "normal"
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      const {
        x,
        y,
        width: width2,
        height,
        foreColor,
        backColor,
        blendMode,
        lineWidth,
        lineHeight
      } = this.state;
      this.state.instance.trigger(this.state.changeEvent, {
        x,
        y,
        width: width2,
        height,
        foreColor,
        backColor,
        blendMode,
        lineWidth,
        lineHeight
      });
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      this.updateData({ [key]: value });
    }
    templateForX() {
      if (this.hasNotX())
        return "";
      let label = "X";
      let units = "";
      if (this.state.type === "diagonal-line") {
        label = this.$i18n("pattern.info.popup.rotate");
        units = ["deg"];
      }
      return sapa.createComponent("InputRangeEditor", {
        label,
        ref: "$x",
        key: "x",
        value: this.state.x,
        min: 0,
        max: 1e3,
        step: 1,
        units,
        onchange: "changeRangeEditor"
      });
    }
    templateForY() {
      if (this.hasNotY())
        return "<div></div>";
      return sapa.createComponent("InputRangeEditor", {
        label: "Y",
        ref: "$y",
        key: "y",
        value: this.state.y,
        min: 0,
        max: 1e3,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForLabel() {
      return `<label>${this.state.type}</label>`;
    }
    templateForWidth() {
      return sapa.createComponent("InputRangeEditor", {
        label: this.$i18n("pattern.info.popup.width"),
        ref: "$width",
        key: "width",
        value: this.state.width,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForHeight() {
      return sapa.createComponent("InputRangeEditor", {
        label: this.$i18n("pattern.info.popup.height"),
        ref: "$height",
        key: "height",
        value: this.state.height,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    hasNotLineWidth() {
      return ["check"].includes(this.state.type);
    }
    hasNotLineHeight() {
      return [
        "cross-dot",
        "dot",
        "check",
        "diagonal-line",
        "horizontal-line"
      ].includes(this.state.type);
    }
    hasNotX() {
      return ["grid", "dot", "horizontal-line"].includes(this.state.type);
    }
    hasNotY() {
      return ["grid", "dot", "diagonal-line", "vertical-line"].includes(this.state.type);
    }
    templateForLineWidth() {
      if (this.hasNotLineWidth())
        return "<div></div>";
      return sapa.createComponent("InputRangeEditor", {
        label: this.$i18n("pattern.info.popup.lineWidth"),
        ref: "$lineWidth",
        key: "lineWidth",
        value: this.state.lineWidth,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForLineHeight() {
      if (this.hasNotLineHeight())
        return "<div></div>";
      return sapa.createComponent("InputRangeEditor", {
        label: this.$i18n("pattern.info.popup.lineHeight"),
        ref: "$lineHeight",
        key: "lineHeight",
        value: this.state.lineHeight,
        min: 0,
        max: 500,
        step: 1,
        onchange: "changeRangeEditor"
      });
    }
    templateForForeColor() {
      return sapa.createComponent("ColorViewEditor", {
        ref: "$foreColor",
        label: this.$i18n("pattern.info.popup.foreColor"),
        key: "foreColor",
        value: this.state.foreColor,
        onchange: "changeRangeEditor"
      });
    }
    templateForBackColor() {
      return sapa.createComponent("ColorViewEditor", {
        ref: "$backColor",
        label: this.$i18n("pattern.info.popup.backColor"),
        key: "backColor",
        value: this.state.backColor,
        onchange: "changeRangeEditor"
      });
    }
    templateForBlendMode() {
      return `
    <div class=''>
      ${sapa.createComponent("BlendSelectEditor", {
        ref: "$blend",
        key: "blendMode",
        label: this.$i18n("pattern.info.popup.blend"),
        value: this.state.blendMode,
        onchange: "changeRangeEditor"
      })}
    </div>
    `;
    }
    getBody() {
      return `
      <div class="background-image-position-picker" ref='$picker'></div>
    `;
    }
    [sapa.LOAD("$picker")]() {
      return `
      
      <div class='box'>
          <div>
            ${this.templateForLabel()}
          </div>
          <div>
            ${this.templateForWidth()}
            ${this.templateForHeight()}        
          </div>
          <div>
            ${this.templateForLineWidth()}
            ${this.templateForLineHeight()}                  
          </div>
          <div>
            ${this.templateForX()}
            ${this.templateForY()}
          </div>
          <div>
            ${this.templateForForeColor()}
            ${this.templateForBackColor()}
          </div>
          <div>
            ${this.templateForBlendMode()}
          </div>
      </div>
    `;
    }
    [sapa.SUBSCRIBE("showPatternInfoPopup")](data, rect2) {
      this.state.changeEvent = data.changeEvent || "changePatternInfoPopup";
      this.state.instance = data.instance;
      this.setState(data.data);
      this.showByRect(rect2);
    }
  }
  var PatternProperty$1 = "";
  class PatternProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("pattern.property.title");
    }
    getClassName() {
      return "el--pattern-property";
    }
    getTitleClassName() {
      return "pattern";
    }
    getBody() {
      return `<div class='pattern-property' ref='$body'></div>`;
    }
    getTools() {
      return `
      <div ref='$tools' class='add-tools'>
        <button type="button" data-pattern='check' data-tooltip="Check">${editor.iconUse("pattern_check")}</button>
        <button type="button" data-pattern='grid' data-tooltip="Grid">${editor.iconUse("pattern_grid")}</button>
        <button type="button" data-pattern='dot' data-tooltip="Dot">${editor.iconUse("pattern_dot")}</button>
        <button type="button" data-pattern='cross-dot' data-tooltip="Cross Dot">${editor.iconUse("pattern_cross_dot", "rotate(45 12 12)")}</button>
        <button type="button" data-pattern='diagonal-line' data-tooltip="Diagonal Line">${editor.iconUse("texture")}</button>
        <button type="button" data-pattern='vertical-line' data-tooltip="Vertical Line" data-direction="bottom right">${editor.iconUse("pattern_horizontal_line", "rotate(90 12 12)")}</button>
        <button type="button" data-pattern='horizontal-line' data-tooltip="Horizontal Line" data-direction="bottom right">${editor.iconUse("pattern_horizontal_line")}</button>
      </div>
    `;
    }
    [sapa.CLICK("$tools button")](e) {
      var patternType = e.$dt.data("pattern");
      this.children.$patternEditor.trigger("add", patternType);
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || {};
      var value = current.pattern;
      return sapa.createComponent("PatternEditor", {
        ref: "$patternEditor",
        value,
        "hide-label": true,
        onchange: "changePatternEditor"
      });
    }
    [sapa.SUBSCRIBE_SELF("changePatternEditor")](key, pattern) {
      this.$commands.executeCommand("setAttribute", "change pattern", this.$context.selection.packByValue({
        pattern
      }));
    }
    get editableProperty() {
      return "pattern";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("refreshSVGArea") + sapa.DEBOUNCE(1e3)]() {
      this.load("$patternSelect");
    }
  }
  var PatternSizeEditor$1 = "";
  class PatternSizeEditor extends editor.EditorElement {
    initState() {
      return {
        index: this.props.index,
        x: editor.Length.parse(this.props.x),
        y: editor.Length.parse(this.props.y),
        width: editor.Length.parse(this.props.width),
        height: editor.Length.parse(this.props.height),
        lineWidth: editor.Length.parse(this.props.lineWidth),
        lineHeight: editor.Length.parse(this.props.lineHeight),
        backColor: this.props.backColor,
        foreColor: this.props.foreColor,
        blendMode: this.props.blendMode,
        type: this.props.type
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.modifyValue(opt);
    }
    modifyValue(value) {
      this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
    }
    setValue(obj2) {
      this.setState(__spreadValues({}, obj2));
    }
    [sapa.BIND("$miniView")]() {
      const {
        type,
        x,
        y,
        width: width2,
        height,
        lineWidth,
        lineHeight,
        backColor,
        foreColor,
        blendMode
      } = this.state;
      let obj2 = {
        type,
        x,
        y,
        width: width2,
        height,
        lineWidth,
        lineHeight,
        backColor,
        foreColor,
        blendMode
      };
      if (this.state.width > 80) {
        obj2.width = 80;
        obj2.x = obj2.x.value / this.state.width / 80;
      }
      if (this.state.height > 80) {
        obj2.height = 80;
        obj2.y = this.state.y.value / this.state.height / 80;
      }
      const pattern = Pattern.parse(obj2);
      return {
        cssText: pattern.toCSS()
      };
    }
    template() {
      return `
            <div class='elf--pattern-size-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK("$preview")]() {
      this.viewBackgroundPositionPopup();
    }
    viewBackgroundPositionPopup() {
      const layoutElement = this.$config.get("editor.layout.elements");
      const bodyRect = layoutElement.$bodyPanel.rect();
      const rect2 = this.$el.rect();
      const newRect = {
        left: bodyRect.left + bodyRect.width - 240,
        top: rect2.top,
        width: 240,
        height: 300
      };
      this.emit("showPatternInfoPopup", {
        changeEvent: (pattern) => {
          this.updateData(__spreadValues({}, pattern));
        },
        data: this.state,
        instance: this
      }, newRect);
    }
  }
  function patternAsset(editor2) {
    editor2.registerElement({
      PatternEditor,
      PatternSizeEditor,
      PatternAssetsProperty
    });
    editor2.registerUI("inspector.tab.style", {
      PatternProperty
    });
    editor2.registerUI("popup", {
      PatternInfoPopup
    });
  }
  var PositionProperty$1 = "";
  const DEFAULT_SIZE = 0;
  class PositionProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("position.property.title");
    }
    afterRender() {
      this.show();
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refreshShowIsNot(["project"]);
    }
    checkChangedValue() {
      var current = this.$context.selection.current;
      if (!current)
        return false;
      return current.hasChangedField("x", "y", "right", "bottom", "width", "height", "angle", "transform", "opacity", "resizingVertical", "resizingHorizontal", "constraints-horizontal", "constriants-vertical");
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.IF("checkChangedValue") + sapa.THROTTLE(10)]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
      this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
      this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
      this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
      this.children.$opacity.setValue(current.opacity || "1");
      this.children.$rotate.setValue(editor.Length.deg(current.angle).round(100));
    }
    isHideHeader() {
      return true;
    }
    getBodyClassName() {
      return "no-padding";
    }
    getBody() {
      return `
      <div class="position-item" ref="$positionItem">
        <div class="grid-layout">
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$x",
        compact: true,
        label: "X",
        key: "x",
        min: -1e5,
        max: 1e5,
        trigger: "enter",
        onchange: "changRangeEditor"
      })}
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$y",
        compact: true,
        trigger: "enter",
        label: "Y",
        key: "y",
        min: -1e4,
        max: 1e4,
        onchange: "changRangeEditor"
      })}
        </div>
        <div class="grid-layout">          
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$width",
        compact: true,
        trigger: "enter",
        label: "W",
        key: "width",
        min: 0,
        max: 3e3,
        onchange: "changRangeEditor"
      })}
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$height",
        compact: true,
        trigger: "enter",
        label: "H",
        key: "height",
        min: 0,
        max: 3e3,
        onchange: "changRangeEditor"
      })}
        </div> 
        <div class="grid-layout">
          ${sapa.createComponent("InputRangeEditor", {
        ref: "$rotate",
        key: "rotateZ",
        compact: true,
        label: "rotate_left",
        min: -360,
        max: 360,
        step: 1,
        units: ["deg"],
        onchange: "changeRotate"
      })}
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$opacity",
        key: "opacity",
        compact: true,
        label: "opacity",
        min: 0,
        max: 1,
        step: 0.01,
        onchange: "changeSelect"
      })}
        </div>                
      </div>
    `;
    }
    refresh() {
      const current = this.$context.selection.current;
      if (current) {
        this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
        this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
        this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
        this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
        this.children.$opacity.setValue(current.opacity || "1");
        this.children.$rotate.setValue(editor.Length.deg(current.angle));
      }
    }
    [sapa.CLICK("$positionItem button[data-command]")](e) {
      const command = e.$dt.data("command");
      console.log(command);
    }
    [sapa.SUBSCRIBE_SELF("changRangeEditor")](key, value) {
      this.$commands.executeCommand("setAttribute", "change position or size", this.$context.selection.packByValue({
        [key]: value
      }));
    }
    [sapa.SUBSCRIBE_SELF("changeRotate")](key, rotate2) {
      this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.packByValue({
        angle: rotate2.value
      }));
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value) {
      this.$commands.executeCommand("setAttribute", `change ${key}`, this.$context.selection.packByValue({
        [key]: value
      }));
    }
  }
  function position(editor2) {
    editor2.registerUI("inspector.tab.style", {
      PositionProperty
    });
  }
  var ProjectProperty$1 = "";
  class ProjectProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("project.property.title");
    }
    getClassName() {
      return "full";
    }
    getTools() {
      return `
      <button type='button' ref='$add' data-tooltip="Add a project" data-direction="bottom right">${editor.iconUse("add")}</button>
    `;
    }
    [sapa.CLICK("$add")]() {
      this.$commands.emit("addProject");
    }
    getBody() {
      return `
      <div class="elf--project-list scrollbar" ref="$projectList"></div>
    `;
    }
    [sapa.LOAD("$projectList") + sapa.DOMDIFF]() {
      var _a;
      var projects = ((_a = this.$model) == null ? void 0 : _a.projects) || [];
      return projects.map((projectId) => {
        var selected = projectId === this.$context.selection.currentProject.id ? "selected" : "";
        const project2 = this.$model.get(projectId);
        return `
        <div class='project-item ${selected}'>
          <div class='detail'>
            <label data-id='${projectId}'>${project2.name || "New Project"}</label>
            <div class="tools">
              <button type="button" class="remove" data-id="${projectId}" title='Remove'>${editor.iconUse("remove2")}</button>
            </div>
          </div>
        </div>
      `;
      });
    }
    [sapa.DOUBLECLICK("$projectList .project-item")](e) {
      this.startInputEditing(e.$dt.$("label"));
    }
    modifyDoneInputEditing(input) {
      this.endInputEditing(input, (index2, text2) => {
        var project2 = this.$editor.projects[index2];
        if (project2) {
          project2.reset({
            name: text2
          });
        }
      });
    }
    [sapa.KEYDOWN("$projectList .project-item label") + sapa.ENTER + sapa.PREVENT + sapa.STOP](e) {
      this.modifyDoneInputEditing(e.$dt);
      return false;
    }
    [sapa.FOCUSOUT("$projectList .project-item label") + sapa.PREVENT + sapa.STOP](e) {
      this.modifyDoneInputEditing(e.$dt);
    }
    [sapa.CLICK("$projectList .project-item label")](e) {
      var id = e.$dt.attr("data-id");
      this.commands.executeCommand("refreshSelectionPorject", "change project", id);
      this.nextTick(() => {
        this.refresh();
      });
    }
    [sapa.CLICK("$projectList .project-item .remove")](e) {
      var id = e.$dt.attr("data-id");
      this.$commands.executeCommand("removeProject", "remove project", id);
      this.nextTick(() => {
        this.refresh();
      });
    }
    [sapa.SUBSCRIBE("refreshProjectList", "refreshAll")]() {
      this.refresh();
    }
  }
  function project(editor2) {
    editor2.registerElement({
      ProjectProperty
    });
  }
  class JSONRenderer {
    constructor(editor2) {
      this.editor = editor2;
    }
    getDefaultRendererInstance() {
      return this.editor.getRendererInstance("json", "rect");
    }
    getRendererInstance(item) {
      return this.editor.getRendererInstance("json", item.itemType) || this.getDefaultRendererInstance() || item;
    }
    async render(item, renderer) {
      if (!item)
        return;
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return await currentRenderer.render(item, renderer || this);
      }
    }
    async renderAll(items, renderer) {
      return await Promise.all(items.map(async (it) => {
        return await this.render(it, renderer);
      }));
    }
    async getResourceDataURI() {
    }
  }
  class ItemRender$1 {
    async render(item, renderer) {
      return await this.toCloneObject(item, renderer);
    }
    async toCloneObject(item, renderer) {
      var json = item.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
      if (item.parent && item.parent.isNot("project")) {
        json.parentId = item.parentId;
      }
      json.referenceId = item.id;
      json.newTargetId = uuid();
      let layers = [];
      for (var i = 0, len2 = item.layers.length; i < len2; i++) {
        layers.push(await renderer.render(item.layers[i], renderer));
      }
      json.layers = layers;
      return json;
    }
  }
  class BaseAssetRender extends ItemRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("svgfilters", "keyframes"));
    }
  }
  class GroupRender extends BaseAssetRender {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("layout", "constraintsHorizontal", "constraintsVertical", "resizingMode", "flexDirection", "flexWrap", "flexFlow", "justifyContent", "alignItems", "alignContent", "order", "flexBasis", "flexGrow", "flexShrink", "gap", "gridTemplateRows", "gridTemplateColumns", "gridTemplateAreas", "gridAutoRows", "gridAutoColumns", "gridAutoFlow", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridColumnGap", "gridRowGap", "animation", "transition", "paddingTop", "paddingRight", "paddingLeft", "paddingBottom"));
    }
  }
  class MovableRender extends GroupRender {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("x", "y", "right", "bottom", "width", "height", "angle", "transformOrigin"));
    }
  }
  class DomRender$1 extends MovableRender {
    async toCloneObject(item, renderer) {
      return __spreadProps(__spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("position", "rootVariable", "variable", "filter", "backdropFilter", "backgroundColor", "backgroundImage", "textClip", "borderRadius", "border", "boxShadow", "textShadow", "clipPath", "color", "fontSize", "lineHeight", "textAlign", "textTransform", "textDecoration", "letterSpacing", "wordSpacing", "textIndent", "perspectiveOrigin", "transformStyle", "perspective", "mixBlendMode", "overflow", "opacity", "animation", "transition")), {
        selectors: item.selectors.map((selector2) => selector2.clone()),
        svg: item.svg.map((svg) => svg.clone())
      });
    }
  }
  class ArtBoardRender$2 extends DomRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name"));
    }
  }
  class LayerRender$1 extends DomRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("tagName"));
    }
  }
  class SVGItemRender$2 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("overflow", "stroke", "stroke-width", "svgfilter", "fill", "fill-rule", "fill-opacity", "stroke-linecap", "stroke-linejoin", "stroke-dashoffset", "stroke-dasharray", "text-anchor"));
    }
  }
  class BooleanPathRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d", "booleanOperation"));
    }
  }
  class CircleRender$2 extends LayerRender$1 {
  }
  class IFrameRender$1 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
    }
  }
  class ImageRender$2 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      const project2 = item.project;
      const image2 = project2.imageKeys[item.src];
      const src = image2.original;
      return __spreadProps(__spreadValues({}, await super.toCloneObject(item, renderer)), {
        src
      });
    }
  }
  class AssetRender extends ItemRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("colors", "gradients", "svgfilters", "svgimages", "images", "keyframes"));
    }
  }
  class TimelineRender extends AssetRender {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("timeline"));
    }
  }
  class ProjectRender$2 extends TimelineRender {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name", "description", "rootVariable"));
    }
  }
  class RectRender$2 extends LayerRender$1 {
  }
  class SplineRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("points", "boundary"));
    }
  }
  class SVGPathRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d"));
    }
  }
  class SVGPolygonRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count"));
    }
  }
  class SVGStarRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count", "radius"));
    }
  }
  class SVGTextPathRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "d", "text", "textLength", "lengthAdjust", "startOffset"));
    }
  }
  class SVGTextRender$2 extends SVGItemRender$2 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "text", "textLength", "lengthAdjust", "shape-inside"));
    }
  }
  class TemplateRender$2 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("engine", "template", "params"));
    }
  }
  class TextRender$2 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("content"));
    }
  }
  class VideoRender$2 extends LayerRender$1 {
    async toCloneObject(item, renderer) {
      return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
    }
  }
  function rendererJson(editor2) {
    editor2.registerRendererType("json", new JSONRenderer(editor2));
    editor2.registerRenderer("json", "project", new ProjectRender$2());
    editor2.registerRenderer("json", "artboard", new ArtBoardRender$2());
    editor2.registerRenderer("json", "rect", new RectRender$2());
    editor2.registerRenderer("json", "circle", new CircleRender$2());
    editor2.registerRenderer("json", "image", new ImageRender$2());
    editor2.registerRenderer("json", "template", new TemplateRender$2());
    editor2.registerRenderer("json", "iframe", new IFrameRender$1());
    editor2.registerRenderer("json", "text", new TextRender$2());
    editor2.registerRenderer("json", "video", new VideoRender$2());
    editor2.registerRenderer("json", "svg-path", new SVGPathRender$2());
    editor2.registerRenderer("json", "boolean-path", new BooleanPathRender$2());
    editor2.registerRenderer("json", "polygon", new SVGPolygonRender$2());
    editor2.registerRenderer("json", "star", new SVGStarRender$2());
    editor2.registerRenderer("json", "spline", new SplineRender$2());
    editor2.registerRenderer("json", "svg-text", new SVGTextRender$2());
    editor2.registerRenderer("json", "svg-textpath", new SVGTextPathRender$2());
  }
  class SampleLayer extends LayerModel {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "sample",
        name: "New Sample Layer",
        sampleText: "Sample Text 1",
        sampleNumber: 1
      }, obj2));
    }
    get sampleText() {
      return this.get("sampleText");
    }
    set sampleText(value) {
      this.set("sampleText", value);
    }
    get sampleNumber() {
      return this.get("sampleNumber");
    }
    set sampleNumber(value) {
      this.set("sampleNumber", value);
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("sampleText", "sampleNumber"));
    }
    editable(editablePropertyName) {
      switch (editablePropertyName) {
        case "sample":
          return true;
      }
      return super.editable(editablePropertyName);
    }
    getDefaultTitle() {
      return "Sample Layer";
    }
  }
  class ItemRender {
    constructor(renderer) {
      this.renderer = renderer;
    }
    setRenderer(renderer) {
      this.renderer = renderer;
    }
    getInnerId(item, postfix = "") {
      return item.id + postfix;
    }
    uniqueId(item) {
      return this.renderer.id + "-" + item.id;
    }
  }
  const Primitive = "SourceGraphic,SourceAlpha,BackgroundImage,BackgroundAlpha,FillPaint,StrokePaint".split(",");
  const DEFAULT_ATTRIBUTES = {
    xChannelSelector: true,
    yChannelSelector: true
  };
  class BaseSVGFilter extends PropertyItem {
    static parse(obj2) {
      var FilterClass = SVGFilterClassName[obj2.type];
      return new FilterClass(obj2);
    }
    hasLight() {
      return false;
    }
    isLight() {
      return false;
    }
    isSource() {
      return false;
    }
    getDefaultObject(obj2 = {}) {
      var id = uuidShort();
      return super.getDefaultObject(__spreadValues({
        itemType: "svgfilter",
        id,
        in: [],
        bound: { x: 100, y: 100, targetX: 0, targetY: 0 },
        connected: []
      }, obj2));
    }
    getInCount() {
      return 0;
    }
    setIn(index2, target) {
      this.json.in[index2] = { id: target.id, type: target.type };
    }
    setConnected(target) {
      var f = this.json.connected.filter((c) => c.id === target.id);
      if (f.length === 0) {
        this.json.connected.push({ id: target.id });
      }
    }
    convert(json) {
      if (typeof json.in === "string") {
        json.in = JSON.parse(json.in);
      }
      if (typeof json.bound === "string") {
        json.bound = JSON.parse(json.bound);
      }
      if (typeof json.connected === "string") {
        json.connected = JSON.parse(json.connected);
      }
      return json;
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("id", "in", "bound", "connected"));
    }
    getDefaultAttribute() {
      var list = [];
      if (this.json.connected.length) {
        list.push(`result="${this.json.id}result"`);
      }
      Object.keys(DEFAULT_ATTRIBUTES).filter((key) => {
        return !!this.json[key];
      }).forEach((key) => {
        list.push(`${key}="${this.json[key]}"`);
      });
      return list.join(" ") + " " + this.getSourceInAttribute();
    }
    hasInIndex() {
      return false;
    }
    getSourceInAttribute(inList) {
      return (inList || this.json.in).map((it, index2) => {
        if (!it)
          return "";
        var indexString = index2 === 0 ? "" : index2 + 1 + "";
        if (!this.hasInIndex()) {
          indexString = "";
        }
        if (Primitive.includes(it.type)) {
          return `in${indexString}="${it.type}"`;
        }
        return `in${indexString}="${it.id}result"`;
      }).join(" ");
    }
    toString() {
      var { type, value } = this.json;
      return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
    }
  }
  class SourceSVGFilter extends BaseSVGFilter {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        type: "Source"
      }, obj2));
    }
    isSource() {
      return true;
    }
    toString() {
      return "";
    }
  }
  class BackgroundAlphaSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "BackgroundAlpha"
      });
    }
  }
  class BackgroundImageSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "BackgroundImage"
      });
    }
  }
  class BlendSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Blend",
        mode: BlendSVGFilter.spec.mode.defaultValue
      });
    }
    getInCount() {
      return 2;
    }
    toString() {
      var { mode } = this.json;
      return `<feBlend ${OBJECT_TO_PROPERTY({
        mode
      })} ${this.getDefaultAttribute()} />`;
    }
    hasInIndex() {
      return true;
    }
  }
  BlendSVGFilter.spec = {
    mode: {
      title: "mode",
      inputType: "blend",
      defaultValue: "normal"
    }
  };
  class ColorMatrixSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "ColorMatrix",
        values: ColorMatrixSVGFilter.spec.values.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { values } = this.json;
      var valueString = values.join(" ");
      return `<feColorMatrix type="matrix" values="${valueString}"  ${this.getDefaultAttribute()} />`;
    }
  }
  ColorMatrixSVGFilter.spec = {
    values: {
      title: "values",
      inputType: "color-matrix",
      column: 5,
      defaultValue: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
    }
  };
  class ComponentTransferSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "ComponentTransfer",
        r: ComponentTransferSVGFilter.spec.r.defaultValue,
        g: ComponentTransferSVGFilter.spec.g.defaultValue,
        b: ComponentTransferSVGFilter.spec.b.defaultValue,
        a: ComponentTransferSVGFilter.spec.a.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    parse(value) {
      var [type, ...values] = value.split(" ");
      if (type === "table" || type === "discrete") {
        return { type, tableValues: values.join(" ") };
      }
      if (type === "linear") {
        var [slop, intercept] = values;
        return { type, slop, intercept };
      } else if (type === "gamma") {
        var [amplitude, exponent, offset] = values;
        return { type, amplitude, exponent, offset };
      }
      return { type };
    }
    toString() {
      var { r, g, b, a } = this.json;
      r = this.parse(r);
      g = this.parse(g);
      b = this.parse(b);
      a = this.parse(a);
      return `<feComponentTransfer ${this.getDefaultAttribute()} >
      ${r && `<feFuncR ${OBJECT_TO_PROPERTY(r)} />`}
      ${g && `<feFuncG ${OBJECT_TO_PROPERTY(g)} />`}
      ${b && `<feFuncB ${OBJECT_TO_PROPERTY(b)} />`}
      ${a && `<feFuncA ${OBJECT_TO_PROPERTY(a)} />`}
    </feComponentTransfe>`;
    }
  }
  ComponentTransferSVGFilter.spec = {
    r: {
      title: "R",
      inputType: "FuncFilter",
      defaultValue: "identity"
    },
    g: {
      title: "G",
      inputType: "FuncFilter",
      defaultValue: "identity"
    },
    b: {
      title: "B",
      inputType: "FuncFilter",
      defaultValue: "identity"
    },
    a: {
      title: "A",
      inputType: "FuncFilter",
      defaultValue: "identity"
    }
  };
  class CompositeSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Composite",
        operator: CompositeSVGFilter.spec.operator.defaultValue,
        k1: CompositeSVGFilter.spec.k1.defaultValue,
        k2: CompositeSVGFilter.spec.k2.defaultValue,
        k3: CompositeSVGFilter.spec.k3.defaultValue,
        k4: CompositeSVGFilter.spec.k4.defaultValue
      });
    }
    getInCount() {
      return 2;
    }
    toString() {
      var { operator, k1, k2, k3, k4 } = this.json;
      var kNumbers = "";
      if (operator === "arithmetic") {
        kNumbers = ` k1="${k1}" k2="${k2}" k3="${k3}" k4="${k4}" `;
      }
      return `<feComposite operator="${operator}" ${kNumbers}  ${this.getDefaultAttribute()} />`;
    }
    hasInIndex() {
      return true;
    }
  }
  CompositeSVGFilter.spec = {
    operator: {
      title: "operator",
      inputType: "select",
      options: "over,in,out,atop,xor,arithmetic",
      defaultValue: "over"
    },
    k1: {
      title: "k1",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    },
    k2: {
      title: "k2",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    },
    k3: {
      title: "k3",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    },
    k4: {
      title: "k4",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    }
  };
  class ConvolveMatrixSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "ConvolveMatrix",
        kernelMatrix: ConvolveMatrixSVGFilter.spec.kernelMatrix.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { kernelMatrix } = this.json;
      var valueString = kernelMatrix.join(" ");
      return `<feConvolveMatrix kernelMatrix="${valueString}"  ${this.getDefaultAttribute()} />`;
    }
  }
  ConvolveMatrixSVGFilter.spec = {
    kernelMatrix: {
      title: "kernelMatrix",
      inputType: "input-array",
      column: 3,
      defaultValue: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
  };
  class DiffuseLightingSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "DiffuseLighting",
        surfaceScale: DiffuseLightingSVGFilter.spec.surfaceScale.defaultValue,
        lightingColor: DiffuseLightingSVGFilter.spec.lightingColor.defaultValue,
        diffuseConstant: DiffuseLightingSVGFilter.spec.diffuseConstant.defaultValue,
        lightInfo: ""
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "diffuseConstant", "lightInfo"));
    }
    hasLight() {
      return true;
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { surfaceScale, diffuseConstant, lightingColor } = this.json;
      return `<feDiffuseLighting ${OBJECT_TO_PROPERTY({
        surfaceScale,
        diffuseConstant,
        "lighting-color": lightingColor
      })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feDiffuseLighting>`;
    }
  }
  DiffuseLightingSVGFilter.spec = {
    surfaceScale: {
      title: "surfaceScale",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    diffuseConstant: {
      title: "diffuseConstant",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    lightingColor: {
      title: "Lighting Color",
      inputType: "color",
      defaultValue: "rgba(0, 0, 0, 1)"
    }
  };
  class DisplacementMapSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "DisplacementMap",
        scale: DisplacementMapSVGFilter.spec.scale.defaultValue
      });
    }
    getInCount() {
      return 2;
    }
    convert(obj2) {
      obj2.scale = editor.Length.parse(obj2.scale);
      return obj2;
    }
    toString() {
      var { scale: scale2 } = this.json;
      var scaleOption = scale2.value ? `scale="${scale2}"` : "";
      return `<feDisplacementMap ${scaleOption}  ${this.getDefaultAttribute()} />`;
    }
    hasInIndex() {
      return true;
    }
  }
  DisplacementMapSVGFilter.spec = {
    scale: {
      title: "scale",
      inputType: "number-range",
      min: 0,
      max: 5e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class DistantLightSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "DistantLight",
        azimuth: DistantLightSVGFilter.spec.azimuth.defaultValue,
        elevation: DistantLightSVGFilter.spec.elevation.defaultValue
      });
    }
    isLight() {
      return true;
    }
    toString() {
      return "";
    }
    toLightString() {
      var { azimuth, elevation } = this.json;
      return `<feDistantLight ${OBJECT_TO_PROPERTY({
        azimuth,
        elevation
      })} />`;
    }
  }
  DistantLightSVGFilter.spec = {
    azimuth: {
      title: "azimuth",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    elevation: {
      title: "elevation",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class DropShadowSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "DropShadow",
        dx: DropShadowSVGFilter.spec.dx.defaultValue,
        dy: DropShadowSVGFilter.spec.dy.defaultValue,
        stdDeviation: DropShadowSVGFilter.spec.stdDeviation.defaultValue,
        color: DropShadowSVGFilter.spec.color.defaultValue,
        opacity: DropShadowSVGFilter.spec.opacity.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { dx, dy, stdDeviation, color, opacity } = this.json;
      return `<feDropShadow ${OBJECT_TO_PROPERTY({
        dx,
        dy,
        stdDeviation,
        "flood-color": color,
        "flood-opacity": opacity
      })}  ${this.getDefaultAttribute()} />`;
    }
  }
  DropShadowSVGFilter.spec = {
    dx: {
      title: "dx",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    dy: {
      title: "dy",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    stdDeviation: {
      title: "stdDeviation",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 0.1,
      defaultValue: editor.Length.number(0)
    },
    opacity: {
      title: "opacity",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(1)
    },
    color: {
      title: "color",
      inputType: "color",
      defaultValue: "rgba(0, 0, 0, 1)"
    }
  };
  class FillPaintSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "FillPaint"
      });
    }
  }
  class FloodSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Flood",
        x: FloodSVGFilter.spec.x.defaultValue,
        y: FloodSVGFilter.spec.y.defaultValue,
        width: FloodSVGFilter.spec.width.defaultValue,
        height: FloodSVGFilter.spec.height.defaultValue,
        color: FloodSVGFilter.spec.color.defaultValue,
        opacity: FloodSVGFilter.spec.opacity.defaultValue
      });
    }
    convert(json) {
      json.x = editor.Length.parse(json.x);
      json.y = editor.Length.parse(json.y);
      json.width = editor.Length.parse(json.width);
      json.height = editor.Length.parse(json.height);
      return json;
    }
    toString() {
      const { opacity, color, x, y, width: width2, height } = this.json;
      return `<feFlood ${OBJECT_TO_PROPERTY({
        x,
        y,
        width: width2,
        height
      })} flood-opacity="${opacity}" flood-color="${color}" ${this.getDefaultAttribute()} />`;
    }
  }
  FloodSVGFilter.spec = {
    x: {
      title: "X",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    y: {
      title: "Y",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    width: {
      title: "width",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    height: {
      title: "height",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    opacity: {
      title: "opacity",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    },
    color: {
      title: "color",
      inputType: "color",
      defaultValue: "rgba(0, 0, 0, 1)"
    }
  };
  class GaussianBlurSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "GaussianBlur",
        stdDeviationX: GaussianBlurSVGFilter.spec.stdDeviationX.defaultValue,
        stdDeviationY: GaussianBlurSVGFilter.spec.stdDeviationY.defaultValue,
        edgeMode: GaussianBlurSVGFilter.spec.edgeMode.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    convert(obj2) {
      obj2.stdDeviationX = editor.Length.parse(obj2.stdDeviationX);
      obj2.stdDeviationY = editor.Length.parse(obj2.stdDeviationY);
      return obj2;
    }
    toString() {
      var { stdDeviationX, stdDeviationY, edgeMode } = this.json;
      var stdDeviation = `${stdDeviationX} ${stdDeviationY}`;
      if (stdDeviationX === stdDeviationY) {
        stdDeviation = stdDeviationX;
      }
      return `<feGaussianBlur  stdDeviation="${stdDeviation}" edgeMode="${edgeMode}"  ${this.getDefaultAttribute()} />`;
    }
  }
  GaussianBlurSVGFilter.spec = {
    stdDeviationX: {
      title: "X",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    stdDeviationY: {
      title: "Y",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    edgeMode: {
      title: "edge",
      inputType: "select",
      options: "none,duplicate,wrap",
      defaultValue: "none"
    }
  };
  class HueRotateSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "HueRotate",
        values: HueRotateSVGFilter.spec.values.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { values } = this.json;
      return `<feColorMatrix type="hueRotate" values="${values}"  ${this.getDefaultAttribute()} />`;
    }
  }
  HueRotateSVGFilter.spec = {
    values: {
      title: "values",
      inputType: "number-range",
      min: 0,
      max: 360,
      step: 0.1,
      defaultValue: editor.Length.number(0)
    }
  };
  class ImageSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Image",
        x: ImageSVGFilter.spec.x.defaultValue,
        y: ImageSVGFilter.spec.y.defaultValue,
        width: ImageSVGFilter.spec.width.defaultValue,
        height: ImageSVGFilter.spec.height.defaultValue,
        src: ImageSVGFilter.spec.src.defaultValue,
        alignment: ImageSVGFilter.spec.alignment.defaultValue,
        scaleing: ImageSVGFilter.spec.scaleing.defaultValue
      });
    }
    convert(json) {
      json.x = editor.Length.parse(json.x);
      json.y = editor.Length.parse(json.y);
      json.width = editor.Length.parse(json.width);
      json.height = editor.Length.parse(json.height);
      return json;
    }
    toString() {
      const { src, x, y, width: width2, height, alignment: alignment2, scaleing } = this.json;
      return `<feImage ${OBJECT_TO_PROPERTY({
        x,
        y,
        width: width2,
        height,
        "xlink:href": src,
        preserveAspectRatio: `${alignment2} ${scaleing}`
      })} ${this.getDefaultAttribute()} />`;
    }
  }
  ImageSVGFilter.spec = {
    x: {
      title: "X",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    y: {
      title: "Y",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    width: {
      title: "width",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    height: {
      title: "height",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    alignment: {
      title: "alignment",
      inputType: "select",
      options: "xMinYMin,xMidYMin,xMaxYMin,xMinYMid,xMidYMid,xMaxYMid,xMinYMax,xMidYMax,xMaxYMax",
      defaultValue: "xMidYMid"
    },
    scaleing: {
      title: "scaleing",
      inputType: "select",
      options: "meet,slice",
      defaultValue: "meet"
    },
    src: {
      title: "Image",
      inputType: "ImageSelectEditor",
      defaultValue: ""
    }
  };
  class LuminanceAlphaSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "LuminanceAlpha"
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      return `<feColorMatrix type="luminanceToAlpha" ${this.getDefaultAttribute()} />`;
    }
  }
  LuminanceAlphaSVGFilter.spec = {};
  class MergeSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Merge"
      });
    }
    getInCount() {
      return 3;
    }
    getDefaultAttribute() {
      var list = [];
      if (this.json.connected.length) {
        list.push(`result="${this.json.id}result"`);
      }
      return list.join(" ");
    }
    toString() {
      var { in: inList } = this.json;
      return `
    <feMerge  ${this.getDefaultAttribute()} >
      ${inList.map((it) => {
        return `<feMergeNode ${this.getSourceInAttribute([it])} />`;
      }).join("")}
    </feMerge>`;
    }
  }
  MergeSVGFilter.spec = {};
  class MorphologySVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Morphology",
        operator: MorphologySVGFilter.spec.operator.defaultValue,
        radius: MorphologySVGFilter.spec.radius.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { operator, radius } = this.json;
      return `<feMorphology operator="${operator}" radius="${radius}"  ${this.getDefaultAttribute()} />`;
    }
  }
  MorphologySVGFilter.spec = {
    operator: {
      title: "Operator",
      inputType: "select",
      options: "erode,dilate",
      defaultValue: "erode"
    },
    radius: {
      title: "Radius",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class OffsetSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Offset",
        dx: OffsetSVGFilter.spec.dx.defaultValue,
        dy: OffsetSVGFilter.spec.dy.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { dx, dy } = this.json;
      return `<feOffset 
      ${OBJECT_TO_PROPERTY({
        dx,
        dy
      })}  ${this.getDefaultAttribute()} />`;
    }
  }
  OffsetSVGFilter.spec = {
    dx: {
      title: "dx",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    dy: {
      title: "dy",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class PointLightSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "PointLight",
        x: PointLightSVGFilter.spec.x.defaultValue,
        y: PointLightSVGFilter.spec.y.defaultValue,
        z: PointLightSVGFilter.spec.z.defaultValue
      });
    }
    isLight() {
      return true;
    }
    toString() {
      return "";
    }
    toLightString() {
      var { x, y, z } = this.json;
      return `<fePointLight ${OBJECT_TO_PROPERTY({
        x,
        y,
        z
      })} />`;
    }
  }
  PointLightSVGFilter.spec = {
    x: {
      title: "x",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    y: {
      title: "y",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    z: {
      title: "z",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class RotaMatrixSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "RotaMatrix",
        hueRotate: RotaMatrixSVGFilter.spec.hueRotate.defaultValue
      });
    }
    convert(json) {
      json.hueRotate = editor.Length.parse(json.hueRotate);
      return json;
    }
    toString() {
      var { id, hueRotate } = this.json;
      return `
      <feColorMatrix type="hueRotate" result="romatrix-${id}"  values="${hueRotate}"/>
      <feColorMatrix type="matrix" in="romatrix-${id}" in2="SourceGraphic"  ${this.getDefaultAttribute()} values="-1 2 -3 0 -.5 2 1 0 0 0 0 3 1 0 0 0 0 1 1 0"/>
    `;
    }
  }
  RotaMatrixSVGFilter.spec = {
    hueRotate: {
      title: "hue-rotate",
      inputType: "number-range",
      min: 0,
      max: 360,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class SaturateSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Saturate",
        values: SaturateSVGFilter.spec.values.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { values } = this.json;
      return `<feColorMatrix type="saturate" values="${values}"  ${this.getDefaultAttribute()} />`;
    }
  }
  SaturateSVGFilter.spec = {
    values: {
      title: "values",
      inputType: "number-range",
      min: -1,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    }
  };
  class SourceAlphaSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "SourceAlpha"
      });
    }
  }
  class SourceGraphicSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "SourceGraphic"
      });
    }
  }
  class SpecularLightingSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "SpecularLighting",
        surfaceScale: SpecularLightingSVGFilter.spec.surfaceScale.defaultValue,
        lightingColor: SpecularLightingSVGFilter.spec.lightingColor.defaultValue,
        specularConstant: SpecularLightingSVGFilter.spec.specularConstant.defaultValue,
        specularExponent: SpecularLightingSVGFilter.spec.specularExponent.defaultValue,
        lightInfo: ""
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "specularConstant", "specularExponent", "lightInfo"));
    }
    hasLight() {
      return true;
    }
    getInCount() {
      return 1;
    }
    toString() {
      var { surfaceScale, specularConstant, specularExponent, lightingColor } = this.json;
      return `<feSpecularLighting ${OBJECT_TO_PROPERTY({
        surfaceScale,
        specularConstant,
        specularExponent,
        "lighting-color": lightingColor
      })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feSpecularLighting>`;
    }
    getSourceInAttribute() {
      return "";
    }
  }
  SpecularLightingSVGFilter.spec = {
    surfaceScale: {
      title: "surfaceScale",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    specularConstant: {
      title: "Constant",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    specularExponent: {
      title: "Exponent",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    lightingColor: {
      title: "Lighting Color",
      inputType: "color",
      defaultValue: "rgba(0, 0, 0, 1)"
    }
  };
  class SpotLightSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "SpotLight",
        x: SpotLightSVGFilter.spec.x.defaultValue,
        y: SpotLightSVGFilter.spec.x.defaultValue,
        z: SpotLightSVGFilter.spec.x.defaultValue,
        pointsAtX: SpotLightSVGFilter.spec.pointsAtX.defaultValue,
        pointsAtY: SpotLightSVGFilter.spec.pointsAtY.defaultValue,
        pointsAtZ: SpotLightSVGFilter.spec.pointsAtZ.defaultValue,
        specularExponent: SpotLightSVGFilter.spec.specularExponent.defaultValue,
        limitingConeAngle: SpotLightSVGFilter.spec.limitingConeAngle.defaultValue
      });
    }
    isLight() {
      return true;
    }
    toString() {
    }
    toLightString() {
      var {
        x,
        y,
        z,
        pointsAtX,
        pointsAtY,
        pointsAtZ,
        specularExponent,
        limitingConeAngle
      } = this.json;
      return `<feSpotLight ${OBJECT_TO_PROPERTY({
        x,
        y,
        z,
        pointsAtX,
        pointsAtY,
        pointsAtZ,
        specularExponent,
        limitingConeAngle
      })} />`;
    }
  }
  SpotLightSVGFilter.spec = {
    x: {
      title: "x",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    y: {
      title: "y",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    z: {
      title: "z",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    pointsAtX: {
      title: "pointsAtX",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    pointsAtY: {
      title: "pointsAtY",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    pointsAtZ: {
      title: "pointsAtZ",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    specularExponent: {
      title: "specularExponent",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    limitingConeAngle: {
      title: "limitingConeAngle",
      inputType: "number-range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: editor.Length.number(1)
    }
  };
  class StrokePaintSVGFilter extends SourceSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "StrokePaint"
      });
    }
  }
  class TileSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Tile",
        x: TileSVGFilter.spec.x.defaultValue,
        y: TileSVGFilter.spec.y.defaultValue,
        width: TileSVGFilter.spec.width.defaultValue,
        height: TileSVGFilter.spec.height.defaultValue
      });
    }
    getInCount() {
      return 1;
    }
    convert(json) {
      json.x = editor.Length.parse(json.x);
      json.y = editor.Length.parse(json.y);
      json.width = editor.Length.parse(json.width);
      json.height = editor.Length.parse(json.height);
      return json;
    }
    toString() {
      const { x, y, width: width2, height } = this.json;
      return `<feTile ${OBJECT_TO_PROPERTY({
        x,
        y,
        width: width2,
        height
      })} ${this.getDefaultAttribute()} />`;
    }
  }
  TileSVGFilter.spec = {
    x: {
      title: "X",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    y: {
      title: "Y",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    width: {
      title: "width",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    },
    height: {
      title: "height",
      inputType: "number-range",
      min: 0,
      max: 1e3,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  class TurbulenceSVGFilter extends BaseSVGFilter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "Turbulence",
        filterType: TurbulenceSVGFilter.spec.filterType.defaultValue,
        baseFrequency: TurbulenceSVGFilter.spec.baseFrequency.defaultValue,
        numOctaves: TurbulenceSVGFilter.spec.numOctaves.defaultValue,
        seed: TurbulenceSVGFilter.spec.seed.defaultValue
      });
    }
    convert(obj2) {
      obj2.baseFrequency = editor.Length.parse(obj2.baseFrequency);
      obj2.numOctaves = editor.Length.parse(obj2.numOctaves);
      obj2.seed = editor.Length.parse(obj2.seed);
      return obj2;
    }
    toString() {
      var { filterType, baseFrequency, numOctaves, seed } = this.json;
      return `<feTurbulence ${OBJECT_TO_PROPERTY({
        type: filterType,
        baseFrequency,
        numOctaves,
        seed
      })}   ${this.getDefaultAttribute()} />`;
    }
  }
  TurbulenceSVGFilter.spec = {
    filterType: {
      title: "Type",
      inputType: "select",
      options: "fractalNoise,turbulence",
      defaultValue: "turbulence"
    },
    baseFrequency: {
      title: "Frequency",
      inputType: "number-range",
      min: 0,
      max: 1,
      step: 0.01,
      defaultValue: editor.Length.number(0)
    },
    numOctaves: {
      title: "Octaves",
      inputType: "number-range",
      min: 1,
      max: 10,
      step: 1,
      defaultValue: editor.Length.number(1)
    },
    seed: {
      title: "Seed",
      inputType: "number-range",
      min: 0,
      max: 1e4,
      step: 1,
      defaultValue: editor.Length.number(0)
    }
  };
  const SVG_FILTER_COMMON_ATTRIBUTES = ["result"];
  class SVGFilter extends PropertyItem {
    static parse(obj2) {
      var FilterClass = SVGFilterClassName[obj2.type];
      return new FilterClass(obj2);
    }
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "svgfilter",
        result: ""
      }, obj2));
    }
    getDefaultAttribute() {
      return SVG_FILTER_COMMON_ATTRIBUTES.map((key) => {
        return `${key}="${this.json[key]}"`;
      }).join(" ");
    }
    toString() {
      var { type, value } = this.json;
      return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
    }
  }
  const SVGFilterClassName = {
    Image: ImageSVGFilter,
    Tile: TileSVGFilter,
    Saturate: SaturateSVGFilter,
    HueRotate: HueRotateSVGFilter,
    LuminanceAlpha: LuminanceAlphaSVGFilter,
    DropShadow: DropShadowSVGFilter,
    SourceGraphic: SourceGraphicSVGFilter,
    SourceAlpha: SourceAlphaSVGFilter,
    BackgroundImage: BackgroundImageSVGFilter,
    BackgroundAlpha: BackgroundAlphaSVGFilter,
    FillPaint: FillPaintSVGFilter,
    StrokePaint: StrokePaintSVGFilter,
    ComponentTransfer: ComponentTransferSVGFilter,
    DistantLight: DistantLightSVGFilter,
    PointLight: PointLightSVGFilter,
    SpotLight: SpotLightSVGFilter,
    DiffuseLighting: DiffuseLightingSVGFilter,
    SpecularLighting: SpecularLightingSVGFilter,
    Blend: BlendSVGFilter,
    Offset: OffsetSVGFilter,
    RotaMatrix: RotaMatrixSVGFilter,
    GaussianBlur: GaussianBlurSVGFilter,
    Flood: FloodSVGFilter,
    Merge: MergeSVGFilter,
    Composite: CompositeSVGFilter,
    Morphology: MorphologySVGFilter,
    Turbulence: TurbulenceSVGFilter,
    DisplacementMap: DisplacementMapSVGFilter,
    ColorMatrix: ColorMatrixSVGFilter,
    ConvolveMatrix: ConvolveMatrixSVGFilter
  };
  const SVGFilterSpecList = {
    Image: ImageSVGFilter.spec,
    Tile: TileSVGFilter.spec,
    DropShadow: DropShadowSVGFilter.spec,
    Saturate: SaturateSVGFilter.spec,
    HueRotate: HueRotateSVGFilter.spec,
    LuminanceAlpha: LuminanceAlphaSVGFilter.spec,
    Offset: OffsetSVGFilter.spec,
    ComponentTransfer: ComponentTransferSVGFilter.spec,
    SpecularLighting: SpecularLightingSVGFilter.spec,
    SpotLight: SpotLightSVGFilter.spec,
    PointLight: PointLightSVGFilter.spec,
    DistantLight: DistantLightSVGFilter.spec,
    DiffuseLighting: DiffuseLightingSVGFilter.spec,
    Blend: BlendSVGFilter.spec,
    RotaMatrix: RotaMatrixSVGFilter.spec,
    Merge: MergeSVGFilter.spec,
    GaussianBlur: GaussianBlurSVGFilter.spec,
    Flood: FloodSVGFilter.spec,
    Morphology: MorphologySVGFilter.spec,
    Composite: CompositeSVGFilter.spec,
    Turbulence: TurbulenceSVGFilter.spec,
    DisplacementMap: DisplacementMapSVGFilter.spec,
    ColorMatrix: ColorMatrixSVGFilter.spec,
    ConvolveMatrix: ConvolveMatrixSVGFilter.spec
  };
  const WEBKIT_ATTRIBUTE_FOR_CSS = [
    "text-fill-color",
    "text-stroke-color",
    "text-stroke-width",
    "background-clip"
  ];
  function valueFilter(obj2) {
    const result = {};
    Object.keys(obj2).forEach((key) => {
      if (sapa.isNotUndefined(obj2[key])) {
        result[key] = obj2[key];
      }
    });
    return result;
  }
  class DomRender extends ItemRender {
    toStringPropertyCSS(item, field) {
      return STRING_TO_CSS(item.get(field));
    }
    toBackgroundImageCSS(item) {
      if (!item.cacheBackgroundImage) {
        item.setBackgroundImageCache();
      }
      return item.cacheBackgroundImage;
    }
    toLayoutCSS(item) {
      if (item.hasLayout()) {
        if (item.isLayout(Layout.FLEX)) {
          return this.toFlexLayoutCSS(item);
        } else if (item.isLayout(Layout.GRID)) {
          return this.toGridLayoutCSS(item);
        }
      }
      return {};
    }
    toLayoutItemCSS(item) {
      var _a, _b;
      var parentLayout = (_a = item.parent) == null ? void 0 : _a["layout"];
      var obj2 = {};
      if (parentLayout === Layout.FLEX) {
        obj2 = {
          position: "relative",
          left: "auto !important",
          top: "auto !important"
        };
      } else if (parentLayout === Layout.GRID) {
        obj2 = {
          position: "relative",
          left: "auto",
          top: "auto"
        };
      } else if (parentLayout === Layout.DEFAULT) {
        obj2 = this.toDefaultLayoutItemCSS(item);
      }
      if (parentLayout === Layout.FLEX) {
        obj2 = __spreadProps(__spreadValues({}, obj2), {
          "flex-basis": item.flexBasis,
          "flex-shrink": item.flexShrink
        });
        const parentLayoutDirection = (_b = item == null ? void 0 : item.parent) == null ? void 0 : _b.flexDirection;
        if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
          obj2.width = "auto";
          obj2["flex-grow"] = item.flexGrow || 1;
        } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
          obj2.height = "auto";
          obj2["flex-grow"] = item.flexGrow || 1;
        }
      } else if (parentLayout === Layout.GRID) {
        obj2 = __spreadProps(__spreadValues({}, obj2), {
          "grid-column-start": item.gridColumnStart,
          "grid-column-end": item.gridColumnEnd,
          "grid-row-start": item.gridRowStart,
          "grid-row-end": item.gridRowEnd
        });
        const columns = Grid.parseStyle(item.parent.gridTemplateColumns);
        const rows = Grid.parseStyle(item.parent.gridTemplateRows);
        obj2["grid-column-start"] = Math.max(1, Math.min(columns.length, obj2["grid-column-start"] || 1));
        obj2["grid-column-end"] = Math.min(columns.length + 1, obj2["grid-column-end"] || 2);
        obj2["grid-row-start"] = Math.max(1, Math.min(rows.length, obj2["grid-row-start"] || 1));
        obj2["grid-row-end"] = Math.min(rows.length + 1, obj2["grid-row-end"] || 2);
      }
      return obj2;
    }
    toDefaultLayoutItemCSS(item) {
      var _a;
      const obj2 = {};
      if ((_a = item.parent) == null ? void 0 : _a.is("project")) {
        return obj2;
      }
      const parentWidth = item.parent.screenWidth;
      switch (item[ConstraintsDirection.HORIZONTAL]) {
        case Constraints.MIN:
          obj2.left = editor.Length.px(item.x);
          obj2.right = "auto !important";
          break;
        case Constraints.MAX:
          obj2.right = editor.Length.px(parentWidth - item.offsetX - item.screenWidth);
          obj2.left = "auto !important";
          break;
        case Constraints.STRETCH:
          obj2.left = editor.Length.px(item.x);
          obj2.right = editor.Length.px(parentWidth - item.offsetX - item.screenWidth);
          obj2.width = "auto !important";
          break;
        case Constraints.CENTER:
          obj2.left = editor.Length.px(item.x);
          break;
        case Constraints.SCALE:
          obj2.left = editor.Length.px(item.x).toPercent(parentWidth);
          obj2.right = editor.Length.px(parentWidth - item.offsetX - item.screenWidth).toPercent(parentWidth);
          obj2.width = "auto !important";
          break;
      }
      const parentHeight = item.parent.screenHeight;
      switch (item[ConstraintsDirection.VERTICAL]) {
        case Constraints.MIN:
          obj2.top = editor.Length.px(item.y);
          obj2.bottom = "auto !important";
          break;
        case Constraints.MAX:
          obj2.top = "auto !important";
          obj2.bottom = editor.Length.px(parentHeight - item.offsetY - item.screenHeight);
          break;
        case Constraints.STRETCH:
          obj2.top = editor.Length.px(item.y);
          obj2.bottom = editor.Length.px(parentHeight - item.offsetY - item.screenHeight);
          obj2.height = "auto !important";
          break;
        case Constraints.CENTER:
          obj2.top = editor.Length.px(item.y);
          break;
        case Constraints.SCALE:
          obj2.top = editor.Length.px(item.y).toPercent(parentHeight);
          obj2.bottom = editor.Length.px(parentHeight - item.offsetY - item.screenHeight).toPercent(parentHeight);
          obj2.height = "auto !important";
          break;
      }
      return obj2;
    }
    toFlexLayoutCSS(item) {
      if (item.parent.isNot("project"))
        ;
      return {
        display: "flex",
        gap: editor.Length.px(item.gap),
        "flex-direction": item.flexDirection,
        "flex-wrap": item.flexWrap,
        "justify-content": item.justifyContent,
        "align-items": item.alignItems,
        "align-content": item.alignContent
      };
    }
    toGridLayoutCSS(item) {
      return {
        display: "grid",
        "grid-template-columns": item.gridTemplateColumns,
        "grid-template-rows": item.gridTemplateRows,
        "grid-template-areas": item.gridTemplateAreas,
        "grid-auto-columns": item.gridAutoColumns,
        "grid-auto-rows": item.gridAutoRows,
        "grid-auto-flow": item.gridAutoFlow,
        "grid-column-gap": item.gridColumnGap,
        "grid-row-gap": item.gridRowGap
      };
    }
    toBoxShadowCSS(item) {
      const boxShadow2 = item.computed("boxShadow", (boxShadow3 = []) => {
        return boxShadow3.map((shadow2) => {
          const { inset, color, offsetX, offsetY, blurRadius, spreadRadius } = shadow2;
          return ` ${inset === "inset" ? "inset" : ""} ${editor.Length.px(offsetX)} ${editor.Length.px(offsetY)} ${editor.Length.px(blurRadius)} ${editor.Length.px(spreadRadius)} ${color}`;
        }).join(", ") || void 0;
      });
      return {
        "box-shadow": boxShadow2
      };
    }
    toTextShadowCSS(item) {
      const textShadow2 = item.computed("textShadow", (textShadow3 = []) => {
        return textShadow3.map((shadow2) => {
          const { color, offsetX, offsetY, blurRadius } = shadow2;
          return ` ${editor.Length.px(offsetX)} ${editor.Length.px(offsetY)} ${editor.Length.px(blurRadius)}  ${color}`;
        }).join(", ") || void 0;
      });
      return {
        "text-shadow": textShadow2
      };
    }
    toFilterCSS(item) {
      const filter2 = item.computed("filter", (filter3 = []) => {
        return filter3.map((f) => {
          switch (f.type) {
            case "blur":
            case "grayscale":
            case "sepia":
            case "invert":
            case "opacity":
            case "saturate":
            case "hue-rotate":
            case "brightness":
            case "contrast":
              return `${f.type}(${f.value})`;
            case "drop-shadow":
              return `drop-shadow(${f.offsetX} ${f.offsetY} ${f.blurRadius} ${f.color})`;
          }
        }).join(" ") || void 0;
      });
      return {
        filter: filter2
      };
    }
    toBackdropFilterCSS(item) {
      const backdropFilter2 = item.computed("backdropFilter", (filter2 = []) => {
        filter2 = filter2 || [];
        return filter2.map((f) => {
          switch (f.type) {
            case "blur":
            case "grayscale":
            case "sepia":
            case "invert":
            case "opacity":
            case "saturate":
            case "hue-rotate":
            case "brightness":
            case "contrast":
              return `${f.type}(${f.value})`;
            case "drop-shadow":
              return `drop-shadow(${f.offsetX} ${f.offsetY} ${f.blurRadius} ${f.color})`;
          }
        }).join(" ") || void 0;
      });
      return {
        "backdrop-filter": backdropFilter2
      };
    }
    toTransitionCSS(item) {
      const transition2 = item.computed("transition", (transition3 = []) => {
        return transition3.map((t) => {
          return `${t.name} ${t.duration} ${t.timingFunction} ${t.delay}`;
        }).join(", ") || void 0;
      });
      return {
        transition: transition2
      };
    }
    toAnimationCSS(item) {
      const animation2 = item.computed("animation", (animation3 = []) => {
        return animation3.map((t) => {
          return [
            t.duration,
            t.timingFunction,
            t.delay,
            t.iterationCount,
            t.direction,
            t.fillMode,
            t.playState,
            t.name
          ].join(" ");
        }).join(", ") || void 0;
      });
      return {
        animation: animation2
      };
    }
    toBorderCSS(item) {
      const borderCSS = item.computed("border", (border2) => {
        const obj2 = __spreadValues({}, STRING_TO_CSS(border2));
        return obj2;
      });
      return borderCSS;
    }
    toBoxModelCSS(item) {
      let obj2 = {};
      if (item.marginTop)
        obj2["margin-top"] = editor.Length.px(item.marginTop);
      if (item.marginBottom)
        obj2["margin-bottom"] = editor.Length.px(item.marginBottom);
      if (item.marginLeft)
        obj2["margin-left"] = editor.Length.px(item.marginLeft);
      if (item.marginRight)
        obj2["margin-right"] = editor.Length.px(item.marginRight);
      if (item.paddingTop)
        obj2["padding-top"] = editor.Length.px(item.paddingTop);
      if (item.paddingBottom)
        obj2["padding-bottom"] = editor.Length.px(item.paddingBottom);
      if (item.paddingLeft)
        obj2["padding-left"] = editor.Length.px(item.paddingLeft);
      if (item.paddingRight)
        obj2["padding-right"] = editor.Length.px(item.paddingRight);
      return obj2;
    }
    toSizeCSS(item) {
      const obj2 = {};
      if (item.isLayout(Layout.FLEX)) {
        switch (item.resizingHorizontal) {
          case ResizingMode.FIXED:
            obj2.width = editor.Length.px(item.screenWidth);
            break;
          case ResizingMode.HUG_CONTENT:
            obj2["min-width"] = editor.Length.px(item.screenWidth);
            break;
        }
        switch (item.resizingVertical) {
          case ResizingMode.FIXED:
            obj2.height = editor.Length.px(item.screenHeight);
            break;
          case ResizingMode.HUG_CONTENT:
            obj2["min-height"] = editor.Length.px(item.screenHeight);
            break;
        }
      }
      if (item.isInDefault()) {
        obj2.width = editor.Length.px(item.screenWidth);
        obj2.height = editor.Length.px(item.screenHeight);
      }
      if (item.isInFlex()) {
        const direction = item.parent.flexDirection;
        if (direction === FlexDirection.ROW || direction === FlexDirection.ROW_REVERSE) {
          obj2.width = editor.Length.px(item.screenWidth);
          obj2.height = editor.Length.px(item.screenHeight);
          if (item.parent["align-items"] === AlignItems.STRETCH) {
            obj2.height = "auto";
          }
          if (item.resizingVertical === ResizingMode.FILL_CONTAINER) {
            obj2.height = "auto";
            obj2["align-self"] = AlignItems.STRETCH;
          }
        } else {
          obj2.width = editor.Length.px(item.screenWidth);
          obj2.height = editor.Length.px(item.screenHeight);
          if (item.parent["align-items"] === AlignItems.STRETCH) {
            obj2.width = "auto";
          }
          if (item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
            obj2.width = "auto";
            obj2["align-self"] = AlignItems.STRETCH;
          }
        }
      }
      if (item.isInGrid()) {
        obj2.width = "auto";
        obj2.height = "auto";
      }
      return obj2;
    }
    toDefaultCSS(item) {
      if (!item.hasCache("toDefaultCSS")) {
        item.addCache("toDefaultCSS", {
          "box-sizing": "border-box"
        });
      }
      let result = item.getCache("toDefaultCSS");
      if (item.isAbsolute) {
        result.left = editor.Length.px(item.x);
        result.top = editor.Length.px(item.y);
      }
      result["background-color"] = item.backgroundColor;
      result["color"] = item.color;
      result["font-size"] = item.fontSize;
      result["font-weight"] = item.fontWeight;
      result["font-style"] = item.fontStyle;
      result["font-family"] = item.fontFamily;
      result["text-align"] = item.textAlign;
      result["text-decoration"] = item.textDecoration;
      result["text-transform"] = item.textTransform;
      result["letter-spacing"] = item.letterSpacing;
      result["word-spacing"] = item.wordSpacing;
      result["line-height"] = item.lineHeight;
      result["text-indent"] = item.textIndent;
      result["text-overflow"] = item.textOverflow;
      result["text-wrap"] = item.textWrap;
      result["position"] = item.position;
      result["overflow"] = item.overflow;
      result["z-index"] = item.zIndex;
      result["opacity"] = item.opacity;
      result["mix-blend-mode"] = item.mixBlendMode;
      result["transform-origin"] = item.transformOrigin;
      result["border-radius"] = item.borderRadius;
      return result;
    }
    toVariableCSS(item) {
      const v = item.computed("variable", (v2) => {
        let obj2 = {};
        v2.split(";").filter((it) => it.trim()).forEach((it) => {
          const [key, value] = it.split(":");
          obj2[`--${key}`] = value;
        });
        return obj2;
      });
      return v;
    }
    toRootVariableCSS(item) {
      let obj2 = {};
      item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
        const [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    }
    toRootVariableString(item) {
      return CSS_TO_STRING(this.toRootVariableCSS(item));
    }
    toWebkitCSS(item) {
      var results = {};
      WEBKIT_ATTRIBUTE_FOR_CSS.forEach((key) => {
        results[`-webkit-${key}`] = item.get(key);
      });
      return results;
    }
    toTextClipCSS(item) {
      let results = {};
      if (item.textClip === "text") {
        results["-webkit-background-clip"] = "text";
        results["-webkit-text-fill-color"] = "transparent";
        results["color"] = "transparent";
      }
      return results;
    }
    toTransformCSS(item) {
      const transform2 = item.computed("angle", (angle) => {
        return {
          transform: angle === 0 ? "" : `rotateZ(${angle}deg)`
        };
      });
      return transform2;
    }
    toDefInnerString(item) {
      return `
      ${this.toClipPath(item)}
      ${this.toSVGFilter(item)}
    `.trim();
    }
    toClipPath(item) {
      if (item.clipPath === "")
        return "";
      if (!item.cacheClipPathObject) {
        item.setClipPathCache();
      }
      var obj2 = item.cacheClipPathObject;
      var value = obj2.value;
      switch (obj2.type) {
        case "path":
          return `<clipPath id="${this.clipPathId(item)}"><path d="${item.clipPathString}" /></clipPath>`;
        case "svg":
          return `<clipPath id="${this.clipPathId(item)}">${value}</clipPath>`;
      }
      return ``;
    }
    toClipPathCSS(item) {
      let str = item.clipPath;
      if (Boolean(str) === false) {
        return null;
      }
      if (!item.cacheClipPathObject) {
        item.setClipPathCache();
      }
      var obj2 = item.cacheClipPathObject;
      switch (obj2.type) {
        case "path":
          if (obj2.value) {
            str = `url(#${this.clipPathId(item)})`;
          }
          break;
        case "svg":
          str = `url(#${this.clipPathId(item)})`;
          break;
      }
      return {
        "clip-path": str
      };
    }
    innerSVGId(item) {
      return item.id + "inner-svg";
    }
    booleanId(item) {
      return item.id + "boolean";
    }
    clipPathId(item) {
      return item.id + "clip-path";
    }
    toDefString(item) {
      var str = this.toDefInnerString(item).trim();
      return str ? `
    <svg class='inner-svg-element' style="display:block" data-id="${this.innerSVGId(item)}" width="0" height="0">
      <defs>
        ${str}
      </defs>
    </svg>
    ` : "";
    }
    toSelectorString(item, prefix = "") {
      var _a;
      return (_a = item.selectors) == null ? void 0 : _a.map((selector2) => selector2.toString(prefix)).join("\n\n");
    }
    generateView(item, prefix = "", appendCSS = "") {
      var cssString = `
      ${this.toKeyframeCSS(item)}
  ${prefix} {  /* ${item.itemType} */
      ${CSS_TO_STRING(this.toCSS(item), "\n    ")}; 
      ${appendCSS}
  }
  ${this.toNestedCSS(item).map((it) => {
        return `${prefix} ${it.selector} { 
        ${it.cssText ? it.cssText : CSS_TO_STRING(it.css || {}, "\n		")}; 
    }`;
      }).join("\n")}
  ${this.toSelectorString(item, prefix)}
    `;
      return cssString;
    }
    convertKey(key) {
      switch (key) {
        case "x":
          return "left";
        case "y":
          return "top";
      }
      return key;
    }
    convertValue(key, value) {
      switch (key) {
        case "left":
          return editor.Length.px(value);
        case "top":
          return editor.Length.px(value);
      }
      return key;
    }
    toKeyframeCSS(item) {
      const keyframes = item.computed("keyframes", (keyframes2) => {
        const text2 = keyframes2.map((it) => {
          return `@keyframes ${it.name} {
${it.offsets.map((offset) => {
            var _a;
            return `${offset.offset}% {
    ${(_a = offset.properties) == null ? void 0 : _a.map((p) => {
              const key = this.convertKey(p.key);
              const value = this.convertValue(key, p.value);
              return `${key}: ${value};`;
            }).join("\n")}
  }`;
          }).join("\n")}
}`;
        }).join("\n");
        return text2;
      });
      return keyframes;
    }
    toSelectorCSS(item) {
      const selectors = item.computed("selectors", (selectors2) => {
        console.log(selectors2);
        return "";
      });
      return selectors;
    }
    toCSS(item) {
      return valueFilter(Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBoxModelCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toBoxShadowCSS(item), this.toTextShadowCSS(item), this.toFilterCSS(item), this.toBackdropFilterCSS(item), this.toTransitionCSS(item), this.toAnimationCSS(item), this.toLayoutCSS(item), this.toSizeCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item)));
    }
    toStyleCode(item) {
      const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
      return cssString;
    }
    toStyle(item) {
      const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
      return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
        return this.renderer.toStyle(it);
      }).join("");
    }
    toStyleData(item) {
      const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
      return {
        styleTag: `<style type='text/css' data-renderer-type="html" data-id='${item.id}'>${cssString}</style>`,
        cssString
      };
    }
    toExportStyle(item) {
      const cssString = this.generateView(item, `.element-item[data-id='${item.id}']`);
      return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}' data-timestamp='${item.timestamp}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
        return this.renderer.toExportStyle(it);
      }).join("");
    }
    render(item) {
      var { elementType, id, name, itemType, isBooleanItem } = item;
      const tagName = elementType || "div";
      return `<${tagName} id="${this.uniqueId(item)}" class="element-item ${itemType}" data-is-boolean-item="${isBooleanItem}" data-id="${id}" data-title="${name}">${this.toDefString(item)}${item.layers.map((it) => {
        return this.renderer.render(it);
      }).join("")}</${tagName}>`;
    }
    toSVGFilter(item) {
      if (item.svgfilters.length === 0)
        return "";
      var filterString = item.computedValue("svgfilters");
      if (item.hasChangedField("svgfilters") || !filterString) {
        filterString = item.computed("svgfilters", (svgfilters) => {
          var filterString2 = svgfilters.map((svgfilter) => {
            return `
              <filter id='${svgfilter.id}'>
                ${svgfilter.filters.map((filter2) => SVGFilter.parse(filter2)).join("\n")}
              </filter>`;
          }).join("");
          return filterString2;
        }, true);
      }
      return filterString;
    }
    renderSVG() {
    }
    toNestedCSS() {
      const result = [];
      return result;
    }
    updateStyle(item) {
      if (item.hasCache("style")) {
        const styleText = this.toStyleData(item).cssString;
        if (item.hasCache("styleText")) {
          if (item.getCache("styleText") === styleText) {
            return;
          }
        }
        item.addCache("styleText", styleText);
        item.getCache("style").text(styleText);
      } else {
        const styleData = this.toStyleData(item);
        const style2 = sapa.Dom.createByHTML(styleData.styleTag);
        item.addCache("style", style2);
        item.addCache("styleText", styleData.cssString);
        document.head.appendChild(style2.el);
      }
    }
    update(item, currentElement) {
      if (!currentElement)
        return;
      this.updateStyle(item);
      let $svg = currentElement.el.$svg;
      if (!$svg) {
        currentElement.el.$svg = currentElement.$(`[data-id="${this.innerSVGId(item)}"]`);
        $svg = currentElement.el.$svg;
        currentElement.el.$booleanSvg = currentElement.$(`[data-id="${this.booleanId(item)}"]`);
      }
      if (currentElement.data("is-boolean-item") !== `${item.isBooleanItem}`) {
        currentElement.attr("data-is-boolean-item", item.isBooleanItem);
      }
      if ($svg) {
        const defString = this.toDefInnerString(item);
        if (defString) {
          var $defs = $svg.$("defs");
          $defs.updateSVGDiff(`<defs>${defString}</defs>`);
        }
      } else {
        const defString = this.toDefString(item);
        if (defString) {
          var a = sapa.Dom.createByHTML(defString);
          if (a) {
            currentElement.prepend(a);
          }
        }
      }
    }
  }
  class LayerRender extends DomRender {
  }
  class SampleRender extends LayerRender {
    update(item, currentElement) {
      const $sampleText = currentElement.$(".sample-text");
      if ($sampleText) {
        $sampleText.text(item.sampleText);
      }
      const $sampleNumber = currentElement.$(".sample-number");
      if ($sampleNumber) {
        $sampleNumber.text(item.sampleNumber);
      }
      const $sampleItems = currentElement.$(".sample-items");
      if ($sampleItems) {
        const template = [...Array(item.sampleNumber)].map((_, i) => `
            <div class="sample-item" style="background-color: yellow">${i}</div>
          `).join("\n");
        $sampleItems.html(template);
      }
      super.update(item, currentElement);
    }
    render(item) {
      var { id, sampleText, sampleNumber } = item;
      return `
      <div class='element-item sample' data-id="${id}">
        ${this.toDefString(item)}
        <div>
          <div class="sample-text">${sampleText}</div>
          <div class="sample-number">${sampleNumber}</div>
          <div class="sample-items" style="display: grid; grid-template-columns: 1fr 1fr 1fr; column-gap: 10px;"></div>
        </div>
      </div>`;
    }
  }
  function sample(editor2) {
    editor2.registerComponent("sample", SampleLayer);
    editor2.registerRenderer("html", "sample", new SampleRender());
    editor2.registerInspector("sample", (current) => {
      return [
        "Sample Text \uD3B8\uC9D1",
        {
          key: "sampleText",
          editor: "TextEditor",
          defaultValue: current.sampleText
        },
        "Sample Number \uD3B8\uC9D1",
        {
          key: "sampleNumber",
          editor: "NumberInputEditor",
          editorOptions: {
            min: 0,
            max: 10,
            step: 1,
            label: "SN"
          },
          defaultValue: current.sampleNumber
        },
        "\uC2A4\uD0C0\uC77C \uCE74\uD53C",
        {
          type: "column",
          size: [1, 1],
          gap: 10,
          columns: [
            {
              key: "copyCssJSON",
              editor: "Button",
              editorOptions: {
                text: "Copy CSS JSON",
                onClick: () => {
                  console.log(JSON.stringify(editor2.html.toCSS(current), null, 4));
                }
              }
            },
            {
              key: "copyCssString",
              editor: "Button",
              editorOptions: {
                text: "Copy CSS String",
                onClick: () => {
                  console.log(CSS_TO_STRING(editor2.html.toCSS(current)));
                }
              }
            },
            {
              key: "changeColor",
              editor: "Button",
              editorOptions: {
                text: "Change Text Random Color",
                onClick: () => {
                  const textColor = Color__namespace.random();
                  const backgroundColor = Color__namespace.random();
                  editor2.context.commands.emit("setAttribute", {
                    [current.id]: {
                      color: textColor,
                      "background-color": backgroundColor
                    }
                  });
                }
              }
            }
          ]
        }
      ];
    });
  }
  var SelectionInfoView$1 = "";
  class SelectionInfoView extends editor.EditorElement {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--selection-info-view"
      });
    }
    [sapa.POINTERSTART("$el [data-artboard-title-id]") + FIRSTMOVE("calculateFirstMovedElement") + MOVE("calculateMovedElement") + END("calculateEndedElement")](e) {
      this.startXY = e.xy;
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      const id = e.$dt.attr("data-artboard-title-id");
      this.$context.selection.select(id);
      if (e.altKey) {
        this.$commands.emit("history.copyLayer", "copy");
      }
      this.initializeDragSelection();
    }
    initializeDragSelection() {
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
    }
    moveTo(dist2) {
      const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
        return add([], v, dist2);
      }), 3 / this.$viewport.scale);
      const localDist = add([], snap.dist, dist2);
      const result = {};
      this.$context.selection.cachedItemMatrices.forEach((it) => {
        const newVerties = it.verties.map((v) => {
          return add([], v, localDist);
        });
        const newDist = subtract([], transformMat4([], newVerties[0], it.parentMatrixInverse), transformMat4([], it.verties[0], it.parentMatrixInverse));
        result[it.id] = {
          x: Math.floor(it.x + newDist[0]),
          y: Math.floor(it.y + newDist[1])
        };
      });
      this.$context.selection.reset(result);
    }
    calculateFirstMovedElement() {
      this.$config.set("set.move.control.point", true);
      this.emit(REFRESH_SELECTION_TOOL);
    }
    calculateMovedElement() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
      this.moveTo(newDist);
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
      this.refresh();
    }
    [sapa.SUBSCRIBE("refreshItemName")](id, title) {
      var _a;
      this.$commands.emit("setAttribute", {
        [id]: { name: title }
      });
      (_a = this.$el.$(`[data-artboard-title-id='${id}']`)) == null ? void 0 : _a.text(title);
    }
    calculateEndedElement() {
      this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
      this.$config.set("set.move.control.point", false);
      this.emit(REFRESH_SELECTION_TOOL);
      this.$commands.emit("history.refreshSelection");
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS)]() {
      if (this.$context.selection.current) {
        if (this.$context.selection.current.is("artboard")) {
          if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "transform", "transform-origin")) {
            this.refresh();
          }
        }
      }
    }
    [sapa.LOAD("$el") + sapa.DOMDIFF]() {
      var _a;
      return (_a = this.$context.selection.currentProject) == null ? void 0 : _a.artboards.map((it) => {
        return {
          item: it,
          title: it.name,
          id: it.id,
          layout: it.layout,
          pointers: this.$viewport.applyVerties(it.verties)
        };
      }).map((it) => this.makeArtboardTitleArea(it));
    }
    getIcon(item) {
      if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
        if (item.isLayout("flex")) {
          return editor.iconUse("layout_flex", item.flexDirection === "column" ? "rotate(90 12 12)" : "");
        } else if (item.isLayout("grid")) {
          return editor.iconUse("layout_grid");
        }
        return "";
      }
      return this.$icon.get(item.itemType, item);
    }
    createSize(pointers, artboardItem) {
      const newPointer = pointers[0];
      const diff = subtract([], pointers[0], pointers[3]);
      const angle = calculateAngle360(diff[0], diff[1]) - 90;
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "artboard-title is-not-drag-area",
        "data-artboard-title-id": artboardItem.id,
        "data-layout": artboardItem.layout,
        style: {
          "transform-origin": "0% 0%",
          transform: `translate3d( calc(${newPointer[0]}px), calc(${newPointer[1]}px), 0px) rotateZ(${angle}deg)`
        }
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        style: "transform: translateY(-100%);"
      }, this.getIcon(artboardItem.item), artboardItem.title));
    }
    makeArtboardTitleArea(it) {
      return this.createSize(it.pointers, it);
    }
    [sapa.SUBSCRIBE("refreshAll")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("appendLayer")]() {
      this.refresh();
    }
  }
  function selectionInfoView(editor2) {
    editor2.registerUI("canvas.view", {
      SelectionInfoView
    });
  }
  var GhostToolView$1 = "";
  const CHECK_RATE = 0.5;
  class GhostToolView extends editor.EditorElement {
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--ghost-tool-view"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        ref: "$containerView"
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        ref: "$view"
      }));
    }
    [sapa.SUBSCRIBE("startGhostToolView")]() {
      const screenVerties = this.$context.selection.verties;
      this.isLayoutItem = this.$context.selection.isLayoutItem;
      this.verties = sapa.clone(screenVerties);
      this.ghostVerties = sapa.clone(screenVerties);
      this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
      this.initMousePoint = this.$viewport.getWorldPosition();
      this.filteredLayers = this.$context.selection.notSelectedLayers;
      this.containerList = this.filteredLayers.filter((it) => it.hasLayout() || it.is("artboard")).map((it) => it.originVerties);
      this.$config.set("set.move.control.point", true);
    }
    collectInformation() {
      var _a, _b;
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = this.getDist();
      this.ghostVerties = this.verties.map((v) => {
        return add([], v, newDist);
      });
      this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
      const filteredLayers = this.$context.selection.filteredLayers.filter((it) => this.$context.selection.check(it) === false);
      this.targetItem = filteredLayers[0];
      if (this.targetItem) {
        const currentParent = (_a = this.$context.selection.current) == null ? void 0 : _a.parent;
        if (currentParent.isNot("project") && (currentParent == null ? void 0 : currentParent.isLayout(Layout.GRID))) {
          this.targetItem = this.$context.selection.current.parent;
        } else {
          if (this.targetItem.hasLayout() && ((_b = this.targetItem) == null ? void 0 : _b.hasChildren())) {
            if (this.targetItem.isLayout(Layout.FLEX)) {
              this.targetItem = this.targetItem.layers[this.targetItem.layers.length - 1];
            } else if (this.targetItem.isLayout(Layout.GRID))
              ;
          }
        }
        this.$context.selection.updateDragTargetItem(this.targetItem);
        this.targetOriginPosition = this.$viewport.applyVerties(toRectVerties(this.targetItem.contentVerties));
        this.targetPoint = this.$viewport.applyVertex(targetMousePoint);
        this.targetRelativeMousePoint = {
          x: (this.targetPoint[0] - this.targetOriginPosition[0][0]) / (this.targetOriginPosition[1][0] - this.targetOriginPosition[0][0]),
          y: (this.targetPoint[1] - this.targetOriginPosition[0][1]) / (this.targetOriginPosition[3][1] - this.targetOriginPosition[0][1])
        };
        if (this.targetItem.isLayoutItem()) {
          this.targetParent = this.targetItem.parent;
          if (this.targetParent) {
            this.targetParentPosition = this.$viewport.applyVerties(this.targetParent.contentVerties);
          }
        } else {
          this.targetParent = null;
          this.targetParentPosition = null;
        }
      } else {
        this.targetPoint = null;
        this.targetRelativeMousePoint = null;
        this.targetParent = null;
        this.targetParentPosition = null;
      }
    }
    [sapa.SUBSCRIBE("moveFirstGhostToolView")]() {
      this.collectInformation();
      this.load("$containerView");
      this.load("$view");
    }
    [sapa.SUBSCRIBE("moveGhostToolView")]() {
      this.collectInformation();
      this.load("$view");
    }
    [sapa.LOAD("$containerView")]() {
      var _a;
      if (!this.ghostVerties) {
        return /* @__PURE__ */ sapa.createElementJsx("svg", null);
      }
      return /* @__PURE__ */ sapa.createElementJsx("svg", null, (_a = this.containerList) == null ? void 0 : _a.map((it) => {
        it = this.$viewport.applyVerties(it);
        return /* @__PURE__ */ sapa.createElementJsx("path", {
          class: "container",
          d: `
                    M ${it[0][0]} ${it[0][1]}
                    L ${it[1][0]} ${it[1][1]}
                    L ${it[2][0]} ${it[2][1]}
                    L ${it[3][0]} ${it[3][1]}
                    Z
                `
        });
      }));
    }
    renderPathForVerties(verties, className) {
      if (!verties) {
        return /* @__PURE__ */ sapa.createElementJsx("g", null);
      }
      const d = vertiesToPath(verties);
      return /* @__PURE__ */ sapa.createElementJsx("g", null, /* @__PURE__ */ sapa.createElementJsx("path", {
        class: className,
        d
      }));
    }
    renderPath(verties, className, data = className) {
      if (!verties)
        return "";
      verties = data === "ghost" ? verties : toRectVerties(verties);
      const textX = className === "flex-item" ? verties[0][0] : verties[0][0];
      const textY = className === "flex-item" ? verties[2][1] + 10 : verties[0][1] - 10;
      return /* @__PURE__ */ sapa.createElementJsx("g", null, /* @__PURE__ */ sapa.createElementJsx("text", {
        x: textX,
        y: textY,
        "font-size": 8
      }, data), this.renderPathForVerties(verties, className));
    }
    renderLayoutFlexRowArea() {
      if (this.targetRelativeMousePoint.x < CHECK_RATE) {
        return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[3]], "flex-target"));
      } else {
        return /* @__PURE__ */ sapa.createElementJsx(sapa.FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[1], this.targetOriginPosition[2]], "flex-target"));
      }
    }
    renderLayoutFlexForFirstItem(direction) {
      const isColumn = direction === FlexDirection.COLUMN;
      const verticalField = isColumn ? "align-items" : "justify-content";
      const verticalConst = isColumn ? AlignItems : JustifyContent;
      const horizontalField = isColumn ? "justify-content" : "align-items";
      const horizontalConst = isColumn ? JustifyContent : AlignItems;
      const rect2 = vertiesToRectangle(this.targetOriginPosition);
      const center = this.ghostScreenVerties[4];
      const width2 = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[1]);
      const height = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[3]);
      let newCenterX = width2 / 2;
      let newCenterY = height / 2;
      switch (this.targetItem[verticalField]) {
        case verticalConst.FLEX_START:
          newCenterX = rect2.x + width2 / 2;
          break;
        case verticalConst.CENTER:
        case verticalConst.SPACE_BETWEEN:
        case verticalConst.SPACE_AROUND:
          newCenterX = rect2.x + rect2.width / 2;
          break;
        case verticalConst.FLEX_END:
          newCenterX = rect2.x + rect2.width - width2 / 2;
          break;
      }
      switch (this.targetItem[horizontalField]) {
        case horizontalConst.FLEX_START:
          newCenterY = rect2.y + height / 2;
          break;
        case horizontalConst.CENTER:
        case horizontalConst.SPACE_BETWEEN:
        case horizontalConst.SPACE_AROUND:
          newCenterY = rect2.y + rect2.height / 2;
          break;
        case horizontalConst.FLEX_END:
          newCenterY = rect2.y + rect2.height - height / 2;
          break;
      }
      const newDist = subtract([], [newCenterX, newCenterY, 0], center);
      const renderVerties = this.ghostScreenVerties.map((it) => add([], it, newDist)).filter((it, index2) => index2 < 4);
      return this.renderPathForVerties(renderVerties, "flex-item", "ghost");
    }
    renderLayoutFlexColumnArea() {
      if (this.targetRelativeMousePoint.y < 0) {
        return "";
      }
      if (this.targetRelativeMousePoint.y < CHECK_RATE) {
        return this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[1]], "flex-target");
      } else {
        return this.renderPathForVerties([this.targetOriginPosition[2], this.targetOriginPosition[3]], "flex-target");
      }
    }
    renderLayoutItemInsertArea() {
      if (!this.targetParent) {
        return;
      }
      if (this.targetParent.hasLayout()) {
        if (this.targetParent.isLayout(Layout.FLEX)) {
          switch (this.targetParent.flexDirection) {
            case FlexDirection.ROW:
              return this.renderLayoutFlexRowArea();
            case FlexDirection.COLUMN:
              return this.renderLayoutFlexColumnArea();
          }
        } else if (this.targetParent.isLayout(Layout.GRID))
          ;
      }
      return /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "insert-area",
        d: ``
      });
    }
    renderLayoutItemForFirst() {
      var _a;
      if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false) {
        if (this.targetItem.isLayout(Layout.FLEX)) {
          return this.renderLayoutFlexForFirstItem(this.targetItem.flexDirection);
        } else if (this.targetItem.isLayout(Layout.GRID))
          ;
      }
      return /* @__PURE__ */ sapa.createElementJsx("path", {
        class: "insert-area",
        d: ``
      });
    }
    [sapa.LOAD("$view") + sapa.DOMDIFF]() {
      var _a;
      const current = this.$context.selection.current;
      if (!this.ghostVerties || !current) {
        return /* @__PURE__ */ sapa.createElementJsx("svg", null);
      }
      const hasTargetView = ((_a = this.targetItem) == null ? void 0 : _a.id) !== current.id;
      return /* @__PURE__ */ sapa.createElementJsx("svg", null, this.targetParent && this.renderPathForVerties(this.targetParentPosition, "target-parent"), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target", ""), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target-rect", ""), hasTargetView ? this.renderLayoutItemInsertArea() : "", hasTargetView ? this.renderLayoutItemForFirst() : "", this.isLayoutItem && this.renderPathForVerties(this.ghostScreenVerties.filter((_, index2) => index2 < 4), "ghost"));
    }
    initializeGhostView() {
      this.isLayoutItem = false;
      this.ghostVerties = void 0;
      this.ghostScreenVerties = void 0;
      this.targetOriginPosition = void 0;
      this.targetOriginPosition = void 0;
      this.targetRelativeMousePoint = void 0;
      this.targetItem = void 0;
      this.targetParent = void 0;
      this.targetParentPosition = void 0;
      this.$context.selection.updateDragTargetItem(this.targetItem);
    }
    getDist() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
      return newDist;
    }
    insertToBackground() {
      const current = this.$context.selection.current;
      const newDist = this.getDist();
      if (current.isLayoutItem() === false)
        return;
      this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.$context.selection.currentProject, newDist);
    }
    getTargetAction() {
      let targetAction = "";
      if (this.targetParent.hasLayout()) {
        if (this.targetParent.isLayout(Layout.FLEX)) {
          switch (this.targetParent.flexDirection) {
            case FlexDirection.ROW:
              if (this.targetRelativeMousePoint.x < CHECK_RATE) {
                targetAction = TargetActionType.INSERT_BEFORE;
              } else {
                targetAction = TargetActionType.INSERT_AFTER;
              }
              break;
            case FlexDirection.COLUMN:
              if (this.targetRelativeMousePoint.y < CHECK_RATE) {
                targetAction = TargetActionType.INSERT_BEFORE;
              } else {
                targetAction = TargetActionType.INSERT_AFTER;
              }
              break;
          }
        }
      }
      return targetAction;
    }
    insertToLayoutItem() {
      const current = this.$context.selection.current;
      const newDist = this.getDist();
      if (this.targetParent.hasLayout()) {
        let targetAction = this.getTargetAction();
        if (this.targetParent.isLayout(Layout.FLEX)) {
          if (targetAction) {
            this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist, targetAction);
          }
        } else if (this.targetParent.isLayout(Layout.GRID)) {
          this.insertToGridItem();
        }
      }
    }
    insertToGridItem() {
      const current = this.$context.selection.current;
      const { info, items } = this.$context.selection.gridInformation || {
        items: []
      };
      const currentVerties = this.ghostVerties.filter((_, index2) => index2 < 4);
      const targetRect = vertiesToRectangle(currentVerties);
      const epsilon = IntersectEpsilonNumberType.RECT / this.$context.viewport.scale;
      const checkedItems = items == null ? void 0 : items.filter((it) => {
        return polyPoly(it.originVerties, currentVerties);
      }).filter((it) => {
        const intersect = intersectRectRect(it.originRect, targetRect);
        return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
      });
      if (checkedItems == null ? void 0 : checkedItems.length) {
        const columnList = checkedItems.map((it) => it.column);
        const rowList = checkedItems.map((it) => it.row);
        const columnStart = Math.min(...columnList);
        const rowStart = Math.min(...rowList);
        const columnEnd = Math.max(...columnList) + 1;
        const rowEnd = Math.max(...rowList) + 1;
        this.$commands.executeCommand("setAttribute", "change grid item", this.$context.selection.packByValue({
          "grid-column-start": columnStart,
          "grid-column-end": columnEnd,
          "grid-row-start": rowStart,
          "grid-row-end": rowEnd
        }));
        if (info.current.hasChild(current.id) === false) {
          this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, info.current, void 0);
        }
        return;
      } else {
        if (this.targetItem) {
          this.emit("refreshGridToolInfo", this.targetItem);
          this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, void 0);
        }
      }
    }
    updateLayer() {
      var _a;
      const current = this.$context.selection.current;
      if (!current)
        return;
      const newDist = this.getDist();
      if (newDist[0] === 0 && newDist[1] === 0) {
        return;
      }
      if (this.targetItem && this.targetItem.id === (current == null ? void 0 : current.id)) {
        return;
      }
      if (!this.targetItem) {
        this.insertToBackground();
        return;
      }
      if (this.targetItem.hasLayout()) {
        const isCtrl = this.$context.keyboardManager.isCtrl();
        if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false && this.targetItem.isLayout(Layout.FLEX) && isCtrl === false) {
          this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
          return;
        } else {
          if (isCtrl) {
            const { info } = this.$context.selection.gridInformation || {
              items: []
            };
            if (info == null ? void 0 : info.current) {
              this.insertToGridItem();
              return;
            }
          } else {
            if (this.targetItem.isLayout(Layout.GRID)) {
              this.insertToGridItem();
              return;
            }
          }
        }
      }
      if (this.targetParent) {
        this.insertToLayoutItem();
        return;
      }
      if (current.isLayoutItem() && current.parent.id !== this.targetItem.id) {
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
      }
    }
    [sapa.SUBSCRIBE("endGhostToolView")](hasMoved = false) {
      if (hasMoved) {
        this.updateLayer();
      }
      this.initializeGhostView();
      this.load();
    }
  }
  var SelectionView = "";
  var directionType$1 = {
    1: "to top left",
    2: "to top right",
    3: "to bottom right",
    4: "to bottom left",
    11: "to top",
    12: "to right",
    13: "to bottom",
    14: "to left"
  };
  const SelectionToolEvent$1 = class extends editor.EditorElement {
    checkViewMode() {
      return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + sapa.IF("checkViewMode")]() {
      if (this.$context.selection.isMany) {
        this.initSelectionTool();
      } else {
        this.hide();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT) + sapa.IF("checkViewMode")]() {
      if (this.$context.selection.isMany) {
        this.initSelectionTool();
      }
    }
  };
  class GroupSelectionToolView extends SelectionToolEvent$1 {
    template() {
      return `
            <div class='elf--selection-view group-selection-view' ref='$selectionView'  style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>        
            </div>
        `;
    }
    toggleEditingPath(isEditingPath) {
      this.refs.$selectionView.toggleClass("editing-path", isEditingPath);
    }
    [sapa.POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
      this.state.moveType = "rotate";
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.verties = this.groupItem.verties;
      this.rotateTargetNumber = +e.$dt.attr("data-number");
      this.refreshRotatePointerIcon();
      this.state.dragging = false;
      this.state.isRotate = true;
      this.$config.set("set.move.control.point", true);
    }
    rotateVertex() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const distVector = subtract([], targetMousePoint, this.initMousePoint);
      const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
      var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
      if (this.$config.get("bodyEvent").shiftKey) {
        distAngle = distAngle - distAngle % this.$config.get("fixed.angle");
      }
      this.localAngle = this.angle + distAngle;
      this.groupItem.reset({
        angle: this.localAngle
      });
      const selectionMatrix = calculateRotationOriginMat4(distAngle, this.verties[4]);
      let cachedItemMatrices = this.$context.selection.cachedItemMatrices;
      if (this.$context.selection.length === 1) {
        cachedItemMatrices = cachedItemMatrices.filter((it) => it.id === this.$context.selection.current.id);
      }
      cachedItemMatrices.forEach((item) => {
        const newVerties = vertiesMap(item.verties, multiply$1([], item.parentMatrixInverse, selectionMatrix));
        const rotatePointer = getRotatePointer(newVerties, 34);
        var lastAngle = calculateAngle(rotatePointer[0] - newVerties[4][0], rotatePointer[1] - newVerties[4][1]) - 270;
        const newTranslate = transformMat4([], newVerties[0], calculateRotationOriginMat4(-lastAngle, newVerties[4]));
        const instance = this.$model.get(item.id);
        if (instance) {
          instance.reset({
            x: newTranslate[0],
            y: newTranslate[1],
            angle: lastAngle
          });
        }
      });
      this.state.dragging = true;
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height", "angle"));
      this.renderPointers();
    }
    rotateEndVertex() {
      this.state.dragging = false;
      this.state.isRotate = false;
      this.$commands.emit("recoverCursor");
      this.$config.set("set.move.control.point", false);
      this.$context.selection.reselect();
      this.initMatrix(true);
      this.nextTick(() => {
        this.$commands.executeCommand("setAttribute", "rotate selection pointer", this.$context.selection.pack("x", "y", "width", "height", "angle"));
      });
    }
    refreshRotatePointerIcon() {
      this.$commands.emit("refreshCursor", "rotate");
    }
    refreshPointerIcon(e) {
      const dataPointer = e.$dt.data("pointer");
      if (dataPointer) {
        const pointer = dataPointer.split(",").map((it) => Number(it));
        const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
        const angle = calculateAngle360(diff[0], diff[1]);
        let iconAngle = Math.floor(angle);
        this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
      } else {
        this.$commands.emit("recoverCursor");
      }
    }
    checkPointerIsNotMoved() {
      return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
    }
    [sapa.POINTEROVER("$pointerRect .rotate-pointer") + sapa.IF("checkPointerIsNotMoved") + sapa.PREVENT](e) {
      this.refreshRotatePointerIcon(e);
    }
    [sapa.POINTEROVER("$pointerRect .pointer") + sapa.IF("checkPointerIsNotMoved") + sapa.PREVENT](e) {
      this.refreshPointerIcon(e);
    }
    [sapa.POINTEROUT("$pointerRect .pointer,.rotate-pointer") + sapa.IF("checkPointerIsNotMoved") + sapa.PREVENT]() {
      this.$commands.emit("recoverCursor");
    }
    [sapa.POINTERSTART("$pointerRect .pointer") + sapa.PREVENT + MOVE("moveVertex") + END("moveEndVertex")](e) {
      this.refreshPointerIcon(e);
      this.state.dragging = true;
      const num = +e.$dt.attr("data-number");
      this.state.moveType = directionType$1[`${num}`];
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.$context.selection.reselect();
      this.state.dragging = false;
      this.initMatrix(true);
      this.cachedGroupItem = this.groupItem.matrix;
      this.$config.set("set.move.control.point", true);
      this.$context.selection.startToCacheChildren();
    }
    calculateNewOffsetMatrixInverse(vertextOffset, width2, height, origin, itemMatrix) {
      const center = add([], TransformOrigin.scale(origin, width2, height), negate([], vertextOffset));
      return calculateMatrixInverse(fromTranslation([], vertextOffset), fromTranslation([], center), itemMatrix, fromTranslation([], negate([], center)));
    }
    calculateDistance(vertext, distVector, reverseMatrix) {
      const currentVertex = clone(vertext);
      const snap = this.$context.snapManager.check([add([], currentVertex, distVector)], 3 / this.$viewport.scale);
      const nextVertex = add([], currentVertex, add([], distVector, snap.dist));
      var currentResult = transformMat4([], currentVertex, reverseMatrix);
      var nextResult = transformMat4([], nextVertex, reverseMatrix);
      const realDist = round$1([], subtract([], nextResult, currentResult));
      return realDist;
    }
    calculateRealDist(item, vertextIndex, distVector) {
      return this.calculateDistance(item.verties[vertextIndex], distVector, item.absoluteMatrixInverse);
    }
    moveGroupItem(lastStartVertex, newWidth, newHeight) {
      this.groupItem.reset({
        x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
        y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
        width: Math.abs(newWidth),
        height: Math.abs(newHeight)
      });
    }
    moveItemForGroup(it, newVerties, realDx = 0, realDy = 0) {
      const transformViewInverse = calculateMatrixInverse(fromTranslation([], newVerties[4]), it.itemMatrix, fromTranslation([], negate([], newVerties[4])));
      const [newX, newY] = transformMat4([], newVerties[0], transformViewInverse);
      const newWidth = distance$1(newVerties[0], newVerties[1]);
      const newHeight = distance$1(newVerties[0], newVerties[3]);
      const instance = this.$model.get(it.id);
      if (instance) {
        instance.reset({
          x: newX + realDx,
          y: newY + realDy,
          width: Math.max(Math.abs(newWidth), 1),
          height: Math.max(Math.abs(newHeight), 1)
        });
      }
    }
    recoverItemForGroup(groupItem, scaleX, scaleY, realDx = 0, realDy = 0) {
      const absoluteMatrix = groupItem.absoluteMatrix;
      const absoluteMatrixInverse = groupItem.absoluteMatrixInverse;
      this.$context.selection.cachedItemMatrices.forEach((it) => {
        const localView = calculateMatrix(it.parentMatrixInverse, absoluteMatrix, fromTranslation([], [realDx, realDy, 0]), fromScaling([], [scaleX, scaleY, 1]), absoluteMatrixInverse);
        const newVerties = vertiesMap(it.verties, localView);
        this.moveItemForGroup(it, newVerties);
      });
    }
    moveBottomRightVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      let [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
      if (this.$config.get("bodyEvent").shiftKey) {
        realDy = realDx * groupItem.height / groupItem.width;
      }
      const newWidth = groupItem.width + realDx;
      const newHeight = groupItem.height + realDy;
      this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top left", [0, 0, 0]);
    }
    moveTopRightVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      let [realDx, realDy] = this.calculateRealDist(groupItem, 1, distVector);
      if (this.$config.get("bodyEvent").shiftKey) {
        realDy = -(realDx * groupItem.height / groupItem.width);
      }
      const newWidth = groupItem.width + realDx;
      const newHeight = groupItem.height - realDy;
      this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom left", [0, newHeight, 0]);
    }
    moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, direction, directionNewVector) {
      const scaleX = newWidth / groupItem.width;
      const scaleY = newHeight / groupItem.height;
      if (scaleX >= 0 && scaleY >= 0) {
        const view = calculateMatrix(groupItem.directionMatrix[direction], this.calculateNewOffsetMatrixInverse(directionNewVector, newWidth, newHeight, groupItem.originalTransformOrigin, groupItem.itemMatrix));
        const lastStartVertex = getTranslation([], view);
        this.moveGroupItem(lastStartVertex, newWidth, newHeight);
        this.recoverItemForGroup(groupItem, scaleX, scaleY, realDx, realDy);
      }
    }
    moveTopVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      const [, realDy] = this.calculateRealDist(groupItem, 0, distVector);
      const newWidth = groupItem.width;
      const newHeight = groupItem.height - realDy;
      this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom", [newWidth / 2, newHeight, 0]);
    }
    moveBottomVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      const [, realDy] = this.calculateRealDist(groupItem, 2, distVector);
      const newWidth = groupItem.width;
      const newHeight = groupItem.height + realDy;
      this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top", [
        newWidth / 2,
        0,
        0
      ]);
    }
    moveTopLeftVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      let [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
      if (this.$config.get("bodyEvent").shiftKey) {
        realDy = realDx * groupItem.height / groupItem.width;
      }
      const newWidth = groupItem.width - realDx;
      const newHeight = groupItem.height - realDy;
      this.moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, "to bottom right", [newWidth, newHeight, 0]);
    }
    moveLeftVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      const [realDx] = this.calculateRealDist(groupItem, 0, distVector);
      const newWidth = groupItem.width - realDx;
      const newHeight = groupItem.height;
      this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to right", [newWidth, newHeight / 2, 0]);
    }
    moveRightVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      const [realDx] = this.calculateRealDist(groupItem, 2, distVector);
      const newWidth = groupItem.width + realDx;
      const newHeight = groupItem.height;
      this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to left", [
        0,
        newHeight / 2,
        0
      ]);
    }
    moveBottomLeftVertex(distVector) {
      const groupItem = this.cachedGroupItem;
      let [realDx, realDy] = this.calculateRealDist(groupItem, 3, distVector);
      if (this.$config.get("bodyEvent").shiftKey) {
        realDy = -(realDx * groupItem.height / groupItem.width);
      }
      const newWidth = groupItem.width - realDx;
      const newHeight = groupItem.height + realDy;
      this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to top right", [newWidth, 0, 0]);
    }
    moveVertex() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
      if (this.state.moveType === "to bottom right") {
        this.moveBottomRightVertex(distVector);
      } else if (this.state.moveType === "to top right") {
        this.moveTopRightVertex(distVector);
      } else if (this.state.moveType === "to top left") {
        this.moveTopLeftVertex(distVector);
      } else if (this.state.moveType === "to bottom left") {
        this.moveBottomLeftVertex(distVector);
      } else if (this.state.moveType === "to top") {
        this.moveTopVertex(distVector);
      } else if (this.state.moveType === "to left") {
        this.moveLeftVertex(distVector);
      } else if (this.state.moveType === "to right") {
        this.moveRightVertex(distVector);
      } else if (this.state.moveType === "to bottom") {
        this.moveBottomVertex(distVector);
      }
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height"));
      this.renderPointers();
      this.state.dragging = true;
    }
    moveEndVertex() {
      this.state.dragging = false;
      this.$commands.emit("recoverCursor");
      this.$config.set("set.move.control.point", false);
      this.$context.selection.reselect();
      this.initMatrix(true);
      this.nextTick(() => {
        this.$context.selection.recoverChildren();
        this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "width", "height"));
        this.$commands.emit("recoverBooleanPath");
      });
    }
    show() {
      this.$el.show();
      this.state.show = true;
    }
    hide() {
      if (this.state.show) {
        this.$el.hide();
        this.state.show = false;
      }
    }
    initSelectionTool() {
      if (this.$el.isHide() && this.$context.selection.isMany) {
        this.show();
      } else {
        if (this.$el.isShow() && this.$context.selection.isMany === false)
          this.hide();
      }
      this.initMatrix();
      this.makeSelectionTool();
    }
    get item() {
      const verties = this.verties || rectToVerties(0, 0, 0, 0);
      if (!this.state.groupSelectionView) {
        this.state.groupSelectionView = this.$editor.context.modelManager.createModel({ itemType: "artboard" }, false);
      }
      this.state.groupSelectionView.reset({
        parentId: this.$context.selection.currentProject.id,
        x: verties[0][0],
        y: verties[0][1],
        width: dist(verties[0], verties[1]),
        height: dist(verties[0], verties[3])
      });
      return this.state.groupSelectionView;
    }
    initMatrix() {
      if (this.$context.selection.isMany && this.state.dragging === false) {
        this.verties = sapa.clone(this.$context.selection.verties);
        this.angle = 0;
        this.localAngle = this.angle;
        this.groupItem = this.item;
        this.cachedGroupItem = this.item.matrix;
      }
    }
    makeSelectionTool() {
      this.renderPointers();
    }
    renderPointers() {
      if (this.$context.selection.isEmpty) {
        this.refs.$pointerRect.empty();
        return;
      }
      this.state.renderPointerList = [
        this.$viewport.applyVerties(this.$context.selection.verties)
      ];
      const { line: line2, point: point2, size, elementLine } = this.createRenderPointers(this.state.renderPointerList[0]);
      this.refs.$pointerRect.updateDiff(line2 + elementLine + point2 + size);
    }
    createPointer(pointer, number, rotate2) {
      return `
        <div    
            class='pointer' 
            data-number="${number}" 
            data-pointer="${pointer}" 
            style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" 
        ></div>
        `;
    }
    createPointerSide(pointer, number, rotate2, width2, height) {
      return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
    }
    createRotatePointer(pointer, number) {
      if (pointer.length === 0)
        return "";
      if (number < 4) {
        return `
            <div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>
            `;
      }
      return `
        <div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>
        `;
    }
    createPointerRect(pointers, rotatePointer) {
      if (pointers.length === 0)
        return "";
      const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
      const line2 = `
            M ${centerPointer[0]},${centerPointer[1]} 
            L ${rotatePointer[0]}, ${rotatePointer[1]} 
        `;
      return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    ${line2}
                    Z
                " />
        </svg>`;
    }
    createLine(pointers) {
      return `
            M ${pointers[0][0]}, ${pointers[0][1]} 
            L ${pointers[1][0]}, ${pointers[1][1]} 
            L ${pointers[2][0]}, ${pointers[2][1]} 
            L ${pointers[3][0]}, ${pointers[3][1]} 
            L ${pointers[0][0]}, ${pointers[0][1]}
            Z
        `;
    }
    createSize(pointers) {
      const top = lerp([], pointers[0], pointers[1], 0.5);
      const right = lerp([], pointers[1], pointers[2], 0.5);
      const bottom = lerp([], pointers[2], pointers[3], 0.5);
      const left = lerp([], pointers[3], pointers[0], 0.5);
      const worldPosition = this.$viewport.applyVertiesInverse(pointers);
      const width2 = dist(worldPosition[0], worldPosition[1]);
      const height = dist(worldPosition[0], worldPosition[3]);
      const list = [
        { start: top, end: bottom },
        { start: right, end: left },
        { start: bottom, end: top },
        { start: left, end: right }
      ].map((it, index2) => {
        return { index: index2, data: it };
      });
      list.sort((a, b) => {
        return a.data.start[1] > b.data.start[1] ? -1 : 1;
      });
      const item = list[0];
      const newPointer = lerp([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
      const diff = subtract([], item.data.start, item.data.end);
      const angle = calculateAngle360(diff[0], diff[1]) + 90;
      let text2 = `${round(width2, 100)} x ${round(height, 100)}`;
      if (this.state.isRotate) {
        const rotateZ2 = this.groupItem.angle;
        if (rotateZ2) {
          text2 = `${rotateZ2}\xB0`;
        }
      }
      return `<div class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
    }
    createRenderPointers(pointers) {
      const diff = subtract([], lerp([], pointers[0], pointers[1], 0.5), lerp([], pointers[0], pointers[2], 0.5));
      const rotate2 = editor.Length.deg(calculateAngle360(diff[0], diff[1]) - 90).round(1e3);
      const rotatePointer = getRotatePointer(pointers, 30);
      const dist$1 = dist(pointers[0], pointers[2]);
      const width2 = dist(pointers[0], pointers[1]);
      const height = dist(pointers[0], pointers[3]);
      return {
        line: this.createPointerRect(pointers, rotatePointer),
        elementLine: `
                <svg class='line' overflow="visible">
                    <path 
                        d="${this.$context.selection.items.map((it) => {
          return this.createLine(this.$viewport.applyVerties(it.originVerties));
        }).join("")}
                        " />
                </svg>
            `,
        size: this.createSize(pointers),
        point: [
          this.createRotatePointer(rotatePointer, 4, "center center"),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height),
          this.createPointer(pointers[0], 1, rotate2),
          this.createPointer(pointers[1], 2, rotate2),
          this.createPointer(pointers[2], 3, rotate2),
          this.createPointer(pointers[3], 4, rotate2)
        ].join("")
      };
    }
    checkShow() {
      if (this.state.show && this.$context.selection.isMany) {
        return true;
      }
      return false;
    }
    [sapa.SUBSCRIBE("hideSelectionToolView")]() {
      this.hide();
    }
  }
  var directionType = {
    1: "to top left",
    2: "to top right",
    3: "to bottom right",
    4: "to bottom left",
    11: "to top",
    12: "to right",
    13: "to bottom",
    14: "to left"
  };
  const SelectionToolEvent = class extends editor.EditorElement {
    checkViewMode() {
      return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + sapa.IF("checkViewMode")]() {
      this.initSelectionTool();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT) + sapa.IF("checkViewMode")]() {
      if (this.$context.selection.isOne) {
        this.initSelectionTool();
      } else {
        this.hide();
      }
    }
    [sapa.SUBSCRIBE("updateModeView")]() {
      if (this.checkViewMode()) {
        this.initSelectionTool();
      } else {
        this.hide();
      }
    }
  };
  class SelectionToolView extends SelectionToolEvent {
    template() {
      return `
            <div class='elf--selection-view one-selection-view' ref='$selectionView' style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>
            </div>
        `;
    }
    toggleEditingPath(isEditingPath) {
      this.$el.toggleClass("editing-path", isEditingPath);
    }
    [sapa.POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
      this.state.moveType = "rotate";
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.$context.selection.reselect();
      this.verties = sapa.clone(this.$context.selection.verties);
      this.$context.snapManager.clear();
      this.rotateTargetNumber = +e.$dt.attr("data-number");
      this.refreshRotatePointerIcon();
      this.state.dragging = true;
      this.state.isRotate = true;
      this.initAngle = this.$context.selection.current.angle;
    }
    rotateVertex() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const distVector = subtract([], targetMousePoint, this.initMousePoint);
      const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
      var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
      const instance = this.$context.selection.current;
      let newAngle = this.initAngle + distAngle;
      if (instance) {
        if (this.$config.get("bodyEvent").shiftKey) {
          newAngle -= newAngle % this.$config.get("fixed.angle");
        }
        instance.angle = round(newAngle % 360, 100);
      }
      this.state.dragging = true;
      this.$commands.emit("setAttribute", this.$context.selection.pack("angle"));
      this.makeSelectionTool();
    }
    rotateEndVertex() {
      this.state.dragging = false;
      this.state.isRotate = false;
      this.$commands.emit("recoverCursor");
      this.verties = null;
      this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.pack("angle"));
    }
    refreshRotatePointerIcon() {
      this.$commands.emit("refreshCursor", "rotate");
    }
    refreshPointerIcon(e) {
      const dataPointer = e.$dt.data("pointer");
      if (dataPointer) {
        const pointer = dataPointer.split(",").map((it) => Number(it));
        const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
        const angle = calculateAngle360(diff[0], diff[1]);
        let iconAngle = Math.floor(angle);
        this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
      } else {
        this.$commands.emit("recoverCursor");
      }
    }
    checkPointerIsNotMoved() {
      return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
    }
    [sapa.POINTEROVER("$pointerRect .rotate-pointer") + sapa.IF("checkPointerIsNotMoved")](e) {
      this.refreshRotatePointerIcon(e);
    }
    [sapa.POINTEROVER("$pointerRect .pointer") + sapa.IF("checkPointerIsNotMoved")](e) {
      this.refreshPointerIcon(e);
    }
    [sapa.POINTEROUT("$pointerRect .pointer,.rotate-pointer") + sapa.IF("checkPointerIsNotMoved")]() {
      this.$commands.emit("recoverCursor");
    }
    [sapa.POINTERSTART("$pointerRect .pointer") + MOVE("moveVertex") + END("moveEndVertex")](e) {
      this.refreshPointerIcon(e);
      this.state.dragging = true;
      const num = +e.$dt.attr("data-number");
      const direction = directionType[`${num}`];
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.state.moveType = direction;
      this.state.moveTarget = num;
      this.$context.snapManager.clear();
      this.verties = this.$context.selection.verties;
      this.hasRotate = this.$context.selection.current.angle !== 0;
      this.cachedCurrentItemMatrix = this.$context.selection.current.matrix;
      this.$context.selection.startToCacheChildren();
    }
    calculateDistance(vertex, distVector, reverseMatrix) {
      const currentVertex = clone(vertex);
      const moveVertex = add([], currentVertex, distVector);
      const snap = this.$context.snapManager.check([moveVertex], 5 / this.$viewport.scale);
      const nextVertex = add([], moveVertex, snap.dist);
      const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
      const realDist = subtract([], nextResult, currentResult);
      return realDist;
    }
    calculateRealDist(item, vertexIndex, distVector) {
      return this.calculateDistance(item.verties[vertexIndex], distVector, item.absoluteMatrixInverse);
    }
    moveItem(instance, lastStartVertex, newWidth, newHeight, options2 = {}) {
      if (instance) {
        let data = {
          x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
          y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
          width: Math.max(Math.abs(newWidth), 1),
          height: Math.max(Math.abs(newHeight), 1)
        };
        if (instance.isInFlex()) {
          delete data.x;
          delete data.y;
        } else if (instance.isInGrid())
          ;
        if (this.hasRotate)
          ;
        else {
          data = objectFloor(data);
          data.width = Math.max(data.width, 1);
          data.height = Math.max(data.height, 1);
        }
        instance.reset(__spreadValues(__spreadValues({}, data), options2));
      }
    }
    moveDirectionVertex(item, newWidth, newHeight, direction, directionNewVector, options2 = {}) {
      const center = subtract([], TransformOrigin.scale(item.originalTransformOrigin, newWidth, newHeight), directionNewVector);
      const newOffsetInverse = calculateMatrixInverse(fromTranslation([], directionNewVector), fromTranslation([], center), item.itemMatrix, fromTranslation([], negate([], center)));
      const view = calculateMatrix(item.directionMatrix[direction], newOffsetInverse);
      const lastStartVertex = getTranslation([], view);
      this.moveItem(this.$model.get(item.id), lastStartVertex, newWidth, newHeight, options2);
    }
    moveBottomRightVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx, realDy] = this.calculateRealDist(item, 2, distVector);
        let directionNewVector = fromValues(0, 0, 0);
        if (altKey) {
          realDx = realDx * 2;
          realDy = realDy * 2;
        }
        if (shiftKey) {
          realDy = realDx * item.height / item.width;
        }
        const newWidth = item.width + realDx;
        const newHeight = metaKey ? newWidth : item.height + realDy;
        if (altKey) {
          directionNewVector = fromValues(realDx / 2, realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to top left", directionNewVector, {
          resizingVertical: ResizingMode.FIXED,
          resizingHorizontal: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveTopRightVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx, realDy] = this.calculateRealDist(item, 1, distVector);
        if (altKey) {
          realDx = realDx * 2;
          realDy = realDy * 2;
        }
        if (shiftKey) {
          realDy = -(realDx * item.height / item.width);
        }
        const newWidth = item.width + realDx;
        const newHeight = metaKey ? newWidth : item.height - realDy;
        let directionNewVector = fromValues(0, newHeight, 0);
        if (altKey) {
          directionNewVector = fromValues(realDx / 2, newHeight + realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to bottom left", directionNewVector, {
          resizingVertical: ResizingMode.FIXED,
          resizingHorizontal: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveTopLeftVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx, realDy] = this.calculateRealDist(item, 0, distVector);
        if (altKey) {
          realDx = realDx * 2;
          realDy = realDy * 2;
        }
        if (shiftKey) {
          realDy = realDx * item.height / item.width;
        }
        const newWidth = item.width - realDx;
        const newHeight = metaKey ? newWidth : item.height - realDy;
        let directionNewVector = fromValues(newWidth, newHeight, 0);
        if (altKey) {
          directionNewVector = fromValues(newWidth + realDx / 2, newHeight + realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to bottom right", directionNewVector, {
          resizingHorizontal: ResizingMode.FIXED,
          resizingVertical: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveTopVertex(distVector) {
      const { altKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [, realDy] = this.calculateRealDist(item, 0, distVector);
        if (altKey) {
          realDy = realDy * 2;
        }
        const newWidth = item.width;
        const newHeight = item.height - realDy;
        let directionNewVector = fromValues(newWidth / 2, newHeight, 0);
        if (altKey) {
          directionNewVector = fromValues(newWidth / 2, newHeight + realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to bottom", directionNewVector, {
          resizingVertical: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveBottomVertex(distVector) {
      const { altKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [, realDy] = this.calculateRealDist(item, 3, distVector);
        if (altKey) {
          realDy = realDy * 2;
        }
        const newWidth = item.width;
        const newHeight = item.height + realDy;
        let directionNewVector = fromValues(newWidth / 2, 0, 0);
        if (altKey) {
          directionNewVector = fromValues(newWidth / 2, realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to top", directionNewVector, {
          resizingVertical: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveRightVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx] = this.calculateRealDist(item, 1, distVector);
        if (altKey) {
          realDx = realDx * 2;
        }
        const newWidth = item.width + realDx;
        let newHeight = item.height;
        if (metaKey) {
          newHeight = newWidth;
        } else if (shiftKey) {
          newHeight = item.height * (1 + realDx / item.width);
        }
        let directionNewVector = fromValues(0, newHeight / 2, 0);
        if (altKey) {
          directionNewVector = fromValues(realDx / 2, newHeight / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to left", directionNewVector, {
          resizingHorizontal: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveLeftVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx] = this.calculateRealDist(item, 0, distVector);
        if (altKey) {
          realDx = realDx * 2;
        }
        const newWidth = item.width - realDx;
        let newHeight = item.height;
        if (metaKey) {
          newHeight = newWidth;
        } else if (shiftKey) {
          newHeight = item.height * (1 - realDx / item.width);
        }
        let directionNewVector = fromValues(newWidth, newHeight / 2, 0);
        if (altKey) {
          directionNewVector = fromValues(newWidth + realDx / 2, newHeight / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to right", directionNewVector, {
          resizingHorizontal: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveBottomLeftVertex(distVector) {
      const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
      const item = this.cachedCurrentItemMatrix;
      if (item) {
        let [realDx, realDy] = this.calculateRealDist(item, 3, distVector);
        if (altKey) {
          realDx = realDx * 2;
          realDy = realDy * 2;
        }
        if (shiftKey) {
          realDy = -(realDx * item.height / item.width);
        }
        const newWidth = item.width - realDx;
        const newHeight = metaKey ? newWidth : item.height + realDy;
        let directionNewVector = fromValues(newWidth, 0, 0);
        if (altKey) {
          directionNewVector = fromValues(newWidth + realDx / 2, realDy / 2, 0);
        }
        this.moveDirectionVertex(item, newWidth, newHeight, "to top right", directionNewVector, {
          resizingVertical: ResizingMode.FIXED,
          resizingHorizontal: ResizingMode.FIXED
        });
        this.updateGridArea(item);
      }
    }
    moveVertex() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
      if (this.state.moveType === "to top left") {
        this.moveTopLeftVertex(distVector);
      } else if (this.state.moveType === "to top") {
        this.moveTopVertex(distVector);
      } else if (this.state.moveType === "to right") {
        this.moveRightVertex(distVector);
      } else if (this.state.moveType === "to bottom") {
        this.moveBottomVertex(distVector);
      } else if (this.state.moveType === "to left") {
        this.moveLeftVertex(distVector);
      } else if (this.state.moveType === "to top right") {
        this.moveTopRightVertex(distVector);
      } else if (this.state.moveType === "to bottom right") {
        this.moveBottomRightVertex(distVector);
      } else if (this.state.moveType === "to bottom left") {
        this.moveBottomLeftVertex(distVector);
      }
      this.$context.selection.recoverChildren();
      const current = this.$context.selection.current;
      if (current.isInGrid()) {
        this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
      } else {
        this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
      }
      this.state.dragging = true;
      this.makeSelectionTool();
    }
    updateGridArea() {
      return GridLayoutEngine.updateGridArea(this.$context.selection.current, this.$context.selection.gridInformation, this.$context.viewport.scale);
    }
    moveEndVertex() {
      this.state.dragging = false;
      this.$commands.emit("recoverCursor");
      this.$context.selection.reselect();
      this.nextTick(() => {
        this.$context.selection.recoverChildren();
        if (this.$context.selection.current.isInGrid()) {
          this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
        } else {
          this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
        }
        this.$commands.emit("recoverBooleanPath");
      });
    }
    show() {
      this.$el.show();
      this.state.show = true;
    }
    hide() {
      this.$el.hide();
      this.state.show = false;
    }
    initSelectionTool() {
      if (this.$el.isShow() && this.$context.selection.isOne === false) {
        this.hide();
      } else if (this.$el.isHide() && this.$context.selection.isOne) {
        this.show();
      }
      this.makeSelectionTool();
    }
    makeSelectionTool() {
      this.renderPointers();
    }
    getRateDistance(startVetex, endVertex, dist$1 = 0) {
      return lerp([], startVetex, endVertex, (dist(startVetex, endVertex) + dist$1) / dist(startVetex, endVertex));
    }
    renderPointers() {
      if (this.$context.selection.isEmpty || this.$config.true("set.move.control.point")) {
        this.refs.$pointerRect.empty();
        return;
      }
      const verties = this.$context.selection.verties;
      if (dist(verties[0], verties[1]) === 0) {
        return;
      }
      const screenVerties = this.$viewport.applyVerties(verties).map((it) => {
        return round$1([], it);
      });
      this.state.renderPointerList = [
        screenVerties,
        [
          this.getRateDistance(screenVerties[4], screenVerties[0], 20),
          this.getRateDistance(screenVerties[4], screenVerties[1], 20),
          this.getRateDistance(screenVerties[4], screenVerties[2], 20),
          this.getRateDistance(screenVerties[4], screenVerties[3], 20)
        ]
      ];
      const pointers = this.createRenderPointers(...this.state.renderPointerList);
      if (pointers) {
        const { line: line2, parentRect, point: point2, size, visiblePath } = pointers;
        this.refs.$pointerRect.updateDiff(line2 + parentRect + point2 + size + visiblePath);
      }
    }
    createPointer(pointer, number, rotate2) {
      return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
    }
    createPointerSide(pointer, number, rotate2, width2, height) {
      return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
    }
    createRotatePointer(pointer, number) {
      if (pointer.length === 0)
        return "";
      if (number < 4) {
        return `<div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>`;
      }
      return `<div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>`;
    }
    createPointerRect(pointers, rotatePointer = void 0) {
      if (pointers.length === 0)
        return "";
      const current = this.$context.selection.current;
      const isArtBoard = current && current.is("artboard");
      let line2 = "";
      if (!isArtBoard && rotatePointer) {
        const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
        line2 += `
                M ${centerPointer[0]},${centerPointer[1]} 
                L ${rotatePointer[0]},${rotatePointer[1]} 
            `;
      }
      return `<svg class='line' overflow="visible"> <path  d=" M ${pointers[0][0]}, ${pointers[0][1]} L ${pointers[1][0]}, ${pointers[1][1]} L ${pointers[2][0]}, ${pointers[2][1]} L ${pointers[3][0]}, ${pointers[3][1]} L ${pointers[0][0]}, ${pointers[0][1]} ${line2} Z" />
        </svg>`;
    }
    createParentRect(pointers = []) {
      if (pointers.length === 0)
        return "";
      return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    Z
                " 
                stroke="red"
                />
        </svg>`;
    }
    createSize(pointers) {
      const top = lerp([], pointers[0], pointers[1], 0.5);
      const right = lerp([], pointers[1], pointers[2], 0.5);
      const bottom = lerp([], pointers[2], pointers[3], 0.5);
      const left = lerp([], pointers[3], pointers[0], 0.5);
      const list = [
        { start: top, end: bottom },
        { start: right, end: left },
        { start: bottom, end: top },
        { start: left, end: right }
      ].map((it, index2) => {
        return { index: index2, data: it };
      });
      list.sort((a, b) => {
        return a.data.start[1] > b.data.start[1] ? -1 : 1;
      });
      const item = list[0];
      const newPointer = lerp([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
      const width2 = this.$context.selection.current.width;
      const height = this.$context.selection.current.height;
      const diff = subtract([], item.data.start, item.data.end);
      const angle = calculateAngle360(diff[0], diff[1]) + 90;
      const widthPx = round(width2, 100);
      const heightPx = round(height, 100);
      let text2 = widthPx === heightPx ? `WH: ${widthPx}` : `${round(width2, 100)} x ${round(height, 100)}`;
      if (this.state.isRotate) {
        text2 = `${round(this.$context.selection.current.angle, 100)}\xB0`;
      }
      return `<div data-layout="${this.$context.selection.current.layout}" class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
    }
    createVisiblePath() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      if (!current.isBooleanItem) {
        return "";
      }
      const newPath = current.absolutePath();
      newPath.transformMat4(this.$viewport.matrix);
      return `
        <svg class='line' overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
    }
    removeNaN(value) {
      return value.replace(/NaN/g, "0");
    }
    createRenderPointers(pointers, selectionPointers) {
      const current = this.$context.selection.current;
      if (current && current.is("text")) {
        if (current.width === 0 && current.height === 0) {
          return;
        }
      }
      const rotate2 = editor.Length.deg(current.nestedAngle).round(1e3);
      const dist$1 = dist(pointers[0], pointers[2]);
      const width2 = dist(pointers[0], pointers[1]);
      const height = dist(pointers[0], pointers[3]);
      return {
        line: this.createPointerRect(pointers),
        size: this.createSize(pointers),
        parentRect: "",
        visiblePath: this.createVisiblePath(),
        point: [
          this.createRotatePointer(selectionPointers[0], 0),
          this.createRotatePointer(selectionPointers[1], 1),
          this.createRotatePointer(selectionPointers[2], 2),
          this.createRotatePointer(selectionPointers[3], 3),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
          dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height),
          this.createPointer(pointers[0], 1, rotate2),
          this.createPointer(pointers[1], 2, rotate2),
          this.createPointer(pointers[2], 3, rotate2),
          this.createPointer(pointers[3], 4, rotate2),
          this.createPointer(pointers[4], 5, rotate2)
        ].join("")
      };
    }
    checkShow() {
      if (this.$modeView.isCurrentMode(ViewModeType.CanvasView) === false) {
        return false;
      }
      if (this.state.show && this.$context.selection.isOne) {
        return true;
      }
      return false;
    }
    [sapa.SUBSCRIBE("hideSelectionToolView")]() {
      this.hide();
    }
  }
  async function selectionToolView(editor2) {
    editor2.registerUI("canvas.view", {
      GhostToolView,
      SelectionToolView,
      GroupSelectionToolView
    }, CanvasViewToolLevel.SELECTION_TOOL);
  }
  var SelectorPopup$1 = "";
  class SelectorPopup extends editor.BasePopup {
    getTitle() {
      return this.$i18n("selector.popup.title");
    }
    initState() {
      return {
        selector: "",
        properties: []
      };
    }
    updateData(opt) {
      this.setState(opt, false);
      this.emit("changeSelectorPopup", this.state);
    }
    getBody() {
      return `
    <div class='elf--selector-popup' ref='$popup'>
      <div class="box">
        ${this.templateForSelector()}
        ${this.templateForProperty()}        
      </div>
    </div>`;
    }
    templateForProperty() {
      return sapa.createComponent("CSSPropertyEditor", {
        ref: "$propertyEditor",
        onchange: "changePropertyEditor"
      });
    }
    templateForSelector() {
      return `
      <div class='name'>
        <label>${this.$i18n("selector.popup.selector")}</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.selector}' ref='$selector'/>
        </div>
      </div>
    `;
    }
    [sapa.INPUT("$selector")](e) {
      if (this.refs.$selector.value.match(/^[a-zA-Z0-9:_\-.\b]+$/)) {
        this.updateData({ selector: this.refs.$selector.value });
      } else {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    refresh() {
      super.refresh();
      this.refs.$selector.val(this.state.selector);
      this.children.$propertyEditor.trigger("showCSSPropertyEditor", this.state.properties);
    }
    [sapa.SUBSCRIBE("changePropertyEditor")](properties) {
      this.updateData({
        properties
      });
    }
    [sapa.SUBSCRIBE("showSelectorPopup")](data) {
      this.setState(data);
      this.refresh();
      this.show(250);
    }
  }
  var SelectorProperty$1 = "";
  const selectorList = [
    "",
    ":hover",
    ":active",
    ":before",
    ":after",
    ":first-child",
    ":last-child",
    ":link",
    ":active",
    ":focus"
  ].map((value) => ({ value }));
  class SelectorProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("selector.property.title");
    }
    getBody() {
      return `<div class='elf--selector-list' ref='$selectorList'></div>`;
    }
    getTools() {
      return `
      <div style='display:inline-block;'>
        ${sapa.createComponent("SelectEditor", {
        ref: "$select",
        key: "selector",
        "none-value": "selector",
        options: selectorList
      })}
      </div>
      <button type="button" ref="$add" title="add Selector">${editor.iconUse("add")}</button>
    `;
    }
    makeSelectorTemplate(selector2, index2) {
      index2 = index2.toString();
      return `
      <div class='selector-item' draggable='true' ref='$selectorIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>
            <span>${selector2.selector || `&lt;${this.$i18n("selector.property.none")}&gt;`}</span>
          </div>
          <div class='tools'>
              <button type="button" class="del" data-index="${index2}">${editor.iconUse("remove2")}</button>
          </div>
        </div>
      </div>
    `;
    }
    [sapa.CLICK("$selectorList .selector-item .name")](e) {
      var index2 = +e.$dt.closest("selector-item").attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.viewSelectorPicker(index2);
    }
    [sapa.CLICK("$selectorList .selector-item .del") + sapa.PREVENT + sapa.STOP](e) {
      var removeIndex = e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      const selectors = current.selectors || [];
      selectors.splice(removeIndex, 1);
      this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.packByValue({
        selectors
      }));
      this.refresh();
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShowIsNot([
        "project",
        "svg-path",
        "svg-brush",
        "svg-textpath",
        "svg-text"
      ]);
    }
    [sapa.LOAD("$selectorList")]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      var selectors = current.selectors || [];
      return selectors.map((selector2, index2) => {
        return this.makeSelectorTemplate(selector2, index2);
      });
    }
    [sapa.DRAGSTART("$selectorList .selector-item .title")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$selectorList .selector-item") + sapa.PREVENT]() {
    }
    [sapa.DROP("$selectorList .selector-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      current.sortSelector(this.startIndex, targetIndex);
      this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.packByValue({
        selectors: [...current.selectors]
      }));
      this.refresh();
    }
    [sapa.CLICK("$add")]() {
      var current = this.$context.selection.current;
      if (current) {
        current.createSelector({
          selector: this.children.$select.getValue()
        });
        this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.packByValue({
          selectors: [...current.selectors]
        }));
      }
      this.refresh();
    }
    viewSelectorPicker(index2) {
      if (typeof this.selectedIndex === "number") {
        this.selectItem(this.selectedIndex, false);
      }
      this.selectedIndex = +index2;
      this.selectItem(this.selectedIndex, true);
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.currentSelector = this.current.selectors[this.selectedIndex];
      this.viewSelectorPropertyPopup();
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.getRef("$selectorIndex", selectedIndex).addClass("selected");
      } else {
        this.getRef("$selectorIndex", selectedIndex).removeClass("selected");
      }
      if (this.current) {
        this.current.selectors.forEach((it, index2) => {
          it.selected = index2 === selectedIndex;
        });
      }
    }
    viewSelectorPropertyPopup(position2) {
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.currentSelector = this.current.selectors[this.selectedIndex];
      const back = this.currentSelector;
      const selector2 = back.selector;
      const properties = back.properties;
      this.emit("showSelectorPopup", {
        position: position2,
        selector: selector2,
        properties
      });
    }
    [sapa.SUBSCRIBE("changeSelectorPopup")](data) {
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.current.selectors[this.selectedIndex] = data;
      this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack({
        selectors: [...this.current.selectors]
      }));
      this.nextTick(() => {
        this.refresh();
      }, 10);
    }
  }
  function selector(editor2) {
    editor2.registerUI("inspector.tab.transition", {
      SelectorProperty
    });
    editor2.registerUI("popup", {
      SelectorPopup
    });
  }
  var SVGFilterAssetsProperty$1 = "";
  class SVGFilterAssetsProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("svgfilter.asset.property.title");
    }
    initState() {
      return {
        mode: "grid"
      };
    }
    getClassName() {
      return "elf--svgfilter-assets-property";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.show();
    }
    getBody() {
      return `
      <div class='property-item svgfilter-assets'>
        <div class='svgfilter-list' ref='$svgfilterList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.LOAD("$svgfilterList")]() {
      var current = this.$context.selection.currentProject || { svgfilters: [] };
      var svgfilters = current.svgfilters;
      var results = svgfilters.map((svgfilter, index2) => {
        var filters = svgfilter.filters.map((filter2) => {
          return SVGFilter.parse(filter2);
        });
        return `
        <div class='svgfilter-item' data-index="${index2}">
          <div class='preview' data-index="${index2}">
            <svg width="0" height="0">
              <filter id="svgfilter-${index2}">
                ${filters.join("")} 
              </filter>
            </svg>
            <div class='svgfilter-view' style='filter: url(#svgfilter-${index2});'></div>
          </div>
          <div class='title'>
            <div>
              <input type='text' class='id' data-key='id' value='${svgfilter.id}' placeholder="id" />
            </div>
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${editor.iconUse("copy")}</button>          
            <button type="button" class='remove'>${editor.iconUse("remove")}</button>
          </div>
        </div>
      `;
      });
      results.push(`<div class='add-svgfilter-item'><button type="button">${editor.iconUse("add")}</button></div>`);
      return results;
    }
    executeSVGFilter(callback, isRefresh = true, isEmit = true) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
        if (isRefresh)
          this.refresh();
        if (isEmit)
          this.emit("refreshSVGFilterAssets");
      } else {
        window.alert("Please select a project.");
      }
    }
    [sapa.CLICK("$svgfilterList .add-svgfilter-item")]() {
      this.executeSVGFilter((project2) => {
        project2.createSVGFilter({
          id: uuidShort(),
          filters: []
        });
      });
    }
    [sapa.CLICK("$svgfilterList .remove")](e) {
      var $item = e.$dt.closest("svgfilter-item");
      var index2 = +$item.attr("data-index");
      this.executeSVGFilter((project2) => {
        project2.removeSVGFilter(index2);
      });
    }
    [sapa.CLICK("$svgfilterList .copy")](e) {
      var $item = e.$dt.closest("svgfilter-item");
      var index2 = +$item.attr("data-index");
      this.executeSVGFilter((project2) => {
        project2.copySVGFilter(index2);
      });
    }
    [sapa.INPUT("$svgfilterList input")](e) {
      var $item = e.$dt.closest("svgfilter-item");
      var index2 = +$item.attr("data-index");
      var obj2 = e.$dt.attrKeyValue("data-key");
      this.executeSVGFilter((project2) => {
        project2.setSVGFilterValue(index2, obj2);
        this.emit("refreshSVGArea");
      }, false);
    }
    [sapa.CLICK("$svgfilterList .preview")](e) {
      var $item = e.$dt.closest("svgfilter-item");
      var index2 = +$item.attr("data-index");
      this.state.$item = $item;
      this.state.$el = e.$dt.$(".svgfilter-view");
      var currentProject = this.$context.selection.currentProject || {
        svgfilters: []
      };
      var svgfilter = currentProject.svgfilters[index2];
      this.emit("showSVGFilterPopup", {
        changeEvent: "changeSVGFilterAssets",
        id: this.id,
        index: index2,
        filters: svgfilter.filters
      });
    }
    [sapa.SUBSCRIBE("updateSVGFilterAssets")](params) {
      this.executeSVGFilter((project2) => {
        project2.setSVGFilterValue(params.index, {
          filters: params.filters
        });
        this.state.$item.$("filter").html(params.filters.join("\n"));
        this.emit("refreshSVGArea");
      }, false);
    }
    [sapa.SUBSCRIBE("changeSVGFilterAssets")](params) {
      if (params.id === this.id) {
        this.trigger("updateSVGFilterAssets", params);
      }
    }
    [sapa.SUBSCRIBE("refreshSVGFilterAssets")]() {
      this.refresh();
    }
  }
  function svgFilterAsset(editor2) {
    editor2.registerElement({
      SVGFilterAssetsProperty
    });
  }
  var alpha = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   .5  0 
`;
  var blue = `
0   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
  var BlueMagenta2 = `
1   0   0   0   0
0   0   0   0   0
0   0   1  .5   0
0   0   0   1   0 
`;
  var BlueShadowMagentHightlight = `
1   0   0   0   0
0   0   0   0   0
0   0   1   1   0
0   0   0   1   0 
`;
  var cyan = `
0   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
  var darken = `
.5   0   0   0   0
0  .5   0   0   0
0   0  .5   0   0
0   0   0   1   0 
`;
  var ElimBlue = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   -2   1   0 
`;
  var GrayOnDark = `
0   0   1   0   0
0   0   1   0   0
0   0   1   0   0
0   0   0   1   0  
`;
  var GrayOnLight = `
1   0   0   0   0
1   0   0   0   0
1   0   0   0   0
0   0   0   1   0 
`;
  var GrayOnMid = `
0   1   0   0   0
0   1   0   0   0
0   1   0   0   0
0   0   0   1   0 
`;
  var green = `
0   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
  var HardGreen = `
1   0   0   0   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
  var HardYellow = `
1   0   0   1   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
  var IdenticalRedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
  var lighten = `
1.5   0   0   0   0
0   1.5   0   0   0
0   0   1.5   0   0
0   0   0   1   0 
`;
  var lime = `
1   0   0   0   0
0   2   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
  var magenta = `
1   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
  var NoGreenMagenta = `
1   1   0   0   0
0   0   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
  var NoGreenRed = `
1   1   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
  var peachy = `
1   0   0   0   0
0  .5   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
  var red = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0
`;
  var RedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   1  -1   0
0   0   0   1   0 
`;
  var yellow = `
1   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
  var YesGreenColorizedMagenta = `
1   1   0   0   0
0   1   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
  var colormatrix = {
    red,
    green,
    blue,
    yellow,
    magenta,
    cyan,
    alpha,
    BlueMagenta2,
    BlueShadowMagentHightlight,
    darken,
    ElimBlue,
    GrayOnDark,
    GrayOnLight,
    GrayOnMid,
    HardGreen,
    HardYellow,
    IdenticalRedOverlay,
    lighten,
    lime,
    NoGreenMagenta,
    NoGreenRed,
    peachy,
    RedOverlay,
    YesGreenColorizedMagenta
  };
  var ColorMatrixEditor$1 = "";
  const COLUMN = 6;
  const sampleList = Object.keys(colormatrix).map((it) => {
    return { title: it, values: colormatrix[it] };
  });
  class ColorMatrixEditor extends editor.EditorElement {
    initState() {
      return {
        values: normalize(this.props.values)
      };
    }
    template() {
      return `
            <div class='elf--color-matrix-editor' >
                <div ref='$body'></div>
                <div class='title'> Mix Color Template </div>
                <div class='color-matrix-template' ref='$sample'></div>
            </div>
        `;
    }
    [sapa.BIND("$body")]() {
      return {
        cssText: `
                display: grid;
                grid-template-columns: repeat(${COLUMN}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
                text-align: left; 
            `
      };
    }
    [sapa.LOAD("$sample")]() {
      return sampleList.map((it, index2) => {
        return `<div class='sample-item' title='${it.title}' data-index="${index2}">${it.title}</div>`;
      });
    }
    [sapa.CLICK("$sample .sample-item")](e) {
      var index2 = +e.$dt.attr("data-index");
      var sample2 = sampleList[index2];
      this.updateData({
        values: normalize(sample2.values)
      });
      this.load("$body");
    }
    [sapa.LOAD("$body")]() {
      var { values } = this.state;
      var text2 = ["R", "G", "B", "A"];
      var a = values.map((value, index2) => {
        var h = "";
        if (index2 % (COLUMN - 1) === 0) {
          h = `<div>${text2[Math.floor(index2 / (COLUMN - 1))]}</div>`;
        }
        var result = `
                ${h}
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
        return result;
      });
      var header = `
            <div></div>
            <div>R</div>
            <div>G</div>
            <div>B</div>
            <div>A</div>
            <div>M</div>
        `;
      return header + a;
    }
    updateData(data) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
    }
    [sapa.INPUT("$body input")](e) {
      var $el = e.$dt;
      var index2 = +$el.attr("data-index");
      var value = +$el.value;
      this.state.values[index2] = value;
      this.updateData();
    }
  }
  var FuncFilterEditor$1 = "";
  class FuncFilterEditor extends editor.EditorElement {
    initState() {
      return __spreadValues({
        label: this.props.label || ""
      }, this.parse(this.props.value));
    }
    parse(value) {
      var [type, ...values] = value.split(" ");
      if (type === "linear") {
        var [slop, intercept] = values;
      } else if (type === "gamma") {
        var [amplitude, exponent, offset] = values;
      }
      return {
        type,
        values,
        slop,
        intercept,
        amplitude,
        exponent,
        offset
      };
    }
    template() {
      return `<div class='small-editor func-filter' ref='$body'></div>`;
    }
    [sapa.LOAD("$body")]() {
      var { type, label } = this.state;
      var hasLabel = label ? "has-label" : "";
      return `
            ${sapa.createComponent("SelectEditor", {
        label,
        ref: "$type",
        key: "type",
        value: this.state.type,
        options: ["identity", "table", "discrete", "linear", "gamma"],
        onchange: "changeType"
      })}
        <div class='elf--func-filter-editor ${hasLabel}' ref='$container' data-selected-type='${type}'>
            ${label ? `<label></label>` : ""}
            <div data-type='identity'>
            </div>
            <div data-type='table'>
                ${sapa.createComponent("TextEditor", {
        label: "tableValues",
        ref: "$values",
        key: "values",
        value: this.state.values.join(" "),
        onchange: (key, value) => {
          this.updateData({
            [key]: value.split(" ")
          });
        }
      })}
            </div>
            <div data-type='linear'>
                ${["slop", "intercept"].map((it) => {
        return `
                        <div>
                            ${sapa.createComponent("NumberRangeEditor", {
          label: it,
          ref: `$${it}`,
          key: it,
          value: this.state[it],
          onchange: (key, value) => {
            this.updateData({
              [key]: value
            });
          }
        })}
                        </div>                    
                    `;
      }).join("")}
            </div>
            <div data-type='gamma'>
                ${["amplitude", "exponent", "offset"].map((it) => {
        return `
                        <div>
                            ${sapa.createComponent("NumberRangeEditor", {
          label: it,
          ref: `$${it}`,
          key: it,
          value: this.state[it],
          onchange: (key, value) => {
            this.updateData({
              [key]: value
            });
          }
        })}
                        </div>                    
                    `;
      }).join("")}            
            </div>                                                
        </div>
    `;
    }
    [sapa.SUBSCRIBE("changeType")](key, type) {
      this.updateData({ type });
      this.refresh();
    }
    getValue() {
      switch (this.state.type) {
        case "table":
        case "discrete":
          return [this.state.type, ...this.state.values].join(" ");
        case "linear":
          return [this.state.type, this.state.slop, this.state.intercept].join(" ");
        case "gamma":
          return [
            this.state.type,
            this.state.amplitude,
            this.state.exponent,
            this.state.offset
          ].join(" ");
      }
      return "identity";
    }
    setValue(value) {
      this.setState(__spreadValues({}, this.parse(value)));
    }
    updateData(data) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
  }
  var dancingStroke = [
    {
      type: "SourceAlpha",
      id: "strokeSource",
      bound: { x: 100, y: 100 },
      connected: [
        {
          id: "morphology"
        }
      ]
    },
    {
      type: "Morphology",
      id: "morphology",
      operator: "dilate",
      radius: "3 3",
      bound: { x: 100, y: 200 },
      in: [{ id: "strokeSource" }],
      connected: [{ id: "composite" }]
    },
    {
      type: "Flood",
      id: "flood",
      bound: { x: 100, y: 200 },
      color: "#30597E",
      opacity: 1,
      connected: [{ id: "composite" }]
    },
    {
      type: "Composite",
      id: "composite",
      bound: { x: 400, y: 150 },
      in: [{ id: "flood" }, { id: "morphology" }],
      operator: "in",
      connected: [
        {
          id: "composite2"
        }
      ]
    },
    {
      type: "SourceAlpha",
      id: "strokeSourceAlpha2",
      bound: { x: 400, y: 200 },
      connected: [
        {
          id: "composite2"
        }
      ]
    },
    {
      type: "Composite",
      id: "composite2",
      bound: { x: 400, y: 150 },
      in: [{ id: "composite" }, { id: "strokeSourceAlpha2" }],
      operator: "out",
      connected: [
        {
          id: "displacementMap"
        }
      ]
    },
    {
      type: "Turbulence",
      id: "turbulence",
      filterType: "fractalNoise",
      baseFrequency: "0.01 0.02",
      numOctaves: 1,
      seed: 0,
      stitchTiles: "stitch",
      bound: { x: 400, y: 200 },
      connected: [
        {
          id: "displacementMap"
        }
      ]
    },
    {
      type: "DisplacementMap",
      id: "displacementMap",
      scale: 17,
      xChannelSelector: "A",
      yChannelSelector: "A",
      bound: { x: 400, y: 200 },
      in: [{ id: "composite2" }, { id: "turbulence" }],
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "SourceGraphic",
      id: "strokeSourceGraphic",
      bound: { x: 400, y: 200 },
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "Merge",
      id: "merge",
      bound: { x: 500, y: 150 },
      in: [{ id: "strokeSourceGraphic" }, { id: "displacementMap" }]
    }
  ];
  var grayscale = [
    {
      type: "Saturate",
      values: "0"
    }
  ];
  var innerShadow = [
    {
      type: "Flood",
      id: "flood",
      bound: { x: 100, y: 200 },
      color: "black",
      opacity: 1,
      connected: [{ id: "composite1" }]
    },
    {
      type: "SourceAlpha",
      id: "shadowSource",
      bound: { x: 100, y: 100 },
      connected: [
        {
          id: "composite1"
        }
      ]
    },
    {
      type: "Composite",
      id: "composite1",
      bound: { x: 200, y: 150 },
      in: [{ id: "flood" }, { id: "shadowSource" }],
      operator: "out",
      connected: [
        {
          id: "offset"
        }
      ]
    },
    {
      type: "Offset",
      id: "offset",
      bound: { x: 300, y: 150 },
      dx: 4,
      dy: 4,
      in: [{ id: "composite1" }],
      connected: [{ id: "blur" }]
    },
    {
      type: "GaussianBlur",
      id: "blur",
      bound: { x: 400, y: 150 },
      stdDeviationX: 4,
      stdDeviationY: 4,
      edge: "none",
      in: [{ id: "offset" }],
      connected: [
        {
          id: "composite2"
        }
      ]
    },
    {
      type: "SourceAlpha",
      id: "shadowSource2",
      bound: { x: 400, y: 250 },
      connected: [
        {
          id: "composite2"
        }
      ]
    },
    {
      type: "Composite",
      id: "composite2",
      bound: { x: 500, y: 150 },
      in: [{ id: "blur" }, { id: "shadowSource2" }],
      operator: "out",
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "SourceGraphic",
      id: "shadowSource3",
      bound: { x: 500, y: 250 },
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "Merge",
      id: "merge",
      bound: { x: 600, y: 150 },
      in: [{ id: "composite2" }, { id: "shadowSource3" }]
    }
  ];
  var shadow = [
    {
      type: "SourceAlpha",
      id: "shadowSource",
      bound: { x: 100, y: 100 },
      connected: [
        {
          id: "offset"
        }
      ]
    },
    {
      type: "Offset",
      id: "offset",
      bound: { x: 200, y: 100 },
      dx: 10,
      dy: 10,
      in: [{ id: "shadowSource" }],
      connected: [{ id: "blur" }]
    },
    {
      type: "GaussianBlur",
      id: "blur",
      bound: { x: 300, y: 100 },
      stdDeviationX: 5,
      stdDeviationY: 5,
      in: [{ id: "offset" }],
      connected: [
        {
          id: "composite"
        }
      ]
    },
    {
      type: "Flood",
      id: "flood",
      bound: { x: 100, y: 200 },
      color: "black",
      opacity: 0.7,
      connected: [{ id: "composite" }]
    },
    {
      type: "Composite",
      id: "composite",
      bound: { x: 400, y: 150 },
      in: [{ id: "flood" }, { id: "blur" }],
      operator: "in",
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "SourceAlpha",
      id: "shadowSource2",
      bound: { x: 400, y: 200 },
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "Merge",
      id: "merge",
      bound: { x: 500, y: 150 },
      in: [{ id: "composite" }, { id: "shadowSource2" }]
    }
  ];
  var stroke = [
    {
      type: "SourceAlpha",
      id: "strokeSource",
      bound: { x: 100, y: 100 },
      connected: [
        {
          id: "morphology"
        }
      ]
    },
    {
      type: "Morphology",
      id: "morphology",
      operator: "dilate",
      radius: "3 3",
      bound: { x: 100, y: 200 },
      in: [{ id: "strokeSource" }],
      connected: [{ id: "composite" }]
    },
    {
      type: "Flood",
      id: "flood",
      bound: { x: 100, y: 200 },
      color: "#30597E",
      opacity: 1,
      connected: [{ id: "composite" }]
    },
    {
      type: "Composite",
      id: "composite",
      bound: { x: 400, y: 150 },
      in: [{ id: "flood" }, { id: "morphology" }],
      operator: "in",
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "SourceGraphic",
      id: "strokeSourceGraphic",
      bound: { x: 400, y: 200 },
      connected: [
        {
          id: "merge"
        }
      ]
    },
    {
      type: "Merge",
      id: "merge",
      bound: { x: 500, y: 150 },
      in: [{ id: "composite" }, { id: "strokeSourceGraphic" }]
    }
  ];
  var svgFilterPreset = {
    dancingStroke,
    stroke,
    grayscale,
    shadow,
    innerShadow
  };
  var SVGFilterEditor$1 = "";
  const filterTypes = [
    {
      label: "GRAPHIC REFERENCES",
      items: [
        { label: "Source Graphic", value: "SourceGraphic" },
        { label: "Source Alpha", value: "SourceAlpha" },
        { label: "Background Image", value: "BackgroundImage" },
        { label: "Background Alpha", value: "BackgroundAlpha" },
        { label: "Fill Paint", value: "FillPaint" },
        { label: "Stroke Paint", value: "StrokePaint" }
      ]
    },
    {
      label: "SOURCES",
      items: [
        { label: "Flood", value: "Flood" },
        { label: "Turbulence", value: "Turbulence" },
        { label: "Image", value: "Image" }
      ]
    },
    {
      label: "MODIFIER",
      items: [
        { label: "Color Matrix", value: "ColorMatrix" },
        { label: "Saturate", value: "Saturate" },
        { label: "HueRotate", value: "HueRotate" },
        { label: "LuminanceToAlpha", value: "LuminanceAlpha" },
        { label: "Drop Shadow", value: "DropShadow" },
        { label: "Morphology", value: "Morphology" },
        { label: "Convolve Matrix", value: "ConvolveMatrix" },
        { label: "Offset", value: "Offset" },
        { label: "Gaussian Blur", value: "GaussianBlur" },
        { label: "Tile", value: "Tile" }
      ]
    },
    {
      label: "LIGHTING",
      items: [
        { label: "Specular Lighting", value: "SpecularLighting" },
        { label: "Diffuse Lighting", value: "DiffuseLighting" },
        { label: "Point Light", value: "PointLight" },
        { label: "Spot Light", value: "SpotLight" },
        { label: "Distant Light", value: "DistantLight" }
      ]
    },
    {
      label: "COMBINERS",
      items: [
        { label: "Blend", value: "Blend" },
        { label: "Composite", value: "Composite" },
        { label: "Merge", value: "Merge" },
        { label: "DisplacementMap", value: "DisplacementMap" }
      ]
    }
  ];
  const SVGFilterTemplateList = [
    {
      label: "Template",
      items: [
        { label: "Grayscale", value: "grayscale" },
        { label: "Shadow", value: "shadow" },
        { label: "Inner Shadow", value: "innerShadow" },
        { label: "Stroke", value: "stroke" },
        { label: "Dancing Stroke", value: "dancingStroke" }
      ]
    }
  ];
  function getIcon(type) {
    switch (type) {
      case "SpecularLighting":
        return editor.iconUse("specular");
      case "DiffuseLighting":
        return editor.iconUse("diffuse");
      case "SourceGraphic":
      case "SourceAlpha":
        return editor.iconUse("image");
      case "BackgroundImage":
      case "BackgroundAlpha":
        return editor.iconUse("outline_image");
      case "Flood":
        return editor.iconUse("palette");
      case "Image":
        return editor.iconUse("landscape");
      case "GaussianBlur":
        return editor.iconUse("blur");
      case "ColorMatrix":
        return editor.iconUse("blur_linear");
      case "Turbulence":
        return editor.iconUse("waves");
      case "Saturate":
        return editor.iconUse("vintage");
      case "HueRotate":
        return editor.iconUse("looks");
      case "LuminanceAlpha":
        return editor.iconUse("opacity");
      case "DropShadow":
        return editor.iconUse("shadow");
      case "Morphology":
        return editor.iconUse("broken_image");
      case "ConvolveMatrix":
        return editor.iconUse("camera_roll");
      case "Offset":
        return editor.iconUse("transform");
      case "Tile":
        return editor.iconUse("view_comfy");
      case "Blend":
        return editor.iconUse("gradient");
      case "Composite":
        return editor.iconUse("merge");
      case "Merge":
        return editor.iconUse("settings_input_component");
      case "DisplacementMap":
        return editor.iconUse("texture");
    }
    return "";
  }
  function getSourceTypeString(type) {
    switch (type) {
      case "SourceGraphic":
      case "SourceAlpha":
      case "BackgroundImage":
      case "BackgroundAlpha":
      case "FillPaint":
      case "StrokePaint":
        return "graphic";
      case "Flood":
      case "Turbulence":
      case "Image":
        return "source";
      case "GaussianBlur":
      case "ColorMatrix":
      case "Saturate":
      case "HueRotate":
      case "LuminanceAlpha":
      case "DropShadow":
      case "Morphology":
      case "ConvolveMatrix":
      case "Offset":
      case "Tile":
        return "modifier";
      case "SpecularLighting":
      case "DiffuseLighting":
      case "SpotLight":
      case "PointLight":
      case "DistantLight":
        return "lighting";
      case "Blend":
      case "Composite":
      case "Merge":
      case "DisplacementMap":
        return "combiner";
    }
    return "";
  }
  const width = 40;
  const half_height = 20;
  const connectedXAxis = {
    1: [width + 5]
  };
  const connectedYAxis = {
    1: [half_height]
  };
  const inXAxis = {
    1: [-7],
    2: [-7],
    3: [-7],
    4: [-7],
    5: [-7]
  };
  let inYAxis = {
    1: [0],
    2: [-7, 7],
    3: [-14, 0, 14],
    4: [-21, -7, 7, 21],
    5: [-28, -14, 0, 14, 28]
  };
  Object.keys(inYAxis).forEach((len2) => {
    inYAxis[len2] = inYAxis[len2].map((it) => it + half_height);
  });
  class SVGFilterEditor extends editor.EditorElement {
    makeFilterSelect() {
      return `
  
    <div class='filter-item-list' ref="$filterSelect">
  
      ${mapjoin(filterTypes, (f) => {
        return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
          return `
                <div class='item' draggable="true" value="${i.value}">
                  <span class='icon'>${getIcon(i.value)}</span>
                  ${this.$i18n(i.label)}
                </div>
                `;
        })}
          </div>
        `;
      })}
    </div>
    `;
    }
    makeFilterTemplateSelect() {
      return `
  
    <div class='filter-item-list' ref="$filterTemplateSelect">
  
      ${mapjoin(SVGFilterTemplateList, (f) => {
        return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
          return ` <div class='item' draggable="true" value="${i.value}">${this.$i18n(i.label)}</div>`;
        })}
          </div>
        `;
      })}
    </div>
    `;
    }
    initState() {
      var filters = this.parseFilter(this.props.value || []);
      return {
        filters,
        selectedTabIndex: 1,
        selectedIndex: -1,
        selectedFilter: null
      };
    }
    template() {
      return `
      <div class='elf--svg-filter-editor filter-list'>
        <div class='left'>
          <div class="tab number-tab" ref="$tab">
            <div class="tab-header full" ref="$header">
              <div class="tab-item selected" data-value="1" title='Item'>
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.filter")}</label>
              </div>
              <div class="tab-item" data-value="2" title="Preset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.preset")}</label>
              </div>
              <div class="tab-item" data-value="3" title="Asset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.asset")}</label>
              </div>
            </div>
            <div class="tab-body">
              <div class="tab-content scrollbar selected" data-value="1">
                ${this.makeFilterSelect()}
              </div>
              <div class="tab-content  scrollbar" data-value="2">
                ${this.makeFilterTemplateSelect()}
              </div>
                     
            </div>
          </div>
        </div>
        <div  class='center'>
          <div class='graph'>
            <div class='drag-line-panel' ref='$dragLinePanel'></div>          
            <div class='connected-line-panel' ref='$connectedLinePanel'></div>
            <div class='graph-panel' ref='$graphPanel' droppable="true"></div>
          </div>
        </div>
        <div class='right'>
          <div class='filter-list' ref='$filterList'></div>
        </div>
      </div>`;
    }
    [sapa.CLICK("$header .tab-item:not(.empty-item)")](e) {
      var selectedTabIndex = +e.$dt.attr("data-value");
      if (this.state.selectedTabIndex === selectedTabIndex) {
        return;
      }
      this.$el.$$(`[data-value="${this.state.selectedTabIndex}"]`).forEach((it) => it.removeClass("selected"));
      this.$el.$$(`[data-value="${selectedTabIndex}"]`).forEach((it) => it.addClass("selected"));
      this.setState({ selectedTabIndex }, false);
    }
    [sapa.DRAGSTART("$filterSelect .item")](e) {
      var filter2 = e.$dt.attr("value");
      e.dataTransfer.setData("filter/type", filter2);
    }
    [sapa.DRAGOVER("$connectedLinePanel") + sapa.PREVENT]() {
    }
    [sapa.DROP("$connectedLinePanel") + sapa.PREVENT](e) {
      var offset = { x: e.offsetX, y: e.offsetY };
      var filterType = e.dataTransfer.getData("filter/type");
      this.makeFilterNode(filterType, { bound: offset });
    }
    makeFilterNode(filterType, opt = {}) {
      this.state.filters.push(this.makeFilter(filterType, opt));
      this.state.selectedIndex = this.state.filters.length - 1;
      this.state.selectedFilter = this.state.filters[this.state.selectedIndex];
      this.refresh();
      this.modifyFilter();
    }
    applyTemplate(templateType) {
      var template = svgFilterPreset[templateType];
      if (template) {
        this.setState({
          selectedIndex: -1,
          selectedFilter: null,
          filters: this.parseFilter(template)
        }, false);
        this.refresh();
        this.modifyFilter();
      }
    }
    getSpec(filterType) {
      return SVGFilterSpecList[filterType];
    }
    makeFilterEditorTemplate(s, filter2, key) {
      var objectId = `${filter2.type}${key}${this.state.selectedIndex}${Date.now()}`;
      if (s.inputType === "color-matrix") {
        return sapa.createComponent("ColorMatrixEditor", {
          ref: `$colorMatrix${objectId}`,
          label: s.title,
          key,
          column: s.column,
          values: filter2[key].join(" "),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "input-array") {
        return sapa.createComponent("InputArrayEditor", {
          ref: `$inputArray${objectId}`,
          label: s.title,
          key,
          "column-label": "R,G,B,A,M",
          "row-label": "R,G,B,A",
          column: s.column,
          values: filter2[key].join(" "),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "blend") {
        return sapa.createComponent("BlendSelectEditor", {
          ref: `$blend${objectId}`,
          label: s.title,
          key,
          value: filter2[key].toString(),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "select") {
        var options2 = s.options;
        if (sapa.isFunction(s.options)) {
          options2 = s.options(this.state.filters);
        }
        return sapa.createComponent("SelectEditor", {
          ref: `$select${objectId}`,
          label: s.title,
          options: options2,
          key,
          value: filter2[key].toString(),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "text") {
        return sapa.createComponent("TextEditor", {
          ref: `$text${objectId}`,
          label: s.title,
          key,
          value: filter2[key].toString(),
          onchange: "changeTextEditor"
        });
      } else if (s.inputType === "number-range") {
        return sapa.createComponent("NumberRangeEditor", {
          ref: `$numberrange${objectId}`,
          label: s.title,
          layout: "block",
          min: s.min,
          max: s.max,
          step: s.step,
          key,
          value: filter2[key].toString(),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "color") {
        return sapa.createComponent("ColorViewEditor", {
          ref: `$colorview${objectId}`,
          label: s.title,
          key,
          value: filter2[key].toString(),
          onchange: "changeRangeEditor"
        });
      } else if (s.inputType === "FuncFilter") {
        return sapa.createComponent("FuncFilterEditor", {
          ref: `$funcFilter${objectId}`,
          label: s.title,
          key,
          value: filter2[key].toString(),
          onchange: "changeFuncFilterEditor"
        });
      } else if (s.inputType === "ImageSelectEditor") {
        return sapa.createComponent("ImageSelectEditor", {
          ref: `$imageSelect${objectId}`,
          label: s.title,
          key,
          value: filter2[key].toString(),
          onchange: "changeRangeEditor"
        });
      }
      return sapa.createComponent("RangeEditor", {
        ref: `$range${objectId}`,
        layout: "block",
        label: s.title,
        min: s.min,
        max: s.max,
        step: s.step,
        key,
        value: filter2[key].toString(),
        units: s.units,
        onchange: "changeRangeEditor"
      });
    }
    makeOneFilterTemplate(spec, filter2) {
      return `
    <div class="filter-item">
      <div class="title">
        <label>${filter2.type}</label>
        <div class="filter-menu">
          <button type="button" class="del">${editor.iconUse("remove")}</button>
        </div>
      </div>
      <div class="filter-ui">
        ${sapa.keyMapJoin(spec, (key, value) => {
        return this.makeFilterEditorTemplate(value, filter2, key);
      })}

      </div>
    </div>
  `;
    }
    makeFilterTemplate(filter2) {
      return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2);
    }
    [sapa.LOAD("$filterList")]() {
      if (this.state.selectedFilter && this.state.selectedFilter.isSource() === false) {
        return this.makeFilterTemplate(this.state.selectedFilter);
      }
      return "";
    }
    modifyFilter() {
      this.state.filters.forEach((f) => {
        if (f.isLight() && f.connected.length) {
          f.connected.forEach((c) => {
            this.state.filters.filter((s) => s.id === c.id).forEach((lightManager) => {
              lightManager.reset({
                lightInfo: f.toLightString()
              });
            });
          });
        }
      });
      this.parent.trigger(this.props.onchange, this.props.key, this.state.filters);
    }
    parseFilter(list = []) {
      return list.map((it) => SVGFilter.parse(it));
    }
    makeFilter(type, opt = {}) {
      return SVGFilter.parse(__spreadProps(__spreadValues({}, opt), { type }));
    }
    [sapa.CLICK("$filterSelect .item[value]")](e) {
      var filterType = e.$dt.attr("value");
      this.makeFilterNode(filterType);
    }
    [sapa.CLICK("$filterTemplateSelect .item[value]")](e) {
      var templateType = e.$dt.attr("value");
      this.applyTemplate(templateType);
    }
    [sapa.CLICK("$filterList .filter-menu .del")]() {
      this.removeFilter(this.state.selectedFilter.id);
    }
    [sapa.LOAD("$graphPanel")]() {
      return this.makeGraphPanel();
    }
    selectFilter(index2) {
      this.setState({
        selectedIndex: index2,
        selectedFilter: this.state.filters[index2]
      }, false);
      this.load("$filterList");
    }
    [sapa.POINTERSTART("$graphPanel .filter-node") + MOVE() + END()](e) {
      this.$target = e.$dt;
      this.$point = null;
      this.pointType = "object";
      this.pointIndex = 0;
      var rect2 = this.refs.$graphPanel.rect();
      this.rect = rect2;
      var index2 = +this.$target.attr("data-index");
      this.selectFilter(index2);
      this.$target.onlyOneClass("selected");
      var pointer = sapa.Dom.create(e.target);
      if (pointer.hasClass("out")) {
        this.$point = pointer;
        this.pointType = "out";
        this.pointIndex = 0;
      } else if (pointer.hasClass("in")) {
        this.$point = pointer;
        this.pointType = "in";
        this.pointIndex = +pointer.attr("data-index");
      } else {
        var filter2 = this.state.selectedFilter;
        this.startXY = sapa.clone(filter2.bound);
      }
      if (this.pointType === "in" || this.pointType === "out") {
        var inRect = pointer.rect();
        var x = inRect.x - rect2.x;
        var y = inRect.y - rect2.y;
        var centerX = x + inRect.width / 2;
        var centerY = y + inRect.height / 2;
        this.startXY = { x: centerX, y: centerY };
      }
      this.startXY.dx = 0;
      this.startXY.dy = 0;
      this.load("$dragLinePanel");
    }
    [sapa.LOAD("$dragLinePanel")]() {
      if (this.pointType === "in" || this.pointType === "out") {
        var { x, y, dx, dy } = this.startXY;
        return `
      <svg>
        <path 
          class="drag-line"
          fill="transparent"
          stroke-width="1"
          d="
            M${x},${y}
            L${x + dx},${y + dy} 
            Z
          "
        />
      </svg>
      `;
      } else {
        return "";
      }
    }
    makeConnectedPath(points) {
      var manager = new PathStringManager();
      var first = points[0];
      var last = points[points.length - 1];
      if (!first)
        return "";
      if (!last)
        return "";
      var dist2 = Math.abs(first.x - last.x) / 2;
      manager.M(first).C({ x: first.x + dist2, y: first.y }, { x: last.x - dist2, y: last.y }, last);
      return manager.d;
    }
    createPath(sourceItem, connectedInfo) {
      if (connectedInfo.path) {
        return connectedInfo.path;
      }
      var sourceX = sourceItem.bound.x + connectedXAxis["1"][0];
      var sourceY = sourceItem.bound.y + connectedYAxis["1"][0];
      var target = this.state.filters.map((it, index3) => {
        return { it, index: index3 };
      }).find((it) => {
        if (!it)
          return false;
        if (!it.it)
          return false;
        return it && it.it.id === connectedInfo.id;
      });
      var len2 = `${target.it.getInCount()}`;
      var source = target.it.in.map((it, index3) => {
        return { it, index: index3 };
      }).find((it) => {
        if (!it)
          return false;
        if (!it.it)
          return false;
        return it.it.id === sourceItem.id;
      });
      if (!source) {
        return [];
      }
      var index2 = source.index;
      var targetX = target.it.bound.x + inXAxis[len2][0];
      var targetY = target.it.bound.y + inYAxis[len2][index2];
      return [
        { x: sourceX, y: sourceY },
        { x: targetX, y: targetY }
      ];
    }
    [sapa.LOAD("$connectedLinePanel")]() {
      return `
      <svg>
        ${this.state.filters.map((it) => {
        return it.connected.map((connectedItem) => {
          var path = this.createPath(it, connectedItem);
          var sourceType = getSourceTypeString(it.type);
          return `
              <path 
                class="connected-line"
                data-source-type="${sourceType}"
                d="${this.makeConnectedPath(path)}"
              />

              ${path.length && `
                <circle 
                  data-source-type="${sourceType}"
                  data-target-id="${connectedItem.id}"
                  data-source-id="${it.id}"
                  class="connected-remove-circle"
                  cx="${(path[0].x + path[1].x) / 2}"
                  cy="${(path[0].y + path[1].y) / 2}"
                />
              `}
              
            `;
        }).join("");
      }).join("")}
      </svg>
    `;
    }
    [sapa.CLICK("$connectedLinePanel .connected-remove-circle")](e) {
      var [tid, sid] = e.$dt.attrs("data-target-id", "data-source-id");
      var filters = this.state.filters;
      filters.filter((it) => it.id === sid).forEach((it) => {
        it.connected = it.connected.filter((c) => c.id != tid);
      });
      filters.filter((it) => it.id === tid).forEach((it) => {
        it.in = it.in.map((inObject) => {
          if (inObject && inObject.id == sid) {
            return null;
          }
          return inObject;
        });
      });
      this.refresh();
      this.modifyFilter();
    }
    getCenterXY($target) {
      var inRect = $target.rect();
      var x = inRect.x - this.rect.x;
      var y = inRect.y - this.rect.y;
      var centerX = x + inRect.width / 2;
      var centerY = y + inRect.height / 2;
      return { x: centerX, y: centerY };
    }
    end(dx, dy) {
      if (this.pointType === "in" || this.pointType === "out") {
        this.startXY.dx = dx;
        this.startXY.dy = dy;
        var filter2 = this.state.selectedFilter;
        var e = this.$config.get("bodyEvent");
        var $target = sapa.Dom.create(e.target);
        var $targetNode = $target.closest("filter-node");
        if (this.pointType === "out") {
          if ($target.hasClass("in")) {
            var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
            if (targetFilter) {
              if (!targetFilter.hasLight() && filter2.isLight())
                ;
              else {
                var targetIndex = +$target.attr("data-index");
                if (!targetFilter.in[targetIndex]) {
                  targetFilter.setIn(targetIndex, filter2);
                  filter2.setConnected(targetFilter);
                }
              }
            }
          }
        } else if (this.pointType === "in") {
          if ($target.hasClass("out")) {
            var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
            if (targetFilter) {
              if (filter2.hasLight() && !targetFilter.isLight())
                ;
              else {
                if (!filter2.in[this.pointIndex]) {
                  filter2.setIn(this.pointIndex, targetFilter);
                  targetFilter.setConnected(filter2);
                }
              }
            }
          }
        }
        this.pointType = "";
      }
      this.load("$dragLinePanel");
      this.load("$connectedLinePanel");
      this.modifyFilter();
    }
    move(dx, dy) {
      var filter2 = this.state.selectedFilter;
      if (filter2) {
        this.startXY.dx = dx;
        this.startXY.dy = dy;
        if (this.pointType === "in") {
          this.load("$dragLinePanel");
        } else if (this.pointType === "out") {
          this.load("$dragLinePanel");
        } else {
          filter2.reset({
            bound: { x: this.startXY.x + dx, y: this.startXY.y + dy }
          });
          this.$target.css({
            left: filter2.bound.x,
            top: filter2.bound.y
          });
          this.load("$connectedLinePanel");
        }
      }
    }
    makeGraphPanel() {
      return this.state.filters.map((it, index2) => {
        const selectedClass = index2 === this.state.selectedIndex ? "selected" : "";
        return `
        <div class='filter-node ${selectedClass}' data-type="${it.type}" data-index="${index2}" data-filter-id="${it.id}" style='left: ${it.bound.x}px;top: ${it.bound.y}px;'>
          <div class='label'>${this.$i18n(it.type)}</div>
          <div class='remove'>${editor.iconUse("close")}</div>
          <div class='preview' data-source-type="${getSourceTypeString(it.type)}" data-filter-type='${it.type}'>${getIcon(it.type)}</div>
          <div class='in-list'>
            ${repeat(it.getInCount()).map((itIn, inIndex) => {
          return `<div class='in' data-index='${inIndex}'></div>`;
        }).join("")}
          </div>
          
          <div class='out' data-index="0">${editor.iconUse("chevron_right")}</div>
          ${it.hasLight() ? `<div class='light'  data-index="0"></div>` : ""}
        </div>
      `;
      });
    }
    [sapa.SUBSCRIBE_SELF("changeFuncFilterEditor")](key, value) {
      var filter2 = this.state.selectedFilter;
      if (filter2) {
        filter2.reset({
          [key]: value
        });
      }
      this.modifyFilter();
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      var filter2 = this.state.selectedFilter;
      if (filter2) {
        filter2.reset({
          [key]: value
        });
      }
      this.modifyFilter();
    }
    [sapa.SUBSCRIBE_SELF("changeTextEditor")](key, value) {
      var filter2 = this.state.selectedFilter;
      if (filter2) {
        filter2.reset({
          [key]: value
        });
      }
      this.modifyFilter();
    }
    removeFilter(id) {
      var filters = this.state.filters.filter((it) => it.id != id);
      filters.forEach((it) => {
        it.connected = it.connected.filter((c) => c.id != id);
        it.in = it.in.filter((c) => c.id != id);
      });
      if (this.state.selectedFilter.id === id) {
        this.state.selectedFilter = null;
        this.state.selectedIndex = -1;
      }
      this.setState({
        filters
      });
      this.modifyFilter();
    }
    [sapa.CLICK("$graphPanel .filter-node .remove")](e) {
      var $target = e.$dt.closest("filter-node");
      var index2 = +$target.attr("data-index");
      var f = this.state.filters[index2];
      this.removeFilter(f.id);
    }
  }
  var SVGFilterPopup$1 = "";
  class SVGFilterPopup extends editor.BasePopup {
    getTitle() {
      return this.$i18n("svgfilter.popup.title");
    }
    getClassName() {
      return "transparent";
    }
    initState() {
      return {
        changeEvent: "changeSVGFilterPopup",
        id: "",
        preview: true,
        filters: []
      };
    }
    updateData(opt) {
      this.setState(opt, false);
      this.emit(this.state.changeEvent, this.state);
    }
    getBody() {
      return `
    <div class='elf--svg-filter-popup' ref='$popup'>
      <div class="box">
        <div class='editor' ref='$editor'></div>
      </div>
    </div>`;
    }
    [sapa.LOAD("$editor")]() {
      return sapa.createComponent("SVGFilterEditor", {
        ref: "$filter",
        title: "Filter Type",
        key: "filter",
        value: this.state.filters,
        onchange: (key, filters) => {
          this.updateData({
            filters
          });
        }
      });
    }
    [sapa.SUBSCRIBE("showSVGFilterPopup")](data) {
      data.filters = data.filters.map((it) => {
        return SVGFilter.parse(it);
      });
      data.preview = sapa.isNotUndefined(data.preview) ? data.preview : true;
      this.setState(data);
      this.show(1e3);
    }
    [sapa.SUBSCRIBE("hideSVGFilterPopup")]() {
      this.$el.hide();
    }
  }
  var SVGFilterSelectEditor$1 = "";
  class SVGFilterSelectEditor extends editor.EditorElement {
    initState() {
      var value = this.props.value;
      return {
        options: [],
        label: this.props.label || "",
        value
      };
    }
    template() {
      var { label } = this.state;
      var hasLabel = label ? "has-label" : "";
      return `
            <div class='elf--svg-filter-select-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <select ref='$options'></select>
                <button type='button' class='open thin' ref='$open' title='Open SVG Filter Editor'>${editor.iconUse("fullscreen")}</button>
                <button type='button' class='remove thin' ref='$remove' title='Remove'>${editor.iconUse("remove")}</button>
            </div>
        `;
    }
    [sapa.CLICK("$remove")]() {
      this.updateData({
        value: ""
      });
    }
    [sapa.CLICK("$open")]() {
      var value = this.state.value;
      if (value.includes("id")) {
        var currentProject = this.$context.selection.currentProject;
        var index2 = currentProject.getSVGFilterIndex(value);
        if (index2 > -1) {
          this.trigger("openSVGFilterPopup", index2);
        }
      }
    }
    getValue() {
      return this.state.value;
    }
    setValue(value) {
      this.setState({ value });
    }
    [sapa.BIND("$options")]() {
      return {
        "data-count": this.state.options.length.toString()
      };
    }
    [sapa.LOAD("$options")]() {
      var current = this.$context.selection.currentProject;
      var options2 = "";
      if (current) {
        options2 = current.svgfilters.map((it) => it.id);
        options2 = options2.length ? "," + options2.join(",") : "";
      }
      options2 += ",-,new";
      options2 = options2.split(",");
      var arr = options2.map((it) => {
        var value = it;
        var label = it;
        if (value.includes(":")) {
          var [value, label] = value.split(":");
        }
        if (label === "") {
          label = this.props["none-value"] ? this.props["none-value"] : "";
        } else if (label === "-") {
          label = "----------";
          value = "";
        }
        var selected = value === this.state.value ? "selected" : "";
        return `<option ${selected} value="${value}">${label}</option>`;
      });
      return arr;
    }
    setOptions(options2 = "") {
      this.setState({
        options: options2.split(this.state.splitChar).map((it) => it.trim())
      });
    }
    [sapa.CHANGE("$options")]() {
      var value = this.refs.$options.value;
      if (value == "new") {
        this.$commands.emit("addSVGFilterAssetItem", (index2, id) => {
          this.updateData({ value: id });
          this.refresh();
          this.trigger("openSVGFilterPopup", index2);
        });
      } else if (value === "-")
        ;
      else {
        this.updateData({ value });
      }
    }
    updateData(data) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
    }
    [sapa.SUBSCRIBE("refreshSVGArea") + sapa.DEBOUNCE(1e3)]() {
      this.load("$options");
    }
    [sapa.SUBSCRIBE("openSVGFilterPopup")](index2) {
      this.emit("refreshSVGFilterAssets");
      this.emit("refreshSVGArea");
      var currentProject = this.$context.selection.currentProject || {
        svgfilters: []
      };
      var svgfilter = currentProject.svgfilters[index2];
      this.emit("showSVGFilterPopup", {
        changeEvent: "changeSVGFilterEditorRealUpdate",
        preview: false,
        index: index2,
        filters: svgfilter.filters
      });
    }
    [sapa.SUBSCRIBE("changeSVGFilterEditorRealUpdate")](params) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        project2.setSVGFilterValue(params.index, {
          filters: params.filters
        });
        this.emit("refreshSVGFilterAssets");
        this.emit("refreshSVGArea");
      }
    }
  }
  function svgItem(editor$1) {
    editor$1.registerElement({
      ColorMatrixEditor,
      FuncFilterEditor,
      SVGFilterSelectEditor,
      SVGFilterEditor
    });
    editor$1.registerUI("inspector.tab.style", {
      SVGItemProperty: editor.ObjectProperty.create({
        title: editor$1.$i18n("svg.item.property.title"),
        editableProperty: "svg-item",
        preventUpdate: true
      })
    });
    editor$1.registerUI("popup", {
      SVGFilterPopup
    });
    editor$1.registerInspector("svg-item", (current) => {
      return [
        {
          key: "edit",
          editor: "Button",
          editorOptions: {
            text: "Edit",
            action: ["open.editor", current]
          }
        },
        {
          type: "column",
          size: [2, 1],
          columns: [
            { type: "label", label: editor$1.$i18n("svg.item.property.fill") },
            {
              key: "fillRule",
              editor: "ToggleCheckBox",
              editorOptions: {
                toggleLabels: [editor.iconUse("join_full"), editor.iconUse("join_right")],
                toggleValues: ["nonzero", "evenodd"]
              },
              defaultValue: current.fillRule || "nonzero"
            }
          ]
        },
        {
          type: "column",
          size: [2, 1],
          columns: [
            {
              key: "fill",
              editor: "FillSingleEditor",
              editorOptions: {
                wide: true
              },
              defaultValue: current.fill
            },
            {
              key: "fillOpacity",
              editor: "number-input",
              editorOptions: {
                compact: true,
                label: "opacity",
                min: 0,
                max: 1,
                step: 0.01
              },
              defaultValue: current.fillOpacity
            }
          ]
        },
        {
          type: "column",
          size: [2, 1],
          columns: [
            { type: "label", label: editor$1.$i18n("svg.item.property.stroke") }
          ]
        },
        {
          type: "column",
          size: [2, 1],
          columns: [
            {
              key: "stroke",
              editor: "fill-single",
              editorOptions: {
                wide: true
              },
              defaultValue: current.stroke
            },
            {
              key: "strokeWidth",
              editor: "number-input",
              editorOptions: {
                compact: true,
                label: "line_weight"
              },
              defaultValue: current.strokeWidth
            }
          ]
        },
        {
          type: "column",
          size: [2, 1],
          columns: [
            {
              key: "strokeDasharray",
              editor: "StrokeDashArrayEditor",
              editorOptions: {
                label: editor$1.$i18n("svg.item.property.dashArray")
              },
              defaultValue: current.strokeDasharray || ""
            },
            {
              key: "strokeDashoffset",
              editor: "number-input",
              editorOptions: {
                compact: true,
                label: "power_input",
                min: -1e3,
                max: 1e3,
                step: 1
              },
              defaultValue: current.strokeDashoffset
            }
          ]
        },
        {
          key: "strokeLinecap",
          editor: "ToggleCheckBox",
          editorOptions: {
            label: editor$1.$i18n("svg.item.property.lineCap"),
            toggleLabels: [
              editor.iconUse("line_cap_butt"),
              editor.iconUse("line_cap_round"),
              editor.iconUse("line_cap_square")
            ],
            toggleValues: [
              StrokeLineCap.BUTT,
              StrokeLineJoin.ROUND,
              StrokeLineCap.SQUARE
            ]
          },
          defaultValue: current.strokeLinecap || StrokeLineCap.BUTT
        },
        {
          key: "strokeLinejoin",
          editor: "ToggleCheckBox",
          editorOptions: {
            label: editor$1.$i18n("svg.item.property.lineJoin"),
            toggleLabels: [
              editor.iconUse("line_join_miter"),
              editor.iconUse("line_join_round"),
              editor.iconUse("line_join_bevel")
            ],
            toggleValues: [
              StrokeLineJoin.MITER,
              StrokeLineJoin.ROUND,
              StrokeLineJoin.BEVEL
            ]
          },
          defaultValue: current.strokeLinejoin || StrokeLineJoin.MITER
        },
        {
          key: "mixBlendMode",
          editor: "BlendSelectEditor",
          editorOptions: {
            label: editor$1.$i18n("svg.item.property.blend")
          },
          defaultValue: current.mixBlendMode
        }
      ];
    });
    editor$1.registerInspector("polygon", (item) => {
      return [
        {
          key: "count",
          editor: "NumberInputEditor",
          editorOptions: {
            label: "Count",
            min: 3,
            max: 100,
            step: 1
          },
          defaultValue: item.count
        },
        {
          key: "button",
          editor: "Button",
          editorOptions: {
            label: "Copy ",
            text: "as path",
            command: "copy.path"
          }
        },
        {
          key: "button2",
          editor: "Button",
          editorOptions: {
            label: "Test Popup",
            action: [
              "showComponentPopup",
              {
                title: "Sample Test Popup",
                width: 400,
                inspector: [
                  {
                    key: "test",
                    editor: "Button",
                    editorOptions: {
                      label: "Test",
                      text: "text",
                      onClick: () => {
                        window.alert("yellow");
                      }
                    }
                  }
                ]
              }
            ]
          }
        }
      ];
    });
    editor$1.registerInspector("spline", () => {
      return [
        {
          key: "boundary",
          editor: "SelectIconEditor",
          editorOptions: {
            label: "Boundary",
            options: ["clamped", "open", "closed"]
          }
        },
        {
          key: "button",
          editor: "Button",
          editorOptions: {
            label: "Copy ",
            text: "as path",
            action: "copy.path"
          }
        }
      ];
    });
    editor$1.registerInspector("star", (item) => {
      return [
        {
          key: "isCurve",
          editor: "ToggleCheckBox",
          editorOptions: {
            label: "Curve",
            defaultValue: item.isCurve
          }
        },
        {
          key: "count",
          editor: "NumberInputEditor",
          editorOptions: {
            label: "Count",
            min: 3,
            max: 100,
            step: 1,
            wide: "true"
          }
        },
        {
          key: "radius",
          editor: "NumberInputEditor",
          editorOptions: {
            label: "Inner Radius",
            min: -1,
            max: 1,
            step: 0.01,
            wide: "true"
          }
        },
        {
          key: "tension",
          editor: "NumberInputEditor",
          editorOptions: {
            label: "Tension",
            min: 0,
            max: 1,
            step: 0.01,
            wide: "true"
          }
        },
        {
          key: "button",
          editor: "Button",
          editorOptions: {
            label: "Copy ",
            text: "as path",
            action: "copy.path"
          }
        }
      ];
    });
  }
  class SVGTextProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("svg.text.property.title");
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refreshShow(["svg-textpath", "svg-text", "svg-tspan"]);
    }
    refresh() {
      var current = this.$context.selection.current;
      if (current) {
        this.setAllValue([
          "lengthAdjust",
          "textLength",
          "startOffset",
          "text-anchor",
          "text"
        ]);
      }
    }
    setAllValue(list = []) {
      var current = this.$context.selection.current;
      if (!current)
        return;
      list.forEach((key) => {
        this.children[`$${key}`].setValue(current[key]);
      });
    }
    getBody() {
      return `
      <div class='property-item '>
        ${sapa.createComponent("TextAreaEditor", {
        ref: "$text",
        label: this.$i18n("svg.text.property.textarea"),
        key: "text",
        onchange: "changeTextValue"
      })}
      </div>        
      <div class='property-item'>
        ${sapa.createComponent("SelectIconEditor", {
        ref: "$text-anchor",
        label: this.$i18n("svg.text.property.anchor"),
        key: "textAnchor",
        options: ["start", "middle", "end"],
        onchange: "changeTextValue"
      })}
          
      </div>            
      <div class='property-item '>
        ${sapa.createComponent("SelectEditor", {
        ref: "$lengthAdjust",
        label: this.$i18n("svg.text.property.length.adjust"),
        key: "lengthAdjust",
        value: "spacing",
        options: ["spacing", "spacingAndGlyphs"],
        onchange: "changeTextValue"
      })}
          
      </div>        
      <div class='property-item '>
        ${sapa.createComponent("RangeEditor", {
        ref: "$textLength",
        label: this.$i18n("svg.text.property.text.length"),
        key: "textLength",
        min: 0,
        max: 1e3,
        step: 0.1,
        onchange: "changeTextValue"
      })}
          
      </div>        
      <div class='property-item '>
        ${sapa.createComponent("RangeEditor", {
        ref: "$startOffset",
        label: this.$i18n("svg.text.property.start.offset"),
        key: "startOffset",
        min: 0,
        max: 1e3,
        step: 0.1,
        onchange: "changeTextValue"
      })}
          
      </div>                    
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeTextValue")](key, value) {
      this.$commands.executeCommand("setAttribute", `change svg text property: ${key}`, this.$context.selection.packByValue({
        [key]: value
      }));
    }
  }
  function svgText(editor2) {
    editor2.registerUI("inspector.tab.style", {
      SVGTextProperty
    });
  }
  function text(editor$1) {
    editor$1.registerUI("inspector.tab.style", {
      TextProperty: editor.ObjectProperty.create({
        title: editor$1.$i18n("text.property.title"),
        editableProperty: "text-style",
        preventUpdate: true
      })
    });
    editor$1.registerInspector("text-style", (current) => {
      return [
        {
          type: "column",
          size: [2, 1, 1],
          columns: [
            {
              key: "textAlign",
              editor: "SelectIconEditor",
              editorOptions: {
                compact: true,
                options: ["left", "center", "right", "justify"],
                icons: [
                  "align_left",
                  "align_center",
                  "align_right",
                  "align_justify"
                ]
              },
              defaultValue: current.textAlign || TextAlign.LEFT
            },
            "-",
            {
              key: "textTransform",
              editor: "SelectIconEditor",
              editorOptions: {
                options: [
                  { value: TextTransform.CAPITALIZE, text: "Ag" },
                  { value: TextTransform.UPPERCASE, text: "AG" },
                  { value: TextTransform.LOWERCASE, text: "ag" }
                ],
                compact: true,
                icons: ["horizontal_rule"]
              },
              defaultValue: current.textTransform
            }
          ]
        },
        {
          type: "column",
          size: [3, 2, 1],
          gap: 20,
          columns: [
            {
              key: "textDecoration",
              editor: "SelectIconEditor",
              editorOptions: {
                options: [
                  { value: TextDecoration.NONE, text: "None" },
                  { value: TextDecoration.UNDERLINE, text: "Underline" },
                  { value: TextDecoration.LINE_THROUGH, text: "LineThrough" }
                ],
                icons: ["horizontal_rule", "underline", "strikethrough"],
                onchange: "changeTextValue"
              },
              defaultValue: current.textDecoration
            },
            {
              key: "fontStyle",
              editor: "SelectIconEditor",
              editorOptions: {
                compact: true,
                options: ["normal", "italic"],
                icons: ["title", "italic"]
              },
              defaultValue: current.fontStyle
            },
            {
              key: "textClip",
              editor: "ToggleButton",
              editorOptions: {
                checkedValue: TextClip.TEXT,
                toggleLabels: [editor.iconUse("vignette"), editor.iconUse("vignette")],
                toggleTitles: ["", "Text Clip"],
                toggleValues: [TextClip.NONE, TextClip.TEXT]
              },
              defaultValue: current.textClip || TextClip.NONE
            }
          ]
        }
      ];
    });
  }
  var textShadow$1 = [
    {
      name: "Mystic",
      shadows: [
        {
          offsetX: 20,
          offsetY: 0,
          blurRadius: 10,
          color: "rgb(0,0,0)"
        }
      ]
    }
  ];
  var TextShadowProperty$1 = "";
  class TextShadowProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("text.shadow.property.title");
    }
    getBody() {
      return `
      <div class="full text-shadow-item" ref="$shadowList"></div>
    `;
    }
    getTools() {
      return `
      <select class='text-shadow-samples' ref="$select">
      ${textShadow$1.map((item, index2) => {
        return `
          <option value="${index2}">${item.name}</option>
        `;
      }).join("")}
      </select>
      <button type="button" ref='$add'>${editor.iconUse("add")}</button>
    `;
    }
    [sapa.CLICK("$add")]() {
      const index2 = +this.refs.$select.value;
      this.children.$textshadow.trigger("add", textShadow$1[index2].shadows);
    }
    [sapa.LOAD("$shadowList")]() {
      var current = this.$context.selection.current || {};
      return sapa.createComponent("TextShadowEditor", {
        ref: "$textshadow",
        key: "textShadow",
        value: sapa.clone(current.textShadow),
        onchange: (key, value) => {
          this.$commands.executeCommand("setAttribute", "change text shadow", this.$context.selection.packByValue({
            [key]: sapa.clone(value)
          }));
        }
      });
    }
    get editableProperty() {
      return "textShadow";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.IF("checkShow") + sapa.DEBOUNCE(100)]() {
      this.refresh();
    }
  }
  function textShadow(editor2) {
    editor2.registerUI("inspector.tab.style", {
      TextShadowProperty
    });
  }
  var TransitionProperty$1 = "";
  class TransitionProperty extends editor.BaseProperty {
    getTitle() {
      return this.$i18n("transition.property.title");
    }
    getBody() {
      return `<div class='elf--transition-list' ref='$transitionList'></div>`;
    }
    getTools() {
      return `
        <button type="button" ref="$add" title="add Transition">${editor.iconUse("add")}</button>
    `;
    }
    isFirstShow() {
      return true;
    }
    [sapa.LOAD("$transitionList") + sapa.DOMDIFF]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      return current.transition.map((it, index2) => {
        const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
        const path = curveToPath(it.timingFunction, 30, 30);
        return `
      <div class='transition-group-item'>
        <div class='transition-item ${selectedClass}' data-index='${index2}' ref="transitionIndex${index2}">
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='labels'>
                <span class='property-name' title='Property'>${it.name}</span>
                <span class='duration' title='Duration'><small>Duration: ${it.duration}</small></span>
                <span class='delay' title='Delay'><small>Delay: ${it.delay}</small></span>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${editor.iconUse("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
      });
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION)]() {
      this.refresh();
    }
    [sapa.CLICK("$add")]() {
      var current = this.$context.selection.current;
      if (current) {
        const transition2 = current.transition || [];
        transition2.push({
          name: "all",
          duration: "1s",
          timingFunction: "linear",
          delay: "0s"
        });
        this.$commands.executeCommand("setAttribute", "add transition", this.$context.selection.packByValue({
          transition: [...transition2]
        }));
        this.nextTick(() => {
          this.refresh();
        }, 10);
      } else {
        window.alert("Select a layer");
      }
    }
    getCurrentTransition() {
      return this.current.transition[this.selectedIndex];
    }
    [sapa.CLICK("$transitionList .tools .del")](e) {
      var removeIndex = e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      current.transition.splice(removeIndex, 1);
      this.$commands.executeCommand("setAttribute", "add transition", this.$context.selection.packByValue({
        transition: [...current.transition]
      }));
      this.nextTick(() => {
        this.refresh();
      }, 10);
    }
    selectItem(selectedIndex, isSelected = true) {
      if (isSelected) {
        this.refs[`transitionIndex${selectedIndex}`].addClass("selected");
      } else {
        this.refs[`transitionIndex${selectedIndex}`].removeClass("selected");
      }
    }
    viewTransitionPicker($preview) {
      if (typeof this.selectedIndex === "number") {
        this.selectItem(this.selectedIndex, false);
      }
      this.selectedIndex = +$preview.attr("data-index");
      this.current = this.$context.selection.current;
      if (!this.current)
        return;
      this.currentTransition = this.current.transition[this.selectedIndex];
      this.viewTransitionPropertyPopup();
    }
    viewTransitionPropertyPopup() {
      if (!this.currentTransition)
        return;
      const transition2 = this.currentTransition;
      this.emit("showTransitionPropertyPopup", {
        changeEvent: "changeTransitionPropertyPopup",
        data: sapa.clone(transition2),
        instance: this
      });
    }
    [sapa.CLICK("$transitionList .preview")](e) {
      this.viewTransitionPicker(e.$dt);
    }
    [sapa.SUBSCRIBE("changeTransitionPropertyPopup")](data) {
      if (this.currentTransition) {
        if (this.current) {
          const transition2 = this.current.transition;
          transition2[this.selectedIndex] = data;
          this.$commands.executeCommand("setAttribute", "add transition", this.$context.selection.packByValue({
            transition: [...transition2]
          }));
          this.nextTick(() => {
            this.refresh();
          }, 10);
        }
      }
    }
  }
  var TransitionPropertyPopup$1 = "";
  const property_list = [
    "none",
    "all",
    "background-color",
    "background-position",
    "background-size",
    "border",
    "border-color",
    "border-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-width",
    "border-left",
    "border-left-color",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-width",
    "border-spacing",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-width",
    "bottom",
    "box-shadow",
    "color",
    "filter",
    "font-size",
    "font-size-adjust",
    "font-weight",
    "height",
    "left",
    "letter-spacing",
    "line-height",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "max-height",
    "max-width",
    "min-height",
    "min-width",
    "opacity",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "perspective",
    "perspective-origin",
    "right",
    "text-decoration",
    "text-decoration-color",
    "text-indent",
    "text-shadow",
    "top",
    "transform",
    "vertical-align",
    "visibility",
    "width",
    "word-spacing",
    "z-index"
  ].map((it) => ({
    value: it,
    text: it
  }));
  class TransitionPropertyPopup extends editor.BasePopup {
    getTitle() {
      return "Transition";
    }
    initState() {
      return {
        changeEvent: "",
        instance: {},
        data: {
          timingFunction: "linear",
          duration: "0s",
          delay: "0s",
          name: "all"
        }
      };
    }
    updateData(opt) {
      this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
      if (this.state.instance) {
        this.state.instance.trigger(this.state.changeEvent, this.state.data);
      }
    }
    getBody() {
      return `<div class='elf--transition-property-popup' ref='$popup'></div>`;
    }
    [sapa.LOAD("$popup")]() {
      return `
      <div class="box">
        ${this.templateForProperty()}
        ${this.templateForTimingFunction()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
      </div>
    `;
    }
    templateForTimingFunction() {
      return `
    <div class='timing-function'>
      <label>Timing function</label>
      ${sapa.createComponent("CubicBezierEditor", {
        ref: "$cubicBezierEditor",
        key: "timingFunction",
        value: this.state.data.timingFunction || "linear",
        onChange: "changeCubicBezier"
      })}
    </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeTransition")](key, value) {
      this.updateData({
        [key]: value
      });
    }
    templateForProperty() {
      return `
      <div class='name'>
        ${sapa.createComponent("SelectEditor", {
        ref: "$property",
        icon: true,
        label: "Property",
        key: "name",
        value: this.state.data.name,
        options: property_list,
        onChange: "changeTransition"
      })}
      </div>
    `;
    }
    templateForDelay() {
      return `
    <div class='delay'>
      ${sapa.createComponent("InputRangeEditor", {
        ref: "$delay",
        label: "Delay",
        key: "delay",
        value: this.state.data.delay,
        units: ["s", "ms"],
        onChange: "changeRangeEditor"
      })}
    </div>
    `;
    }
    templateForDuration() {
      return `
    <div class='duration'>
      ${sapa.createComponent("InputRangeEditor", {
        ref: "$duration",
        label: "Duration",
        key: "duration",
        value: this.state.data.duration,
        units: ["s", "ms"],
        onChange: "changeRangeEditor"
      })}
    </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      this.updateData({ [key]: value });
    }
    [sapa.SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
      this.updateData({ [key]: value });
    }
    [sapa.SUBSCRIBE("showTransitionPropertyPopup")](data) {
      this.setState(data);
      this.show(250);
      this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
    }
    [sapa.SUBSCRIBE("hideTransitionPropertyPopup")]() {
      this.$el.hide();
    }
  }
  function transition(editor2) {
    editor2.registerUI("inspector.tab.transition", {
      TransitionProperty
    });
    editor2.registerUI("popup", {
      TransitionPropertyPopup
    });
  }
  var VideoProperty$1 = "";
  class VideoProperty extends editor.BaseProperty {
    getClassName() {
      return "item elf--video-property";
    }
    getTitle() {
      return this.$i18n("video.property.title");
    }
    initState() {
      return {
        $video: { el: {} },
        status: "play",
        volume: 1
      };
    }
    getBody() {
      return `<div ref='$body' style='padding-top: 3px;'></div>`;
    }
    get video() {
      return this.state.$video.el;
    }
    get volumeStatus() {
      if (this.state.volume === 0)
        return "muted";
      if (this.state.volume > 0.5)
        return "up";
      return "down";
    }
    play() {
      if (this.video)
        this.video.play();
    }
    pause() {
      if (this.video)
        this.video.pause();
    }
    [sapa.LOAD("$body")]() {
      var current = this.$context.selection.current || { playTime: "0:1:1" };
      var currentTime = current.currentTime || 0;
      var duration = (current.playTime || "0:1:1").split(":").pop();
      return `
        <div ref='$tools' class='play-control' data-selected-value="${this.state.status}">
          <button type="button" data-value="play" >${editor.iconUse("play")} ${this.$i18n("video.property.play")}</button>
          <button type="button" data-value="pause">${editor.iconUse("pause")}  ${this.$i18n("video.property.pause")}</button>      
          <div>
            ${sapa.createComponent("NumberRangeEditor", {
        ref: "$currentTime",
        min: 0,
        max: duration,
        value: currentTime,
        step: 1e-3,
        onchange: "changeCurrentTime"
      })}
          </div>
        </div>    
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='volume'></span>
            ${this.$i18n("video.property.volume")}
          </div>
          <div ref='$volume_control' class='volume-control' data-selected-value='${this.volumeStatus}'>
            <span data-value='muted'>${editor.iconUse("volume_off")}</span>
            <span data-value='down'>${editor.iconUse("volume_down")}</span>
            <span data-value='up'>${editor.iconUse("volume_up")}</span>
            <input type="range" ref='$volume' min="0" max="1" step="0.001" value="${this.state.volume}" />
          </div>          
        </div>
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='playbackRate'></span>
            ${this.$i18n("video.property.playbackRate")}
          </div>
          <div>
            ${sapa.createComponent("NumberRangeEditor", {
        ref: "$playbackRate",
        min: 0.1,
        max: 10,
        clamp: true,
        value: this.state.playbackRate,
        step: 1e-3,
        onchange: "changePlaybackRate"
      })}
          </div>
        </div>        
        <div class='property-item animation-property-item full'>
          <div class='group'>
            <span class='add-timeline-property' data-property='playTime'></span>
            ${this.$i18n("video.property.playTime")}
          </div>
          ${sapa.createComponent("MediaProgressEditor", {
        ref: "$progress",
        key: "playTime",
        value: current.playTime,
        onchange: "changeSelect"
      })}
        </div>
      `;
    }
    [sapa.SUBSCRIBE("changeCurrentTime")](key, currentTime) {
      this.setState({ currentTime }, false);
      this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ currentTime }));
    }
    [sapa.SUBSCRIBE("changePlaybackRate")](key, playbackRate) {
      this.setState({ playbackRate }, false);
      this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ playbackRate }));
    }
    [sapa.CHANGEINPUT("$volume")]() {
      const volume = Number(this.refs.$volume.value);
      this.setState({ volume }, false);
      this.bindData("$volume_control");
      this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ volume }));
    }
    [sapa.BIND("$volume_control")]() {
      return {
        "data-selected-value": this.volumeStatus
      };
    }
    [sapa.BIND("$tools")]() {
      return {
        "data-selected-value": this.state.status
      };
    }
    [sapa.CLICK("$tools button")](e) {
      var playType = e.$dt.attr("data-value");
      switch (playType) {
        case "play":
          this.setState({ status: "pause" }, false);
          this.play();
          break;
        case "pause":
          this.setState({ status: "play" }, false);
          this.pause();
          break;
      }
      this.bindData("$tools");
    }
    [sapa.SUBSCRIBE_SELF("changeValue") + sapa.DEBOUNCE(100)](key, value) {
      if (!this.state.$video)
        return;
      this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value) {
      this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
    }
    [sapa.SUBSCRIBE_SELF("updateVideoEvent")]() {
      if (this.video.paused) {
        this.setState({
          status: "play",
          currentTime: this.video.currentTime
        }, false);
        this.bindData("$tools");
      }
      this.children.$currentTime.setValue(this.video.currentTime);
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      const current = this.$context.selection.current;
      this.refreshShow(["video"]);
      if (current && current.is("video")) {
        this.emit("refElement", current.id, ($el) => {
          const $video = $el.$("video");
          this.state.$video = $video;
          this.setState({
            volume: current.volume,
            currentTime: current.currentTime,
            playbackRate: current.playbackRate
          }, false);
          this.video.ontimeupdate = (e) => {
            this.trigger("updateVideoEvent", e);
          };
          this.video.onprogress = (e) => {
            this.trigger("updateVideoEvent", e);
          };
          this.load("$body");
        });
      }
    }
  }
  function video(editor2) {
    editor2.registerUI("inspector.tab.style", {
      VideoProperty
    });
  }
  var ComponentPopup$1 = "";
  class ComponentPopup extends editor.BasePopup {
    getClassName() {
      return "component-property w(800)";
    }
    getTitle() {
      return "Component";
    }
    initState() {
      return {
        title: "",
        inspector: []
      };
    }
    refresh() {
      this.setTitle(this.state.title || this.getTitle());
      this.load();
    }
    getBody() {
      return `
      <div ref='$body'></div>
    `;
    }
    [sapa.BIND("$body")]() {
      return {
        style: {
          width: this.state.width || 250
        }
      };
    }
    [sapa.LOAD("$body")]() {
      const inspector2 = this.state.inspector;
      return sapa.createComponent("ComponentEditor", {
        inspector: inspector2,
        onchange: "changeComponent"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeComponent")](key, value) {
      if (sapa.isFunction(this.state.changeEvent)) {
        this.emit(this.state.changeEvent, key, value);
      }
    }
    [sapa.SUBSCRIBE(SHOW_COMPONENT_POPUP)](data) {
      this.setState(data, false);
      this.refresh();
      this.show(data.width);
    }
  }
  var ComponentProperty$1 = "";
  class ComponentProperty extends editor.BaseProperty {
    getClassName() {
      return "component-property";
    }
    getTitle() {
      return "Component";
    }
    isShow() {
      var _a;
      var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
      const inspector2 = this.$context.components.createInspector(current);
      if (current && (current.is("component") || inspector2.length > 0)) {
        return true;
      }
      return false;
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(() => {
        const current = this.$context.selection.current;
        const inspector2 = this.$context.components.createInspector(current);
        return inspector2.length > 0;
      });
    }
    refresh() {
      var current = this.$context.selection.current;
      if (current) {
        this.setTitle(current.getDefaultTitle() || current.itemType || current.name);
        this.load();
      }
    }
    getBody() {
      return `
      <div ref='$body'></div>
    `;
    }
    [sapa.LOAD("$body")]() {
      var _a;
      var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
      if (!current)
        return "";
      const inspector2 = this.$context.components.createInspector(current);
      inspector2.forEach((it) => {
        if (sapa.isString(it)) {
          return;
        }
        let defaultValue = current[it.key] || it.defaultValue;
        if (sapa.isFunction(it.convertDefaultValue)) {
          defaultValue = it.convertDefaultValue(current, it.key);
        }
        it.defaultValue = defaultValue;
      });
      return sapa.createComponent("ComponentEditor", {
        ref: "$comp",
        inspector: inspector2,
        onchange: "changeComponentProperty"
      });
    }
    [sapa.SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
      this.$commands.executeCommand("setAttribute", "change component : " + key, this.$context.selection.packByValue({
        [key]: value
      }));
    }
  }
  function component(editor2) {
    editor2.registerUI("inspector.tab.style", {
      ComponentProperty
    });
    editor2.registerUI("popup", {
      ComponentPopup
    });
  }
  const blend_list = [
    BlendMode.NORMAL,
    BlendMode.MULTIPLY,
    BlendMode.SCREEN,
    BlendMode.OVERLAY,
    BlendMode.DARKEN,
    BlendMode.LIGHTEN,
    BlendMode.COLOR_DODGE,
    BlendMode.COLOR_BURN,
    BlendMode.HARD_LIGHT,
    BlendMode.SOFT_LIGHT,
    BlendMode.DIFFERENCE,
    BlendMode.EXCLUSION,
    BlendMode.HUE,
    BlendMode.SATURATION,
    BlendMode.COLOR,
    BlendMode.LUMINOSITY
  ];
  class BlendSelectEditor extends editor.SelectEditor {
    getBlendList() {
      return blend_list.map((it) => {
        return { value: it, text: this.$i18n(`blend.${it}`) };
      });
    }
    initState() {
      return __spreadProps(__spreadValues({}, super.initState()), {
        options: this.getBlendList()
      });
    }
  }
  var BoxShadowEditor$1 = "";
  class BoxShadowEditor extends editor.EditorElement {
    initState() {
      return {
        boxShadows: this.props.value || []
      };
    }
    template() {
      return `
      <div class="elf--box-shadow-editor" >
        <div class='box-shadow-list' ref='$shadowList'></div>
      </div>
    `;
    }
    [sapa.LOAD("$shadowList") + sapa.DOMDIFF]() {
      var arr = this.state.boxShadows.map((shadow2, index2) => {
        return `
        <div class="shadow-item real" data-index="${index2}">
            <label draggable="true" data-index="${index2}">${editor.iconUse("drag_indicator")}</label>
            <div class="shadow-content">
            ${sapa.createComponent("ColorViewEditor", {
          mini: true,
          key: "color",
          value: shadow2.color,
          params: index2,
          onchange: "changeKeyValue"
        })}
            ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          key: "offsetX",
          label: "X",
          value: shadow2.offsetX,
          params: index2,
          onchange: "changeKeyValue"
        })}          
            ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          key: "offsetY",
          label: "Y",
          value: shadow2.offsetY,
          params: index2,
          onchange: "changeKeyValue"
        })}                    
            ${sapa.createComponent("ToggleButton", {
          mini: true,
          key: "inset",
          value: shadow2.inset,
          params: index2,
          onChange: "changeKeyValue",
          checkedValue: BoxShadowStyle.INSET,
          toggleLabels: [editor.iconUse("border_style"), editor.iconUse("border_style")],
          toggleTitles: [BoxShadowStyle.INSET, BoxShadowStyle.INSET],
          toggleValues: [BoxShadowStyle.OUTSET, BoxShadowStyle.INSET]
        })}            

            ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          label: "B",
          key: "blurRadius",
          value: shadow2.blurRadius,
          params: index2,
          onchange: "changeKeyValue"
        })} 
            ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          label: "S",
          key: "spreadRadius",
          value: shadow2.spreadRadius,
          params: index2,
          onchange: "changeKeyValue"
        })}             
          </div>
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${editor.iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
      });
      return arr.join("");
    }
    modifyBoxShadow() {
      var value = this.state.boxShadows;
      this.parent.trigger(this.props.onchange, this.props.key, value);
    }
    [sapa.SUBSCRIBE("add")](shadows = void 0) {
      if (sapa.isArray(shadows)) {
        this.state.boxShadows.push(...shadows);
      } else {
        const shadowObj = {
          color: "black",
          inset: BoxShadowStyle.OUTSET,
          offsetX: 2,
          offsetY: 2,
          blurRadius: 3,
          spreadRadius: 1
        };
        this.state.boxShadows.push(shadowObj);
      }
      this.refresh();
      this.modifyBoxShadow();
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.DRAGSTART("$shadowList .shadow-item > label")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$shadowList .shadow-item") + sapa.PREVENT]() {
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortBoxShadow(startIndex, targetIndex) {
      this.sortItem(this.state.boxShadows, startIndex, targetIndex);
    }
    [sapa.DROP("$shadowList .shadow-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      this.sortBoxShadow(this.startIndex, targetIndex);
      this.refresh();
      this.modifyBoxShadow();
    }
    [sapa.CLICK("$shadowList .remove")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.boxShadows.splice(index2, 1);
      this.refresh();
      this.modifyBoxShadow();
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
      var shadow2 = this.state.boxShadows[index2];
      this.state.boxShadows[index2] = __spreadProps(__spreadValues({}, shadow2), { [key]: value });
      this.modifyBoxShadow();
    }
  }
  const colors$k = [
    "#FFF8E1",
    "#FFECB3",
    "#FFE082",
    "#FFD54F",
    "#FFCA28",
    "#FFC107",
    "#FFB300",
    "#FFA000",
    "#FF8F00",
    "#FF6F00",
    "#FFE57F",
    "#FFD740",
    "#FFC400",
    "#FFAB00"
  ].map((color) => {
    return { color };
  });
  var materialAmber = {
    title: "material amber",
    key: "material-amber",
    execute: function() {
      return colors$k;
    }
  };
  var __glob_0_0$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialAmber
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$j = [
    "#e3f2fd",
    "#bbdefb",
    "#90caf9",
    "#64b5f6",
    "#42a5f5",
    "#2196f3",
    "#1e88e5",
    "#1976d2",
    "#1565c0",
    "#0d47a1",
    "#2196f3",
    "#82b1ff",
    "#448aff",
    "#2979ff",
    "#2962ff"
  ].map((color) => {
    return { color };
  });
  var materialBlue = {
    title: "material blue",
    key: "material-blue",
    execute: function() {
      return colors$j;
    }
  };
  var __glob_0_1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialBlue
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$i = [
    "#ECEFF1",
    "#CFD8DC",
    "#B0BEC5",
    "#90A4AE",
    "#78909C",
    "#607D8B",
    "#546E7A",
    "#455A64",
    "#37474F",
    "#263238"
  ].map((color) => {
    return { color };
  });
  var materialBluegray = {
    title: "material bluegray",
    key: "material-bluegray",
    execute: function() {
      return colors$i;
    }
  };
  var __glob_0_2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialBluegray
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$h = [
    "#EFEBE9",
    "#D7CCC8",
    "#BCAAA4",
    "#A1887F",
    "#8D6E63",
    "#795548",
    "#6D4C41",
    "#5D4037",
    "#4E342E",
    "#3E2723"
  ].map((color) => {
    return { color };
  });
  var materialBrown = {
    title: "material brown",
    key: "material-brown",
    execute: function() {
      return colors$h;
    }
  };
  var __glob_0_3$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialBrown
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$g = [
    "#e0f7fa",
    "#b2ebf2",
    "#80deea",
    "#4dd0e1",
    "#26c6da",
    "#00bcd4",
    "#00acc1",
    "#0097a7",
    "#00838f",
    "#006064",
    "#00bcd4",
    "#84ffff",
    "#18ffff",
    "#00e5ff",
    "#00b8d4"
  ].map((color) => {
    return { color };
  });
  var materialCyan = {
    title: "material cyan",
    key: "material-cyan",
    execute: function() {
      return colors$g;
    }
  };
  var __glob_0_4$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialCyan
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$f = [
    "#FBE9E7",
    "#FFCCBC",
    "#FFAB91",
    "#FF8A65",
    "#FF7043",
    "#FF5722",
    "#F4511E",
    "#E64A19",
    "#D84315",
    "#BF360C",
    "#FF9E80",
    "#FF6E40",
    "#FF3D00",
    "#DD2C00"
  ].map((color) => {
    return { color };
  });
  var materialDeeporange = {
    title: "material deep orange",
    key: "material-deeporange",
    execute: function() {
      return colors$f;
    }
  };
  var __glob_0_5$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialDeeporange
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$e = [
    "#ede7f6",
    "#d1c4e9",
    "#b39ddb",
    "#9575cd",
    "#7e57c2",
    "#673ab7",
    "#5e35b1",
    "#512da8",
    "#4527a0",
    "#311b92",
    "#673ab7",
    "#b388ff",
    "#7c4dff",
    "#651fff",
    "#6200ea"
  ].map((color) => {
    return { color };
  });
  var materialDeeppurple = {
    title: "material deep purple",
    key: "material-deeppurple",
    execute: function() {
      return colors$e;
    }
  };
  var __glob_0_6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialDeeppurple
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$d = [
    "#FAFAFA",
    "#F5F5F5",
    "#EEEEEE",
    "#E0E0E0",
    "#BDBDBD",
    "#9E9E9E",
    "#757575",
    "#616161",
    "#424242",
    "#212121"
  ].map((color) => {
    return { color };
  });
  var materialGray = {
    title: "material gray",
    key: "material-gray",
    execute: function() {
      return colors$d;
    }
  };
  var __glob_0_7$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialGray
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$c = [
    "#E8F5E9",
    "#C8E6C9",
    "#A5D6A7",
    "#81C784",
    "#66BB6A",
    "#4CAF50",
    "#43A047",
    "#388E3C",
    "#2E7D32",
    "#1B5E20",
    "#B9F6CA",
    "#69F0AE",
    "#00E676",
    "#00C853"
  ].map((color) => {
    return { color };
  });
  var materialGreen = {
    title: "material green",
    key: "material-green",
    execute: function() {
      return colors$c;
    }
  };
  var __glob_0_8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialGreen
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$b = [
    "#e8eaf6",
    "#c5cae9",
    "#9fa8da",
    "#7986cb",
    "#5c6bc0",
    "#3f51b5",
    "#3949ab",
    "#303f9f",
    "#283593",
    "#1a237e",
    "#3f51b5",
    "#8c9eff",
    "#536dfe",
    "#3d5afe",
    "#304ffe"
  ].map((color) => {
    return { color };
  });
  var materialIndigo = {
    title: "material indigo",
    key: "material-indigo",
    execute: function() {
      return colors$b;
    }
  };
  var __glob_0_9$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialIndigo
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$a = [
    "#e1f5fe",
    "#b3e5fc",
    "#81d4fa",
    "#4fc3f7",
    "#29b6f6",
    "#03a9f4",
    "#039be5",
    "#0288d1",
    "#0277bd",
    "#01579b",
    "#03a9f4",
    "#80d8ff",
    "#40c4ff",
    "#00b0ff",
    "#0091ea"
  ].map((color) => {
    return { color };
  });
  var materialLightblue = {
    title: "material light blue",
    key: "material-lightblue",
    execute: function() {
      return colors$a;
    }
  };
  var __glob_0_10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialLightblue
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$9 = [
    "#F1F8E9",
    "#DCEDC8",
    "#C5E1A5",
    "#AED581",
    "#9CCC65",
    "#8BC34A",
    "#7CB342",
    "#689F38",
    "#558B2F",
    "#33691E",
    "#CCFF90",
    "#B2FF59",
    "#76FF03",
    "#64DD17"
  ].map((color) => {
    return { color };
  });
  var materialLightgreen = {
    title: "material lightgreen",
    key: "material-lightgreen",
    execute: function() {
      return colors$9;
    }
  };
  var __glob_0_11$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialLightgreen
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$8 = [
    "#F9FBE7",
    "#F0F4C3",
    "#E6EE9C",
    "#DCE775",
    "#D4E157",
    "#CDDC39",
    "#C0CA33",
    "#AFB42B",
    "#9E9D24",
    "#827717",
    "#F4FF81",
    "#EEFF41",
    "#C6FF00",
    "#AEEA00"
  ].map((color) => {
    return { color };
  });
  var materialLime = {
    title: "material lime",
    key: "material-lime",
    execute: function() {
      return colors$8;
    }
  };
  var __glob_0_12$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialLime
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$7 = [
    "#FFF3E0",
    "#FFE0B2",
    "#FFCC80",
    "#FFB74D",
    "#FFA726",
    "#FF9800",
    "#FB8C00",
    "#F57C00",
    "#EF6C00",
    "#E65100",
    "#FFD180",
    "#FFAB40",
    "#FF9100",
    "#FF6D00"
  ].map((color) => {
    return { color };
  });
  var materialOrange = {
    title: "material orange",
    key: "material-orange",
    execute: function() {
      return colors$7;
    }
  };
  var __glob_0_13$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialOrange
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$6 = [
    "#fce4ec",
    "#f8bbd0",
    "#f48fb1",
    "#f06292",
    "#ec407a",
    "#e91e63",
    "#d81b60",
    "#c2185b",
    "#ad1457",
    "#880e4f",
    "#e91e63",
    "#ff80ab",
    "#ff4081",
    "#f50057",
    "#c51162"
  ].map((color) => {
    return { color };
  });
  var materialPink = {
    title: "material pink",
    key: "material-pink",
    execute: function() {
      return colors$6;
    }
  };
  var __glob_0_14$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialPink
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$5 = [
    "#f3e5f5",
    "#e1bee7",
    "#ce93d8",
    "#ba68c8",
    "#ab47bc",
    "#9c27b0",
    "#8e24aa",
    "#7b1fa2",
    "#6a1b9a",
    "#4a148c",
    "#9c27b0",
    "#ea80fc",
    "#e040fb",
    "#d500f9",
    "#aa00ff"
  ].map((color) => {
    return { color };
  });
  var materialPurple = {
    title: "material purple",
    key: "material-purple",
    execute: function() {
      return colors$5;
    }
  };
  var __glob_0_15$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialPurple
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$4 = [
    "#ffebee",
    "#ffcdd2",
    "#ef9a9a",
    "#e57373",
    "#ef5350",
    "#f44336",
    "#e53935",
    "#d32f2f",
    "#c62828",
    "#b71c1c",
    "#f44336",
    "#ff8a80",
    "#ff5252",
    "#ff1744",
    "#d50000"
  ].map((color) => {
    return { color };
  });
  var materialRed = {
    title: "material red",
    key: "material-red",
    execute: function() {
      return colors$4;
    }
  };
  var __glob_0_16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialRed
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$3 = [
    "#e0f2f1",
    "#b2dfdb",
    "#80cbc4",
    "#4db6ac",
    "#26a69a",
    "#009688",
    "#00897b",
    "#00796b",
    "#00695c",
    "#004d40",
    "#009688",
    "#a7ffeb",
    "#64ffda",
    "#1de9b6",
    "#00bfa5"
  ].map((color) => {
    return { color };
  });
  var materialTeal = {
    title: "material teal",
    key: "material-teal",
    execute: function() {
      return colors$3;
    }
  };
  var __glob_0_17$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialTeal
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$2 = [
    "#FFFDE7",
    "#FFF9C4",
    "#FFF59D",
    "#FFF176",
    "#FFEE58",
    "#FFEB3B",
    "#FDD835",
    "#FBC02D",
    "#F9A825",
    "#F57F17",
    "#FFFF8D",
    "#FFFF00",
    "#FFEA00",
    "#FFD600"
  ].map((color) => {
    return { color };
  });
  var materialYellow = {
    title: "material yellow",
    key: "material-yellow",
    execute: function() {
      return colors$2;
    }
  };
  var __glob_0_18$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": materialYellow
  }, Symbol.toStringTag, { value: "Module" }));
  const colors$1 = [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ].map((color) => {
    return { color };
  });
  var opencolorGray = {
    title: "opencolor gray",
    resource: "https://yeun.github.io/open-color/",
    key: "opencolor-gray",
    execute: function() {
      return colors$1;
    }
  };
  var __glob_0_19$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": opencolorGray
  }, Symbol.toStringTag, { value: "Module" }));
  var random = {
    title: "random",
    key: "random",
    execute: function(count = 42) {
      const colorList = Color__namespace.randomByCount(count).map((color) => {
        return { color };
      });
      colorList.sort((a, b) => {
        const localA = Color__namespace.parse(a.color);
        const localB = Color__namespace.parse(b.color);
        return localA.h > localB.h ? 1 : -1;
      });
      return colorList;
    }
  };
  var __glob_0_20$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": random
  }, Symbol.toStringTag, { value: "Module" }));
  const modules$1 = { "./colors_list/material-amber.js": __glob_0_0$1, "./colors_list/material-blue.js": __glob_0_1$1, "./colors_list/material-bluegray.js": __glob_0_2$1, "./colors_list/material-brown.js": __glob_0_3$1, "./colors_list/material-cyan.js": __glob_0_4$1, "./colors_list/material-deeporange.js": __glob_0_5$1, "./colors_list/material-deeppurple.js": __glob_0_6$1, "./colors_list/material-gray.js": __glob_0_7$1, "./colors_list/material-green.js": __glob_0_8$1, "./colors_list/material-indigo.js": __glob_0_9$1, "./colors_list/material-lightblue.js": __glob_0_10$1, "./colors_list/material-lightgreen.js": __glob_0_11$1, "./colors_list/material-lime.js": __glob_0_12$1, "./colors_list/material-orange.js": __glob_0_13$1, "./colors_list/material-pink.js": __glob_0_14$1, "./colors_list/material-purple.js": __glob_0_15$1, "./colors_list/material-red.js": __glob_0_16$1, "./colors_list/material-teal.js": __glob_0_17$1, "./colors_list/material-yellow.js": __glob_0_18$1, "./colors_list/opencolor-gray.js": __glob_0_19$1, "./colors_list/random.js": __glob_0_20$1 };
  var colors = Object.values(modules$1).map((it) => it.default);
  var ColorAssetsEditor$1 = "";
  class ColorAssetsEditor extends editor.EditorElement {
    initState() {
      return {
        mode: "grid",
        preset: "random",
        isLoaded: false,
        colors
      };
    }
    getTools() {
      return `<div ref="$tools"></div>`;
    }
    [sapa.LOAD("$tools")]() {
      const options2 = this.state.colors.map((it) => {
        return { value: it.key, text: it.title };
      });
      return sapa.createComponent("SelectEditor", {
        key: "preset",
        value: this.state.preset,
        options: options2,
        onchange: "changePreset"
      });
    }
    [sapa.SUBSCRIBE("changePreset")](key, value) {
      this.setState({
        [key]: value
      });
    }
    template() {
      return `
      <div class='elf--color-assets-editor'>
        <div class='color-assets-head'>
          <div class='tools'>${this.getTools()}</div>
        </div>
        <div class='color-list' ref='$colorList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
    }
    [sapa.CLICK("$title")]() {
      this.$el.toggleClass("is-open");
    }
    [sapa.LOAD("$colorList")]() {
      var preset = this.state.colors.find((it) => it.key === this.state.preset);
      if (!preset) {
        return "";
      }
      var results = preset.execute().map((item, index2) => {
        return `<div class='color-item' data-index="${index2}" data-color="${item.color}"><div class='preview' title="${item.color}" data-index="${index2}"><div class='color-view' style='background-color: ${item.color};'></div></div></div>`;
      });
      return results;
    }
    executeColor(callback, isRefresh = true, isEmit = true) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        callback && callback(project2);
        if (isRefresh)
          this.refresh();
        if (isEmit)
          this.emit("refreshColorAssets");
      } else {
        window.alert("Please select a project.");
      }
    }
    [sapa.CLICK("$colorList .preview")](e) {
      const color = e.$dt.$(".color-view").css("background-color");
      this.modifyColorPicker(color);
    }
    modifyColorPicker(color) {
      this.parent.trigger(this.props.onchange, this.props.key, color, this.props.params);
    }
  }
  var ColorSingleEditor$1 = "";
  class ColorSingleEditor extends editor.EditorElement {
    initState() {
      return {
        params: this.props.params,
        color: this.props.color || "rgba(0, 0, 0, 1)"
      };
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      this.modifyColor();
    }
    modifyColor() {
      this.parent.trigger(this.props.onchange, this.props.key, this.state.color, this.state.params);
    }
    changeColor(color) {
      this.setState({ color });
    }
    setValue(color) {
      this.changeColor(color);
    }
    [sapa.BIND("$miniView")]() {
      return {
        style: {
          "background-color": this.state.color
        }
      };
    }
    template() {
      return `
            <div class='elf--color-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
    }
    [sapa.CLICK("$preview")]() {
      this.viewColorPicker();
    }
    viewColorPicker() {
      this.emit("showColorPickerPopup", {
        target: this,
        changeEvent: (color) => {
          this.refs.$miniView.cssText(`background-color: ${color}`);
          this.updateData({ color });
        },
        color: this.state.color
      });
    }
  }
  var ColorViewEditor$1 = "";
  class ColorViewEditor extends editor.EditorElement {
    initState() {
      const value = this.props.value || "rgba(0, 0, 0, 1)";
      const compact = sapa.isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
      const mini = sapa.isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
      return {
        label: this.props.label,
        title: this.props.title,
        value,
        compact,
        mini,
        color: Color__namespace.parse(value),
        colorFocus: false,
        opacityFocus: false
      };
    }
    updateData(opt = {}) {
      this.setState(opt);
      this.modifyColor();
    }
    updateEndData(opt = {}) {
      this.setState(opt);
      this.modifyEndColor();
    }
    getValue() {
      return this.state.value;
    }
    setValue(value) {
      this.changeColor(value);
    }
    modifyColor() {
      this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
    }
    modifyEndColor() {
      this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
    }
    changeColor(value) {
      this.setState({
        value,
        color: Color__namespace.parse(value)
      });
    }
    get alpha() {
      return this.state.color.a * 100;
    }
    get hexColor() {
      return Color__namespace.formatWithoutAlpha(this.state.color, "hex");
    }
    get fullColor() {
      return Color__namespace.format(this.state.color, this.state.color.type);
    }
    refresh() {
      this.refreshColorView();
      this.refs.$colorCode.val(this.state.value);
      this.refs.$opacityCode.val(this.alpha);
    }
    refreshColorView() {
      this.bindData("$miniView1");
      this.bindData("$miniView2");
    }
    template() {
      var { label, title } = this.state;
      return `
            <div class='elf--color-view-editor'>
                ${label ? `<label data-tooltip="${title}"><span>${label}</span></label>` : ""}            
                <div class='color-code' ref="$container">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>
                            <div class='color-view' ref='$miniView1'></div>
                            <div class='color-view' ref='$miniView2'></div>
                        </div>
                    </div>                
                    <div class="color-input">
                        <input type="text" ref='$colorCode' value='${this.state.value}' tabIndex="1" />
                    </div>
                    <div class="opacity-input">                    
                        <input type="number" ref='$opacityCode' value='${this.alpha}' tabIndex="2" max="100" min="0" step="0.1" />
                    </div>                    
                </div>
            </div>
        `;
    }
    [sapa.BIND("$el")]() {
      var { label, compact, mini, colorFocus, opacityFocus } = this.state;
      return {
        class: [
          "elf--color-view-editor",
          {
            "has-label": label,
            compact,
            mini
          },
          {
            focused: colorFocus || opacityFocus
          }
        ]
      };
    }
    [sapa.BIND("$miniView1")]() {
      return {
        style: {
          "background-color": this.hexColor
        }
      };
    }
    [sapa.BIND("$miniView2")]() {
      return {
        style: {
          "background-color": this.fullColor
        }
      };
    }
    [sapa.BIND("$colorCode")]() {
      return {
        value: this.props.format ? this.hexColor : this.state.value
      };
    }
    [sapa.BIND("$opacityCode")]() {
      return {
        value: this.alpha
      };
    }
    [sapa.FOCUSIN("$colorCode")]() {
      this.setState({
        colorFocus: true
      });
      this.refs.$colorCode.select();
    }
    [sapa.FOCUSOUT("$colorCode")]() {
      this.setState({
        colorFocus: false
      });
    }
    [sapa.FOCUSIN("$opacityCode")]() {
      this.setState({
        opacityFocus: true
      });
      this.refs.$opacityCode.select();
    }
    [sapa.FOCUSOUT("$opacityCode")]() {
      this.setState({
        opacityFocus: false
      });
    }
    [sapa.CLICK("$preview")]() {
      this.viewColorPicker();
    }
    viewColorPicker() {
      this.emit("showColorPickerPopup", {
        target: this,
        changeEvent: (color) => {
          this.updateData({ value: color, color: Color__namespace.parse(color) });
        },
        changeEndEvent: (color) => {
          this.updateEndData({ value: color, color: Color__namespace.parse(color) });
        },
        color: this.state.value
      }, null, this.$el.rect());
    }
    [sapa.CLICK("$remove")]() {
      this.updateData({ value: "" });
    }
    [sapa.INPUT("$el .color-input input")](e) {
      var color = e.$dt.value;
      this.updateData({
        value: color,
        color: Color__namespace.parse(color)
      });
      this.refreshColorView();
    }
    [sapa.INPUT("$el .opacity-input input")](e) {
      var opacity = +e.$dt.value;
      opacity = Math.max(0, Math.min(100, opacity));
      const color = Color__namespace.parse(this.state.value);
      color.a = round(opacity / 100, 1e3);
      const value = Color__namespace.format(color, color.type);
      this.updateData({
        value,
        color
      });
      this.refreshColorView();
    }
  }
  var CSSPropertyEditor$1 = "";
  class CSSPropertyEditor extends editor.EditorElement {
    initState() {
      return {
        hideTitle: this.props["hide-title"] === "true",
        hideRefresh: this.props["hide-refresh"] === "true",
        properties: []
      };
    }
    updateData(opt) {
      this.setState(opt, false);
      this.modifyProperty();
    }
    modifyProperty() {
      this.parent.trigger(this.props.onchange, this.state.properties);
    }
    template() {
      const hideTitleClass = this.state.hideTitle ? "hide-title" : "";
      const hideRefreshClass = this.state.hideRefresh ? "hide-refresh" : "";
      return `
      <div class='elf--css-property-editor ${hideTitleClass} ${hideRefreshClass}'>
        <div class='title'>
          <label>${this.$i18n("css.property.editor.properties")}</label>
          <div class='tools'>
            ${this.makePropertySelect()}
            <button type="button" ref='$addProperty'>${editor.iconUse("add")}</button>
          </div>
        </div>
        <div class='input grid-1 css-property-list' ref='$property'></div>
      </div>
    `;
    }
    getPropertyDefaultValue(key) {
      switch (key) {
        case "animation-timing-function":
        case "box-shadow":
        case "text-shadow":
        case "color":
        case "background-image":
        case "background-color":
        case "text-fill-color":
        case "text-stroke-color":
        case "filter":
        case "backdrop-filter":
        case "var":
        case "transform":
        case "transform-origin":
        case "perspective-origin":
        case "playTime":
          return editor.Length.string("");
        case "offset-distance":
          return editor.Length.percent(0);
        case "rotate":
          return editor.Length.deg(0);
        case "mix-blend-mode":
          return "normal";
        case "clip-path":
          return "";
        case "opacity":
          return 1;
        default:
          return 0;
      }
    }
    getDefinedKey(key) {
      switch (key) {
        case "animation-timing-function":
          return "animationTimingFunction";
        case "box-shadow":
          return "boxShadow";
        case "text-shadow":
          return "textShadow";
        case "color":
          return "color";
        case "background-image":
          return "backgroundImage";
        case "background-color":
          return "backgroundColor";
        case "text-fill-color":
          return "textFillColor";
        case "text-stroke-color":
          return "textStrokeColor";
        case "filter":
          return "filter";
        case "backdrop-filter":
          return "backdropFilter";
        case "var":
          return "var";
        case "transform":
          return "transform";
        case "transform-origin":
          return "transformOrigin";
        case "perspective-origin":
          return "perspectiveOrigin";
        case "playTime":
          return "playTime";
        case "offset-distance":
          return "offsetDistance";
        case "rotate":
          return "rotate";
        case "mix-blend-mode":
          return "mixBlendMode";
        case "clip-path":
          return "clipPath";
        case "opacity":
          return "opacity";
        default:
          return key;
      }
    }
    [sapa.CLICK("$addProperty")]() {
      var key = this.getRef("$propertySelect").value;
      var searchItem = this.state.properties.find((it) => {
        return it.key === key;
      });
      if (searchItem) {
        window.alert(`${key} is already added.`);
        return;
      }
      var value = this.getPropertyDefaultValue(key);
      var current = this.$context.selection.current;
      if (current) {
        value = current[this.getDefinedKey(key)];
      }
      this.state.properties.push({ key, value });
      this.refresh();
      this.modifyProperty();
    }
    makeIndivisualPropertyColorEditor(property, index2) {
      var key = property.key;
      return `<div class='property-editor'>
    ${sapa.createComponent("ColorViewEditor", {
        ref: `${key}${index2}`,
        label: property.key,
        title: property.key,
        value: property.value,
        key: property.key,
        onChange: "changeColorProperty"
      })}
  </div>`;
    }
    makeCustomePropertyEditor(property, index2) {
      return `<div class='property-editor'>
        ${sapa.createComponent(property.editor, {
        onchange: "changeSelect",
        ref: `$customProperty${index2}`,
        key: property.key,
        value: property.value
      })}
      </div>`;
    }
    makeIndivisualPropertyEditor(property, index2) {
      if (property.key === "background-image") {
        return `
        <div class='property-editor'>
          ${sapa.createComponent("BackgroundImageEditor", {
          ref: `$backgroundImage${index2}`,
          key: property.key,
          "hide-title": this.state.hideTitle,
          value: property.value,
          onchange: "changeKeyValue"
        })}
        </div>
      `;
      } else if (property.key === "filter") {
        return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$filter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
      } else if (property.key === "backdrop-filter") {
        return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$backdropFilter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
      } else if (property.key === "box-shadow") {
        return `
        <div class='property-editor'>
          <object refClass="BoxShadowEditor" ref='$boxshadow${index2}' value="${property.value}" hide-label="false" onChange="changeBoxShadowProperty" />
        </div>
      `;
      } else if (property.key === "text-shadow") {
        return `
        <div class='property-editor'>
          <object refClass="TextShadowEditor" ref='$textshadow${index2}' value="${property.value}" hide-label="false" onChange="changeTextShadowProperty" />
        </div>
      `;
      } else if (property.key === "var") {
        return `
        <div class='property-editor'>
          <object refClass="VarEditor" ref='$var${index2}' value="${property.value}" onChange="changeVar" />
        </div>
      `;
      } else if (property.key === "transform") {
        return `
        <div class='property-editor'>
          <object refClass="TransformEditor" ref='$transform${index2}' value="${property.value}" onChange="changeTransform" />
        </div>
      `;
      } else if (property.key === "transform-origin") {
        return `
        <div class='property-editor'>
          <object refClass="TransformOriginEditor" ref='$transformOrigin${index2}' value="${property.value}" onChange="changeTransformOrigin" />
        </div>
      `;
      } else if (property.key === "perspective-origin") {
        return `
        <div class='property-editor'>
          <object refClass="PerspectiveOriginEditor" ref='$perspectiveOrigin${index2}' value="${property.value}" onChange="changePerspectiveOrigin" />
        </div>
      `;
      } else if (property.key === "fill-rule") {
        return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$fillRule${index2}' 
          key='fill-rule' 
          icon="true" 
          options=${sapa.variable(["nonzero", "evenodd"])}
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
      } else if (property.key === "stroke-linecap") {
        return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinecap${index2}' 
          key='stroke-linecap' 
          icon="true" 
          options=${sapa.variable(["butt", "round", "square"])}          
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
      } else if (property.key === "stroke-linejoin") {
        return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinejoin${index2}' 
          key='stroke-linejoin' 
          icon="true" 
          options=${sapa.variable([
          "miter",
          "arcs",
          "bevel",
          "miter-clip",
          "round"
        ])}                    
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
      } else if (property.key === "mix-blend-mode") {
        return `
        <div class='property-editor'>
          <object refClass="BlendSelectEditor" 
          ref='$mixBlendMode${index2}' 
          key='mix-blend-mode' 
          icon="true" 
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
      } else if (property.key === "stroke-dasharray") {
        return `
        <object refClass="StrokeDashArrayEditor" 
          ref='$strokeDashArray${index2}' 
          key='stroke-dasharray'
          value='${property.value}' 
          onchange='changeSelect' 
        />
      `;
      } else if (property.key === "border-radius") {
        return `
        <object refClass="BorderRadiusEditor"
          ref='$borderRadius${index2}' 
          key='border-radius'
          value='${property.value}' 
          onchange='changeBorderRadius' 
        />
      `;
      } else if (property.key === "border") {
        return `
        <object refClass="BorderEditor"
          ref='$border${index2}' 
          key='border'
          value='${property.value}' 
          onchange='changeKeyValue' 
        />
      `;
      } else if (property.key === "clip-path") {
        return `
        <object refClass="ClipPathEditor"
          ref='$clipPath${index2}' 
          key='clip-path'
          value='${property.value}' 
          onchange='changeClipPath' 
        />
      `;
      } else if (property.key === "d") {
        return `
        <object refClass="PathDataEditor" ref='$pathData${index2}' key='d' value='${property.value}' onchange='changeSelect' />
      `;
      } else if (property.key === "points") {
        return `
        <object refClass="PolygonDataEditor" ref='$polygonData${index2}' key='points' value='${property.value}' onchange='changeSelect' />
      `;
      } else if (property.key === "playTime") {
        return `
        <object refClass="MediaProgressEditor" ref='$playTime${index2}'  key='playTime' value="${property.value}" onchange="changeSelect" />      
      `;
      }
      return `
      <div class='property-editor'>
        ???

      </div>
    `;
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value) {
      this.modifyPropertyValue(key, value);
    }
    [sapa.SUBSCRIBE_SELF("changeBorderRadius")](value) {
      this.modifyPropertyValue("border-radius", value);
    }
    [sapa.SUBSCRIBE_SELF("changeClipPath")](value) {
      this.modifyPropertyValue("clip-path", value);
    }
    [sapa.SUBSCRIBE_SELF("changeColorProperty")](key, color) {
      this.modifyPropertyValue(key, color);
    }
    [sapa.SUBSCRIBE_SELF("changeBackgroundImageProperty")](key, backgroundImage2) {
      this.modifyPropertyValue(key, backgroundImage2);
    }
    [sapa.SUBSCRIBE_SELF("changeFilterProperty")](filter2) {
      this.modifyPropertyValue("filter", filter2);
    }
    [sapa.SUBSCRIBE_SELF("changeBackdropFilterProperty")](filter2) {
      this.modifyPropertyValue("backdrop-filter", filter2);
    }
    [sapa.SUBSCRIBE_SELF("changeBoxShadowProperty")](boxshadow) {
      this.modifyPropertyValue("box-shadow", boxshadow);
    }
    [sapa.SUBSCRIBE_SELF("changeTextShadowProperty")](textShadow2) {
      this.modifyPropertyValue("text-shadow", textShadow2);
    }
    [sapa.SUBSCRIBE_SELF("changeVar")](value) {
      this.modifyPropertyValue("var", value);
    }
    [sapa.SUBSCRIBE_SELF("changeTransform")](value) {
      this.modifyPropertyValue("transform", value);
    }
    [sapa.SUBSCRIBE_SELF("changeTransformOrigin")](value) {
      this.modifyPropertyValue("transform-origin", value);
    }
    [sapa.SUBSCRIBE_SELF("changePerspectiveOrigin")](value) {
      this.modifyPropertyValue("perspective-origin", value);
    }
    [sapa.SUBSCRIBE_SELF("changeSelect")](key, value) {
      this.modifyPropertyValue(key, value);
    }
    makePropertyEditor(property, index2) {
      if (property.editor) {
        return this.makeCustomePropertyEditor(property, index2);
      }
      switch (property.key) {
        case "animation-timing-function":
        case "box-shadow":
        case "text-shadow":
        case "background-image":
        case "filter":
        case "backdrop-filter":
        case "var":
        case "transform":
        case "transform-origin":
        case "perspective-origin":
        case "mix-blend-mode":
        case "border":
        case "border-radius":
        case "clip-path":
        case "fill-rule":
        case "stroke-linecap":
        case "stroke-linejoin":
        case "stroke-dasharray":
        case "d":
        case "points":
        case "offset-path":
        case "playTime":
          return this.makeIndivisualPropertyEditor(property, index2);
        case "color":
        case "background-color":
        case "text-fill-color":
        case "text-stroke-color":
        case "stroke":
        case "fill":
          return this.makeIndivisualPropertyColorEditor(property, index2);
        case "opacity":
        case "fill-opacity":
        case "stroke-dashoffset":
        case "offset-distance":
          let min = 0;
          let max = 1;
          let step2 = 0.01;
          return `
          <div class='property-editor'>
            ${sapa.createComponent("NumberInputEditor", {
            ref: `$opacity${index2}`,
            key: property.key,
            label: property.key,
            min,
            max,
            step: step2,
            value: property.value || 1,
            onchange: "changeRangeEditor"
          })}
              
          </div>
        `;
        case "x":
        case "y":
        case "width":
        case "height":
          return `
            <div class='property-editor'>
              ${sapa.createComponent("NumberInputEditor", {
            ref: `$opacity${index2}`,
            key: property.key,
            label: property.key,
            min: -2e4,
            max: 2e4,
            step: 1,
            value: property.value || 1,
            onchange: "changeRangeEditor"
          })}
                
            </div>
          `;
        case "rotate":
          return `
          <div class='property-editor'>
            ${sapa.createComponent("InputRangeEditor", {
            ref: `rangeEditor${index2}`,
            key: property.key,
            value: property.value,
            min: -2e3,
            max: 2e3,
            units: ["deg"],
            onChange: "changeRangeEditor"
          })}
          </div>
        `;
        case "margin-top":
        case "margin-bottom":
        case "margin-left":
        case "margin-right":
        case "padding-top":
        case "padding-bottom":
        case "padding-left":
        case "padding-right":
        case "perspective":
        case "text-stroke-width":
        default:
          return `
          <div class='property-editor'>
            ${sapa.createComponent("InputRangeEditor", {
            ref: `rangeEditor${index2}`,
            key: property.key,
            label: property.key,
            value: property.value,
            max: 1e3,
            onChange: "changeRangeEditor"
          })}
          </div>
        `;
      }
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      this.modifyPropertyValue(key, value + "");
    }
    searchKey(key, callback) {
      this.state.properties.filter((it) => it.key === key).forEach(callback);
    }
    modifyPropertyValue(key, value) {
      this.searchKey(key, (it) => {
        it.value = value;
      });
      this.modifyProperty();
    }
    makePropertySelect() {
      return `
      <select class='property-select' ref='$propertySelect'>
        <optgroup label='Position'>
          <option value='x'>x</option>
          <option value='y'>y</option>        
        </optgroup>
        <optgroup label='Size'>
          <option value='width'>width</option>
          <option value='height'>height</option>
        </optgroup>      
        <optgroup label='Box Model'>
          <option value='margin-left'>margin-left</option>
          <option value='margin-right'>margin-right</option>
          <option value='margin-bottom'>margin-bottom</option>
          <option value='margin-top'>margin-top</option>
          <option value='padding-left'>padding-left</option>
          <option value='padding-right'>padding-right</option>
          <option value='padding-bottom'>padding-bottom</option>
          <option value='padding-top'>padding-top</option>       
        </optgroup>
        <optgroup label='Border'>
          <option value='border'>border</option>
          <option value='border-radius'>border-radius</option>
        </optgroup>        
        <optgroup label='Style'>
          <option value='background-color'>background-color</option>
          <option value='background-image'>background-image</option>
          <option value='box-shadow'>box-shadow</option>
          <option value='text-shadow'>text-shadow</option>
          <option value='filter'>filter</option>      
          <option value='backdrop-filter'>backdrop-filter</option>
          <option value='mix-blend-mode'>mix-blend-mode</option>
        </optgroup>            
        <optgroup label='Transform'>
          <option value='transform'>transform</option>
          <option value='transform-origin'>transform-origin</option>
          <option value='perspective'>perspective</option>
          <option value='perspective-origin'>perspective-origin</option>
        </optgroup>
        <optgroup label='Font'>
          <option value='font-size'>font-size</option>
          <option value='font-weight'>font-weight</option>          
        </optgroup>
        <optgroup label='Animation'>
          <option value='animation-timing-function'>timing-function</option>
        </optgroup>        
      </select>
    `;
    }
    [sapa.LOAD("$property") + sapa.DOMDIFF]() {
      return this.state.properties.map((it, index2) => {
        return `
        <div class='css-property-item'>   
          <div class='value-editor'>
            ${this.makePropertyEditor(it, index2)}
          </div>
          <button type="button" 
            class='remove' 
            data-index="${index2}">${editor.iconUse("remove2")}</button>
        </div>
      `;
      });
    }
    [sapa.SUBSCRIBE("showCSSPropertyEditor")](properties = []) {
      this.setState({ properties });
      this.refresh();
    }
    [sapa.CLICK("$property .remove")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.properties.splice(index2, 1);
      this.refresh();
      this.modifyProperty();
    }
    [sapa.CLICK("$property .refresh")]() {
      this.parent.trigger("refreshPropertyValue");
    }
  }
  var CubicBezierEditor$1 = "";
  class CubicBezierEditor extends editor.EditorElement {
    initState() {
      return {
        key: this.props.key,
        currentBezier: getPredefinedCubicBezier(this.props.value || "linear"),
        isAnimating: sapa.isUndefined(this.props.isAnimating) ? true : Boolean(this.props.isAnimating),
        currentBezierIndex: 0,
        selectedColor: "#609de2",
        animatedColor: "#609de266",
        curveColor: "#609de2",
        baseLineColor: "rgba(117, 117, 117, 0.46)"
      };
    }
    template() {
      const linearCurve = curveToPath(this.state.currentBezier, 150, 150);
      const linearCurvePoint = curveToPointLine(this.state.currentBezier, 150, 150);
      const easeCurve = curveToPath("ease", 30, 30);
      const easeCurvePoint = curveToPointLine("ease", 30, 30);
      const easeInCurve = curveToPath("ease-in", 30, 30);
      const easeInCurvePoint = curveToPointLine("ease-in", 30, 30);
      const easeOutCurve = curveToPath("ease-out", 30, 30);
      const easeOutCurvePoint = curveToPointLine("ease-out", 30, 30);
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--cubic-bezier-editor"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "predefined"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "left",
        ref: "$left"
      }, editor.iconUse("chevron_left")), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "predefined-text",
        ref: "$text"
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "right",
        ref: "$right"
      }, editor.iconUse("chevron_right"))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "animation",
        ref: "$animationArea"
      }, /* @__PURE__ */ sapa.createElementJsx("canvas", {
        class: "animation-canvas",
        ref: "$animationCanvas",
        title: "Click and Replay point animation",
        width: "230px",
        height: "20px"
      })), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "item-list",
        ref: "$itemList",
        "data-selected-value": ""
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "item",
        "data-bezier": "ease",
        title: "ease"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "item-canvas",
        width: "30",
        height: "30",
        viewBox: "0 0 30 30"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeCurve,
        stroke: "white",
        "stroke-width": "1",
        fill: "none"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeCurvePoint,
        stroke: "gray",
        "stroke-width": "1",
        fill: "none"
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "item",
        "data-bezier": "ease-in",
        title: "ease-in"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "item-canvas",
        width: "30",
        height: "30",
        viewBox: "0 0 30 30"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeInCurve,
        stroke: "white",
        "stroke-width": "1",
        fill: "none"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeInCurvePoint,
        stroke: "gray",
        "stroke-width": "1",
        fill: "none"
      }))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "item",
        "data-bezier": "ease-out",
        title: "ease-out"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "item-canvas",
        width: "30",
        height: "30",
        viewBox: "0 0 30 30"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeOutCurve,
        stroke: "white",
        "stroke-width": "1",
        fill: "none"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: easeOutCurvePoint,
        stroke: "gray",
        "stroke-width": "1",
        fill: "none"
      })))), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "bezier"
      }, /* @__PURE__ */ sapa.createElementJsx("svg", {
        class: "bezier-canvas",
        width: "150",
        height: "150",
        viewBox: "0 0 150 150",
        overflow: "visible"
      }, /* @__PURE__ */ sapa.createElementJsx("path", {
        d: linearCurve,
        stroke: "black",
        "stroke-width": "1",
        fill: "none",
        ref: "$bezierCanvas"
      }), /* @__PURE__ */ sapa.createElementJsx("path", {
        d: linearCurvePoint,
        stroke: "gray",
        "stroke-width": "1",
        fill: "none",
        ref: "$bezierCanvasPoint"
      })), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "control",
        ref: "$control"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "pointer1",
        ref: "$pointer1"
      }), /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "pointer2",
        ref: "$pointer2"
      }))));
    }
    [sapa.BIND("$animationArea")]() {
      return {
        style: {
          display: this.state.isAnimating ? "block" : "none"
        }
      };
    }
    [sapa.BIND("$bezierCanvas")]() {
      return {
        d: curveToPath(this.state.currentBezier, 150, 150)
      };
    }
    [sapa.BIND("$bezierCanvasPoint")]() {
      return {
        d: curveToPointLine(this.state.currentBezier, 150, 150)
      };
    }
    updateData(opt = {}) {
      this.setState(opt);
      this.modifyCubicBezier();
    }
    modifyCubicBezier() {
      this.parent.trigger(this.props.onchange, this.state.key, formatCubicBezier(this.state.currentBezier));
    }
    [sapa.CLICK("$left")]() {
      var { currentBezier, currentBezierIndex } = this.state;
      if (currentBezierIndex == 0) {
        currentBezierIndex = bezierList.length - 1;
      } else {
        --currentBezierIndex;
      }
      var currentBezier = bezierList[currentBezierIndex];
      this.updateData({ currentBezierIndex, currentBezier });
      this.refresh();
    }
    [sapa.CLICK("$right")]() {
      var { currentBezier, currentBezierIndex } = this.state;
      currentBezierIndex = ++currentBezierIndex % bezierList.length;
      currentBezier = bezierList[currentBezierIndex];
      this.updateData({ currentBezierIndex, currentBezier });
      this.refresh();
    }
    [sapa.CLICK("$text")]() {
      var currentBezier = [...bezierList[this.state.currentBezierIndex]];
      this.updateData({ currentBezier });
      this.refresh();
    }
    [sapa.CLICK("$itemList .item")](e) {
      var bezierString = e.$dt.attr("data-bezier");
      this.refs.$itemList.attr("data-selected-value", bezierString);
      var currentBezier = getPredefinedCubicBezier(bezierString);
      this.updateData({
        currentBezier
      });
      this.refresh();
    }
    refresh() {
      this.refreshEasingText();
      this.refreshBezierCanvas();
    }
    refreshBezierCanvas() {
      this.bindData("$bezierCanvas");
      this.bindData("$bezierCanvasPoint");
      this.refreshPointer();
      this.drawPoint();
    }
    refreshEasingText() {
      this.refs.$text.html(this.state.currentBezier[4] || "ease");
    }
    refreshPointer() {
      var currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
      var width2 = 150;
      var height = 150;
      var left = currentBezier[0] * width2;
      var top = (1 - currentBezier[1]) * height;
      this.refs.$pointer1.css({
        left: editor.Length.px(left),
        top: editor.Length.px(top)
      });
      left = currentBezier[2] * width2;
      top = (1 - currentBezier[3]) * height;
      this.refs.$pointer2.css({
        left: editor.Length.px(left),
        top: editor.Length.px(top)
      });
    }
    drawPoint() {
      if (this.state.isAnimating === false)
        return;
      if (this.timer)
        window.clearTimeout(this.timer);
      if (this.animationTimer)
        window.clearTimeout(this.animationTimer);
      this.timer = window.setTimeout(() => {
        this.animationPoint();
      }, 100);
    }
    start(i) {
      var pos = this.animationCanvasData.func(i);
      var x = 10 + (this.animationCanvasData.width - 20) * pos.y;
      var y = 10;
      var context = this.animationCanvasData.context;
      context.beginPath();
      context.arc(x, y, 5, 0, 2 * Math.PI);
      context.fill();
      context.stroke();
      context.closePath();
      if (i >= 1) {
        return;
      }
      this.animationTimer = window.setTimeout(() => {
        this.start(i + 0.05);
      }, 50);
    }
    animationPoint() {
      const currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
      var func = createBezierForPattern(formatCubicBezier(currentBezier));
      this.refs.$animationCanvas.clear();
      var width2 = this.refs.$animationCanvas.width();
      var height = this.refs.$animationCanvas.height();
      var context = this.refs.$animationCanvas.context();
      context.fillStyle = this.state.animatedColor;
      context.strokeStyle = this.state.selectedColor;
      context.lineWidth = 1;
      this.animationCanvasData = {
        func,
        width: width2,
        height,
        context
      };
      this.start(0);
    }
    setPosition(e) {
      var width2 = this.refs.$control.width();
      var height = this.refs.$control.height();
      var minX = this.refs.$control.offset().left;
      var minY = this.refs.$control.offset().top;
      var p = e;
      var x = p.x;
      if (0 > x) {
        x = 0;
      } else if (p.x > document.body.clientWidth) {
        x = document.body.clientWidth;
      }
      x -= minX;
      if (x < 0) {
        x = 0;
      }
      if (width2 < x) {
        x = width2;
      }
      var y = p.y;
      y -= minY;
      return {
        x: div(x, width2),
        y: y == height ? 0 : div(height - y, height)
      };
    }
    [sapa.POINTERSTART("$pointer1") + MOVE("movePointer1") + END("drawPoint")](e) {
      this.clientX = e.clientX;
      this.clientY = e.clientY;
    }
    movePointer1(dx, dy) {
      var pos = this.setPosition({
        x: this.clientX + dx,
        y: this.clientY + dy
      });
      this.state.currentBezier[0] = pos.x;
      this.state.currentBezier[1] = pos.y;
      this.refreshBezierCanvas();
      this.modifyCubicBezier();
    }
    [sapa.POINTERSTART("$pointer2") + MOVE("movePointer2") + END("drawPoint")](e) {
      this.clientX = e.clientX;
      this.clientY = e.clientY;
    }
    movePointer2(dx, dy) {
      var pos = this.setPosition({
        x: this.clientX + dx,
        y: this.clientY + dy
      });
      this.state.currentBezier[2] = pos.x;
      this.state.currentBezier[3] = pos.y;
      this.refreshBezierCanvas();
      this.modifyCubicBezier();
    }
    [sapa.SUBSCRIBE("showCubicBezierEditor")](timingFunction) {
      var currentBezier = getPredefinedCubicBezier(timingFunction || this.state.currentBezier);
      this.setState({ currentBezier });
      this.refresh();
    }
  }
  var DirectionEditor$1 = "";
  const typeList = [
    { key: "top", title: "Top" },
    { key: "right", title: "Right" },
    { key: "bottom", title: "Bottom" },
    { key: "left", title: "Left" }
  ];
  class DirectionEditor extends editor.EditorElement {
    initState() {
      var [count, top, right, bottom, left] = editor.DirectionLength.parse(this.props.value);
      return {
        isAll: count === 1,
        all: top.clone(),
        top: top.clone(),
        right: right.clone(),
        bottom: bottom.clone(),
        left: left.clone()
      };
    }
    template() {
      return `<div class='elf--direction-editor' ref='$body'></div>`;
    }
    [sapa.SUBSCRIBE("changeBorderRadius")](key, value) {
      if (key === "all") {
        typeList.forEach((it) => {
          this.state[it.key] = value.clone();
          this.children[`$${it.key}`].setValue(value.clone());
        });
      }
      this.updateData({
        [key]: value
      });
    }
    [sapa.LOAD("$body")]() {
      var selectedValue = this.state.isAll ? "all" : "partitial";
      var direction = this.state.all;
      var display = selectedValue === "all" ? "display:none" : "display:block";
      return `
      <div class="property-item direction-item">
        <div class="radius-selector" data-selected-value="${selectedValue}" ref="$selector">
          <button type="button" data-value="all">${editor.iconUse("border_all")}</button>
          <button type="button" data-value="partitial">
            ${editor.iconUse("border_inner")}
          </button>
        </div>
        <div class="radius-value">
          ${sapa.createComponent("RangeEditor", {
        ref: "$all",
        key: "all",
        value: direction,
        onchange: "changeBorderRadius"
      })}
        </div>
      </div>
      <div
        class="property-item full direction-item"
        ref="$partitialSetting"
        style="${display}"
      >
        <div class="radius-setting-box">
          ${typeList.map((it) => {
        var value = this.state[it.key];
        return `
              <div>
                  ${sapa.createComponent("RangeEditor", {
          ref: `$${it.key}`,
          label: it.title,
          key: it.key,
          value,
          onchange: "changeBorderRadius"
        })}
              </div>  
            `;
      }).join("")}
        </div>
      </div>
    `;
    }
    updateData(opt = {}) {
      this.setState(opt, false);
      var value = [];
      if (this.state.isAll) {
        value = [
          1,
          this.state.all,
          this.state.all,
          this.state.all,
          this.state.all
        ];
      } else {
        value = [
          4,
          this.state.top,
          this.state.right,
          this.state.bottom,
          this.state.left
        ];
      }
      this.parent.trigger(this.props.onchange, value);
    }
    [sapa.CLICK("$selector button")](e) {
      var type = e.$dt.attr("data-value");
      this.refs.$selector.attr("data-selected-value", type);
      if (type === "all") {
        this.refs.$partitialSetting.hide();
      } else {
        this.refs.$partitialSetting.show("grid");
      }
      this.updateData({
        isAll: type === "all"
      });
    }
  }
  var FilterEditor$1 = "";
  const FILTER_REG = /((blur|grayscale|drop-shadow|hue-rotate|invert|brightness|contrast|opacity|saturate|sepia|url)\(([^)]*)\))/gi;
  class Filter extends PropertyItem {
    getDefaultObject(obj2 = {}) {
      return super.getDefaultObject(__spreadValues({
        itemType: "filter"
      }, obj2));
    }
    toString() {
      return `${this.json.type}(${this.json.value || ""})`;
    }
    static parse(obj2) {
      var FilterClass = FilterClassName[obj2.type];
      if (FilterClass) {
        return new FilterClass(obj2);
      } else {
        return new URLSvgFilter({
          value: obj2.value
        });
      }
    }
    static parseStyle(filter2) {
      var filters = [];
      if (!filter2)
        return filters;
      var results = Color.convertMatches(filter2);
      var matches = results.str.match(FILTER_REG) || [];
      matches.forEach((value, index2) => {
        var [filterName, filterValue] = value.split("(");
        filterValue = filterValue.split(")")[0];
        if (filterName === "drop-shadow") {
          var arr = filterValue.split(" ");
          var colors2 = arr.filter((it) => it.includes("@")).map((it) => {
            return Color.reverseMatches(it, results.matches);
          });
          var values = arr.filter((it) => !it.includes("@"));
          filters[index2] = Filter.parse({
            type: filterName,
            offsetX: editor.Length.parse(values[0]),
            offsetY: editor.Length.parse(values[1]),
            blurRadius: editor.Length.parse(values[2]),
            color: colors2[0] || "rgba(0, 0, 0, 1)"
          });
        } else {
          filters[index2] = Filter.parse({
            type: filterName,
            value: editor.Length.parse(filterValue)
          });
        }
      });
      return filters;
    }
    static join(list) {
      return list.map((it) => Filter.parse(it)).join(" ");
    }
    toJSON() {
      return {
        type: this.json.type,
        value: this.json.value
      };
    }
  }
  class BlurFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "blur",
        value: BlurFilter.spec.defaultValue
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
    }
  }
  BlurFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "px",
    units: ["px", "em"],
    defaultValue: "0px"
  };
  class URLSvgFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "svg",
        value: URLSvgFilter.spec.defaultValue
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
    }
    toString() {
      return `url(#${this.json.value || ""})`;
    }
  }
  URLSvgFilter.spec = {
    inputType: "select",
    defaultValue: ""
  };
  class GrayscaleFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "grayscale",
        value: GrayscaleFilter.spec.defaultValue
      });
    }
    toCloneObject() {
      return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
    }
  }
  GrayscaleFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(0)
  };
  class HueRotateFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "hue-rotate",
        value: HueRotateFilter.spec.defaultValue
      });
    }
  }
  HueRotateFilter.spec = {
    inputType: "range",
    min: 0,
    max: 360,
    step: 1,
    unit: "deg",
    units: ["deg"],
    defaultValue: editor.Length.deg(0)
  };
  class InvertFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "invert",
        value: InvertFilter.spec.defaultValue
      });
    }
  }
  InvertFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(0)
  };
  class BrightnessFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "brightness",
        value: BrightnessFilter.spec.defaultValue
      });
    }
  }
  BrightnessFilter.spec = {
    inputType: "range",
    min: 0,
    max: 200,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(100)
  };
  class ContrastFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "contrast",
        value: ContrastFilter.spec.defaultValue
      });
    }
  }
  ContrastFilter.spec = {
    inputType: "range",
    min: 0,
    max: 200,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(100)
  };
  class OpacityFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "opacity",
        value: OpacityFilter.spec.defaultValue
      });
    }
  }
  OpacityFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(100)
  };
  class SaturateFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "saturate",
        value: SaturateFilter.spec.defaultValue
      });
    }
  }
  SaturateFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(100)
  };
  class SepiaFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "sepia",
        value: SepiaFilter.spec.defaultValue
      });
    }
  }
  SepiaFilter.spec = {
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    unit: "%",
    units: ["%"],
    defaultValue: editor.Length.percent(0)
  };
  class DropshadowFilter extends Filter {
    getDefaultObject() {
      return super.getDefaultObject({
        type: "drop-shadow",
        multi: true,
        offsetX: DropshadowFilter.spec.offsetX.defaultValue,
        offsetY: DropshadowFilter.spec.offsetY.defaultValue,
        blurRadius: DropshadowFilter.spec.blurRadius.defaultValue,
        color: DropshadowFilter.spec.color.defaultValue
      });
    }
    toString() {
      var json = this.json;
      return `drop-shadow(${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.color})`;
    }
    toJSON() {
      return {
        type: this.json.type,
        offsetX: this.json.offsetX,
        offsetY: this.json.offsetY,
        blurRadius: this.json.blurRadius,
        color: this.json.color
      };
    }
  }
  DropshadowFilter.spec = {
    offsetX: {
      title: "Offset X",
      inputType: "range",
      min: -100,
      max: 100,
      step: 1,
      defaultValue: "0px",
      unit: "px",
      units: ["px", "em"]
    },
    offsetY: {
      title: "Offset Y",
      inputType: "range",
      min: -100,
      max: 100,
      step: 1,
      defaultValue: "0px",
      unit: "px",
      units: ["px", "em"]
    },
    blurRadius: {
      title: "Blur Radius",
      inputType: "range",
      min: 0,
      max: 100,
      step: 1,
      defaultValue: "0px",
      unit: "px",
      units: ["px", "em", "%"]
    },
    color: {
      title: "Color",
      inputType: "color",
      defaultValue: "rgba(0, 0, 0, 1)",
      unit: "color"
    }
  };
  const FilterClassName = {
    blur: BlurFilter,
    grayscale: GrayscaleFilter,
    "hue-rotate": HueRotateFilter,
    invert: InvertFilter,
    brightness: BrightnessFilter,
    contrast: ContrastFilter,
    opacity: OpacityFilter,
    saturate: SaturateFilter,
    sepia: SepiaFilter,
    "drop-shadow": DropshadowFilter,
    svg: URLSvgFilter
  };
  const filter_list = [
    "blur",
    "grayscale",
    "hue-rotate",
    "invert",
    "brightness",
    "contrast",
    "drop-shadow",
    "opacity",
    "saturate",
    "sepia",
    "svg"
  ];
  var specList = {
    blur: BlurFilter.spec,
    grayscale: GrayscaleFilter.spec,
    "hue-rotate": HueRotateFilter.spec,
    invert: InvertFilter.spec,
    brightness: BrightnessFilter.spec,
    contrast: ContrastFilter.spec,
    "drop-shadow": DropshadowFilter.spec,
    opacity: OpacityFilter.spec,
    saturate: SaturateFilter.spec,
    sepia: SepiaFilter.spec,
    svg: URLSvgFilter.spec
  };
  class FilterEditor extends editor.EditorElement {
    initState() {
      return {
        hideLabel: this.props.hideLabel === "true" ? true : false,
        filters: this.props.value || []
      };
    }
    template() {
      return `
      <div class='elf--filter-editor filter-list'>
          <div class='filter-list' ref='$filterList'></div>
      </div>`;
    }
    [sapa.LOAD("$filterSelect")]() {
      var list = filter_list.map((it) => {
        return { title: it, value: it };
      });
      var svgFilterList = this.getSVGFilterList();
      var totalList = [];
      if (svgFilterList.length) {
        totalList = [...list, { title: "-------", value: "" }, ...svgFilterList];
      } else {
        totalList = [...list];
      }
      return totalList.map((it) => {
        var { title, value } = it;
        return `<option value='${value}'>${title}</option>`;
      });
    }
    getSpec(filterType) {
      return specList[filterType];
    }
    makeDropShadowFilterTemplate(spec, filter2, index2) {
      return `
      <div class="filter-item">
        <div class="title drop-shadow">
          <label draggable="true"  data-index="${index2}">${editor.iconUse("drag_indicator")}</label>
          <span class='sub-title'>${this.$i18n("filter.property.drop-shadow")}</span>
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">${editor.iconUse("remove2")}</button>
          </div>
        </div>
        <div class="filter-ui-list">
          ${sapa.createComponentList([
        "ColorViewEditor",
        {
          ref: `$dropShadowColorView${index2}`,
          params: index2,
          compact: true,
          value: filter2.color,
          onchange: "changeDropShadowColor"
        }
      ], ...["offsetX", "offsetY", "blurRadius"].map((key) => {
        return [
          "InputRangeEditor",
          {
            ref: `$${key}${index2}`,
            label: this.$i18n(`filter.property.drop-shadow.${key}`),
            key: index2,
            min: spec[key].min,
            max: spec[key].max,
            step: spec[key].step,
            params: key,
            value: filter2[key].value || spec[key].defaultValue,
            units: spec[key].units,
            onchange: "changeRangeEditor"
          }
        ];
      }))}
        </div>

      </div>
    `;
    }
    getSVGFilterList() {
      var current = this.$context.selection.current;
      var arr = [];
      if (current) {
        arr = current.svgfilters.map((it) => {
          return {
            title: `svg - #${it.id}`,
            value: it.id
          };
        });
      }
      return arr;
    }
    makeOneFilterEditor(index2, filter2, spec) {
      if (filter2.type === "svg") {
        var options2 = "";
        var current = this.$context.selection.current;
        if (current) {
          options2 = current.svgfilters.map((it) => {
            return { value: it.id };
          });
        }
        return sapa.createComponent("SelectEditor", {
          ref: `$select${index2}`,
          key: index2,
          label: "SVG Filter",
          value: filter2.value,
          options: ["", ...options2],
          onchange: "changeRangeEditor"
        });
      }
      return sapa.createComponent("InputRangeEditor", {
        ref: `$range${index2}_${filter2.type}`,
        label: this.$i18n("filter.property." + filter2.type),
        key: index2,
        min: spec.min,
        max: spec.max,
        value: filter2.value,
        units: spec.units,
        onchange: "changeRangeEditor"
      });
    }
    makeOneFilterTemplate(spec, filter2, index2) {
      return `
      <div class="filter-item" data-index="${index2}">
        <div class="title" >
          <label draggable="true" data-index="${index2}">${editor.iconUse("drag_indicator")}</label>
          ${filter2.type != "svg" ? `
          <div class="filter-ui">
            ${this.makeOneFilterEditor(index2, filter2, spec)}
          </div>
        ` : `
          <div>
            <span class='svg-filter-edit' data-index="${index2}">${filter2.value}</span>
          </div>
        `}          
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">
              ${editor.iconUse("remove2")}
            </button>
          </div>
        </div>
      </div>
    `;
    }
    makeFilterTemplate(filter2, index2) {
      if (filter2.type === "drop-shadow") {
        return this.makeDropShadowFilterTemplate(this.getSpec(filter2.type), filter2, index2);
      } else {
        return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2, index2);
      }
    }
    [sapa.LOAD("$filterList")]() {
      return this.state.filters.map((filter2, index2) => {
        return this.makeFilterTemplate(filter2, index2.toString());
      });
    }
    [sapa.DRAGSTART("$filterList .filter-item > .title > label")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$filterList .filter-item > .title > label") + sapa.PREVENT]() {
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortFilter(startIndex, targetIndex) {
      this.sortItem(this.state.filters, startIndex, targetIndex);
    }
    [sapa.DROP("$filterList .filter-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      var current = this.$context.selection.current;
      if (!current)
        return;
      this.sortFilter(this.startIndex, targetIndex);
      this.refresh();
      this.modifyFilter();
    }
    modifyFilter() {
      var value = this.state.filters;
      this.parent.trigger(this.props.onchange, this.props.key, value, this.props.params);
    }
    makeFilter(type, opt = {}) {
      return Filter.parse(__spreadProps(__spreadValues({}, opt), { type }));
    }
    [sapa.CLICK("$filterList .svg-filter-edit")](e) {
      var _a, _b;
      var index2 = +e.$dt.attr("data-index");
      var filter2 = this.state.filters[index2];
      var current = this.$context.selection.current;
      if (current) {
        var svgfilterIndex = current.getSVGFilterIndex((_b = (_a = filter2.value) == null ? void 0 : _a.value) == null ? void 0 : _b.replace("#", ""));
        this.trigger("openSVGFilterPopup", svgfilterIndex);
      }
    }
    [sapa.SUBSCRIBE("openSVGFilterPopup")](index2) {
      const current = this.$context.selection.current || { svgfilters: [] };
      const svgfilter = current.svgfilters[index2];
      this.emit("showSVGFilterPopup", {
        changeEvent: (params) => {
          var current2 = this.$context.selection.current;
          if (current2) {
            current2.setSVGFilterValue(params.index, {
              filters: params.filters
            });
            this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.pack("svgfilters", "filter"));
          }
        },
        index: index2,
        preview: false,
        filters: svgfilter.filters
      });
    }
    [sapa.SUBSCRIBE_SELF("add")](filterType) {
      if (filterType === "svg") {
        const index2 = this.$context.selection.current.createSVGFilter({
          filters: []
        });
        const filter2 = this.$context.selection.current.svgfilters[index2];
        this.state.filters.push(this.makeFilter(filterType, {
          value: filter2.id
        }));
        this.refresh();
        this.modifyFilter();
        this.trigger("openSVGFilterPopup", index2);
      } else {
        this.state.filters.push(this.makeFilter(filterType));
        this.refresh();
        this.modifyFilter();
      }
    }
    [sapa.CLICK("$add")]() {
      var filterType = this.refs.$filterSelect.value;
      this.trigger("add", filterType);
    }
    [sapa.CLICK("$filterList .filter-menu .del")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.filters.splice(index2, 1);
      this.refresh();
      this.modifyFilter();
    }
    [sapa.SUBSCRIBE_SELF("changeDropShadowColor")](key, color, params) {
      var index2 = +params;
      this.state.filters[index2].color = color;
      this.modifyFilter();
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
      if (params) {
        this.state.filters[+key][params] = value;
      } else {
        this.state.filters[+key].value = value;
      }
      this.modifyFilter();
    }
  }
  const font_list = [
    "",
    "Arial",
    "Arial Black",
    "Times New Roman",
    "Times",
    "Courier New",
    "Courier",
    "Verdana",
    "Georgia",
    "Palatino",
    "Garamond",
    "Bookman",
    "Tahoma",
    "Trebuchet MS",
    "Impact",
    "Comic Sans MS",
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  class FontSelectEditor extends editor.SelectEditor {
    getFontList() {
      return font_list.map((it) => {
        return { value: it };
      });
    }
    initState() {
      return __spreadProps(__spreadValues({}, super.initState()), {
        options: this.getFontList()
      });
    }
  }
  var GradientEditor$1 = "";
  class GradientEditor extends editor.EditorElement {
    initState() {
      var _a;
      const image2 = BackgroundImage.parseImage(this.props.value || "static-gradient(#ececec)");
      const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
      this.$context.selection.selectColorStep(id);
      if (id) {
        this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      }
      return {
        id,
        index: +(this.props.index || 0),
        value: this.props.value,
        image: image2
      };
    }
    setValue(value) {
      this.setState({
        image: BackgroundImage.parseImage(value)
      }, false);
      this.refresh();
    }
    template() {
      return `
        <div class='elf--gradient-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>
        </div>
      `;
    }
    [sapa.CHANGE("$file")](e) {
      var project2 = this.$context.selection.currentProject;
      if (project2) {
        [...e.target.files].forEach((item) => {
          this.$commands.emit("updateImageAssetItem", item, (local) => {
            this.trigger("setImageUrl", local);
          });
        });
      }
    }
    [sapa.SUBSCRIBE_SELF("changeTabType")](type) {
      var _a, _b;
      const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
      const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
      if (oldType === GradientType.STATIC) {
        if (colorsteps.length === 0) {
          colorsteps.push(colorsteps[0], colorsteps[0]);
        } else if (colorsteps.length === 1) {
          colorsteps.push(colorsteps[0], colorsteps[0]);
        }
      }
      var url = type === "image-resource" ? this.state.image.url : this.state.url;
      this.state.image = BackgroundImage.changeImageType({
        type,
        url,
        colorsteps,
        angle: this.state.image.angle || 0,
        radialType: this.state.image.radialType || RadialGradientType.CIRCLE,
        radialPosition: this.state.image.radialPosition || ["50%", "50%"]
      });
      this.refresh();
      this.updateData();
    }
    [sapa.SUBSCRIBE_SELF("changeColorStepOffset")](key, value) {
      if (this.currentStep) {
        this.currentStep.percent = value.value;
        this.state.image.sortColorStep();
        this.refresh();
        this.updateData();
      }
    }
    [sapa.CLICK("$back")](e) {
      var rect2 = this.refs.$stepList.rect();
      var minX = rect2.x;
      var maxX = rect2.right;
      var x = e.xy.x;
      if (x < minX)
        x = minX;
      else if (x > maxX)
        x = maxX;
      var percent = (x - minX) / rect2.width * 100;
      this.state.image.insertColorStep(percent);
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
    [sapa.BIND("$el")]() {
      var type = this.state.image.type;
      if (type === "url") {
        type = "image-resource";
      }
      return {
        "data-selected-editor": type
      };
    }
    [sapa.BIND("$stepList")]() {
      return {
        style: {
          "background-image": this.getLinearGradient()
        }
      };
    }
    [sapa.LOAD("$stepList") + sapa.DOMDIFF]() {
      var _a;
      var colorsteps = ((_a = this.state.image) == null ? void 0 : _a.colorsteps) || [];
      return colorsteps.map((it) => {
        var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
        return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>      
        <div class='arrow'></div>      
      </div>`;
      });
    }
    removeStep(id) {
      this.state.image.removeColorStep(id);
      this.refresh();
      this.updateData();
    }
    selectStep(id) {
      this.state.id = id;
      this.$context.selection.selectColorStep(id);
      if (this.state.image.colorsteps) {
        this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
        this.parent.trigger("selectColorStep", this.currentStep.color);
      }
      this.refresh();
    }
    [sapa.KEYUP("$el .step")](e) {
      const id = e.$dt.data("id");
      switch (e.code) {
        case "Delete":
        case "Backspace":
          this.removeStep(id);
          break;
        case "BracketRight":
          this.sortToRight(id);
          break;
        case "BracketLeft":
          this.sortToLeft(id);
          break;
        case "Equal":
          this.appendColorStep(id);
          break;
        case "Minus":
          this.prependColorStep(id);
          break;
      }
    }
    sortToRight(id) {
      this.state.image.sortToRight();
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    sortToLeft(id) {
      this.state.image.sortToLeft();
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    appendColorStep(id) {
      const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
      const nextIndex = currentIndex + 1;
      const currentColorStep = this.state.image.colorsteps[currentIndex];
      const nextColorStep = this.state.image.colorsteps[nextIndex];
      if (!nextColorStep) {
        if (currentColorStep.percent !== 100) {
          this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
        }
      } else {
        this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
      }
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    doFocus(id) {
      this.nextTick(() => {
        this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
      }, 100);
    }
    prependColorStep(id) {
      const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
      const prevIndex = currentIndex - 1;
      const currentColorStep = this.state.image.colorsteps[currentIndex];
      const prevColorStep = this.state.image.colorsteps[prevIndex];
      if (!prevColorStep) {
        if (currentColorStep.percent !== 0) {
          this.state.image.insertColorStep(currentColorStep.percent);
        }
      } else {
        this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
      }
      this.refresh();
      this.updateData();
      this.doFocus(id);
    }
    [sapa.POINTERSTART("$stepList .step") + MOVE() + END()](e) {
      var id = e.$dt.attr("data-id");
      if (e.altKey) {
        this.removeStep(id);
        return false;
      } else {
        e.$dt.focus();
        this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
        this.selectStep(id);
        this.startXY = e.xy;
        this.cachedStepListRect = this.refs.$stepList.rect();
      }
    }
    getStepListRect() {
      return this.cachedStepListRect;
    }
    move(dx) {
      var rect2 = this.getStepListRect();
      var minX = rect2.x;
      var maxX = rect2.right;
      var x = this.startXY.x + dx;
      if (x < minX)
        x = minX;
      else if (x > maxX)
        x = maxX;
      var percent = (x - minX) / rect2.width * 100;
      if (this.$config.get("bodyEvent").shiftKey) {
        percent = Math.floor(percent);
      }
      this.currentStep.setValue(percent, rect2.width);
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
    end(dx, dy) {
      if (dx === 0 && dy === 0) {
        if (this.isSelectedColorStep) {
          if (this.currentStep) {
            this.currentStep.cut = !this.currentStep.cut;
            this.refresh();
            this.updateData();
          }
        }
      }
      this.doFocus(this.state.id);
    }
    getLinearGradient() {
      var { image: image2 } = this.state;
      return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
    }
    [sapa.SUBSCRIBE_SELF("setColorStepColor")](color) {
      if (this.state.image.type === "static-gradient") {
        this.state.image.colorsteps[0].color = color;
        this.refresh();
        this.updateData();
      } else {
        if (this.currentStep) {
          this.currentStep.color = color;
          this.refresh();
          this.updateData();
        }
      }
    }
    [sapa.SUBSCRIBE("setImageUrl")](url) {
      if (this.state.image) {
        this.state.url = url;
        this.state.image.reset({ url });
        this.refresh();
        this.updateData();
      }
    }
    updateData(data = {}) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.state.image.toString());
    }
  }
  var IconListViewEditor$1 = "";
  class IconListViewEditor extends editor.EditorElement {
    initState() {
      return {
        value: this.props.value
      };
    }
    template() {
      return `<div class='select-editor elf--list-view-editor' ref='$body'></div>`;
    }
    [sapa.BIND("$body")]() {
      return {
        "data-column": this.props.column || 1
      };
    }
    [sapa.LOAD("$body")]() {
      return Object.keys(icon).map((key) => {
        var html = editor.iconUse(key);
        var selected = key === this.state.value ? "selected" : "";
        return `<div class='list-view-item ${selected}'  data-key='${key}'>${html}</div>`;
      });
    }
    getValue() {
      return this.state.value;
    }
    setValue(value) {
      this.state.value = value;
      this.refresh();
    }
    [sapa.CLICK("$body .list-view-item")](e) {
      var key = e.$dt.attr("data-key");
      e.$dt.onlyOneClass("selected");
      this.updateData({
        value: key
      });
    }
    updateData(data) {
      this.setState(data, false);
      this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
    }
  }
  class IterationCountEditor extends editor.InputRangeEditor {
    initState() {
      var value = this.props.value;
      if (value === "infinite") {
        value = new editor.Length(0, "infinite");
      } else {
        value = editor.Length.number(value);
      }
      var units = this.props.units || ["px", "em", "%"];
      return __spreadValues(__spreadValues({}, super.initState()), {
        key: this.props.key,
        params: this.props.params || "",
        units,
        value
      });
    }
  }
  var MediaProgressEditor$1 = "";
  class MediaProgressEditor extends editor.EditorElement {
    initState() {
      const [start, end, duration] = (this.props.value || "").split(":");
      return {
        start: +(start || 0),
        end: +(end || 1),
        duration: +(duration || 1)
      };
    }
    refresh() {
      this.load();
      this.children.$s.setValue(this.state.start * this.state.duration);
      this.children.$e.setValue(this.state.end * this.state.duration);
      this.children.$s.setMax(this.state.duration);
      this.children.$e.setMax(this.state.duration);
    }
    template() {
      const { start, end, duration } = this.state;
      return `
            <div class='elf--media-progress-editor'>
                <div class='drag-area'>
                    <div class='progress-bar' ref='$progress'></div>
                    <div class='bar' ref='$bar'></div>                
                    <div class='drag-item start' ref='$start'></div>
                    <div class='drag-item end' ref='$end'></div>
                </div>
                <div class='item'>
                    ${sapa.createComponent("NumberRangeEditor", {
        ref: "$s",
        label: "Start",
        key: "start",
        min: 0,
        max: duration,
        step: 1e-3,
        value: start * duration,
        onchange: "changeValue"
      })}
                </div>
                <div class='item'>
                    ${sapa.createComponent("NumberRangeEditor", {
        ref: "$e",
        label: "End",
        key: "end",
        min: 0,
        max: duration,
        step: 1e-3,
        value: end * duration,
        onchange: "changeValue"
      })}
                </div>                
            </div>
        `;
    }
    [sapa.SUBSCRIBE_SELF("changeValue")](key, value) {
      this.updateData({
        [key]: value / this.state.duration
      }, true);
    }
    [sapa.POINTERSTART("$start") + MOVE("moveStart")]() {
      this.rect = this.refs.$progress.rect();
      this.pos = editor.Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
      this.max = editor.Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
    }
    moveStart(dx) {
      var realPos = Math.min(this.max.value, Math.max(0, this.pos.value + dx));
      this.state.start = realPos / this.rect.width;
      this.children.$s.setValue(this.state.start * this.state.duration);
      this.refresh();
      this.updateData();
    }
    [sapa.BIND("$start")]() {
      return {
        "data-info": this.state.start,
        style: {
          left: editor.Length.percent((this.state.start || 0) * 100)
        }
      };
    }
    [sapa.POINTERSTART("$end") + MOVE("moveStartForEnd")]() {
      this.rect = this.refs.$progress.rect();
      this.pos = editor.Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
      this.min = editor.Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
      this.max = this.rect.width;
    }
    moveStartForEnd(dx) {
      var realPos = Math.max(this.min.value, Math.min(this.max.value, this.pos.value + dx));
      this.state.end = realPos / this.rect.width;
      this.children.$e.setValue(this.state.end * this.state.duration);
      this.refresh();
      this.updateData();
    }
    [sapa.BIND("$end")]() {
      return {
        "data-info": this.state.end,
        style: {
          left: editor.Length.percent((this.state.end || 1) * 100)
        }
      };
    }
    [sapa.BIND("$bar")]() {
      const start = this.state.start || 0;
      const end = this.state.end || 1;
      return {
        style: {
          left: editor.Length.percent(start * 100),
          width: editor.Length.percent((end - start) * 100)
        }
      };
    }
    getValue() {
      const { start, end, duration } = this.state;
      return `${start}:${end}:${duration}`;
    }
    setValue(value) {
      const [start, end, duration] = value.split(":");
      this.setState({
        start: Number(start),
        end: Number(end),
        duration: Number(duration)
      });
    }
    updateData(data = {}, isRefresh = false) {
      this.setState(data, isRefresh);
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
  }
  var PathEditor$1 = "";
  const SEGMENT_DIRECTION = ["startPoint", "endPoint", "reversePoint"];
  function calculateSnapPoint(points, sourceKey, target, distanceValue, dist2) {
    var checkedPointList = points.filter((p) => {
      if (!p)
        return false;
      return Math.abs(p[sourceKey] - target) <= dist2;
    }).map((p) => {
      return { dist: Math.abs(p[sourceKey] - target), point: p };
    });
    checkedPointList.sort((a, b) => {
      return a.dist < b.dist ? -1 : 1;
    });
    var point2 = null;
    if (checkedPointList.length) {
      point2 = checkedPointList[0].point;
      distanceValue += point2[sourceKey] - target;
    }
    return { point: point2, distanceValue };
  }
  function calculateMovePointSnap(points, moveXY, dist2) {
    var snapPointX = calculatePointDist(points, "x", moveXY.x, dist2);
    var snapPointY = calculatePointDist(points, "y", moveXY.y, dist2);
    var snapEndPoint = __spreadValues({}, moveXY);
    if (snapPointX) {
      snapEndPoint.x = snapPointX.x;
    }
    if (snapPointY) {
      snapEndPoint.y = snapPointY.y;
    }
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { snapPointList, moveXY: snapEndPoint };
  }
  function calculatePointDist(points, sourceKey, target, dist2) {
    var checkedPointList = [];
    var arr = SEGMENT_DIRECTION;
    points.filter((p) => p).forEach((p) => {
      arr.filter((key) => p[key]).forEach((key) => {
        var point2 = p[key];
        var tempDist = Math.abs(point2[sourceKey] - target);
        if (tempDist <= dist2) {
          checkedPointList.push({ dist: tempDist, point: point2 });
        }
      });
    });
    checkedPointList.sort((a, b) => {
      return a.dist > b.dist ? 1 : -1;
    });
    return checkedPointList.length ? checkedPointList[0].point : null;
  }
  function toPath(points, minX, minY, scale2 = 1) {
    var d = [];
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      if (current.command === "M") {
        d.push({ command: "M", values: [current.startPoint] });
      } else {
        var prevPoint = Point.getPrevPoint(points, index2);
        if (current.curve === false) {
          if (prevPoint.curve === false) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [prevPoint.endPoint, current.startPoint]
            });
          }
        } else {
          if (prevPoint.curve === false) {
            if (Point.isEqual(current.reversePoint, current.startPoint)) {
              d.push({ command: "L", values: [current.startPoint] });
            } else {
              d.push({
                command: "Q",
                values: [current.reversePoint, current.startPoint]
              });
            }
          } else {
            d.push({
              command: "C",
              values: [
                prevPoint.endPoint,
                current.reversePoint,
                current.startPoint
              ]
            });
          }
        }
      }
      if (current.close) {
        d.push({ command: "Z" });
      }
    }
    var dString = d.map((segment) => {
      return calculateRelativePosition(minX, minY, segment, scale2);
    }).join(" ");
    return {
      d: dString
    };
  }
  function calculateRelativePosition(minX, minY, segment, scale2 = 1) {
    var { command, values } = segment;
    switch (command) {
      case "Z":
        return "Z";
      default:
        var str = values.map((v) => {
          var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
          var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
          return `${tx} ${ty}`;
        }).join(" ");
        return `${command} ${str}`;
    }
  }
  function checkInArea(area2, point2) {
    if (area2.x2.value < point2.x) {
      return false;
    }
    if (area2.y2.value < point2.y) {
      return false;
    }
    if (area2.x.value > point2.x) {
      return false;
    }
    if (area2.y.value > point2.y) {
      return false;
    }
    return true;
  }
  class PurePathGenerator {
    generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
      return toPath(points, minX, minY, scale2).d;
    }
    constructor(pathEditor) {
      this.pathEditor = pathEditor;
      this.pathStringManager = new PathStringManager();
      this.guideLineManager = new PathStringManager();
      this.segmentManager = new SegmentManager(null);
      this.points = [];
      this.cachedSegmentKeys = {};
      this.initialize();
      this.initializeSelect();
    }
    initialize() {
      this.splitLines = [];
      this.guideLineManager.reset();
      this.segmentManager.reset();
      this.pathStringManager.reset();
    }
    initializeSelect(initPointList = []) {
      this.selectedPointKeys = {};
      this.selectedPointList = [];
      if (initPointList.length) {
        this.select(...initPointList.map((p) => {
          const checkedPoint = this.points[p.index][p.key];
          if (!checkedPoint)
            return void 0;
          return {
            x: checkedPoint.x,
            y: checkedPoint.y,
            key: p.key,
            index: checkedPoint.index
          };
        }).filter(Boolean));
      }
    }
    get state() {
      return this.pathEditor.state;
    }
    get clonePoints() {
      return [...this.points];
    }
    get length() {
      return this.points.length;
    }
    setPoints(points = []) {
      this.points = points;
      this.snapPointList = [];
      if (this.points.length === 0) {
        this.select();
        this.selectGroup(-1);
      }
    }
    selectInBox(box, isToggle = false) {
      var list = [];
      this.points.forEach((point2, index2) => {
        SEGMENT_DIRECTION.forEach((key) => {
          const p = point2[key];
          if (checkInArea(box, p)) {
            list.push({ x: p.x, y: p.y, key, index: index2 });
          }
        });
      });
      if (isToggle) {
        list = list.map((it) => {
          const selectedKey = this.makeSegmentKey(it);
          return __spreadProps(__spreadValues({}, it), {
            included: Boolean(this.selectedPointKeys[selectedKey])
          });
        });
        const includedList = list.filter((it) => it.included);
        const notIncludedList = list.filter((it) => !it.included);
        let uniqueList = [...this.selectedPointList];
        if (includedList.length) {
          uniqueList = this.selectedPointList.filter((it) => {
            const oldKey = this.makeSegmentKey(it);
            return Boolean(includedList.find((includeNode) => {
              return oldKey === this.makeSegmentKey(includeNode);
            })) === false;
          });
        }
        this.select(...uniqueList, ...notIncludedList);
      } else {
        this.select(...list);
      }
    }
    makeSegmentKey(p) {
      return `${p.key}_${p.index}`;
    }
    select(...list) {
      this.selectedPointKeys = {};
      this.selectedPointList = list.map(({ x, y, key, index: index2 }) => ({
        x,
        y,
        key,
        index: +index2
      }));
      list.forEach((it) => {
        var key = this.makeSegmentKey(it);
        this.selectedPointKeys[key] = true;
      });
    }
    convertPointsToSelectionList(points) {
      var list = [];
      points.forEach((point2) => {
        SEGMENT_DIRECTION.forEach((key) => {
          const { x, y } = point2[key];
          list.push({ x, y, key, index: point2.index });
        });
      });
      return list;
    }
    selectGroup(groupIndex) {
      const group = this.splitedGroupList[groupIndex];
      if (group) {
        this.select(...this.convertPointsToSelectionList(group.points));
      } else {
        this.select();
      }
    }
    getCacheSegmentKey(segmentKey, index2) {
      if (!this.cachedSegmentKeys[segmentKey]) {
        this.cachedSegmentKeys[segmentKey] = {};
      }
      if (!this.cachedSegmentKeys[segmentKey][index2]) {
        this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
          key: segmentKey,
          index: index2
        });
      }
      return this.cachedSegmentKeys[segmentKey][index2];
    }
    toggleSelect(key, index2) {
      if (this.points[index2]) {
        var point2 = this.points[index2][key];
        if (point2 && !this.isSelectedSegment(key, index2)) {
          this.select(...this.selectedPointList, {
            x: point2.x,
            y: point2.y,
            key,
            index: index2
          });
        } else {
          this.select(...this.selectedPointList.filter((it) => {
            return it.key !== key || it.index !== index2;
          }));
        }
      }
    }
    selectKeyIndex(key, index2) {
      if (this.points[index2]) {
        var point2 = this.points[index2][key];
        if (point2 && !this.isSelectedSegment(key, index2)) {
          this.select({ x: point2.x, y: point2.y, key, index: index2 });
        }
      }
    }
    reselect() {
      this.selectedPointList.filter(Boolean).forEach((it) => {
        var _a;
        var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
        if (point2) {
          it.x = point2.x;
          it.y = point2.y;
        }
      });
    }
    isSelectedSegment(segment, index2) {
      var key = this.getCacheSegmentKey(segment, index2);
      return this.selectedPointKeys[key];
    }
    commitTransformMatrix(point2, transformMatrix) {
      var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
      return { x: result[0], y: result[1] };
    }
    transformMat4(transformMatrix) {
      this.transformPoints.forEach((p, index2) => {
        var realPoint = this.points[index2];
        Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
        Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
        Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
      });
    }
    transform(type) {
      var { x, y, width: width2, height } = this.transformRect;
      var view = create$4();
      translate(view, view, [x, y, 0]);
      switch (type) {
        case "flipX":
          scale(view, view, [-1, 1, 1]);
          translate(view, view, [-width2, 0, 0]);
          break;
        case "flipY":
          scale(view, view, [1, -1, 1]);
          translate(view, view, [0, -height, 0]);
          break;
        case "flip":
          scale(view, view, [-1, -1, 1]);
          translate(view, view, [-width2, -height, 0]);
          break;
      }
      translate(view, view, [-x, -y, 0]);
      this.transformMat4(view);
    }
    initTransform(rect2) {
      this.transformRect = sapa.clone(rect2);
      this.transformPoints = this.clonePoints.map((p) => {
        return {
          startPoint: sapa.clone(p.startPoint),
          endPoint: sapa.clone(p.endPoint),
          reversePoint: sapa.clone(p.reversePoint)
        };
      });
    }
    setConnectedPoint(dx, dy) {
      var state = this.state;
      var x = state.dragXY.x + dx;
      var y = state.dragXY.y + dy;
      var endPoint = { x, y };
      var reversePoint = { x, y };
      if (state.dragPoints) {
        state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
      }
      var point2 = {
        startPoint: state.startPoint,
        endPoint,
        curve: !!state.dragPoints,
        reversePoint,
        connected: true,
        close: true
      };
      this.points.push(point2);
    }
    setLastPoint(startPoint) {
      var endPoint = sapa.clone(startPoint);
      var reversePoint = sapa.clone(startPoint);
      var point2 = {
        startPoint,
        endPoint,
        curve: false,
        reversePoint,
        connected: false,
        close: false
      };
      this.points.push(point2);
    }
    getPrevPoint(index2) {
      return Point.getPrevPoint(this.points, index2);
    }
    getIndexPoint(index2) {
      return Point.getIndexPoint(this.points, index2);
    }
    getNextPoint(index2) {
      return Point.getNextPoint(this.points, index2);
    }
    getConnectedPointList(index2) {
      return Point.getConnectedPointList(this.points, index2);
    }
    isFirst(segment) {
      return Point.isFirst(segment);
    }
    getLastPoint(index2) {
      return Point.getLastPoint(this.points, index2);
    }
    setCachePoint(index2, segmentKey) {
      var state = this.state;
      this.snapPointList = [];
      this.selectedIndex = index2;
      state.connectedPoint = this.getPrevPoint(index2);
      state.connectedPointList = sapa.clone(Point.getConnectedPointList(this.points, this.selectedIndex));
      if (state.connectedPoint && !state.connectedPoint.connected) {
        state.connectedPoint = null;
      }
      state.segment = this.getIndexPoint(index2);
      if (state.segment.connected) {
        state.connectedPoint = this.getNextPoint(index2);
      }
      var isFirstSegment = this.isFirst(state.segment);
      if (isFirstSegment) {
        var lastPoint = this.getLastPoint(index2);
        if (lastPoint.connected) {
          state.connectedPoint = lastPoint;
        }
      }
      state.segmentKey = segmentKey;
      state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
      state.originalSegment = sapa.clone(state.segment);
      if (state.connectedPoint) {
        state.originalConnectedPoint = sapa.clone(state.connectedPoint);
      }
      state.cachedPoints = [];
      this.points.filter((p) => p && p != state.segment).forEach((p) => {
        state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
      });
    }
    clamp(value, min, max) {
      if (sapa.isUndefined(min) || sapa.isUndefined(max)) {
        return value;
      }
      return Math.max(min, Math.min(max, value));
    }
    moveSegment(segmentKey, dx, dy, originSegment = void 0, maxWidth = void 0, maxHeight = void 0) {
      if (originSegment) {
        const segment = this.points[originSegment.index][segmentKey];
        segment.x = this.clamp(originSegment[segmentKey].x + dx, 0, maxWidth);
        segment.y = this.clamp(originSegment[segmentKey].y + dy, 0, maxHeight);
      } else {
        var state = this.state;
        var originPoint = state.originalSegment[segmentKey];
        var targetPoint = state.segment[segmentKey];
        if (originPoint) {
          targetPoint.x = this.clamp(originPoint.x + dx, 0, maxWidth);
          targetPoint.y = this.clamp(originPoint.y + dy, 0, maxHeight);
        }
      }
    }
    calculateToCurve(point2, nextPoint, prevPoint) {
      var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
      var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
      var dx = (nextPoint.startPoint.x - centerX) / 2;
      var dy = (nextPoint.startPoint.y - centerY) / 2;
      point2.endPoint = {
        x: point2.startPoint.x + dx,
        y: point2.startPoint.y + dy
      };
      point2.reversePoint = {
        x: point2.startPoint.x - dx,
        y: point2.startPoint.y - dy
      };
      return { dx, dy };
    }
    convertToCurve(index2) {
      var point2 = this.points[index2];
      if (point2.curve) {
        point2.curve = false;
        point2.reversePoint = sapa.clone(point2.startPoint);
        point2.endPoint = sapa.clone(point2.startPoint);
        if (point2.command === "M") {
          var lastPoint = Point.getPrevPoint(this.points, point2.index);
          if (lastPoint.connected) {
            lastPoint.curve = false;
            lastPoint.reversePoint = sapa.clone(lastPoint.startPoint);
            lastPoint.endPoint = sapa.clone(lastPoint.startPoint);
          }
        } else {
          var nextPoint = this.getNextPoint(index2);
          if (nextPoint && nextPoint.command === "M") {
            var firstPoint = nextPoint;
            firstPoint.curve = false;
            firstPoint.reversePoint = sapa.clone(firstPoint.startPoint);
            firstPoint.endPoint = sapa.clone(firstPoint.startPoint);
          }
        }
      } else {
        point2.curve = true;
        var prevPoint = this.getPrevPoint(index2);
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          nextPoint = this.getNextPoint(firstPoint.index);
          this.calculateToCurve(point2, nextPoint, prevPoint);
          firstPoint.curve = true;
          firstPoint.endPoint = sapa.clone(point2.endPoint);
          firstPoint.reversePoint = sapa.clone(point2.reversePoint);
        } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
          this.calculateToCurve(point2, nextPoint, prevPoint);
        } else if (!nextPoint && prevPoint) {
          var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
          var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
          point2.endPoint = {
            x: point2.startPoint.x + centerX,
            y: point2.startPoint.y + centerY
          };
          point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
        } else if (!prevPoint && nextPoint) {
          var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
          var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
          point2.endPoint = {
            x: point2.startPoint.x + centerX,
            y: point2.startPoint.y + centerY
          };
          point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
        }
      }
    }
    moveCurveSegment(segmentKey, dx, dy) {
      var state = this.state;
      this.moveSegment(segmentKey, dx, dy);
      var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
      state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
    }
    rotateSegmentTarget(segmentKey, target) {
      var state = this.state;
      if (state.originalSegment && state.segment) {
        var { x: cx, y: cy } = state.originalSegment.startPoint;
        var { x: rx, y: ry } = state.segment[segmentKey];
        var { x: tx, y: ty } = state.originalSegment[target];
        var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
        state.segment[target] = { x, y };
      }
    }
    rotateSegment(segmentKey) {
      this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
    }
    calculateSnap(segmentKey, dx, dy, dist2 = 1) {
      var state = this.state;
      var cachedPoints = state.cachedPoints;
      var original = state.originalSegment[segmentKey];
      if (!segmentKey) {
        return { dx, dy, snapPointList: [] };
      }
      var realX = original.x + dx;
      var realY = original.y + dy;
      var { point: snapPointX, distanceValue: dx } = calculateSnapPoint(cachedPoints, "x", realX, dx, dist2);
      var { point: snapPointY, distanceValue: dy } = calculateSnapPoint(cachedPoints, "y", realY, dy, dist2);
      var snapEndPoint = {
        x: original.x + dx,
        y: original.y + dy
      };
      var snapPointList = [];
      if (snapPointX) {
        snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
      }
      if (snapPointY) {
        snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
      }
      return { dx, dy, snapPointList };
    }
    copySegment(from, to) {
      to.startPoint = sapa.clone(from.startPoint);
      to.endPoint = sapa.clone(from.endPoint);
      to.reversePoint = sapa.clone(from.reversePoint);
    }
    get selectedLength() {
      return this.selectedPointList.length;
    }
    moveSelectedSegment(dx, dy) {
      if (this.selectedPointList.length > 0) {
        this.selectedPointList.forEach((it) => {
          var target = this.points[it.index][it.key];
          target.x = it.x + dx;
          target.y = it.y + dy;
        });
      } else if (this.selectedGroup) {
        this.moveSelectedGroup(dx, dy);
      }
    }
    moveSelectedGroup(dx, dy, maxWidth, maxHeight) {
      this.selectedGroup.points.forEach((it) => {
        const target = this.points[it.index];
        target.startPoint.x = this.clamp(it.startPoint.x + dx, 0, maxWidth);
        target.startPoint.y = this.clamp(it.startPoint.y + dy, 0, maxHeight);
        target.endPoint.x = it.endPoint.x + dx;
        target.endPoint.y = it.endPoint.y + dy;
        target.reversePoint.x = it.reversePoint.x + dx;
        target.reversePoint.y = it.reversePoint.y + dy;
      });
    }
    get selectedGroup() {
      return this.splitedGroupList[this.state.selectedGroupIndex];
    }
    get splitedGroupList() {
      return Point.getSplitedGroupList(this.points);
    }
    get groupList() {
      return Point.getGroupList(this.points);
    }
    getGroup(groupList, pointIndex) {
      return Point.getGroup(groupList, pointIndex);
    }
    get selectedGroupIndexList() {
      const groupIndexList = /* @__PURE__ */ new Set();
      const groupList = this.groupList;
      if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
        return groupList.map((group) => group.groupIndex);
      }
      const points = this.selectedPointList;
      points.forEach((it) => {
        const group = this.getGroup(groupList, it.index);
        if (group) {
          groupIndexList.add(group.groupIndex);
        }
      });
      return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
    }
    removeSelectedSegment() {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.removed = true;
      });
      const pointGroup = Point.splitPoints(this.points);
      const newPoints = Point.recoverPoints(pointGroup.map((points) => {
        return points.filter((p) => !p.startPoint.removed).map((p) => {
          if (p.endPoint.removed) {
            p.endPoint = sapa.clone(p.startPoint);
          }
          if (p.reversePoint.removed) {
            p.reversePoint = sapa.clone(p.startPoint);
          }
          if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
            p.command = "L";
            p.curve = false;
          }
          return p;
        });
      }));
      this.points = newPoints;
      this.select();
    }
    move(dx, dy, e, maxWidth, maxHeight) {
      var state = this.state;
      var { isCurveSegment, segmentKey, connectedPoint } = state;
      if (this.selectedPointList.length > 1) {
        this.moveSelectedSegment(dx, dy, maxWidth, maxHeight);
      } else if (this.selectedPointList.length === 1) {
        var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
        this.snapPointList = snapPointList || [];
        if (isCurveSegment) {
          if (e.altKey) {
            this.moveSegment(segmentKey, dx, dy);
            this.rotateSegment(segmentKey);
          } else if (e.shiftKey) {
            this.moveSegment(segmentKey, dx, dy);
          } else {
            this.moveSegment(segmentKey, dx, dy);
            var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
            state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
          }
        } else {
          this.moveSegment("startPoint", dx, dy, null, maxWidth, maxHeight);
          this.moveSegment("endPoint", dx, dy);
          this.moveSegment("reversePoint", dx, dy);
          if (!e.altKey) {
            state.connectedPointList.forEach((it) => {
              this.moveSegment("startPoint", dx, dy, it, maxWidth, maxHeight);
              this.moveSegment("endPoint", dx, dy, it);
              this.moveSegment("reversePoint", dx, dy, it);
            });
          }
        }
        connectedPoint && this.copySegment(state.segment, state.connectedPoint);
      } else if (this.state.selectedGroupIndex > -1) {
        this.moveSelectedGroup(dx, dy, maxWidth, maxHeight);
      }
    }
    moveEnd(dx, dy) {
      var state = this.state;
      var points = this.points;
      var x = state.dragXY.x + dx;
      var y = state.dragXY.y + dy;
      var endPoint = { x, y };
      var reversePoint = { x, y };
      if (state.dragPoints) {
        reversePoint = Point.getReversePoint(state.startPoint, endPoint);
      }
      points.push({
        command: state.clickCount === 0 ? "M" : "",
        startPoint: state.startPoint,
        endPoint,
        curve: !!state.dragPoints,
        reversePoint
      });
      state.startPoint = null;
      state.dragPoints = false;
      state.moveXY = null;
    }
    setPoint(obj2) {
      var p0 = obj2.first[0];
      var p1 = obj2.second[obj2.second.length - 1];
      var allPoints = this.clonePoints;
      var firstItem = Point.getPoint(allPoints, p0);
      var secondItem = Point.getPoint(allPoints, p1);
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
        {
          startPoint: obj2.first[3],
          reversePoint: obj2.first[2],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
      this.points = allPoints;
      return firstIndex + 1;
    }
    setPointQuard(obj2) {
      var p0 = obj2.first[0];
      var p1 = obj2.second[obj2.second.length - 1];
      var allPoints = this.clonePoints;
      var firstItem = Point.getPoint(allPoints, p0);
      var secondItem = Point.getPoint(allPoints, p1);
      if (firstItem.curve && secondItem.curve === false) {
        var newPoints = [
          __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
          {
            startPoint: obj2.first[2],
            reversePoint: obj2.first[1],
            curve: true,
            endPoint: obj2.second[1]
          }
        ];
        var firstIndex = Point.getIndex(allPoints, p0);
        allPoints.splice(firstIndex, 1, ...newPoints);
      } else {
        var newPoints = [
          __spreadValues({}, firstItem),
          {
            startPoint: obj2.first[2],
            reversePoint: obj2.first[1],
            curve: true,
            endPoint: obj2.second[1]
          },
          __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
        ];
        var firstIndex = Point.getIndex(allPoints, p0);
        allPoints.splice(firstIndex, 2, ...newPoints);
      }
      this.points = allPoints;
      return firstIndex + 1;
    }
    setPointLine(obj2) {
      var p0 = obj2.first[0];
      var allPoints = this.clonePoints;
      var newPoints = [
        {
          command: "L",
          startPoint: obj2.first[1],
          curve: false,
          endPoint: obj2.first[1],
          reversePoint: obj2.first[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex + 1, 0, ...newPoints);
      this.points = allPoints;
      return firstIndex + 1;
    }
    toPath(minX = 0, minY = 0, scale2 = 1) {
      return toPath(this.clonePoints, minX, minY, scale2);
    }
    makeSVGPath() {
      this.initialize();
      this.makePointGuide(this.points);
      this.makeMovePositionGuide();
      return this.toSVGString();
    }
    makeTriangleDistancePointGuide(first, second) {
      var minX = Math.min(first.startPoint.x, second.startPoint.x);
      var maxX = Math.max(first.startPoint.x, second.startPoint.x);
      var minY = Math.min(first.startPoint.y, second.startPoint.y);
      var maxY = Math.max(first.startPoint.y, second.startPoint.y);
      if (first.startPoint.x < second.startPoint.x && first.startPoint.y < second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
        var centerX = minX;
        var centerY = minY;
        var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
        var dist2 = 20;
        var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
        var last = getXYInCircle(angle, dist2, centerX, centerY);
        this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
      } else if (first.startPoint.x < second.startPoint.x && first.startPoint.y > second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y > second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
      } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y < second.startPoint.y) {
        this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      }
    }
    makeDistancePointGuide(prevPoint, current, nextPoint) {
      if (current.selected) {
        if (prevPoint) {
          this.makeTriangleDistancePointGuide(prevPoint, current);
        }
        if (nextPoint) {
          this.makeTriangleDistancePointGuide(current, nextPoint);
        }
      }
    }
    makeStartPointGuide(prevPoint, current, nextPoint, index2) {
      current.startPoint.isFirst = true;
      if (current.curve === false) {
        this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
        if (Point.isEqual(current.startPoint, current.endPoint) === false) {
          this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
        }
      }
    }
    makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2) {
      var mng = this.segmentManager;
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        } else {
          if (current.connected) {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          } else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      }
    }
    makeMiddlePointGuideSplitLine(prevPoint, current) {
      const selected = "selected";
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
          } else {
            this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
          }
        } else {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      }
    }
    makePointGuide(points) {
      for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
        var currentIndex = index2;
        var current = points[currentIndex];
        if (!current)
          continue;
        var nextPoint = Point.getNextPoint(points, index2);
        var prevPoint = Point.getPrevPoint(points, index2);
        if (prevPoint && prevPoint.command === "M") {
          if (current.startPoint) {
            current.startPoint.isSecond = true;
          }
        }
        if (current.startPoint) {
          if (nextPoint) {
            current.startPoint.isLast = nextPoint.command === "M";
          } else {
            current.startPoint.isLast = index2 === len2 - 1;
          }
        }
        current.selected = this.selectedIndex === index2;
        if (current.command === "M") {
          this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
        } else {
          this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2);
          this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2);
        }
        if (current.close) {
          this.pathStringManager.Z();
        }
      }
    }
    makeMovePositionGuide() {
      var state = this.state;
      var {
        startPoint,
        moveXY,
        dragPoints,
        snapPointList,
        isGroupSegment
      } = state;
      var points = this.points;
      if (moveXY) {
        snapPointList = snapPointList || [];
        var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap(points, moveXY, 3);
        snapPointList.push.apply(snapPointList, movePointSnapPointList);
        state.moveXY = newMoveXY;
        moveXY = newMoveXY;
        this.snapPointList = snapPointList;
        var prev = points[points.length - 1];
        if (dragPoints && !isGroupSegment) {
          if (!prev) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
            this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
          } else if (prev.curve) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
            this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
          } else if (prev.curve === false) {
            var { x, y } = Point.getReversePoint(startPoint, moveXY);
            this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
            this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
          }
        } else {
          if (!prev)
            ;
          else if (prev.curve) {
            this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
            this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
          } else {
            if (!prev.close) {
              this.guideLineManager.M(prev.startPoint).L(moveXY);
              this.segmentManager.addPoint(false, prev.startPoint);
            }
          }
        }
      }
    }
    makeSnapLines() {
      var snapLines = [];
      if (this.snapPointList) {
        var snapPath = new PathStringManager();
        snapLines = this.snapPointList.map((snapPoint) => {
          snapPath.reset();
          return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
        });
      }
      return snapLines.join("");
    }
    makePathArea() {
      const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
        const d = this.generatorPathString(points);
        const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
        return {
          points,
          startPointIndex,
          groupIndex,
          center: verties[4],
          d
        };
      });
      const pathCount = pathList.length;
      return `
            <g>
               ${pathList.map((it) => {
        const { center } = it;
        const [x, y] = center;
        const selected = this.state.selectedGroupIndex === it.groupIndex;
        return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
      }).join("")}
            </g>
        `;
    }
    toSVGString() {
      return `
        <svg width="100%" height="100%" class='svg-editor-canvas' tabIndex="-1">
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
    }
  }
  function xy([x, y]) {
    return { x, y };
  }
  function scaleLinear(source, target) {
    function targetScale(t) {
      if (target[0] < target[1]) {
        return target[0] + t * (target[1] - target[0]);
      } else if (target[0] > target[1]) {
        return target[0] - t * (target[0] - target[1]);
      }
    }
    function rate(v1, v2, current) {
      const minValue = Math.min(v1, v2);
      const maxValue = Math.max(v1, v2);
      return (current - minValue) / (maxValue - minValue);
    }
    return (x) => {
      if (source[0] < source[1]) {
        return targetScale(rate(source[0], source[1], x));
      } else if (source[0] > source[1]) {
        return targetScale(1 - rate(source[0], source[1], x));
      }
    };
  }
  const SegmentConvertor = class extends editor.EditorElement {
    convertToCurve(index2) {
      this.pathGenerator.convertToCurve(index2);
      this.renderPath();
      this.updatePathLayer();
    }
    isEditableSegment() {
      return this.state.disableCurve === false;
    }
    [sapa.DOUBLECLICK("$view [data-segment]") + sapa.IF("isEditableSegment") + sapa.PREVENT](e) {
      var index2 = +e.$dt.attr("data-index");
      this.convertToCurve(index2);
    }
    [sapa.DOUBLETAB("$view [data-segment]") + sapa.PREVENT + sapa.DELAY(300)](e) {
      var index2 = +e.$dt.attr("data-index");
      this.convertToCurve(index2);
    }
  };
  const PathCutter = class extends SegmentConvertor {
    calculatePointOnLine(d, clickPosition) {
      var parser = new PathParser(d);
      return parser.getClosedPoint(clickPosition);
    }
    [sapa.POINTERSTART("$view .split-path") + MOVE() + END()](e) {
      this.initRect();
      var parser = new PathParser(e.$dt.attr("d"));
      var clickPosition = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      var selectedSegmentIndex = -1;
      if (this.isMode("path")) {
        this.state.dragXY = clickPosition;
        this.state.startPoint = this.state.dragXY;
        this.pathGenerator.setLastPoint(this.state.startPoint);
        this.state.isSplitPath = true;
        this.renderPath();
        if (this.state.current) {
          this.updatePathLayer();
        }
        return;
      } else {
        if (parser.segments[1].command === "C") {
          var points = [
            xy(parser.segments[0].values),
            xy(parser.segments[1].values.slice(0, 2)),
            xy(parser.segments[1].values.slice(2, 4)),
            xy(parser.segments[1].values.slice(4, 6))
          ];
          var curve = recoverBezier(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
        } else if (parser.segments[1].command === "Q") {
          var points = [
            xy(parser.segments[0].values),
            xy(parser.segments[1].values.slice(0, 2)),
            xy(parser.segments[1].values.slice(2, 4))
          ];
          var curve = recoverBezierQuard(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
        } else if (parser.segments[1].command === "L") {
          var points = [
            xy(parser.segments[0].values),
            xy(parser.segments[1].values.slice(0, 2))
          ];
          var curve = recoverBezierLine(...points, 20);
          var t = curve(clickPosition.x, clickPosition.y);
          selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
          if (e.altKey) {
            this.pathGenerator.convertToCurve(selectedSegmentIndex);
          }
        }
        this.renderPath();
        this.updatePathLayer();
        this.changeMode("segment-move");
        this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
        this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
      }
    }
  };
  class PathEditor extends PathCutter {
    initialize() {
      super.initialize();
      this.pathParser = new PathParser();
      this.pathGenerator = new PurePathGenerator(this);
    }
    initState() {
      return {
        domain: this.props.domain || [0, 1],
        range: this.props.range || [1, 0],
        isControl: false,
        disableCurve: false,
        points: [],
        mode: "path",
        clickCount: 0,
        isSegment: false,
        isFirstSegment: false,
        current: null
      };
    }
    template() {
      return `
        <div class='elf--path-editor' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
    }
    [sapa.BIND("$el")]() {
      return {
        style: {
          height: editor.Length.px(this.props.height) || 200
        }
      };
    }
    initRect(isForce = false) {
      if (!this.state.rect || isForce || this.state.rect.width == 0 || this.state.rect.height == 0) {
        this.state.rect = this.refs.$view.rect();
      }
    }
    [sapa.SUBSCRIBE("PathEditorDone")]() {
      this.updatePathLayer();
    }
    [sapa.KEYUP() + sapa.ENTER]() {
      this.trigger("PathEditorDone");
    }
    [sapa.KEYUP() + sapa.ESCAPE]() {
      if (this.state.current) {
        this.updatePathLayer();
      }
    }
    [sapa.KEYUP() + sapa.DELETE]() {
      console.log("delete");
    }
    [sapa.KEYUP("$el .segment")](e) {
      const index2 = +e.$dt.data("index");
      console.log(index2);
      switch (e.code) {
        case "Delete":
        case "Backspace":
          this.trigger("deleteSegment");
          break;
      }
    }
    [sapa.SUBSCRIBE_SELF("deleteSegment")]() {
      this.pathGenerator.reselect();
      this.pathGenerator.removeSelectedSegment();
      this.renderPath();
      this.updatePathLayer();
    }
    [sapa.SUBSCRIBE_SELF("moveSegment")](dx, dy) {
      this.pathGenerator.reselect();
      this.pathGenerator.moveSelectedSegment(dx, dy);
      this.renderPath();
      this.updatePathLayer();
    }
    recoverAreaToPath(d) {
      this.initRect(true);
      var parser = new PathParser(d);
      parser.scaleFunc(this.state.domainScaleInvert, this.state.rangeScaleInvert);
      return parser.d;
    }
    updatePathLayer() {
      var { d } = this.pathGenerator.toPath();
      const value = this.recoverAreaToPath(d);
      this.parent.trigger(this.props.onchange, this.state.key, value);
    }
    changeMode(mode, obj2) {
      this.setState(__spreadValues({
        mode,
        clickCount: 0,
        moveXY: null
      }, obj2), false);
      if (obj2 == null ? void 0 : obj2.points) {
        this.pathGenerator.setPoints(obj2.points || []);
      }
    }
    isMode(mode) {
      return this.state.mode === mode;
    }
    convertPathToArea(obj2) {
      this.initRect(true);
      const width2 = this.state.rect.width;
      const height = this.state.rect.height;
      this.state.domainScale = scaleLinear([0, 1], [0, width2]);
      this.state.rangeScale = scaleLinear([1, 0], [0, height]);
      this.state.domainScaleInvert = scaleLinear([0, width2], [0, 1]);
      this.state.rangeScaleInvert = scaleLinear([0, height], [1, 0]);
      this.pathParser.reset(obj2.d).scaleFunc(this.state.domainScale, this.state.rangeScale);
    }
    refreshEditorView(obj2) {
      this.convertPathToArea(obj2);
      this.pathGenerator.setPoints(this.pathParser.convertGenerator());
      this.renderPath();
    }
    afterRender() {
      const { mode, value } = this.props;
      const obj2 = { d: value };
      if (mode === "move") {
        obj2.current = null;
        obj2.points = [];
      }
      this.changeMode(mode, obj2);
      window.setTimeout(() => {
        this.refreshEditorView(obj2, true);
      }, 10);
    }
    [sapa.BIND("$view")]() {
      var _a;
      const path = this.pathGenerator.makeSVGPath();
      const strokeWidth = editor.Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
      return {
        class: {
          path: this.state.mode === "path",
          modify: this.state.mode === "modify",
          transform: this.state.mode === "transform",
          "segment-move": this.state.mode === "segment-move",
          "is-control": this.state.isControl,
          "has-one-stroke-width": strokeWidth === 1
        },
        htmlDiff: path
      };
    }
    [sapa.BIND("$splitCircle")]() {
      if (this.state.splitXY) {
        return {
          cx: this.state.splitXY.x,
          cy: this.state.splitXY.y,
          r: 5
        };
      } else {
        return {
          r: 0
        };
      }
    }
    renderPath() {
      this.bindData("$view");
    }
    get checkDistance() {
      return false;
    }
    getPathRect() {
      this.initRect(true);
      const { d } = this.pathGenerator.toPath();
      return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
    }
    resetTransformZone() {
      var rect2 = this.getPathRect();
      this.state.transformZoneRect = rect2;
    }
    [sapa.POINTERMOVE("$view") + sapa.PREVENT](e) {
      this.initRect();
      if (this.isMode("path") && this.state.rect) {
        this.state.moveXY = {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        };
        this.state.altKey = e.altKey;
        this.renderPath();
      } else {
        var $target = sapa.Dom.create(e.target);
        var isSplitPath = $target.hasClass("split-path");
        if (isSplitPath) {
          this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
            x: e.xy.x - this.state.rect.x,
            y: e.xy.y - this.state.rect.y
          });
        } else {
          this.state.splitXY = null;
        }
        this.bindData("$splitCircle");
        this.state.altKey = false;
      }
    }
    [sapa.POINTERSTART("$view :not(.split-path)") + sapa.PREVENT + sapa.STOP + MOVE() + END()](e) {
      this.initRect();
      this.state.altKey = false;
      var isPathMode = this.isMode("path");
      this.$config.set("set.move.control.point", true);
      this.state.dragXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      var $target = sapa.Dom.create(e.target);
      this.$segmentTarget = $target;
      if ($target.hasClass("svg-editor-canvas") && !isPathMode)
        ;
      else {
        this.pathGenerator.reselect();
        this.state.isSegment = $target.attr("data-segment") === "true";
        this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
        this.state.selectedGroupIndex = -1;
        this.state.selectedPointIndex = -1;
      }
      if (isPathMode) {
        if (this.state.isFirstSegment) {
          var index2 = +$target.attr("data-index");
          this.state.startPoint = this.pathGenerator.points[index2].startPoint;
        } else {
          this.state.startPoint = this.state.dragXY;
        }
        this.state.dragPoints = false;
        this.state.endPoint = null;
      } else {
        if (this.state.isSegment) {
          this.changeMode("segment-move");
          var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
          const localIndex = +index2;
          this.pathGenerator.setCachePoint(localIndex, segmentKey);
          this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
          this.state.segmentKey = segmentKey;
          this.renderPath();
        }
      }
    }
    move(dx, dy) {
      const e = this.$config.get("bodyEvent");
      if (this.state.segmentKey === "startPoint") {
        const newXY = {
          x: Math.max(0, Math.min(this.state.rect.width, e.xy.x - this.state.rect.x)),
          y: Math.max(0, Math.min(this.state.rect.height, e.xy.y - this.state.rect.y))
        };
        dx = newXY.x - this.state.dragXY.x;
        dy = newXY.y - this.state.dragXY.y;
      }
      if (this.isMode("segment-move")) {
        this.pathGenerator.move(dx, dy, e, this.state.rect.width, this.state.rect.height);
        this.renderPath();
        this.updatePathLayer();
      } else if (this.isMode("path")) {
        const dist2 = getDist(dx, dy, 0, 0);
        if (dist2 >= 2) {
          this.state.dragPoints = e.altKey ? false : true;
        }
      }
    }
    renderSegment(callback) {
      if (this.pathGenerator.selectedLength) {
        this.pathGenerator.reselect();
        if (sapa.isFunction(callback))
          callback();
        this.renderPath();
        this.updatePathLayer();
      }
    }
    end(dx, dy) {
      this.$config.set("set.move.control.point", false);
      if (this.isMode("modify")) {
        this.pathGenerator.reselect();
      } else if (this.isMode("segment-move")) {
        this.changeMode("modify");
        this.pathGenerator.reselect();
        this.renderPath();
        this.updatePathLayer();
      } else if (this.isMode("path")) {
        if (this.state.isFirstSegment) {
          this.changeMode("modify");
          this.pathGenerator.setConnectedPoint(dx, dy);
          this.renderPath();
          if (this.state.current) {
            this.updatePathLayer();
          }
        } else {
          if (this.state.isSplitPath)
            ;
          else {
            this.pathGenerator.moveEnd(dx, dy);
            this.state.clickCount++;
            this.renderPath();
            this.pathGenerator.reselect();
          }
        }
        this.state.isSplitPath = false;
      }
    }
  }
  var PathDataEditor$1 = "";
  class PathDataEditor extends editor.EditorElement {
    initState() {
      var parser = new PathParser(this.props.value || "");
      return {
        parser
      };
    }
    makeSegments() {
      return this.refs.$data.$$(".segment").map(($segment) => {
        var $command = $segment.$(".command");
        var command = $command.attr("data-command");
        if (command === "Z" && $command.attr("data-toggle") === "false") {
          return null;
        }
        var values = $segment.$$(".values input[type=number]").map((it) => {
          return +it.value;
        });
        return {
          command,
          values
        };
      }).filter((it) => it);
    }
    updateData() {
      var segments = this.makeSegments();
      this.state.parser.resetSegments(segments);
      this.modifyPathData();
    }
    modifyPathData() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
    setValue(value) {
      this.setState({
        parser: new PathParser(value)
      });
    }
    getValue() {
      return this.state.parser.joinPath();
    }
    template() {
      return `
            <div class='elf--path-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
    }
    [sapa.LOAD("$data")]() {
      var segments = [];
      this.state.parser.segments.forEach((it, index2) => {
        var s = __spreadValues({}, it);
        segments.push(s);
        var next = this.state.parser.segments[index2 + 1];
        if (next && next.command === "M") {
          if (s.command !== "Z") {
            segments.push({ command: "Z", toggle: false, values: [] });
          } else {
            s.toggle = true;
          }
        }
      });
      var last = this.state.parser.segments[this.state.parser.segments.length - 1];
      if (last && last.command !== "Z") {
        segments.push({ command: "Z", toggle: false, values: [] });
      }
      var arr = segments.map((it) => {
        var cls = it.command === "M" ? "m" : "";
        return `
                <div class='segment ${cls}'>
                    <div class='command' data-command='${it.command}' data-toggle="${it.toggle}" title='Toggle'>${it.command}</div>
                    <div class='values'>
                        ${it.values.map((v) => {
          return `<input type="number" value="${v}" />`;
        }).join("")}

                        ${it.command === "Z" ? it.toggle === false ? "opened" : "closed" : ""}
                    </div>
                </div>
            `;
      });
      arr.unshift(`
            <div class='segment-empty'>
                <div class='command'></div>
                <div class='values'>
                    <span>X</span>
                    <span>Y</span>
                </div>
            </div>
        `);
      return arr;
    }
    [sapa.INPUT("$data input[type=number]") + sapa.DEBOUNCE(300)]() {
      this.updateData();
    }
    [sapa.CLICK("$data .command[data-toggle]")](e) {
      var [command, toggle] = e.$dt.attrs("data-command", "data-toggle");
      if (command === "Z") {
        if (toggle !== "false") {
          toggle = "false";
        } else {
          toggle = "true";
        }
        e.$dt.attr("data-toggle", toggle);
        this.updateData();
      }
    }
  }
  var PolygonDataEditor$1 = "";
  const splitReg = /[\b\t ,]/g;
  class PolygonParser extends PathParser {
    constructor(points = "") {
      super(points);
    }
    reset(points = "") {
      this.segments = [];
      this.points = points;
      this.parse();
    }
    resetSegments(segments = []) {
      this.segments = segments;
      this.points = this.joinPoints();
    }
    parse() {
      var points = this.points;
      if (Array.isArray(points)) {
        points = points.join(" ");
      }
      var arr = points.trim().split(splitReg).filter((it) => it);
      var segments = [];
      for (var i = 0, len2 = arr.length; i < len2; i += 2) {
        segments.push({ x: +arr[i], y: +arr[i + 1] });
      }
      this.segments = segments;
    }
    convertGenerator() {
      return this.segments;
    }
    length() {
      return this.segments.length;
    }
    toPathString() {
      var path = new PathStringManager();
      for (var i = 0, len2 = this.segments.length; i < len2; i++) {
        var s = this.segments[i];
        if (i === 0) {
          path.M(s);
        } else if (i === len2 - 1) {
          path.L(s).L(this.segments[0]).Z();
        } else {
          path.L(s);
        }
      }
      return path.d;
    }
    joinPath(segments) {
      return this.joinPoints(segments);
    }
    joinPoints(segments) {
      var list = segments || this.segments;
      return list.map((it) => {
        return `${it.x},${it.y}`;
      }).join(" ");
    }
    each(callback, isReturn = false) {
      var newSegments = this.segments.map((segment) => {
        return callback.call(this, segment);
      });
      if (isReturn) {
        return newSegments;
      } else {
        this.segments = newSegments;
      }
    }
    _loop(m, isReturn = false) {
      return this.each(function(segment) {
        var [x, y] = m([segment.x, segment.y], 0);
        segment.x = x;
        segment.y = y;
        return segment;
      }, isReturn);
    }
    clone() {
      return new PolygonParser(this.joinPoints());
    }
    toString() {
      return this.joinPoints();
    }
  }
  class PolygonDataEditor extends editor.EditorElement {
    initState() {
      var parser = new PolygonParser(this.props.value || "");
      return {
        parser
      };
    }
    makeSegments() {
      return this.refs.$data.$$(".segment").map(($segment) => {
        var x = +$segment.$('[data-key="x"]').value;
        var y = +$segment.$('[data-key="y"]').value;
        return { x, y };
      });
    }
    updateData() {
      var segments = this.makeSegments();
      this.state.parser.resetSegments(segments);
      this.modifyPolygonData();
    }
    modifyPolygonData() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
    setValue(value) {
      this.setState({
        parser: new PolygonParser(value || "")
      });
    }
    getValue() {
      return this.state.parser.joinPoints();
    }
    template() {
      return `
            <div class='elf--polygon-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
    }
    [sapa.LOAD("$data")]() {
      return this.state.parser.segments.map((it) => {
        return `
                <div class='segment'>
                    <div class='values'>
                        <label>X <input type="number" data-key="x" value="${it.x}" /></label>
                        <label>Y <input type="number" data-key="y" value="${it.y}" /></label>
                    </div>
                </div>
            `;
      });
    }
    [sapa.INPUT("$data input[type=number]") + sapa.DEBOUNCE(300)]() {
      this.updateData();
    }
  }
  var StrokeDashArrayEditor$1 = "";
  const dash_list = [
    [10, 5],
    [5, 1],
    [1, 5],
    [0.9],
    [15, 10, 5],
    [15, 10, 5, 10],
    [15, 10, 5, 10, 15],
    [5, 5, 1, 5]
  ];
  class StrokeDashArrayEditor extends editor.EditorElement {
    initState() {
      var value = sapa.isArray(this.props.value) ? this.props.value : this.generateValue(this.props.value || "");
      return {
        label: this.props.label || "",
        value,
        count: 1
      };
    }
    template() {
      const { label } = this.state;
      const hasLabel = !!label;
      return `
      <div class='elf--stroke-dasharray-editor'>
        <div class='tools ${hasLabel ? "has-label" : ""}'>
          ${hasLabel ? `<label class='label'>${label}</label>` : ""}
          <div class="buttons">
            <label ref='$add'>${editor.iconUse("add")}</label>          
          </div>
        </div>      
        <div ref='$body' class='dash-list'></div>
        <div ref='$list' class='dash-sample-list'></div>
      </div>
    `;
    }
    [sapa.CLICK("$el .tools label")]() {
      this.refs.$list.toggle();
    }
    getValue() {
      return this.state.value;
    }
    generateValue(value) {
      return value.split(" ").filter(Boolean).map((it) => +it);
    }
    setValue(value) {
      if (!sapa.isArray(value)) {
        value = this.generateValue(value);
      }
      this.setState({
        value
      });
    }
    [sapa.LOAD("$list")]() {
      return dash_list.map((value, index2) => {
        return `
        <div class='dash-sample' data-index='${index2}'>
          <div class='dash-sample-value'>
            <svg width="100" height="2">
              <line x1="5" y1="0" x2="95" y2="0" stroke-dasharray="${value.join(",")}" stroke-width="2" stroke="black" />
            </svg>
          </div>
        </div>
      `;
      });
    }
    [sapa.LOAD("$body")]() {
      this.state.count++;
      return this.state.value.map((value, index2) => {
        var num = index2 + 1;
        return `
        <div class='dasharray-item'>
          ${sapa.createComponent("NumberInputEditor", {
          ref: `$dash-${this.state.count}-${num}`,
          compact: true,
          key: index2,
          value,
          min: 0,
          max: 100,
          step: 1,
          onchange: "changeRangeEditor"
        })}  
          <button type="button" data-index="${index2}" class='delete'>${editor.iconUse("close")}</button>
        </div>
      `;
      });
    }
    [sapa.SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
      var index2 = +key;
      this.state.value[index2] = value;
      this.modifyStrokeDashArray();
    }
    [sapa.CLICK("$list .dash-sample")](e) {
      const value = dash_list[+e.$dt.data("index")];
      this.setState({ value }, false);
      this.refresh();
      this.modifyStrokeDashArray();
      this.refs.$list.toggle();
    }
    [sapa.CLICK("$add")]() {
      this.setState({
        value: [...this.state.value, 0]
      }, false);
      this.refresh();
      this.modifyStrokeDashArray();
    }
    [sapa.CLICK("$body .delete")](e) {
      const index2 = +e.$dt.attr("data-index");
      this.state.value.splice(index2, 1);
      this.refresh();
      this.modifyStrokeDashArray();
    }
    modifyStrokeDashArray() {
      this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
    }
    [sapa.POINTERSTART("document")](e) {
      const $target = sapa.Dom.create(e.target);
      const parent = $target.closest("elf--stroke-dasharray-editor");
      if (!parent) {
        this.refs.$list.hide();
      }
    }
  }
  var TextShadowEditor$1 = "";
  class TextShadowEditor extends editor.EditorElement {
    initState() {
      return {
        textShadows: this.props.value || []
      };
    }
    template() {
      return `
      <div class="elf--text-shadow-editor" >
        <div class='text-shadow-list' ref='$shadowList'></div>
      </div>
    `;
    }
    [sapa.LOAD("$shadowList")]() {
      var arr = this.state.textShadows.map((shadow2, index2) => {
        return `
        <div class="shadow-item real" data-index="${index2}">
          <label draggable="true" data-index="${index2}">${editor.iconUse("drag_indicator")}</label>
          ${sapa.createComponent("ColorViewEditor", {
          mini: true,
          key: "color",
          value: shadow2.color,
          params: index2,
          onchange: "changeKeyValue"
        })}
          ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          key: "offsetX",
          label: "X",
          value: shadow2.offsetX,
          params: index2,
          onchange: "changeKeyValue"
        })}          
          ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          key: "offsetY",
          label: "Y",
          value: shadow2.offsetY,
          params: index2,
          onchange: "changeKeyValue"
        })}                    
          ${sapa.createComponent("NumberInputEditor", {
          mini: true,
          label: "B",
          key: "blurRadius",
          value: shadow2.blurRadius,
          params: index2,
          onchange: "changeKeyValue"
        })}                    
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${editor.iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
      });
      return arr.join("");
    }
    modifyTextShadow() {
      var value = this.state.textShadows;
      this.parent.trigger(this.props.onchange, this.props.key, value);
    }
    [sapa.SUBSCRIBE("add")](shadows) {
      if (sapa.isArray(shadows)) {
        this.state.textShadows.push(...shadows);
      } else {
        this.state.textShadows.push({
          color: "#000000",
          offsetX: 0,
          offsetY: 0,
          blurRadius: 0
        });
      }
      this.refresh();
      this.modifyTextShadow();
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.DRAGSTART("$shadowList .shadow-item > label")](e) {
      this.startIndex = +e.$dt.attr("data-index");
    }
    [sapa.DRAGOVER("$shadowList .shadow-item") + sapa.PREVENT]() {
    }
    sortItem(arr, startIndex, targetIndex) {
      arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
    }
    sortTextShadow(startIndex, targetIndex) {
      this.sortItem(this.state.textShadows, startIndex, targetIndex);
    }
    [sapa.DROP("$shadowList .shadow-item") + sapa.PREVENT](e) {
      var targetIndex = +e.$dt.attr("data-index");
      this.sortTextShadow(this.startIndex, targetIndex);
      this.refresh();
      this.modifyTextShadow();
    }
    [sapa.CLICK("$shadowList .remove")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.textShadows.splice(index2, 1);
      this.refresh();
      this.modifyTextShadow();
    }
    [sapa.SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
      var shadow2 = this.state.textShadows[index2];
      this.state.textShadows[index2] = __spreadProps(__spreadValues({}, shadow2), { [key]: value });
      this.modifyTextShadow();
    }
  }
  var VarEditor$1 = "";
  class VarEditor extends editor.EditorElement {
    initState() {
      var values = this.props.value.split(";").filter((it) => it.trim()).map((it) => {
        let [key, value] = it.split(":");
        key = key.replace("--", "");
        return { key, value };
      });
      return {
        hideLabel: this.props.hideLabel == "true" ? true : false,
        params: this.props.params || "",
        values
      };
    }
    template() {
      var labelClass = this.state.hideLabel ? "hide" : "";
      return `
        <div class='elf--var-editor var-list'>
            <div class='label ${labelClass}' >
                <label>${this.props.title || ""}</label>
                <div class='tools'>
                    <button type="button" ref="$add" title="add Var">${editor.iconUse("add")}</button>
                </div>
            </div>
            <div class='var-list' ref='$varList'></div>
        </div>`;
    }
    [sapa.SUBSCRIBE("add")]() {
      this.state.values.push({
        key: "",
        value: ""
      });
      this.refresh();
      this.updateData();
    }
    [sapa.CLICK("$add")]() {
      this.trigger("add");
    }
    [sapa.LOAD("$varList")]() {
      return this.state.values.map((it, index2) => {
        return `
                <div class='var-item' >
                    <div>
                        <input type="text" data-type="key" value="${it.key}" data-index="${index2}"  placeholder="variable" />
                    </div>
                    <div>
                        <input type="text" data-type="value" value="${it.value}" data-index="${index2}"  placeholder="value" />
                    </div>
                    <div class="tools">
                        <button type="button" class="del" data-index="${index2}">
                        ${icon.remove2}
                        </button>
                    </div>
                </div>
            `;
      });
    }
    [sapa.CLICK("$varList .del")](e) {
      var index2 = +e.$dt.attr("data-index");
      this.state.values.splice(index2, 1);
      this.refresh();
      this.updateData();
    }
    [sapa.INPUT("$varList input")](e) {
      var index2 = +e.$dt.attr("data-index");
      var type = e.$dt.attr("data-type");
      this.state.values[index2][type] = e.$dt.value;
      this.updateData();
    }
    updateData() {
      var value = this.state.values.map((it) => {
        return `${it.key}:${it.value}`;
      }).join(";");
      this.parent.trigger(this.props.onchange, value, this.props.params);
    }
  }
  var propertyEditor$1 = {
    BlendSelectEditor,
    BoxShadowEditor,
    ColorAssetsEditor,
    ColorSingleEditor,
    ColorViewEditor,
    CSSPropertyEditor,
    CubicBezierEditor,
    DirectionEditor,
    FilterEditor,
    FontSelectEditor,
    GradientEditor,
    IconListViewEditor,
    IterationCountEditor,
    MediaProgressEditor,
    PathEditor,
    PathDataEditor,
    PolygonDataEditor,
    StrokeDashArrayEditor,
    TextShadowEditor,
    VarEditor
  };
  function propertyEditor(editor2) {
    editor2.registerElement(propertyEditor$1);
    editor2.registerAlias({
      "icon-list-view": "IconListViewEditor",
      "box-shadow": "BoxShadowEditor",
      "text-shadow": "TextShadowEditor",
      component: "ComponentEditor",
      "text-area": "TextAreaEditor",
      text: "TextEditor",
      "color-single": "ColorSingleEditor",
      "cubic-bezier": "CubicBezierEditor",
      path: "PathEditor",
      "clip-path": "ClipPathEditor",
      "color-view": "ColorViewEditor",
      var: "VarEditor",
      "path-data": "PathDataEditor",
      "polygon-data": "PolygonDataEditor",
      "input-array": "InputArrayEditor",
      "stroke-dash-array": "StrokeDashArrayEditor",
      "number-input": "NumberInputEditor",
      "number-range": "NumberRangeEditor",
      "media-progress": "MediaProgressEditor",
      "select-icon": "SelectIconEditor",
      "css-property": "CSSPropertyEditor",
      direction: "DirectionEditor",
      "iteration-count": "IterationCountEditor",
      gradient: "GradientEditor",
      filter: "FilterEditor",
      select: "SelectEditor",
      "blend-select": "BlendSelectEditor",
      range: "RangeEditor",
      "input-range": "InputRangeEditor",
      "color-assets": "ColorAssetsEditor",
      "font-select": "FontSelectEditor"
    });
  }
  function defaultIcons(editor2) {
    editor2.registerIcon("artboard", "artboard");
    editor2.registerIcon("circle", "lens");
    editor2.registerIcon("image", "image");
    editor2.registerIcon("text", "title");
    editor2.registerIcon("svg-text", "title");
    editor2.registerIcon("boolean-path", "pentool");
    editor2.registerIcon("svg-path", "pentool");
    editor2.registerIcon("polygon", "polygon");
    editor2.registerIcon("star", "star");
    editor2.registerIcon("spline", "smooth");
    editor2.registerIcon("rect", "rect");
  }
  var ContentProperty$1 = "";
  class ContentProperty extends editor.BaseProperty {
    getTitle() {
      return "Content";
    }
    [sapa.SUBSCRIBE(REFRESH_SELECTION, REFRESH_CONTENT) + sapa.DEBOUNCE(100)]() {
      this.refreshShow(["text"]);
    }
    getBody() {
      return `
      <div class="property-item elf--content-item">
        <textarea ref="$contentItem"></textarea>
      </div>
    `;
    }
    [sapa.BIND("$contentItem")]() {
      var current = this.$context.selection.current;
      if (!current)
        return "";
      return {
        value: current.content || ""
      };
    }
    [sapa.INPUT("$contentItem")]() {
      this.setContent();
    }
    setContent() {
      var current = this.$context.selection.current;
      if (current) {
        var data = {
          content: this.refs.$contentItem.value
        };
        current.reset(data);
        this.emit(UPDATE_CANVAS, current);
      }
    }
  }
  function content(editor2) {
    editor2.registerElement({
      ContentProperty
    });
  }
  var en_US = {
    "app.title": "elf",
    "app.sample": (a, b, c) => {
      return `${a}-${b}-${c}`;
    },
    "app.lang.en_US": "English",
    "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
    "app.lang.fr_FR": "Fran\xE7ais",
    "app.label.lang": "Language",
    "app.layout.all": "Layout",
    "app.layout.css": "CSS Mode",
    "app.layout.svg": "SVG Mode",
    "app.label.layout": "Menu Layout",
    "app.theme.dark": "Dark",
    "app.theme.light": "Light",
    "app.theme.toon": "Toon",
    "app.theme.gray": "Gray",
    "app.label.theme": "Theme",
    "app.tab.title.projects": "Projects",
    "app.tab.title.layers": "Layers",
    "app.tab.title.libraries": "Library",
    "app.tab.title.components": "Component",
    "app.tab.title.artboards": "Artboard",
    "app.tab.title.assets": "Assets",
    "app.tab.title.keyMap": "KeyMap",
    "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
    "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
    "menu.item.download.title": "Source",
    "menu.item.save.title": "Save",
    "menu.item.export.title": "Export",
    "menu.item.codepen.title": "CodePen",
    "menu.item.fullscreen.title": "Full Screen",
    "menu.item.shortcuts.title": "ShortCuts",
    "menu.item.github.title": "Github",
    "menu.item.learn.title": "Learn",
    "menu.item.projects.title": "Projects",
    "menu.item.language.title": "Language",
    "project.property.title": "Project",
    "project.information.property.title": "Project information",
    "project.information.property.name": "Name",
    "project.information.property.description": "Description",
    "artboard.property.title": "ArtBoards",
    "artboard.property.layout.title.flex": "Flex",
    "artboard.property.layout.title.grid": "Grid",
    "layer.tree.property.title": "Layers",
    "layer.tree.property.layout.title.flex": "Flex",
    "layer.tree.property.layout.title.grid": "Grid",
    "alignment.property.title": "Alignment",
    "position.property.title": "Position",
    "position.property.X": "X",
    "position.property.Y": "Y",
    "size.property.title": "Size",
    "position.property.width": "W",
    "position.property.height": "H",
    "position.property.opacity": "Opacity",
    "position.property.rotate": "Rotate",
    "background.color.property.title": "Appearance",
    "background.color.property.color": "Color",
    "background.color.property.zindex": "z-index",
    "background.color.property.blend": "Blend",
    "background.color.property.overflow": "Overflow",
    "background.color.property.overflow.visible": "Visible",
    "background.color.property.overflow.hidden": "Hidden",
    "background.color.property.overflow.scroll": "Scroll",
    "background.color.property.overflow.auto": "Auto",
    "blend.normal": "normal",
    "blend.multiply": "multiply",
    "blend.screen": "screen",
    "blend.overlay": "overlay",
    "blend.darken": "darken",
    "blend.lighten": "lighten",
    "blend.color-dodge": "color-dodge",
    "blend.color-burn": "color-burn",
    "blend.hard-light": "hard-light",
    "blend.soft-light": "soft-light",
    "blend.difference": "difference",
    "blend.exclusion": "exclusion",
    "blend.hue": "hue",
    "blend.saturation": "saturation",
    "blend.color": "color",
    "blend.luminosity": "luminosity",
    "background.image.property.title": "Fill",
    "border.property.title": "Border",
    "border.radius.property.title": "Border Radius",
    "boxshadow.property.title": "Box Shadows",
    "filter.property.title": "Filter",
    "filter.property.blur": "Blur",
    "filter.property.grayscale": "GrayScale",
    "filter.property.hue-rotate": "Hue Rotate",
    "filter.property.invert": "Invert",
    "filter.property.brightness": "Brightness",
    "filter.property.contrast": "Contrast",
    "filter.property.drop-shadow": "Drop Shadow",
    "filter.property.drop-shadow.color": "Color",
    "filter.property.drop-shadow.offsetX": "Offset X",
    "filter.property.drop-shadow.offsetY": "Offset Y",
    "filter.property.drop-shadow.blurRadius": "Blur",
    "filter.property.opacity": "Opacity",
    "filter.property.saturate": "Saturate",
    "filter.property.sepia": "Sepia",
    "filter.property.svg": "SVG",
    "font.property.title": "Font",
    "font.property.color": "Color",
    "font.property.size": "Size",
    "font.property.stretch": "Stretch",
    "font.property.weight": "Weight",
    "font.property.style": "Style",
    "font.property.family": "Family",
    "font.spacing.property.title": "Font spacing",
    "font.spacing.property.lineHeight": "Line height",
    "font.spacing.property.letterSpacing": "Letter spacing",
    "font.spacing.property.wordSpacing": "Word spacing",
    "font.spacing.property.indent": "Indent",
    "backdrop.filter.property.title": "Backdrop Filter",
    "clippath.property.title": "Clip Path",
    "export.property.title": "Export",
    "export.property.download": "Download",
    "iframe.property.title": "IFrame",
    "image.property.title": "Image",
    "image.property.origin": "Origin",
    "image.property.size": "Size",
    "image.property.width": "Width",
    "image.property.height": "height",
    "video.property.title": "Video",
    "video.property.play": "Play",
    "video.property.pause": "Pause",
    "video.property.volume": "Volume",
    "video.property.playbackRate": "Playback Rate",
    "video.property.currentTime": "Current Time",
    "video.property.playTime": "Play Time Distance",
    "motion.property.title": "Motion",
    "text.property.title": "Text Style",
    "text.property.align": "Align",
    "text.property.transform": "Transform",
    "text.property.decoration": "Decoration",
    "text.clip.property.title": "Text Clip",
    "text.shadow.property.title": "Text Shadows",
    "text.fill.property.title": "Text Fill",
    "text.fill.property.fill": "Fill",
    "text.fill.property.stroke": "Stroke",
    "text.fill.property.strokeWidth": "Width",
    "transform.property.title": "Transform",
    "transform.origin.property.title": "Transform Origin",
    "transition.property.title": "CSS Transition",
    "keyframe.property.title": "CSS Keyframe",
    "selector.property.title": "Selector",
    "selector.property.none": "None selector",
    "path.data.property.title": "Path Information",
    "polygon.data.property.title": "Polygon Information",
    "perspective.property.title": "Perspective",
    "perspective.origin.property.title": "Perspective Origin",
    "svg.item.property.title": "Appearance",
    "svg.item.property.isMotionPath": "Motion Path",
    "svg.item.property.fill": "Fill",
    "svg.item.property.fillOpacity": "Opacity",
    "svg.item.property.path": "Path",
    "svg.item.property.polygon": "Polygon",
    "svg.item.property.totalLength": "Total Length",
    "svg.item.property.fillRule": "Fill Rule",
    "svg.item.property.stroke": "Stroke",
    "svg.item.property.strokeWidth": "Width",
    "svg.item.property.dashArray": "Dash Array",
    "svg.item.property.dashOffset": "Dash Offset",
    "svg.item.property.lineCap": "Line Cap",
    "svg.item.property.lineJoin": "Line Join",
    "svg.item.property.filter": "Filter",
    "svg.item.property.blend": "Blend Mode",
    "border.editor.all": "All",
    "border.editor.width": "Width",
    "border.editor.style": "Style",
    "border.editor.color": "C",
    "border.editor.top": "Top",
    "border.editor.left": "Left",
    "border.editor.right": "Right",
    "border.editor.bottom": "Bottom",
    "border.radius.editor.topLeft": "Top Left",
    "border.radius.editor.topRight": "Top Right",
    "border.radius.editor.bottomLeft": "Bottom Left",
    "border.radius.editor.bottomRight": "Bottom Right",
    "boxshadow.editor.blur": "Blur",
    "boxshadow.editor.spread": "Spread",
    "css.property.editor.properties": "Properties",
    "offset.path.list.editor.path": "Path",
    "offset.path.list.editor.totalLength": "Total Length",
    "offset.path.list.editor.distance": "Distance",
    "offset.path.list.editor.direction": "Direction",
    "offset.path.list.editor.rotate": "Rotate",
    "svgfilter.select.editor.message.create": "Create new svg filter",
    "svgfilter.select.editor.message.select": "Select a filter",
    "fill.editor.message.click.image": "Click the preview area if you want to select a image",
    "fill.editor.message.drag.position": "Drag if you want to move center position",
    "fill.editor.x1": "Start X",
    "fill.editor.x2": "End X",
    "fill.editor.y1": "Start Y",
    "fill.editor.y2": "End Y",
    "fill.editor.spread": "Spread",
    "fill.editor.offset": "Offset",
    "fill.editor.cx": "Center X",
    "fill.editor.cy": "Center Y",
    "fill.editor.r": "End radius",
    "fill.editor.fx": "Start X",
    "fill.editor.fy": "Start Y",
    "fill.editor.fr": "Start radius",
    "perspective.origin.editor.originX": "Origin X",
    "perspective.origin.editor.originY": "Origin Y",
    "path.manager.msg": "Keydown ESC or Enter key to close editing",
    "path.manager.mode.done": "Done",
    "path.manager.mode.modify": "Modify",
    "path.manager.mode.path": "Path",
    "path.manager.mode.warp": "Warp",
    "path.manager.mode.transform": "Transform",
    "path.manager.mode.reverse": "Reverse",
    "path.manager.mode.flipX": "Flip X",
    "path.manager.mode.flipY": "Flip Y",
    "path.manager.mode.flipOrigin": "Flip Origin",
    "colorpicker.popup.title": "ColorPicker",
    "selector.popup.title": "Selector Property",
    "selector.popup.selector": "Selector",
    "background.image.position.popup.title": "Background Pattern",
    "background.image.position.popup.size": "Size",
    "background.image.position.popup.width": "Width",
    "background.image.position.popup.height": "Height",
    "background.image.position.popup.repeat": "Repeat",
    "background.image.position.popup.blend": "Blend",
    "background.image.position.popup.type.repeat": "repeat",
    "background.image.position.popup.type.no-repeat": "no repeat",
    "background.image.position.popup.type.repeat-x": "repeat-x",
    "background.image.position.popup.type.repeat-y": "repeat-y",
    "background.image.position.popup.type.space": "space",
    "background.image.position.popup.type.round": "round",
    "gradient.picker.popup.title": "Gradient & Image Picker",
    "gradient.picker.popup.static-gradient": "Static",
    "gradient.picker.popup.linear-gradient": "Linear",
    "gradient.picker.popup.repeating-linear-gradient": "Repeating Linear",
    "gradient.picker.popup.radial-gradient": "Radial",
    "gradient.picker.popup.repeating-radial-gradient": "Repeating Radial",
    "gradient.picker.popup.conic-gradient": "Linear",
    "gradient.picker.popup.repeating-conic-gradient": "Repeating Conic",
    "image.asset.property.title": "Image",
    "video.asset.property.title": "Video",
    "color.asset.property.title": "Color",
    "gradient.asset.property.title": "Gradient",
    "pattern.asset.property.title": "Pattern",
    "svgfilter.asset.property.title": "SVG Filter",
    "inspector.tab.title.design": "Design",
    "inspector.tab.title.component": "Component",
    "inspector.tab.title.transition": "Animation",
    "inspector.tab.title.asset": "Assets",
    "inspector.tab.title.text": "Text",
    "inspector.tab.title.code": "Code",
    "inspector.tab.title.history": "History",
    "timeline.property.title": "Timeline",
    "timeline.property.resize": "Drag if you want to resize timeline height.",
    "timeline.animation.property.title": "Animations",
    "timeline.play.control.play": "Play",
    "timeline.play.control.pause": "Pause",
    "timeline.play.control.first": "First",
    "timeline.play.control.prev": "Previous",
    "timeline.play.control.next": "Next",
    "timeline.play.control.last": "Last",
    "timeline.play.control.direction": "Direction",
    "timeline.play.control.speed": "Speed",
    "timeline.play.control.repeat": "Repeat",
    "timeline.play.control.infinite": "Infinite",
    "timeline.play.control.normal": "normal",
    "timeline.play.control.alternate": "alternate",
    "timeline.play.control.reverse": "reverse",
    "timeline.play.control.alternate.reverse": "alternate reverse",
    "timeline.value.editor.value": "Value",
    "timeline.value.editor.time": "Time",
    "timeline.value.editor.timing": "Timing",
    "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
    "svgfilter.popup.title": "SVG Filter",
    "css.item.rotate": "Rotate",
    "css.item.rotateX": "Rotate X",
    "css.item.rotateY": "Rotate Y",
    "css.item.rotateZ": "Rotate Z",
    "css.item.rotate3d": "3D Rotate",
    "css.item.skewX": "Skew X",
    "css.item.skewY": "Skew Y",
    "css.item.translate": "Translate",
    "css.item.translateX": "Translate X",
    "css.item.translateY": "Translate Y",
    "css.item.translateZ": "Translate Z",
    "css.item.translate3d": "3D Translate",
    "css.item.perspective": "Perspective",
    "css.item.scale": "Scale",
    "css.item.scaleX": "Scale X",
    "css.item.scaleY": "Scale Y",
    "css.item.scaleZ": "Scale Z",
    "css.item.scale3d": "3D Scale",
    "css.item.matrix": "Matrix",
    "css.item.matrix3d": "3D Matrix",
    "animation.property.title": "CSS Animation",
    "animation.property.direction": "Direction",
    "animation.property.play.state": "Play State",
    "animation.property.fill.mode": "Fill Mode",
    "animation.property.delay": "Delay",
    "animation.property.duration": "Duration",
    "animation.property.iteration.count": "Iteration Count",
    "animation.property.Select a keyframe": "Select a keyframe",
    "animation.property.popup.title": "Animation",
    "animation.property.popup.timing.function": "Timing Function",
    "animation.property.popup.keyframe": "Keyframe",
    "animation.property.popup.direction": "Direction",
    "animation.property.popup.play.state": "Play State",
    "animation.property.popup.fill.mode": "Fill Mode",
    "animation.property.popup.delay": "Delay",
    "animation.property.popup.duration": "Duration",
    "animation.property.popup.iteration": "Iteration",
    "animation.property.popup.normal": "normal",
    "animation.property.popup.reverse": "reverse",
    "animation.property.popup.alternate": "alternate",
    "animation.property.popup.alternate-reverse": "alternate-reverse",
    "animation.property.popup.none": "none",
    "animation.property.popup.forwards": "forwards",
    "animation.property.popup.backwards": "backwards",
    "animation.property.popup.both": "both",
    "animation.property.popup.Select a keyframe": "Select a keyframe",
    "keyframe.popup.title": "Keyframe",
    "code.view.property.title": "CodeView",
    "svg.filter.editor.tab.filter": "Filter",
    "svg.filter.editor.tab.preset": "Preset",
    "svg.filter.editor.tab.asset": "Assets",
    "svg.filter.editor.GRAPHIC REFERENCES": "GRAPHIC REFERENCES",
    "svg.filter.editor.SOURCES": "SOURCES",
    "svg.filter.editor.MODIFIER": "MODIFIER",
    "svg.filter.editor.LIGHTING": "LIGHTING",
    "svg.filter.editor.COMBINERS": "COMBINERS",
    "svg.filter.editor.Template": "Template",
    "layout.property.title": "Layout",
    "layout.property.flex": "Flex Box",
    "layout.property.grid": "Grid",
    "layout.property.default": "Default",
    "layout.property.resizing.title": "Resizing",
    "layout.property.resizing.self.title": "Self Resizing",
    "default.layout.item.property.title.constraints": "Constraints",
    "flex.layout.editor.row": "Row",
    "flex.layout.editor.column": "column",
    "flex.layout.editor.row-reverse": "Row Reverse",
    "flex.layout.editor.column-reverse": "Column Reverse",
    "flex.layout.editor.nowrap": "Nowrap",
    "flex.layout.editor.wrap": "Wrap",
    "flex.layout.editor.wrap-reverse": "Wrap Reverse",
    "flex.layout.editor.flex-start": "Start",
    "flex.layout.editor.flex-end": "End",
    "flex.layout.editor.center": "Center",
    "flex.layout.editor.space-between": "Between",
    "flex.layout.editor.space-around": "Around",
    "flex.layout.editor.baseline": "BaseLine",
    "flex.layout.editor.stretch": "Stretch",
    "flex.layout.editor.direction": "Direction",
    "flex.layout.editor.justify-content": "Justify Content",
    "flex.layout.editor.align-items": "Align Items",
    "flex.layout.editor.align-content": "Align Content",
    "flex.layout.item.property.title": "Flex Item Detail",
    "flex.layout.item.property.grow": "Flex Grow",
    "flex.layout.item.property.shrink": "Flex Shrink",
    "flex.layout.item.property.basis": "Flex Basis",
    "flex.layout.item.property.none": "none",
    "flex.layout.item.property.auto": "auto",
    "flex.layout.item.property.value": "value",
    "grid.layout.editor.template.columns": "Columns",
    "grid.layout.editor.column.gap": "Column Gap",
    "grid.layout.editor.template.rows": "Rows",
    "grid.layout.editor.row.gap": "Row Gap",
    "grid.box.editor.box.title": "Box",
    "grid.box.editor.type": "Type",
    "grid.box.editor.repeat": "Repeat",
    "grid.box.editor.length": "Length",
    "grid.box.editor.none": "None",
    "grid.box.editor.auto": "Auto",
    "grid.box.editor.count": "Count",
    "grid.box.editor.value": "Size",
    "grid.layout.item.property.title": "Layout Item Detail",
    "grid.layout.item.property.column": "Column",
    "grid.layout.item.property.row": "Row",
    "grid.layout.item.property.start": "Start",
    "grid.layout.item.property.end": "End",
    "grid.layout.item.property.none": "none",
    "grid.layout.item.property.value": "value",
    "box.model.property.title": "Box Model",
    "box.model.property.margin": "Margin",
    "box.model.property.padding": "Padding",
    "component.items.canvas": "Canvas",
    "component.items.layer": "Layer",
    "component.items.3dlayer": "3D Layer",
    "component.items.drawing": "Drawing",
    "component.items.custom": "Custom Component",
    "component.items.chart": "Chart",
    "component.items.plugin": "Plugin",
    "svg.text.property.title": "SVG Text Style",
    "svg.text.property.textarea": "Text Area",
    "svg.text.property.size": "Font Size",
    "svg.text.property.weight": "Font Weight",
    "svg.text.property.style": "Font Style",
    "svg.text.property.anchor": "Text Anchor",
    "svg.text.property.family": "Font Family",
    "svg.text.property.length.adjust": "Length Adjust",
    "svg.text.property.text.length": "Text Length",
    "svg.text.property.start.offset": "Start Offset",
    "fill.picker.popup.title": "SVG Fragment picker",
    "gradient.editor.drag.message": "Drag if you want to move center pointer.",
    "draw.manager.tolerance": "Tolerance",
    "pattern.property.title": "Pattern",
    "pattern.info.popup.title": "Pattern Info",
    "pattern.info.popup.width": "Width",
    "pattern.info.popup.height": "Height",
    "pattern.info.popup.lineWidth": "Line Width",
    "pattern.info.popup.lineHeight": "Line Height",
    "pattern.info.popup.rotate": "Rotate",
    "pattern.info.popup.blend": "Blend Mode",
    "pattern.info.popup.foreColor": "Fore",
    "pattern.info.popup.backColor": "Back",
    "stroke.dasharray.editor.add": "Add Dash",
    "viewport.panning.enable": "You can move the area by holding down space key and dragging the screen.",
    "image.select.editor.button": "Select Image"
  };
  var fr_FR = {
    "app.title": "elf",
    "app.sample": (a, b, c) => {
      return `${a}-${b}-${c}`;
    },
    "app.lang.en_US": "English",
    "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
    "app.lang.fr_FR": "Fran\xE7ais",
    "app.label.lang": "Langue",
    "app.layout.all": "Layout",
    "app.layout.css": "CSS Mode",
    "app.layout.svg": "SVG Mode",
    "app.label.layout": "Menu Layout",
    "app.theme.dark": "Sombre",
    "app.theme.light": "Clair",
    "app.theme.gray": "Gris",
    "app.label.theme": "Th\xE8me",
    "app.tab.title.projects": "Projets",
    "app.tab.title.layers": "Objets",
    "app.tab.title.libraries": "Librarie",
    "app.tab.title.components": "Objet",
    "app.tab.title.artboards": "Artboard",
    "app.tab.title.assets": "Elements",
    "app.tab.title.keyMap": "Clavier",
    "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
    "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
    "menu.item.download.title": "T\xE9l\xE9charger",
    "menu.item.save.title": "Enregistrer",
    "menu.item.export.title": "Exporter",
    "menu.item.codepen.title": "CodePen",
    "menu.item.fullscreen.title": "Ecran",
    "menu.item.shortcuts.title": "ShortCuts",
    "menu.item.github.title": "Github",
    "menu.item.learn.title": "Docs",
    "menu.item.projects.title": "Projects",
    "project.property.title": "Projet",
    "project.information.property.title": "Information",
    "project.information.property.name": "Nom",
    "project.information.property.description": "Description",
    "artboard.property.title": "Planche",
    "artboard.property.layout.title.flex": "Flex",
    "artboard.property.layout.title.grid": "Grille",
    "layer.tree.property.title": "Objets",
    "layer.tree.property.layout.title.flex": "Flex",
    "layer.tree.property.layout.title.grid": "Grille",
    "alignment.property.title": "Alignment",
    "position.property.title": "Position",
    "position.property.X": "X",
    "position.property.Y": "Y",
    "size.property.title": "Taille",
    "position.property.width": "Largeur",
    "position.property.height": "Hauteur",
    "position.property.opacity": "Opacity",
    "position.property.rotate": "Rotate",
    "background.color.property.title": "Apparance",
    "background.color.property.color": "Couleur",
    "background.color.property.zindex": "z-index",
    "background.color.property.opacity": "Opacit\xE9",
    "background.color.property.blend": "M\xE9lange",
    "background.color.property.overflow": "D\xE9bordement",
    "background.color.property.overflow.visible": "Visible",
    "background.color.property.overflow.hidden": "Cach\xE9",
    "background.color.property.overflow.scroll": "Scroll",
    "background.color.property.overflow.auto": "Auto",
    "blend.normal": "normal",
    "blend.multiply": "multiplie",
    "blend.screen": "\xE9cran",
    "blend.overlay": "couche",
    "blend.darken": "sombre",
    "blend.lighten": "clair",
    "blend.color-dodge": "dodge",
    "blend.color-burn": "brul\xE9",
    "blend.hard-light": "dur",
    "blend.soft-light": "doux",
    "blend.difference": 'diff"rence',
    "blend.exclusion": "exclusion",
    "blend.hue": "teinte",
    "blend.saturation": "saturation",
    "blend.color": "couleur",
    "blend.luminosity": "luminosit\xE9",
    "background.image.property.title": "Remplissage",
    "border.property.title": "Bordure",
    "border.radius.property.title": "Rayon de bordure",
    "boxshadow.property.title": "Ombres",
    "filter.property.title": "Filtre",
    "filter.property.blur": "Flou",
    "filter.property.grayscale": "Echelle de gris",
    "filter.property.hue-rotate": "Rotation teinte",
    "filter.property.invert": "Invertir",
    "filter.property.brightness": "Luminosit\xE9",
    "filter.property.contrast": "Contraste",
    "filter.property.drop-shadow": "Ombre port\xE9e",
    "filter.property.drop-shadow.color": "Couleur",
    "filter.property.drop-shadow.offsetX": "D\xE9calage X",
    "filter.property.drop-shadow.offsetY": "D\xE9calage Y",
    "filter.property.drop-shadow.blurRadius": "Flou",
    "filter.property.opacity": "Opacit\xE9",
    "filter.property.saturate": "Saturation",
    "filter.property.sepia": "S\xE9pia",
    "filter.property.svg": "SVG",
    "font.property.title": "Police",
    "font.property.color": "Couleur",
    "font.property.size": "Taille",
    "font.property.stretch": "Etirement",
    "font.property.weight": "Poids",
    "font.property.style": "Style",
    "font.property.family": "Famille",
    "font.spacing.property.title": "Espaces du texte",
    "font.spacing.property.lineHeight": "Hauteur de ligne",
    "font.spacing.property.letterSpacing": "Espace inter-caract\xE8res",
    "font.spacing.property.wordSpacing": "Espace inter-mots",
    "font.spacing.property.indent": "Identation",
    "backdrop.filter.property.title": "Filtre Backdrop",
    "clippath.property.title": "Chemin du Clip",
    "export.property.title": "Exporter",
    "export.property.download": "T\xE9l\xE9charger",
    "iframe.property.title": "IFrame",
    "image.property.title": "Image",
    "image.property.origin": "Origine",
    "image.property.size": "Taille",
    "image.property.width": "Largeur",
    "image.property.height": "Hauteur",
    "video.property.title": "Video",
    "video.property.play": "Jouer",
    "video.property.pause": "Pause",
    "video.property.volume": "Volume",
    "video.property.playbackRate": "Vitesse de lecture",
    "video.property.currentTime": "Temps actuel",
    "video.property.playTime": "Temps de lecture",
    "motion.property.title": "Mouvement",
    "text.property.title": "Style Texte",
    "text.property.align": "Alignement",
    "text.property.transform": "Transformation",
    "text.property.decoration": "D\xE9coration",
    "text.clip.property.title": "Clip Texte",
    "text.shadow.property.title": "Ombres Texte",
    "text.fill.property.title": "Remplissage Texte",
    "text.fill.property.fill": "Remplissage",
    "text.fill.property.stroke": "Trait",
    "text.fill.property.strokeWidth": "Largeur",
    "transform.property.title": "Transformation",
    "transform.origin.property.title": "Origine Transformation",
    "transition.property.title": "Transition CSS",
    "keyframe.property.title": "Image cl\xE9 CSS",
    "selector.property.title": "S\xE9l\xE9cteur",
    "selector.property.none": "Aucun s\xE9l\xE9cteur",
    "path.data.property.title": "Information Chemin",
    "polygon.data.property.title": "Information Polygone",
    "perspective.property.title": "Perspective",
    "perspective.origin.property.title": "Origine Perspective",
    "svg.item.property.title": "Appearance",
    "svg.item.property.isMotionPath": "Chemin de mouvement",
    "svg.item.property.fill": "Remplissage",
    "svg.item.property.fillOpacity": "Opacit\xE9",
    "svg.item.property.path": "Chemin",
    "svg.item.property.polygon": "Polygone",
    "svg.item.property.totalLength": "Longueur totale",
    "svg.item.property.fillRule": "R\xE8gle remplissage",
    "svg.item.property.stroke": "Trait",
    "svg.item.property.strokeWidth": "Largeur de trait",
    "svg.item.property.dashArray": "Suite tiret",
    "svg.item.property.dashOffset": "D\xE9calage tiret",
    "svg.item.property.lineCap": "Chapeau Ligne",
    "svg.item.property.lineJoin": "Jonction ligne",
    "svg.item.property.filter": "Filtre",
    "svg.item.property.blend": "Blend Mode",
    "border.editor.all": "Tout",
    "border.editor.width": "Largeur",
    "border.editor.style": "Style",
    "border.editor.color": "Couleur",
    "border.editor.top": "Haut",
    "border.editor.left": "Gauche",
    "border.editor.right": "Droite",
    "border.editor.bottom": "Bas",
    "border.radius.editor.topLeft": "Haut gauche",
    "border.radius.editor.topRight": "Haut droite",
    "border.radius.editor.bottomLeft": "Bas gauche",
    "border.radius.editor.bottomRight": "Bas droite",
    "boxshadow.editor.blur": "Flou",
    "boxshadow.editor.spread": "Etalement",
    "css.property.editor.properties": "Propri\xE9t\xE9s",
    "offset.path.list.editor.path": "Chemin",
    "offset.path.list.editor.totalLength": "Longueur totale",
    "offset.path.list.editor.distance": "Distance",
    "offset.path.list.editor.direction": "Direction",
    "offset.path.list.editor.rotate": "Rotation",
    "svgfilter.select.editor.message.create": "Cr\xE9er un filtre svg",
    "svgfilter.select.editor.message.select": "S\xE9lection filtre",
    "fill.editor.message.click.image": "Cliquez sur aper\xE7u si vous souhaitez s\xE9lectionner une image",
    "fill.editor.message.drag.position": "Prendre pour changer la position centrale",
    "fill.editor.x1": "D\xE9but X",
    "fill.editor.x2": "Fin X",
    "fill.editor.y1": "D\xE9but Y",
    "fill.editor.y2": "Fin Y",
    "fill.editor.spread": "Etalement",
    "fill.editor.offset": "D\xE9calage",
    "fill.editor.cx": "Centre X",
    "fill.editor.cy": "Centre Y",
    "fill.editor.r": "Rayon de fin",
    "fill.editor.fx": "D\xE9part X",
    "fill.editor.fy": "D\xE9part Y",
    "fill.editor.fr": "Rayon de d\xE9part",
    "perspective.origin.editor.originX": "Origine X",
    "perspective.origin.editor.originY": "Origine Y",
    "path.manager.msg": "Appuyer ESC ou Entr\xE9z keypour fermer Edition",
    "path.manager.mode.done": "Done",
    "path.manager.mode.modify": "Modifier",
    "path.manager.mode.path": "Chemin",
    "path.manager.mode.warp": "Warp",
    "path.manager.mode.transform": "Transformer",
    "path.manager.mode.reverse": "Reverse",
    "path.manager.mode.flipX": "Retouner X",
    "path.manager.mode.flipY": "Retouner Y",
    "path.manager.mode.flipOrigin": "Retouner Origine",
    "colorpicker.popup.title": "Pipette",
    "selector.popup.title": "Propi\xE9t\xE9 de S\xE9lecteur",
    "selector.popup.selector": "S\xE9lecteur",
    "background.image.position.popup.title": "Motif de fond",
    "background.image.position.popup.size": "Taille",
    "background.image.position.popup.width": "Largeur",
    "background.image.position.popup.height": "Hauteur",
    "background.image.position.popup.repeat": "Rep\xE8te",
    "background.image.position.popup.blend": "M\xE9lange",
    "background.image.position.popup.type.repeat": "rep\xE8te",
    "background.image.position.popup.type.no-repeat": "sans rep\xE9tition",
    "background.image.position.popup.type.repeat-x": "rep\xE8te-x",
    "background.image.position.popup.type.repeat-y": "rep\xE8te-y",
    "background.image.position.popup.type.space": "espace",
    "background.image.position.popup.type.round": "rond",
    "gradient.picker.popup.title": "S\xE9lection Gradient & Image",
    "image.asset.property.title": "Image",
    "video.asset.property.title": "Vid\xE9o",
    "color.asset.property.title": "Couleur",
    "gradient.asset.property.title": "Gradient",
    "pattern.asset.property.title": "Motif",
    "svgfilter.asset.property.title": "Filtre SVG",
    "inspector.tab.title.design": "Design",
    "inspector.tab.title.component": "Composant",
    "inspector.tab.title.transition": "Animation",
    "inspector.tab.title.asset": "El\xE9ments",
    "inspector.tab.title.text": "Texte",
    "inspector.tab.title.code": "Code",
    "inspector.tab.title.history": "History",
    "timeline.property.title": "Chronologie",
    "timeline.property.resize": "Drag if you want to resize timeline height.",
    "timeline.animation.property.title": "Animations",
    "timeline.play.control.play": "Jouer",
    "timeline.play.control.pause": "Pause",
    "timeline.play.control.first": "Premier",
    "timeline.play.control.prev": "Pr\xE9c\xE9dent",
    "timeline.play.control.next": "Suivant",
    "timeline.play.control.last": "Dernier",
    "timeline.play.control.direction": "Direction",
    "timeline.play.control.speed": "Vitesse",
    "timeline.play.control.repeat": "R\xE9p\xE9ter",
    "timeline.play.control.infinite": "Infini",
    "timeline.play.control.normal": "normal",
    "timeline.play.control.alternate": "alternatif",
    "timeline.play.control.reverse": "inverse",
    "timeline.play.control.alternate.reverse": "inverse alternatif",
    "timeline.value.editor.value": "Valeur",
    "timeline.value.editor.time": "Temps",
    "timeline.value.editor.timing": "Calage temps",
    "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
    "svgfilter.popup.title": "Filtre SVG",
    "css.item.rotate": "Rotation",
    "css.item.rotateX": "Rotation X",
    "css.item.rotateY": "Rotation Y",
    "css.item.rotateZ": "Rotation Z",
    "css.item.rotate3d": "Rotation 3D",
    "css.item.skewX": "Oblique X",
    "css.item.skewY": "Oblique Y",
    "css.item.translate": "Translation",
    "css.item.translateX": "Translation X",
    "css.item.translateY": "Translation Y",
    "css.item.translateZ": "Translation Z",
    "css.item.translate3d": "Translation 3D",
    "css.item.perspective": "Persp\xE9ctive",
    "css.item.scale": "Echelle",
    "css.item.scaleX": "Echelle X",
    "css.item.scaleY": "Echelle Y",
    "css.item.scaleZ": "Echelle Z",
    "css.item.scale3d": "Echelle 3D",
    "css.item.matrix": "Matrice",
    "css.item.matrix3d": "Matrice 3D",
    "animation.property.title": "Animation CSS",
    "animation.property.direction": "Direction",
    "animation.property.play.state": "Etat lecture",
    "animation.property.fill.mode": "Mode remplissage",
    "animation.property.delay": "D\xE9lais",
    "animation.property.duration": "Dur\xE9e",
    "animation.property.iteration.count": "Nombre It\xE9rations",
    "animation.property.Select a keyframe": "Selectionner une image cl\xE9",
    "animation.property.popup.title": "Animation",
    "animation.property.popup.timing.function": "Fonction temps",
    "animation.property.popup.keyframe": "image cl\xE9",
    "animation.property.popup.direction": "Direction",
    "animation.property.popup.play.state": "Etat lecture",
    "animation.property.popup.fill.mode": "Mode remplissage",
    "animation.property.popup.delay": "D\xE9lais",
    "animation.property.popup.duration": "Dur\xE9\xE9",
    "animation.property.popup.iteration": "It\xE9ration",
    "animation.property.popup.normal": "normal",
    "animation.property.popup.reverse": "inverse",
    "animation.property.popup.alternate": "alternatif",
    "animation.property.popup.alternate-reverse": "inverse alternatif",
    "animation.property.popup.none": "Aucun",
    "animation.property.popup.forwards": "en avant",
    "animation.property.popup.backwards": "en arri\xE8re",
    "animation.property.popup.both": "les deux",
    "animation.property.popup.Select a keyframe": "Selectionner une image cl\xE9",
    "keyframe.popup.title": "image cl\xE9",
    "code.view.property.title": "Vue code",
    "svg.filter.editor.tab.filter": "Filtrer",
    "svg.filter.editor.tab.preset": "Pre-rempli",
    "svg.filter.editor.tab.asset": "El\xE9ments",
    "svg.filter.editor.GRAPHIC REFERENCES": "REFERENCES GRAPHIQUES",
    "svg.filter.editor.SOURCES": "SOURCES",
    "svg.filter.editor.MODIFIER": "MODIFIER",
    "svg.filter.editor.LIGHTING": "ECLAIRAGE",
    "svg.filter.editor.COMBINERS": "COMBINER",
    "svg.filter.editor.Template": "Mod\xE8le",
    "layout.property.title": "Disposition",
    "layout.property.flex": "Bo\xEEte Flex",
    "layout.property.grid": "Grille",
    "layout.property.default": "D\xE9faut",
    "layout.property.resizing.title": "Resizing",
    "layout.property.resizing.self.title": "Self Resizing",
    "default.layout.item.property.title.constraints": "Constraints",
    "flex.layout.editor.row": "Ligne",
    "flex.layout.editor.column": "Colonne",
    "flex.layout.editor.row-reverse": "Inverse ligne",
    "flex.layout.editor.column-reverse": "Inverse Colonne",
    "flex.layout.editor.nowrap": "Non-emball\xE9",
    "flex.layout.editor.wrap": "Emball\xE9 (wrap)",
    "flex.layout.editor.wrap-reverse": "Inverse emball\xE9",
    "flex.layout.editor.flex-start": "D\xE9but",
    "flex.layout.editor.flex-end": "Fin",
    "flex.layout.editor.center": "Centrer",
    "flex.layout.editor.space-between": "Entre",
    "flex.layout.editor.space-around": "Autour",
    "flex.layout.editor.baseline": "Base",
    "flex.layout.editor.stretch": "Etirement",
    "flex.layout.editor.direction": "Direction",
    "flex.layout.editor.justify-content": "Justifier",
    "flex.layout.editor.align-items": "Aligner objets",
    "flex.layout.editor.align-content": "Aligner contenu",
    "flex.layout.item.property.title": "D\xE9tail Disposition objet",
    "flex.layout.item.property.grow": "Augmenter Flex",
    "flex.layout.item.property.shrink": "R\xE9duire Flex",
    "flex.layout.item.property.basis": "Base Flex",
    "flex.layout.item.property.none": "Aucun",
    "flex.layout.item.property.auto": "auto",
    "flex.layout.item.property.value": "valeur",
    "grid.layout.editor.template.columns": "Colonne",
    "grid.layout.editor.column.gap": "Espace Colonne",
    "grid.layout.editor.template.rows": "Lignes",
    "grid.layout.editor.row.gap": "Espace lignes",
    "grid.box.editor.box.title": "Bo\xEEte",
    "grid.box.editor.type": "Type",
    "grid.box.editor.repeat": "R\xE9p\xE9ter",
    "grid.box.editor.length": "Longueur",
    "grid.box.editor.none": "Aucun",
    "grid.box.editor.auto": "Auto",
    "grid.box.editor.count": "Compte",
    "grid.box.editor.value": "Taille",
    "grid.layout.item.property.title": "D\xE9tail disposition objets",
    "grid.layout.item.property.column": "Colonne",
    "grid.layout.item.property.row": "Ligne",
    "grid.layout.item.property.start": "D\xE9but",
    "grid.layout.item.property.end": "Fin",
    "grid.layout.item.property.none": "Aucun",
    "grid.layout.item.property.value": "valeur",
    "box.model.property.title": "Mod\xE8le",
    "box.model.property.margin": "Marge",
    "box.model.property.padding": "Espace",
    "component.items.canvas": "Toile",
    "component.items.layer": "Objet",
    "component.items.3dlayer": "Objet 3D",
    "component.items.drawing": "Dessin",
    "component.items.custom": "Composant personnalis\xE9",
    "component.items.chart": "Chart",
    "component.items.plugin": "Plugin",
    "svg.text.property.title": "Style SVG Texte",
    "svg.text.property.textarea": "Zone Texte",
    "svg.text.property.size": "Taille",
    "svg.text.property.weight": "Poids",
    "svg.text.property.style": "Style",
    "svg.text.property.anchor": "Ancre Texte",
    "svg.text.property.family": "Famille",
    "svg.text.property.length.adjust": "Ajusteement longueur",
    "svg.text.property.text.length": "Ajusteement Texte",
    "svg.text.property.start.offset": "D\xE9callage d\xE9part",
    "fill.picker.popup.title": "S\xE9lection Fragment SVG",
    "gradient.editor.drag.message": "Glisser pour d\xE9placer centre.",
    "draw.manager.tolerance": "Tol\xE9rance",
    "pattern.property.title": "Motif",
    "pattern.info.popup.title": "Info Motif",
    "pattern.info.popup.width": "Largeur",
    "pattern.info.popup.height": "Hauteur",
    "pattern.info.popup.lineWidth": "Largeur ligne",
    "pattern.info.popup.lineHeight": "Hauteur de ligne",
    "pattern.info.popup.rotate": "Rotatation",
    "pattern.info.popup.blend": "M\xE9lange",
    "pattern.info.popup.foreColor": "Avant",
    "pattern.info.popup.backColor": "Arri\xE8re",
    "stroke.dasharray.editor.add": "Ajout tiret",
    "viewport.panning.enable": "You can move the area by holding down space and dragging the screen."
  };
  var ko_KR = {
    "app.title": "elf",
    "app.sample": (a, b, c) => {
      return `${a}-${b}-${c}`;
    },
    "app.lang.en_US": "English",
    "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
    "app.lang.fr_FR": "Fran\xE7ais",
    "app.label.lang": "\uC5B8\uC5B4",
    "app.layout.all": "\uB808\uC774\uC544\uC6C3",
    "app.layout.css": "CSS \uBAA8\uB4DC",
    "app.layout.svg": "SVG \uBAA8\uB4DC",
    "app.label.layout": "\uBA54\uB274\uAD6C\uC131",
    "app.theme.dark": "\uC5B4\uB450\uC6B4",
    "app.theme.light": "\uBC1D\uC740",
    "app.theme.toon": "\uADF8\uB9AC\uAE30",
    "app.theme.gray": "\uD68C\uC0C9",
    "app.label.theme": "\uD14C\uB9C8",
    "app.tab.title.projects": "\uD504\uB85C\uC81D\uD2B8",
    "app.tab.title.layers": "\uB808\uC774\uC5B4",
    "app.tab.title.libraries": "\uB77C\uC774\uBE0C\uB7EC\uB9AC",
    "app.tab.title.components": "\uCEF4\uD3EC\uB10C\uD2B8",
    "app.tab.title.artboards": "\uC544\uD2B8\uBCF4\uB4DC",
    "app.tab.title.assets": "\uC5D0\uC14B",
    "app.tab.title.keyMap": "\uB2E8\uCD95\uD0A4",
    "app.confirm.message.artboard.items.removeArtboard": "\uC544\uD2B8\uBCF4\uB4DC \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    "app.confirm.message.custom-component.items.removeCustomComponent": "\uCEF4\uD3EC\uB10C\uD2B8 \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
    "menu.item.download.title": "\uB2E4\uC6B4\uB85C\uB4DC",
    "menu.item.save.title": "\uC800\uC7A5",
    "menu.item.export.title": "\uB0B4\uBCF4\uB0B4\uAE30",
    "menu.item.fullscreen.title": "\uC804\uCCB4\uD654\uBA74",
    "menu.item.shortcuts.title": "\uB2E8\uCD95\uD0A4",
    "menu.item.github.title": "Github",
    "menu.item.learn.title": "\uBC30\uC6B0\uAE30",
    "menu.item.projects.title": "\uD504\uB85C\uC81D\uD2B8",
    "project.property.title": "\uD504\uB85C\uC81D\uD2B8",
    "project.information.property.title": "\uD504\uB85C\uC81D\uD2B8 \uC815\uBCF4",
    "project.information.property.name": "\uC774\uB984",
    "project.information.property.description": "\uC124\uBA85",
    "artboard.property.title": "\uC544\uD2B8\uBCF4\uB4DC",
    "artboard.property.layout.title.flex": "\uD50C\uB809\uC2A4",
    "artboard.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
    "layer.tree.property.title": "\uB808\uC774\uC5B4",
    "layer.tree.property.layout.title.flex": "\uD50C\uB809\uC2A4",
    "layer.tree.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
    "alignment.property.title": "\uC815\uB82C",
    "position.property.title": "\uC704\uCE58",
    "position.property.X": "X",
    "position.property.Y": "Y",
    "size.property.title": "\uD06C\uAE30",
    "position.property.width": "\uB113\uC774",
    "position.property.height": "\uB192\uC774",
    "position.property.rotate": "\uD68C\uC804",
    "position.property.opacity": "\uD22C\uBA85",
    "background.color.property.title": "\uD45C\uC2DC",
    "background.color.property.color": "\uBC30\uACBD\uC0C9",
    "background.color.property.zindex": "z-index",
    "background.color.property.blend": "\uBE14\uB80C\uB4DC\uBAA8\uB4DC",
    "background.color.property.overflow": "\uC624\uBC84\uD50C\uB85C\uC6B0",
    "background.color.property.overflow.visible": "\uBCF4\uC774\uAE30",
    "background.color.property.overflow.hidden": "\uC228\uAE30\uAE30",
    "background.color.property.overflow.scroll": "\uC2A4\uD06C\uB864",
    "background.color.property.overflow.auto": "\uC790\uB3D9",
    "blend.normal": "Normal(\uD45C\uC900) \uD63C\uD569\uBAA8\uB4DC",
    "blend.multiply": "Multiply(\uACF1\uD558\uAE30) \uBAA8\uB4DC",
    "blend.screen": "Screen(\uC2A4\uD06C\uB9B0) \uBAA8\uB4DC ",
    "blend.overlay": "Overlay(\uC624\uBC84\uB808\uC774) \uBAA8\uB4DC",
    "blend.darken": "Darken(\uC5B4\uB461\uAE30) \uBAA8\uB4DC",
    "blend.lighten": "Lighten(\uBC1D\uAE30) \uBAA8\uB4DC ",
    "blend.color-dodge": "Color Dodge(\uCEEC\uB7EC \uB2F7\uC9C0) \uBAA8\uB4DC ",
    "blend.color-burn": "Color Burn(\uCEEC\uB7EC \uBC88) \uBAA8\uB4DC ",
    "blend.hard-light": "Hard Light(\uD558\uB4DC \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
    "blend.soft-light": "Soft Light(\uC18C\uD504\uD2B8 \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
    "blend.difference": "Difference(\uCC28\uC774) \uBAA8\uB4DC",
    "blend.exclusion": "Exclusion(\uC81C\uC678) \uBAA8\uB4DC",
    "blend.hue": "Hue(\uC0C9\uC870) \uBAA8\uB4DC ",
    "blend.saturation": "Saturation(\uCC44\uB3C4) \uBAA8\uB4DC",
    "blend.color": "Color(\uC0C9\uC0C1) \uBAA8\uB4DC",
    "blend.luminosity": "Luminosity(\uAD11\uB3C4) \uBAA8\uB4DC ",
    "background.image.property.title": "\uCC44\uC6B0\uAE30",
    "border.property.title": "\uC678\uACFD\uC120",
    "border.radius.property.title": "\uB465\uADFC \uC678\uACFD\uC120",
    "boxshadow.property.title": "\uADF8\uB9BC\uC790",
    "filter.property.title": "\uD544\uD130",
    "filter.property.blur": "\uD750\uB9BC(Blur)",
    "filter.property.grayscale": "\uD68C\uC0C9(GrayScale)",
    "filter.property.hue-rotate": "\uC0C9\uC870(HueRotate)",
    "filter.property.invert": "\uBC18\uC804(Invert)",
    "filter.property.brightness": "\uBC1D\uAE30(Brightness)",
    "filter.property.contrast": "\uB300\b\uC870(Contrast)",
    "filter.property.drop-shadow": "\uADF8\uB9BC\uC790(Drop Shadow)",
    "filter.property.drop-shadow.color": "\uC0C9",
    "filter.property.drop-shadow.offsetX": "X",
    "filter.property.drop-shadow.offsetY": "Y",
    "filter.property.drop-shadow.blurRadius": "\uD750\uB9BC",
    "filter.property.opacity": "\uD22C\uBA85\uB3C4(Opacity)",
    "filter.property.saturate": "\uCC44\uB3C4(Saturate)",
    "filter.property.sepia": "\uAC08\uC0C9\uD1A4(Sepia)",
    "filter.property.svg": "SVG",
    "font.property.title": "\uD3F0\uD2B8",
    "font.property.color": "\uC0C9",
    "font.property.size": "\uD06C\uAE30",
    "font.property.stretch": "\uBED7\uAE30",
    "font.property.weight": "\uAD75\uAE30",
    "font.property.style": "\uC2A4\uD0C0\uC77C",
    "font.property.family": "\uAE00\uAF34",
    "font.spacing.property.title": "\uD3F0\uD2B8 \uACF5\uAC04",
    "font.spacing.property.lineHeight": "\uC904 \uB192\uC774",
    "font.spacing.property.letterSpacing": "\uAE00\uC790 \uAC04\uACA9",
    "font.spacing.property.wordSpacing": "\uB2E8\uC5B4 \uAC04\uACA9",
    "font.spacing.property.indent": "\uB4E4\uC5EC\uC4F0\uAE30",
    "backdrop.filter.property.title": "\uD6C4\uBA74 \uD544\uD130",
    "clippath.property.title": "\uD074\uB9BD\uD328\uC2A4",
    "export.property.title": "\uB0B4\uBCF4\uB0B4\uAE30",
    "export.property.download": "\uB2E4\uC6B4\uB85C\uB4DC",
    "iframe.property.title": "\uC544\uC774\uD504\uB808\uC784",
    "image.property.title": "\uC774\uBBF8\uC9C0",
    "image.property.origin": "\uC6D0\uBCF8",
    "image.property.size": "\uD06C\uAE30",
    "image.property.width": "\uB113\uC774",
    "image.property.height": "\uB192\uC774",
    "video.property.title": "\uBE44\uB514\uC624",
    "video.property.play": "\uC2DC\uC791",
    "video.property.pause": "\uBA48\uCDA4",
    "video.property.volume": "\uBCFC\uB968",
    "video.property.playbackRate": "\uBE60\uB974\uAE30",
    "video.property.currentTime": "\uD604\uC7AC \uC2DC\uAC04",
    "video.property.playTime": "\uD50C\uB808\uC774 \uC2DC\uAC04 \uAC04\uACA9",
    "motion.property.title": "\uBAA8\uC158",
    "path.data.property.title": "\uD328\uC2A4 \uC815\uBCF4",
    "polygon.data.property.title": "\uD3F4\uB9AC\uACE4 \uC815\uBCF4",
    "text.property.title": "\uD14D\uC2A4\uD2B8 \uC2A4\uD0C0\uC77C",
    "text.property.align": "\uC815\uB82C",
    "text.property.transform": "\uBCC0\uD615",
    "text.property.decoration": "\uC7A5\uC2DD",
    "text.clip.property.title": "\uD14D\uC2A4\uD2B8 \uD074\uB9BD",
    "text.shadow.property.title": "\uD14D\uC2A4\uD2B8 \uADF8\uB9BC\uC790",
    "text.fill.property.title": "\uD14D\uC2A4\uD2B8 \uCC44\uC6B0\uAE30",
    "text.fill.property.fill": "\uCC44\uC6B0\uAE30",
    "text.fill.property.stroke": "\uC724\uACFD\uC120",
    "text.fill.property.strokeWidth": "\uC724\uACFD\uC120 \uAD75\uAE30",
    "transform.property.title": "\uD2B8\uB79C\uC2A4\uD3FC",
    "transform.origin.property.title": "\uD2B8\uB79C\uC2A4\uD3FC Origin",
    "transition.property.title": "CSS \uD2B8\uB79C\uC9C0\uC158",
    "keyframe.property.title": "CSS \uD0A4\uD504\uB808\uC784",
    "selector.property.title": "CSS \uC140\uB809\uD130",
    "selector.property.none": "\uC120\uD0DD\uC790 \uC5C6\uC74C",
    "perspective.property.title": "\uD22C\uC601(perspective)",
    "perspective.origin.property.title": "\uD22C\uC601 \uC911\uC2EC\uC810",
    "svg.item.property.title": "\uBCF4\uC774\uAE30",
    "svg.item.property.isMotionPath": "\uBAA8\uC158 \uD328\uC2A4",
    "svg.item.property.fill": "\uCC44\uC6B0\uAE30",
    "svg.item.property.fillOpacity": "\uD22C\uBA85\uB3C4",
    "svg.item.property.path": "\uD328\uC2A4",
    "svg.item.property.polygon": "\uD3F4\uB9AC\uACE4",
    "svg.item.property.totalLength": "\uC804\uCCB4 \uAE38\uC774",
    "svg.item.property.fillRule": "\uCC44\uC6B0\uAE30 \uADDC\uCE59",
    "svg.item.property.stroke": "\uC120",
    "svg.item.property.strokeWidth": "\uC120 \uAD75\uAE30",
    "svg.item.property.dashArray": "\uC810\uC120 \uAE38\uC774",
    "svg.item.property.dashOffset": "\uC810\uC120 \uC704\uCE58",
    "svg.item.property.lineCap": "\uC120 \uBAA8\uC591",
    "svg.item.property.lineJoin": "\uACB9\uCE5C \uC120",
    "svg.item.property.filter": "\uD544\uD130",
    "svg.item.property.blend": "\uBE14\uB80C\uB4DC",
    "border.editor.all": "\uC804\uCCB4",
    "border.editor.width": "\uD06C\uAE30",
    "border.editor.style": "\uC2A4\uD0C0\uC77C",
    "border.editor.color": "\uC0C9",
    "border.editor.top": "\uC704",
    "border.editor.left": "\uC67C\uCABD",
    "border.editor.right": "\uC624\uB978\uCABD",
    "border.editor.bottom": "\uC544\uB798",
    "border.radius.editor.topLeft": "\uC67C\uCABD \uC704",
    "border.radius.editor.topRight": "\uC624\uB978\uCABD \uC704",
    "border.radius.editor.bottomLeft": "\uC67C\uCABD \uC544\uB798",
    "border.radius.editor.bottomRight": "\uC624\uB978\uCABD \uC544\uB798",
    "boxshadow.editor.blur": "\uD750\uB9BC",
    "boxshadow.editor.spread": "\uAE38\uC774",
    "css.property.editor.properties": "\uC18D\uC131",
    "offset.path.list.editor.path": "\uD328\uC2A4",
    "offset.path.list.editor.totalLength": "\uC804\uCCB4 \uAE38\uC774",
    "offset.path.list.editor.distance": "\uAC70\uB9AC",
    "offset.path.list.editor.direction": "\uBC29\uD5A5",
    "offset.path.list.editor.rotate": "\uD68C\uC804",
    "svgfilter.select.editor.message.create": "\uC0C8\uB85C\uC6B4 SVG Filter \uB97C \uB9CC\uB4DC\uC138\uC694.",
    "svgfilter.select.editor.message.select": "\uD544\uD130\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
    "fill.editor.message.click.image": "\uC774\uBBF8\uC9C0\uB97C \uC120\uD0DD\uD558\uACE0 \uC2F6\uC73C\uBA74 \uD504\uB9AC\uBDF0 \uC601\uC5ED\uC744 \uD074\uB9AD\uD558\uC138\uC694.",
    "fill.editor.message.drag.position": "\uAC00\uC6B4\uB370 \uC704\uCE58\uB97C \uB4DC\uB798\uADF8 \uD574\uBCF4\uC138\uC694.",
    "fill.editor.x1": "\uC2DC\uC791 X",
    "fill.editor.x2": "\uB05D X",
    "fill.editor.y1": "\uC2DC\uC791 Y",
    "fill.editor.y2": "\uB05D Y",
    "fill.editor.spread": "\uD655\uC0B0",
    "fill.editor.offset": "\uC704\uCE58",
    "fill.editor.cx": "\uC911\uC2EC\uC810 X",
    "fill.editor.cy": "\uC911\uC2EC\uC810 Y",
    "fill.editor.r": "\uB05D \uBC18\uC9C0\uB984",
    "fill.editor.fx": "\uC2DC\uC791 X",
    "fill.editor.fy": "\uC2DC\uC791 Y",
    "fill.editor.fr": "\uC2DC\uC791 \uBC18\uC9C0\uB984",
    "perspective.origin.editor.originX": "\uC911\uC2EC\uC810 X",
    "perspective.origin.editor.originY": "\uC911\uC2EC\uC810 Y",
    "path.manager.msg": "\uD3B8\uC9D1\uC744 \uC885\uB8CC\uD560 \uB54C\uB294 ESC \uD0A4\uB098 Enter \uD0A4\uB97C \uB204\uB974\uC138\uC694. \uB610\uB294 \uD654\uBA74\uC744 \uD074\uB9AD\uD558\uC2DC\uBA74 \uB429\uB2C8\uB2E4.",
    "path.manager.mode.done": "\uC644\uB8CC",
    "path.manager.mode.modify": "\uC810 \uD3B8\uC9D1",
    "path.manager.mode.path": "\uC810 \uCD94\uAC00",
    "path.manager.mode.warp": "\uC6CC\uD504",
    "path.manager.mode.transform": "\uBCC0\uD615",
    "path.manager.mode.reverse": "\uC21C\uC11C\uBCC0\uACBD",
    "path.manager.mode.flipX": "X\uCD95 \uD68C\uC804",
    "path.manager.mode.flipY": "Y\uCD95 \uD68C\uC804",
    "path.manager.mode.flipOrigin": "\uC804\uCCB4 \uD68C\uC804",
    "colorpicker.popup.title": "\uC0C9\uC0C1 \uC120\uD0DD",
    "selector.popup.title": "\uC120\uD0DD\uC790 \uC18D\uC131",
    "selector.popup.selector": "\uC120\uD0DD\uC790",
    "background.image.position.popup.title": "\uBC30\uACBD \uD328\uD134",
    "background.image.position.popup.size": "\uD06C\uAE30",
    "background.image.position.popup.width": "\uB113\uC774",
    "background.image.position.popup.height": "\uB192\uC774",
    "background.image.position.popup.repeat": "\uBC18\uBCF5",
    "background.image.position.popup.blend": "\uBE14\uB80C\uB4DC",
    "background.image.position.popup.type.repeat": "\uBC18\uBCF5",
    "background.image.position.popup.type.no-repeat": "\uBC18\uBCF5 \uC548\uD568",
    "background.image.position.popup.type.repeat-x": "x\uCD95 \uBC18\uBCF5",
    "background.image.position.popup.type.repeat-y": "y\uCD95 \uBC18\uBCF5",
    "background.image.position.popup.type.space": "\uACF5\uBC31\uC720\uC9C0",
    "background.image.position.popup.type.round": "\uBC18\uC62C\uB9BC",
    "gradient.picker.popup.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 \uC774\uBBF8\uC9C0",
    "image.asset.property.title": "\uC774\uBBF8\uC9C0",
    "video.asset.property.title": "\uBE44\uB514\uC624",
    "color.asset.property.title": "\uC0C9",
    "gradient.asset.property.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8",
    "pattern.asset.property.title": "\uD328\uD134",
    "svgfilter.asset.property.title": "SVG \uD544\uD130",
    "inspector.tab.title.design": "\uB514\uC790\uC778",
    "inspector.tab.title.component": "\uCEF4\uD3EC\uB10C\uD2B8 \uC18D\uC131",
    "inspector.tab.title.transition": "\uC560\uB2C8\uBA54\uC774\uC158",
    "inspector.tab.title.asset": "\uC5D0\uC14B \uAD00\uB9AC\uC790",
    "inspector.tab.title.text": "\uD14D\uC2A4\uD2B8",
    "inspector.tab.title.code": "\uCF54\uB4DC",
    "inspector.tab.title.history": "\uAE30\uB85D",
    "timeline.property.title": "\uD0C0\uC784\uB77C\uC778",
    "timeline.property.resize": "\uD0C0\uC784\uB77C\uC778 \uB192\uC774\uB97C \uBCC0\uACBD\uD569\uB2C8\uB2E4. \uB4DC\uB798\uADF8 \uD574\uC8FC\uC138\uC694.",
    "timeline.animation.property.title": "\uC560\uB2C8\uBA54\uC774\uC158",
    "timeline.play.control.play": "\uD50C\uB808\uC774",
    "timeline.play.control.pause": "\uBA48\uCDA4",
    "timeline.play.control.first": "\uCC98\uC74C\uC73C\uB85C",
    "timeline.play.control.prev": "\uC774\uC804\uC73C\uB85C",
    "timeline.play.control.next": "\uB2E4\uC74C\uC73C\uB85C",
    "timeline.play.control.last": "\uB9C8\uC9C0\uB9C9\uC73C\uB85C",
    "timeline.play.control.direction": "\uBC29\uD5A5",
    "timeline.play.control.speed": "\uC18D\uB825",
    "timeline.play.control.repeat": "\uBC18\uBCF5",
    "timeline.play.control.infinite": "\uBB34\uD55C",
    "timeline.play.control.normal": "normal",
    "timeline.play.control.alternate": "alternate",
    "timeline.play.control.reverse": "reverse",
    "timeline.play.control.alternate.reverse": "alternate reverse",
    "timeline.value.editor.value": "\uAC12",
    "timeline.value.editor.time": "\uC2DC\uAC04",
    "timeline.value.editor.timing": "\uD0C0\uC774\uBC0D \uD568\uC218",
    "timeline.value.editor.offset.message": "Enter\uD0A4\uB97C \uC785\uB825\uD558\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.",
    "svgfilter.popup.title": "SVG \uD544\uD130",
    "css.item.rotate": "\uD68C\uC804",
    "css.item.rotateX": "X\uCD95 \uD68C\uC804",
    "css.item.rotateY": "Y\uCD95 \uD68C\uC804",
    "css.item.rotateZ": "Z\uCD95 \uD68C\uC804",
    "css.item.rotate3d": "3D \uD68C\uC804",
    "css.item.skewX": "X\uCD95 \uB298\uC774\uAE30",
    "css.item.skewY": "Y\uCD95 \uB298\uC774\uAE30",
    "css.item.translate": "\uC774\uB3D9",
    "css.item.translateX": "X\uCD95 \uC774\uB3D9",
    "css.item.translateY": "Y\uCD95 \uC774\uB3D9",
    "css.item.translateZ": "Z\uCD95 \uC774\uB3D9",
    "css.item.translate3d": "3D \uC774\uB3D9",
    "css.item.perspective": "\uC6D0\uADFC",
    "css.item.scale": "\uD06C\uAE30\uBCC0\uACBD",
    "css.item.scaleX": "X\uCD95 \uD06C\uAE30\uBCC0\uACBD",
    "css.item.scaleY": "Y\uCD95 \uD06C\uAE30\uBCC0\uACBD",
    "css.item.scaleZ": "Z\uCD95 \uD06C\uAE30\uBCC0\uACBD",
    "css.item.scale3d": "3D \uD06C\uAE30\uBCC0\uACBD",
    "css.item.matrix": "\uBCC0\uD658 \uD589\uB82C",
    "css.item.matrix3d": "3D \uBCC0\uD658 \uD589\uB82C",
    "animation.property.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
    "animation.property.direction": "\uBC29\uD5A5",
    "animation.property.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
    "animation.property.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
    "animation.property.delay": "\uB300\uAE30\uC2DC\uAC04",
    "animation.property.duration": "\uC2DC\uAC04",
    "animation.property.iteration.count": "\uBC18\uBCF5 \uD69F\uC218",
    "animation.property.select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694",
    "animation.property.popup.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
    "animation.property.popup.timing.function": "\uD0C0\uC774\uBC0D \uD568\uC218",
    "animation.property.popup.keyframe": "\uD0A4\uD504\uB808\uC784",
    "animation.property.popup.direction": "\uBC29\uD5A5",
    "animation.property.popup.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
    "animation.property.popup.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
    "animation.property.popup.delay": "\uB300\uAE30\uC2DC\uAC04",
    "animation.property.popup.duration": "\uC2DC\uAC04",
    "animation.property.popup.iteration": "\uBC18\uBCF5 \uD69F\uC218",
    "animation.property.popup.normal": "\uC2DC\uAC04\uC21C",
    "animation.property.popup.reverse": "\uC5ED\uC2DC\uAC04\uC21C",
    "animation.property.popup.alternate": "\uC655\uBCF5 \uC2DC\uAC04\uC21C",
    "animation.property.popup.alternate-reverse": "\uC655\uBCF5 \uC5ED\uC2DC\uAC04\uC21C",
    "animation.property.popup.none": "none",
    "animation.property.popup.forwards": "forwards",
    "animation.property.popup.backwards": "backwards",
    "animation.property.popup.both": "both",
    "animation.property.popup.Select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.",
    "keyframe.popup.title": "\uD0A4\uD504\uB808\uC784",
    "code.view.property.title": "\uCF54\uB4DC\uBDF0",
    "svg.filter.editor.tab.filter": "\uD544\uD130",
    "svg.filter.editor.tab.preset": "\uD504\uB9AC\uC14B",
    "svg.filter.editor.tab.asset": "\uC5D0\uC14B",
    "svg.filter.editor.GRAPHIC REFERENCES": "\uCC38\uC870 \uADF8\uB798\uD53D",
    "svg.filter.editor.SOURCES": "\uC6D0\uBCF8",
    "svg.filter.editor.MODIFIER": "\uC218\uC815",
    "svg.filter.editor.LIGHTING": "\uBE5B",
    "svg.filter.editor.COMBINERS": "\uACB0\uD569",
    "svg.filter.editor.Template": "\uD15C\uD50C\uB9BF",
    "layout.property.title": "\uB808\uC774\uC544\uC6C3",
    "layout.property.flex": "\uD50C\uB809\uC2A4 \uBC15\uC2A4",
    "layout.property.grid": "\uADF8\uB9AC\uB4DC",
    "layout.property.default": "\uAE30\uBCF8 \uC88C\uD45C",
    "layout.property.resizing.title": "\uC0AC\uC774\uC988 \uC870\uC808",
    "layout.property.resizing.self.title": "\uC544\uC774\uD15C \uC0AC\uC774\uC988 \uC870\uC808",
    "default.layout.item.property.title.constraints": "Constraints",
    "flex.layout.editor.row": "\uD589",
    "flex.layout.editor.column": "\uC5F4",
    "flex.layout.editor.row-reverse": "\uC5ED\uBC29\uD5A5 \uD589",
    "flex.layout.editor.column-reverse": "\uC5ED\uBC29\uD5A5 \uC5F4",
    "flex.layout.editor.nowrap": "\uAC10\uC2F8\uC9C0 \uC54A\uAE30",
    "flex.layout.editor.wrap": "\uAC10\uC2F8\uAE30",
    "flex.layout.editor.wrap-reverse": "\uC5ED\uBC29\uD5A5 \uAC10\uC2F8\uAE30",
    "flex.layout.editor.flex-start": "\uC2DC\uC791",
    "flex.layout.editor.flex-end": "\uB05D",
    "flex.layout.editor.center": "\uC911\uAC04",
    "flex.layout.editor.space-between": "\uACF5\uAC04 \uC911\uAC04 \uCC44\uC6C0",
    "flex.layout.editor.space-around": "\uACF5\uAC04 \uC591\uB05D \uCC44\uC6C0",
    "flex.layout.editor.baseline": "\uAE30\uBCF8\uC120",
    "flex.layout.editor.stretch": "\uD3BC\uCE58\uAE30",
    "flex.layout.editor.direction": "\uBC29\uD5A5",
    "flex.layout.editor.justify-content": "\uCEE8\uD150\uCE20 \uC870\uC815",
    "flex.layout.editor.align-items": "\uC544\uC774\uD15C \uC815\uB82C",
    "flex.layout.editor.align-content": "\uCEE8\uD150\uCE20 \uC815\uB82C",
    "flex.layout.item.property.title": "\uD50C\uB809\uC2A4 \uC544\uC774\uD15C \uC124\uC815",
    "flex.layout.item.property.grow": "\uACF5\uAC04 \uBE44\uC728",
    "flex.layout.item.property.shrink": "\uCD95\uC18C \uBE44\uC728",
    "flex.layout.item.property.basis": "\uCD08\uAE30 \uD06C\uAE30",
    "flex.layout.item.property.none": "\uC5C6\uC74C",
    "flex.layout.item.property.auto": "\uC790\uB3D9",
    "flex.layout.item.property.value": "\uAC12",
    "grid.layout.editor.template.columns": "\uC5F4",
    "grid.layout.editor.column.gap": "\uC5F4 \uAC04\uACA9",
    "grid.layout.editor.template.rows": "\uD589",
    "grid.layout.editor.row.gap": "\uD589 \uAC04\uACA9",
    "grid.box.editor.box.title": "\uC601\uC5ED",
    "grid.box.editor.type": "\uD0C0\uC785",
    "grid.box.editor.repeat": "\uBC18\uBCF5",
    "grid.box.editor.length": "\uAE38\uC774",
    "grid.box.editor.none": "\uC5C6\uC74C",
    "grid.box.editor.auto": "\uC790\uB3D9",
    "grid.box.editor.count": "\uAC1C\uC218",
    "grid.box.editor.value": "\uD06C\uAE30",
    "grid.layout.item.property.title": "\uADF8\uB9AC\uB4DC \uC544\uC774\uD15C \uC124\uC815",
    "grid.layout.item.property.column": "\uC5F4",
    "grid.layout.item.property.row": "\uD589",
    "grid.layout.item.property.start": "\uC2DC\uC791",
    "grid.layout.item.property.End": "\uB05D",
    "grid.layout.item.property.none": "\uC5C6\uC74C",
    "grid.layout.item.property.value": "\uAC12",
    "box.model.property.title": "\uBC15\uC2A4 \uBAA8\uB378",
    "box.model.property.margin": "\uB9C8\uC9C4",
    "box.model.property.padding": "\uD328\uB529",
    "component.items.canvas": "\uCE94\uBC84\uC2A4",
    "component.items.layer": "\uB808\uC774\uC5B4",
    "component.items.3dlayer": "3D \uB808\uC774\uC5B4",
    "component.items.drawing": "\uADF8\uB9AC\uAE30",
    "component.items.custom": "\uC0AC\uC6A9\uC790 \uC815\uC758 \uCEF4\uD3EC\uB10C\uD2B8",
    "component.items.chart": "\uCC28\uD2B8",
    "component.items.plugin": "\uD50C\uB7EC\uADF8\uC778",
    "svg.text.property.title": "SVG Text \uC2A4\uD0C0\uC77C",
    "svg.text.property.textarea": "\uD14D\uC2A4\uD2B8 \uC785\uB825",
    "svg.text.property.size": "\uD3F0\uD2B8 \uD06C\uAE30",
    "svg.text.property.weight": "\uD3F0\uD2B8 \uAD75\uAE30",
    "svg.text.property.style": "\uD3F0\uD2B8 \uC2A4\uD0C0\uC77C",
    "svg.text.property.anchor": "\uD14D\uC2A4\uD2B8 \uC704\uCE58",
    "svg.text.property.family": "\uD3F0\uD2B8 \uAE00\uAF34",
    "svg.text.property.length.adjust": "\uAE38\uC774 \uB300\uC751",
    "svg.text.property.text.length": "\uD14D\uC2A4\uD2B8 \uAE38\uC774",
    "svg.text.property.start.offset": "\uC2DC\uC791 \uC9C0\uC810",
    "fill.picker.popup.title": "\uC0C9 \uCC44\uC6B0\uAE30",
    "gradient.editor.drag.message": "\uB4DC\uB798\uADF8 \uD558\uBA74 \uC911\uC2EC\uC810\uC744 \uC62E\uAE38 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
    "draw.manager.tolerance": "\uD3EC\uC778\uD2B8 \uD5C8\uC6A9 \uC624\uCC28",
    "pattern.property.title": "\uD328\uD134",
    "pattern.info.popup.title": "\uD328\uD134 \uC815\uBCF4",
    "pattern.info.popup.width": "\uB113\uC774",
    "pattern.info.popup.height": "\uB192\uC774",
    "pattern.info.popup.lineWidth": "\uC120 \uB113\uC774",
    "pattern.info.popup.lineHeight": "\uC120 \uB192\uC774",
    "pattern.info.popup.rotate": "\uD68C\uC804",
    "pattern.info.popup.blend": "\uBE14\uB80C\uB4DC",
    "pattern.info.popup.foreColor": "\uD328\uD134\uC0C9",
    "pattern.info.popup.backColor": "\uBC30\uACBD\uC0C9",
    "stroke.dasharray.editor.add": "\uC810 \uCD94\uAC00",
    "viewport.panning.enable": "space \uB97C \uB204\uB978\uCC44 \uD654\uBA74\uC744 \uB4DC\uB798\uADF8 \uD558\uBA74 \uC601\uC5ED\uC744 \uC6C0\uC9C1\uC77C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  };
  var locales = {
    en_US,
    fr_FR,
    ko_KR
  };
  function defaultMessages(editor2) {
    Object.keys(locales).forEach(function(locale) {
      editor2.registerI18nMessage(locale, locales[locale]);
    });
  }
  var add_artboard = {
    category: "Tool",
    key: "a",
    command: "addLayerView",
    args: ["artboard"],
    description: "Add ArtBoard",
    when: "CanvasView"
  };
  var __glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_artboard
  }, Symbol.toStringTag, { value: "Module" }));
  var add_artboard_pan = {
    category: "Tool",
    key: "a",
    command: "addLayerView",
    args: ["artboard"],
    description: "Add ArtBoard",
    when: "LayerAppendView"
  };
  var __glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_artboard_pan
  }, Symbol.toStringTag, { value: "Module" }));
  var add_brush = {
    category: "Tool",
    key: "b",
    command: "addLayerView",
    args: ["brush"],
    description: "Draw SVG Path",
    when: "CanvasView"
  };
  var __glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_brush
  }, Symbol.toStringTag, { value: "Module" }));
  var add_circle = {
    category: "Tool",
    key: "o",
    command: "addLayerView",
    args: ["circle"],
    description: "Add circle layer",
    when: "CanvasView"
  };
  var __glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_circle
  }, Symbol.toStringTag, { value: "Module" }));
  var add_circle_l = {
    category: "Tool",
    key: "l",
    command: "addLayerView",
    args: ["circle"],
    description: "Add circle layer",
    when: "CanvasView"
  };
  var __glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_circle_l
  }, Symbol.toStringTag, { value: "Module" }));
  var add_path = {
    category: "Tool",
    key: "p",
    command: "addLayerView",
    args: ["path"],
    description: "Add SVG Path layer",
    when: "CanvasView"
  };
  var __glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_path
  }, Symbol.toStringTag, { value: "Module" }));
  var add_rect = {
    category: "Tool",
    key: "r",
    command: "addLayerView",
    args: [
      "rect",
      {
        backgroundColor: "gray"
      }
    ],
    description: "Add rect layer",
    when: "CanvasView"
  };
  var __glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_rect
  }, Symbol.toStringTag, { value: "Module" }));
  var add_rect_m = {
    category: "Tool",
    key: "m",
    command: "addLayerView",
    args: ["rect"],
    description: "Add rect layer",
    when: "CanvasView"
  };
  var __glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_rect_m
  }, Symbol.toStringTag, { value: "Module" }));
  var add_rect_pan = {
    category: "Tool",
    key: "r",
    command: "addLayerView",
    args: [
      "rect",
      {
        backgroundColor: "gray"
      }
    ],
    description: "Add rect layer",
    when: "LayerAppendView"
  };
  var __glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_rect_pan
  }, Symbol.toStringTag, { value: "Module" }));
  var add_text = {
    category: "Tool",
    key: "t",
    command: "addLayerView",
    args: ["text"],
    description: "Add text layer",
    when: "CanvasView"
  };
  var __glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": add_text
  }, Symbol.toStringTag, { value: "Module" }));
  var clipboard_copy = {
    category: "Edit",
    key: "cmd+c",
    command: "clipboard.copy",
    description: "Copy objects",
    when: "CanvasView"
  };
  var __glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": clipboard_copy
  }, Symbol.toStringTag, { value: "Module" }));
  var clipboard_paste = {
    category: "Edit",
    key: "cmd+v",
    win: "ctrl+v",
    command: "clipboard.paste",
    description: "Paste selected objects",
    when: "CanvasView"
  };
  var __glob_0_11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": clipboard_paste
  }, Symbol.toStringTag, { value: "Module" }));
  var escape = {
    category: "Tool",
    key: "escape",
    command: "select.none",
    description: "None selection",
    when: "CanvasView"
  };
  var __glob_0_12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": escape
  }, Symbol.toStringTag, { value: "Module" }));
  var group_item = {
    category: "Group",
    key: "cmd+g",
    win: "ctrl+g",
    command: "group.item",
    description: "Grouping selected items",
    when: "CanvasView"
  };
  var __glob_0_13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": group_item
  }, Symbol.toStringTag, { value: "Module" }));
  var history_redo = {
    category: "History",
    key: "cmd+shift+z",
    win: "ctrl+shift+z",
    command: "history.redo",
    description: "redoing in history",
    when: "CanvasView"
  };
  var __glob_0_14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_redo
  }, Symbol.toStringTag, { value: "Module" }));
  var history_undo = {
    category: "History",
    key: "cmd+z",
    win: "ctrl+z",
    command: "history.undo",
    description: "undoing in history",
    when: "CanvasView"
  };
  var __glob_0_15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": history_undo
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_alt_down = {
    category: "Layer",
    key: "Alt+ArrowDown",
    command: "moveLayer",
    description: "move 5px to down",
    args: [0, 5],
    when: "CanvasView"
  };
  var __glob_0_16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_alt_down
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_alt_left = {
    category: "Layer",
    key: "Alt+ArrowLeft",
    command: "moveLayer",
    description: "move 5px to left",
    args: [-5, 0],
    when: "CanvasView"
  };
  var __glob_0_17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_alt_left
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_alt_right = {
    category: "Layer",
    key: "Alt+ArrowRight",
    command: "moveLayer",
    description: "move 5px to right",
    args: [5, 0],
    when: "CanvasView"
  };
  var __glob_0_18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_alt_right
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_alt_up = {
    category: "Layer",
    key: "Alt+ArrowUp",
    command: "moveLayer",
    description: "move 5px to up",
    args: [0, -5],
    when: "CanvasView"
  };
  var __glob_0_19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_alt_up
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_down = {
    category: "Layer",
    key: "[",
    command: "history.send.backward",
    description: "move layer to below",
    args: ["send backward"],
    when: "CanvasView"
  };
  var __glob_0_20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_down
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_depth_up = {
    category: "Layer",
    key: "]",
    command: "history.bring.forward",
    description: "move layer to above",
    args: ["bring forward"],
    when: "CanvasView"
  };
  var __glob_0_21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_depth_up
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_key_down = {
    category: "Layer",
    key: "ArrowDown",
    command: "moveLayer",
    description: "move 1px to down",
    args: [0, 1],
    when: "CanvasView"
  };
  var __glob_0_22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_key_down
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_key_left = {
    category: "Layer",
    key: "ArrowLeft",
    command: "moveLayer",
    description: "move 1px to left",
    args: [-1, 0],
    when: "CanvasView"
  };
  var __glob_0_23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_key_left
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_key_right = {
    category: "Layer",
    key: "ArrowRight",
    command: "moveLayer",
    description: "move 1px to right",
    args: [1, 0],
    when: "CanvasView"
  };
  var __glob_0_24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_key_right
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_key_up = {
    category: "Layer",
    key: "ArrowUp",
    command: "moveLayer",
    description: "move 1px to up",
    args: [0, -1],
    when: "CanvasView"
  };
  var __glob_0_25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_key_up
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_shift_down = {
    category: "Layer",
    key: "Shift+ArrowDown",
    command: "moveLayer",
    description: "move 10px to down",
    args: [0, 10],
    when: "CanvasView"
  };
  var __glob_0_26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_shift_down
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_shift_left = {
    category: "Layer",
    key: "Shift+ArrowLeft",
    command: "moveLayer",
    description: "move 10px to left",
    args: [-10, 0],
    when: "CanvasView"
  };
  var __glob_0_27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_shift_left
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_shift_right = {
    category: "Layer",
    key: "Shift+ArrowRight",
    command: "moveLayer",
    description: "move 10px to right",
    args: [10, 0],
    when: "CanvasView"
  };
  var __glob_0_28 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_shift_right
  }, Symbol.toStringTag, { value: "Module" }));
  var item_move_shift_up = {
    category: "Layer",
    key: "Shift+ArrowUp",
    command: "moveLayer",
    description: "move 10px to up",
    args: [0, -10],
    when: "CanvasView"
  };
  var __glob_0_29 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_move_shift_up
  }, Symbol.toStringTag, { value: "Module" }));
  var item_rotate_meta_left = {
    category: "Layer",
    key: "Meta+ArrowLeft",
    command: "rotateLayer",
    description: "rotate to left",
    args: [-5],
    when: "CanvasView"
  };
  var __glob_0_30 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_rotate_meta_left
  }, Symbol.toStringTag, { value: "Module" }));
  var item_rotate_meta_right = {
    category: "Layer",
    key: "Meta+ArrowRight",
    command: "rotateLayer",
    description: "rotate to right",
    args: [5],
    when: "CanvasView"
  };
  var __glob_0_31 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": item_rotate_meta_right
  }, Symbol.toStringTag, { value: "Module" }));
  var removeLayer = {
    category: "Layer",
    key: "Backspace",
    command: "history.removeLayer",
    description: "Delete selected items",
    args: ["Delete selected items"],
    when: "CanvasView"
  };
  var __glob_0_32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeLayer
  }, Symbol.toStringTag, { value: "Module" }));
  var removeLayerByDeleteKey = {
    category: "Layer",
    key: "Delete",
    command: "history.removeLayer",
    description: "Delete selected items",
    args: ["Delete selected items"],
    when: "CanvasView"
  };
  var __glob_0_33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": removeLayerByDeleteKey
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_delete = {
    category: "Path",
    key: "Backspace",
    command: "segment.delete",
    description: "Delete selected segment",
    when: "PathEditorView"
  };
  var __glob_0_34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_delete
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_alt_down = {
    category: "Path",
    key: "Alt+ArrowDown",
    command: "segment.move.down",
    description: "move 5px to down",
    args: [{ dy: 5 }],
    when: "PathEditorView"
  };
  var __glob_0_35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_alt_down
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_alt_left = {
    category: "Path",
    key: "Alt+ArrowLeft",
    command: "segment.move.left",
    description: "move 5px to left",
    args: [{ dx: 5 }],
    when: "PathEditorView"
  };
  var __glob_0_36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_alt_left
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_alt_right = {
    category: "Path",
    key: "Alt+ArrowRight",
    command: "segment.move.right",
    description: "move 5px to right",
    args: [{ dx: 5 }],
    when: "PathEditorView"
  };
  var __glob_0_37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_alt_right
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_alt_up = {
    category: "Path",
    key: "Alt+ArrowUp",
    command: "segment.move.up",
    description: "move 5px to up ",
    args: [{ dy: 5 }],
    when: "PathEditorView"
  };
  var __glob_0_38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_alt_up
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_key_down = {
    category: "Path",
    key: "ArrowDown",
    command: "segment.move.down",
    description: "move 1px to down",
    args: [{ dy: 1 }],
    when: "PathEditorView"
  };
  var __glob_0_39 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_key_down
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_key_left = {
    category: "Path",
    key: "ArrowLeft",
    command: "segment.move.left",
    description: "move 1px to left",
    args: [{ dx: 1 }],
    when: "PathEditorView"
  };
  var __glob_0_40 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_key_left
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_key_right = {
    category: "Path",
    key: "ArrowRight",
    command: "segment.move.right",
    description: "move 1px to right",
    args: [{ dx: 1 }],
    when: "PathEditorView"
  };
  var __glob_0_41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_key_right
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_key_up = {
    category: "Path",
    key: "ArrowUp",
    command: "segment.move.up",
    description: "move 1px to up",
    args: [{ dy: 1 }],
    when: "PathEditorView"
  };
  var __glob_0_42 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_key_up
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_shift_down = {
    category: "Path",
    key: "Shift+ArrowDown",
    command: "segment.move.down",
    description: "move 10px to down",
    args: [{ dy: 10 }],
    when: "PathEditorView"
  };
  var __glob_0_43 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_shift_down
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_shift_left = {
    category: "Path",
    key: "Shift+ArrowLeft",
    command: "segment.move.left",
    description: "move 10px to left",
    args: [{ dx: 10 }],
    when: "PathEditorView"
  };
  var __glob_0_44 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_shift_left
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_shift_right = {
    category: "Path",
    key: "Shift+ArrowRight",
    command: "segment.move.right",
    description: "move 10px to right",
    args: [{ dx: 10 }],
    when: "PathEditorView"
  };
  var __glob_0_45 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_shift_right
  }, Symbol.toStringTag, { value: "Module" }));
  var segment_move_shift_up = {
    category: "Path",
    key: "Shift+ArrowUp",
    command: "segment.move.up",
    description: "move 10px to up",
    args: [{ dy: 10 }],
    when: "PathEditorView"
  };
  var __glob_0_46 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": segment_move_shift_up
  }, Symbol.toStringTag, { value: "Module" }));
  var select_all = {
    category: "Tool",
    key: "CMD+A",
    win: "CTRL+A",
    command: "select.all",
    description: "Selection all layers"
  };
  var __glob_0_47 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": select_all
  }, Symbol.toStringTag, { value: "Module" }));
  var select_view = {
    category: "Tool",
    key: "v",
    command: "addLayerView",
    args: ["select"],
    description: "Selection"
  };
  var __glob_0_48 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": select_view
  }, Symbol.toStringTag, { value: "Module" }));
  var set_tool_hand = {
    category: "Tools",
    key: "h",
    command: "toggleHandTool",
    description: "set hand tool on",
    when: "CanvasView"
  };
  var __glob_0_49 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": set_tool_hand
  }, Symbol.toStringTag, { value: "Module" }));
  var set_tool_hand_m = {
    category: "Tools",
    key: "h",
    command: "toggleHandTool",
    description: "set hand tool on",
    when: "LayerAppendView"
  };
  var __glob_0_50 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": set_tool_hand_m
  }, Symbol.toStringTag, { value: "Module" }));
  var show_pan = {
    category: "Tool",
    key: "space",
    command: "showPan",
    description: "Show panning area",
    when: "CanvasView"
  };
  var __glob_0_51 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": show_pan
  }, Symbol.toStringTag, { value: "Module" }));
  var ungroup_item = {
    category: "Group",
    key: "shift+cmd+g",
    win: "shift+ctrl+g",
    command: "ungroup.item",
    description: "Ungrouping selected group layer",
    when: "CanvasView"
  };
  var __glob_0_52 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": ungroup_item
  }, Symbol.toStringTag, { value: "Module" }));
  var zoom_default = {
    category: "View",
    key: "0",
    command: "zoom.default",
    description: "zoom by scale 1",
    when: "CanvasView"
  };
  var __glob_0_53 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": zoom_default
  }, Symbol.toStringTag, { value: "Module" }));
  var zoom_in = {
    category: "View",
    key: "Equal",
    command: "zoom.in",
    description: "zoom in",
    when: "CanvasView"
  };
  var __glob_0_54 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": zoom_in
  }, Symbol.toStringTag, { value: "Module" }));
  var zoom_out = {
    category: "View",
    key: "minus",
    command: "zoom.out",
    description: "zoom Out",
    when: "CanvasView"
  };
  var __glob_0_55 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": zoom_out
  }, Symbol.toStringTag, { value: "Module" }));
  const modules = { "./shortcuts_list/add.artboard.js": __glob_0_0, "./shortcuts_list/add.artboard.pan.js": __glob_0_1, "./shortcuts_list/add.brush.js": __glob_0_2, "./shortcuts_list/add.circle.js": __glob_0_3, "./shortcuts_list/add.circle.l.js": __glob_0_4, "./shortcuts_list/add.path.js": __glob_0_5, "./shortcuts_list/add.rect.js": __glob_0_6, "./shortcuts_list/add.rect.m.js": __glob_0_7, "./shortcuts_list/add.rect.pan.js": __glob_0_8, "./shortcuts_list/add.text.js": __glob_0_9, "./shortcuts_list/clipboard.copy.js": __glob_0_10, "./shortcuts_list/clipboard.paste.js": __glob_0_11, "./shortcuts_list/escape.js": __glob_0_12, "./shortcuts_list/group.item.js": __glob_0_13, "./shortcuts_list/history.redo.js": __glob_0_14, "./shortcuts_list/history.undo.js": __glob_0_15, "./shortcuts_list/item.move.alt.down.js": __glob_0_16, "./shortcuts_list/item.move.alt.left.js": __glob_0_17, "./shortcuts_list/item.move.alt.right.js": __glob_0_18, "./shortcuts_list/item.move.alt.up.js": __glob_0_19, "./shortcuts_list/item.move.depth.down.js": __glob_0_20, "./shortcuts_list/item.move.depth.up.js": __glob_0_21, "./shortcuts_list/item.move.key.down.js": __glob_0_22, "./shortcuts_list/item.move.key.left.js": __glob_0_23, "./shortcuts_list/item.move.key.right.js": __glob_0_24, "./shortcuts_list/item.move.key.up.js": __glob_0_25, "./shortcuts_list/item.move.shift.down.js": __glob_0_26, "./shortcuts_list/item.move.shift.left.js": __glob_0_27, "./shortcuts_list/item.move.shift.right.js": __glob_0_28, "./shortcuts_list/item.move.shift.up.js": __glob_0_29, "./shortcuts_list/item.rotate.meta.left.js": __glob_0_30, "./shortcuts_list/item.rotate.meta.right.js": __glob_0_31, "./shortcuts_list/removeLayer.js": __glob_0_32, "./shortcuts_list/removeLayerByDeleteKey.js": __glob_0_33, "./shortcuts_list/segment.delete.js": __glob_0_34, "./shortcuts_list/segment.move.alt.down.js": __glob_0_35, "./shortcuts_list/segment.move.alt.left.js": __glob_0_36, "./shortcuts_list/segment.move.alt.right.js": __glob_0_37, "./shortcuts_list/segment.move.alt.up.js": __glob_0_38, "./shortcuts_list/segment.move.key.down.js": __glob_0_39, "./shortcuts_list/segment.move.key.left.js": __glob_0_40, "./shortcuts_list/segment.move.key.right.js": __glob_0_41, "./shortcuts_list/segment.move.key.up.js": __glob_0_42, "./shortcuts_list/segment.move.shift.down.js": __glob_0_43, "./shortcuts_list/segment.move.shift.left.js": __glob_0_44, "./shortcuts_list/segment.move.shift.right.js": __glob_0_45, "./shortcuts_list/segment.move.shift.up.js": __glob_0_46, "./shortcuts_list/select.all.js": __glob_0_47, "./shortcuts_list/select.view.js": __glob_0_48, "./shortcuts_list/set.tool.hand.js": __glob_0_49, "./shortcuts_list/set.tool.hand.m.js": __glob_0_50, "./shortcuts_list/show.pan.js": __glob_0_51, "./shortcuts_list/ungroup.item.js": __glob_0_52, "./shortcuts_list/zoom.default.js": __glob_0_53, "./shortcuts_list/zoom.in.js": __glob_0_54, "./shortcuts_list/zoom.out.js": __glob_0_55 };
  var shortcuts$1 = Object.values(modules).map((it) => it.default);
  function shortcuts(editor2) {
    shortcuts$1.forEach((shortcut) => {
      editor2.registerShortCut(shortcut);
    });
  }
  var designEditorPlugins = [
    configs,
    commands,
    menus,
    shortcuts,
    defaultMessages,
    defaultItems,
    defaultPatterns,
    defaultIcons,
    rendererJson,
    propertyEditor,
    gradient,
    layertab,
    inspector,
    depth,
    alignment,
    position,
    layout,
    boxModel,
    pathTool,
    artboard,
    svgText,
    font,
    text,
    textShadow,
    content,
    appearance,
    component,
    backgroundImage,
    patternAsset,
    border,
    borderRadius,
    video,
    image,
    svgFilterAsset,
    svgItem,
    layerTree,
    backgroundClip,
    borderImage,
    filter,
    backdropFilter,
    boxShadow,
    clipPath,
    exportResource,
    transition,
    keyframe,
    animation,
    selector,
    codeview,
    history,
    project,
    selectionInfoView,
    selectionToolView,
    guideLineView,
    layerAppendView,
    lineView,
    hoverView,
    pathDrawView,
    pathEditorView,
    gradientEditorView,
    fillEditorView,
    ClippathEditorView,
    imageAsset,
    sample,
    function(editor$1) {
      editor$1.registerMenu("context.menu.layer2", [
        {
          type: "button",
          title: "Layer"
        }
      ]);
      editor$1.registerMenu("context.menu.layer", [
        {
          type: "button",
          title: "Sample"
        },
        {
          type: "button",
          title: "Sample"
        },
        {
          type: "button",
          title: "Sample",
          action: (editor2) => {
            console.log(editor2);
          }
        },
        {
          type: "button",
          title: "Sample"
        },
        {
          type: "dropdown",
          title: "dropdown",
          items: [
            {
              title: "menu.item.fullscreen.title",
              command: "toggle.fullscreen",
              shortcut: "ALT+/",
              closable: true
            }
          ]
        }
      ]);
      editor$1.registerUI("context.menu", {
        ContextMenuView: editor.ContextMenuView
      });
    }
  ];
  var CanvasView$1 = "";
  var DragAreaView$1 = "";
  class DragAreaRectView extends editor.EditorElement {
    initState() {
      return {
        mode: "selection",
        x: 0,
        y: 0,
        width: 1e4,
        height: 1e4,
        cachedCurrentElement: {},
        html: ""
      };
    }
    template() {
      return `
            <div class="elf--drag-area-view" ref="$dragAreaView" style="pointer-events:none;">
                <div class='drag-area-rect' ref='$dragAreaRect'></div>
            </div>            
        `;
    }
    [sapa.SUBSCRIBE("drawAreaView")](style2) {
      this.refs.$dragAreaRect.css(style2);
    }
    [sapa.SUBSCRIBE("initDrawAreaView")]() {
      this.trigger("drawAreaView", {
        left: editor.Length.px(-1e4),
        top: editor.Length.px(0),
        width: editor.Length.px(0),
        height: editor.Length.px(0)
      });
    }
    [sapa.SUBSCRIBE("startDragAreaView")]() {
      this.initMousePoint = this.$viewport.getWorldPosition();
      this.dragRect = {
        left: editor.Length.px(this.initMousePoint[0]),
        top: editor.Length.px(this.initMousePoint[1]),
        width: editor.Length.px(0),
        height: editor.Length.px(0)
      };
      this.trigger("drawAreaView", this.dragRect);
    }
    getSelectedItems(rect2, areaVerties) {
      var project2 = this.$context.selection.currentProject;
      let items = [];
      let selectedArtboard = [];
      if (project2) {
        if (rect2.width === 0 && rect2.height === 0) {
          items = [];
        } else {
          project2.layers.forEach((layer) => {
            if (layer.is("artboard") && layer.isIncludeByArea(areaVerties)) {
              selectedArtboard.push(layer);
            } else if (layer.is("artboard") && layer.checkInArea(areaVerties) && layer.hasChildren() === false) {
              items.push(layer);
            } else {
              items.push.apply(items, layer.checkInAreaForAll(areaVerties));
            }
          });
          items = items.filter((it) => {
            return it.isDragSelectable;
          });
          if (items.length > 1) {
            items = items.filter((it) => {
              return it.is("artboard") === false;
            });
          }
        }
      }
      const selectedItems = selectedArtboard.length ? selectedArtboard : items;
      return selectedItems;
    }
    [sapa.SUBSCRIBE("moveDragAreaView")]() {
      const e = this.$config.get("bodyEvent");
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
      if (e.shiftKey) {
        newDist[1] = newDist[0];
      }
      const startVertex = floor([], this.initMousePoint);
      const endVertex = floor([], add([], this.initMousePoint, newDist));
      const start = this.$viewport.applyVertex(startVertex);
      const end = this.$viewport.applyVertex(endVertex);
      const locaRect = toRectVerties([start, end]);
      this.dragRect = {
        left: locaRect[0][0],
        top: locaRect[0][1],
        width: Math.abs(locaRect[1][0] - locaRect[0][0]),
        height: Math.abs(locaRect[3][1] - locaRect[0][1])
      };
      this.trigger("drawAreaView", {
        left: editor.Length.px(this.dragRect.left),
        top: editor.Length.px(this.dragRect.top),
        width: editor.Length.px(this.dragRect.width),
        height: editor.Length.px(this.dragRect.height)
      });
      var { left: x, top: y, width: width2, height } = this.dragRect;
      var rect2 = {
        x,
        y,
        width: width2,
        height
      };
      const selectedItems = this.getSelectedItems(rect2, toRectVertiesWithoutTransformOrigin([startVertex, endVertex]));
      this.$context.selection.selectByGroup(...selectedItems);
    }
    [sapa.SUBSCRIBE("endDragAreaView")]() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
      this.$config.init("set.move.control.point", false);
      if (newDist[0] === 0 && newDist[1] === 0) {
        this.$context.selection.empty();
      }
      this.trigger("initDrawAreaView");
      this.$context.selection.reselect();
      this.$commands.emit("history.refreshSelection");
    }
  }
  class DragAreaView extends editor.EditorElement {
    initState() {
      return {
        mode: "selection",
        x: 0,
        y: 0,
        width: 1e4,
        height: 1e4,
        cachedCurrentElement: {},
        html: ""
      };
    }
    template() {
      return `
            <div class="elf--drag-area-view" ref="$dragAreaView"></div>            
        `;
    }
    checkSelectionArea(e) {
      const mousePoint = this.$viewport.getWorldPosition(e);
      if (this.$context.selection.hasPoint(mousePoint)) {
        return true;
      }
    }
    checkEditMode(e) {
      if (this.$config.is("editing.mode", EditingMode.HAND)) {
        return false;
      }
      const code = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
      if (this.$context.keyboardManager.check(code)) {
        return false;
      }
      const mousePoint = this.$viewport.getWorldPosition(e);
      this.inSelection = false;
      if (this.$context.selection.hasPoint(mousePoint)) {
        this.inSelection = true;
        if (this.$context.selection.current.is("artboard")) {
          if (this.$context.selection.current.hasChildren()) {
            this.$config.init("set.dragarea.mode", true);
            this.$config.init("set.move.mode", false);
            return true;
          } else {
            this.$config.init("set.dragarea.mode", false);
            this.$config.init("set.move.mode", true);
            return true;
          }
        } else {
          this.$config.init("set.dragarea.mode", false);
          this.$config.init("set.move.mode", true);
          return true;
        }
      }
      this.mouseOverItem = this.$context.selection.filteredLayers[0];
      if (this.mouseOverItem) {
        this.$config.init("set.dragarea.mode", false);
        this.$config.init("set.move.mode", true);
      } else {
        this.$config.init("set.dragarea.mode", true);
        this.$config.init("set.move.mode", false);
      }
      return true;
    }
    [sapa.POINTERSTART("$dragAreaView") + sapa.IF("checkEditMode") + MOVE("movePointer") + END("moveEndPointer")]() {
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("startDragAreaView");
      }
      this.$config.set("editing.mode.itemType", "select");
    }
    initializeDragSelection() {
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
    }
    movePointer() {
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("moveDragAreaView");
      }
    }
    moveEndPointer() {
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("endDragAreaView");
      }
      this.$config.init("set.dragarea.mode", false);
      this.$config.init("set.move.mode", false);
    }
  }
  var PageTools$1 = "";
  class PageTools extends editor.EditorElement {
    template() {
      return `     
      <div class='elf--page-tools'>
        <button type='button' ref='$minus'>${editor.iconUse("remove2")}</button>
        <div class='select'>
          ${sapa.createComponent("NumberInputEditor", {
        ref: "$scaleInput",
        min: 10,
        max: 240,
        step: 1,
        key: "scale",
        value: this.$viewport.scale * 100,
        onchange: this.subscribe((key, scale2) => {
          this.$viewport.setScale(scale2 / 100);
          this.emit(UPDATE_VIEWPORT);
          this.trigger(UPDATE_VIEWPORT);
        }, 1e3)
      })}
        </div>
        <label>%</label>
        <button type='button' ref='$plus'>${editor.iconUse("add")}</button>        
        <button type='button' ref='$center' data-tooltip="Move to Center" data-direction="top">${editor.iconUse("gps_fixed")}</button>    
        <button type='button' ref='$ruler' data-tooltip="Toggle Ruler" data-direction="top">${editor.iconUse("straighten")}</button>    
        <button type='button' ref='$fullscreen' data-tooltip="FullScreen Canvas" data-direction="top">${editor.iconUse("fullscreen")}</button>                        
        ${this.$injectManager.generate("page.tools")}                             
      </div>

    `;
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      const scale2 = Math.floor(this.$viewport.scale * 100);
      if (this.children.$scaleInput) {
        this.children.$scaleInput.setValue(scale2);
      }
    }
    [sapa.CLICK("$plus")]() {
      const oldScale = this.$viewport.scale;
      this.$viewport.setScale(oldScale + 0.01);
      this.emit(UPDATE_VIEWPORT);
      this.trigger(UPDATE_VIEWPORT);
    }
    [sapa.CLICK("$minus")]() {
      const oldScale = this.$viewport.scale;
      this.$viewport.setScale(oldScale - 0.01);
      this.emit(UPDATE_VIEWPORT);
      this.trigger(UPDATE_VIEWPORT);
    }
    [sapa.CLICK("$center")]() {
      this.$commands.emit("moveSelectionToCenter");
    }
    [sapa.CLICK("$ruler")]() {
      this.$config.toggle("show.ruler");
    }
    [sapa.CLICK("$fullscreen")]() {
      this.emit("bodypanel.toggle.fullscreen");
    }
    [sapa.CLICK("$buttons button")](e) {
      const itemId = e.$dt.data("item-id");
      const pathIndex = e.$dt.data("path-index");
      const current = this.$editor.get(itemId);
      if (current.editablePath) {
        this.$commands.emit("open.editor", current);
      } else {
        const pathList = PathParser.fromSVGString(current.absolutePath().d).toPathList();
        this.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          d: pathList[pathIndex].d,
          changeEvent: (data) => {
            pathList[pathIndex].reset(data.d);
            const newPathD = current.invertPath(PathParser.joinPathList(pathList).d).d;
            this.$commands.executeCommand("setAttribute", "modify sub path", {
              [itemId]: current.updatePath(newPathD)
            });
          }
        });
      }
      this.emit("hideSelectionToolView");
    }
  }
  const char_list = [/\(/gi, /\)/gi];
  const function_list = "grayscale,matrix,rotateZ,blur,sepia,linear-gradient,radial-gradient,conic-gradient,circle,inset,polygon,rgb".split(",").map((it) => {
    return new RegExp(it, "gi");
  });
  const keyword_list = "butt,miter,start,at,black,repeat,lighten,multiply,solid,border-box,visible,absolute,relative,auto".split(",").map((it) => {
    return new RegExp(it, "gi");
  });
  function replaceKeyword(str) {
    keyword_list.forEach((ke) => {
      str = str.replace(ke, (str2) => {
        return `<span class="keyword">${str2}</span>`;
      });
    });
    function_list.forEach((ke) => {
      str = str.replace(ke, (str2) => {
        return `<span class="function">${str2}</span>`;
      });
    });
    char_list.forEach((ke) => {
      str = str.replace(ke, (str2) => {
        return `<span class="char">${str2}</span>`;
      });
    });
    return str;
  }
  function filterKeyName(str) {
    return str.split(";").filter((it) => it.trim()).map((it) => {
      it = it.trim();
      var [key, value] = it.split(":").map((it2) => it2.trim());
      if (value === "") {
        return "";
      }
      return `<div class="block"><strong>${key}</strong><span>:&nbsp;</span><span class="value">${replaceKeyword(value)}</span><span>;</span></div>`;
    }).join("").trim();
  }
  class HTMLRenderer {
    constructor(editor2) {
      __privateAdd(this, _id, void 0);
      __privateAdd(this, _renderers, {});
      this.editor = editor2;
      __privateSet(this, _id, uuid());
    }
    setRendererType(itemType, renderInstance) {
      renderInstance.setRenderer(this);
      __privateGet(this, _renderers)[itemType] = renderInstance;
    }
    get id() {
      return __privateGet(this, _id);
    }
    getDefaultRendererInstance() {
      return __privateGet(this, _renderers)["rect"];
    }
    getRendererInstance(item) {
      const currentRenderer = __privateGet(this, _renderers)[item.itemType] || this.editor.getRendererInstance("html", item.itemType) || this.getDefaultRendererInstance() || item;
      currentRenderer.setRenderer(this);
      return currentRenderer;
    }
    render(item) {
      if (!item)
        return;
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.render(item);
      }
    }
    renderSVG(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer.renderSVG)) {
        return currentRenderer.renderSVG(item);
      }
      return this.getDefaultRendererInstance().renderSVG(item);
    }
    to(type, item) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer[type])) {
        return currentRenderer[type].call(currentRenderer, item);
      }
      const defaultInstance = this.getDefaultRendererInstance();
      if (sapa.isFunction(defaultInstance[type])) {
        return defaultInstance[type].call(defaultInstance, item);
      }
    }
    toCSS(item, omit = {}) {
      const css = this.to("toCSS", item);
      Object.keys(omit).forEach((key) => {
        delete css[key];
      });
      return css;
    }
    toKeyframeCSS(item) {
      return this.to("toKeyframeCSS", item);
    }
    toNestedCSS(item) {
      return this.to("toNestedCSS", item);
    }
    toTransformCSS(item) {
      return this.to("toTransformCSS", item);
    }
    toGridLayoutCSS(item) {
      return this.to("toGridLayoutCSS", item);
    }
    toLayoutItemCSS(item) {
      return this.to("toLayoutItemCSS", item);
    }
    toLayoutBaseModelCSS(item) {
      return this.to("toLayoutBaseModelCSS", item);
    }
    toStyle(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer.toStyle)) {
        return currentRenderer.toStyle(item);
      }
      return this.getDefaultRendererInstance().toStyle(item);
    }
    toStyleData(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer.toStyleData)) {
        return currentRenderer.toStyleData(item);
      }
      return this.getDefaultRendererInstance().toStyleData(item);
    }
    toExportStyle(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer.toExportStyle)) {
        return currentRenderer.toExportStyle(item);
      }
      return this.getDefaultRendererInstance().toExportStyle(item);
    }
    update(item, currentElement, editor2) {
      const currentRenderer = this.getRendererInstance(item);
      if (sapa.isFunction(currentRenderer.update)) {
        return currentRenderer.update(item, currentElement, editor2);
      }
      return this.getDefaultRendererInstance().update(item, currentElement, editor2);
    }
    codeview(item) {
      if (!item) {
        return "";
      }
      const currentProject = item.project;
      let rootVariable = currentProject ? CSS_TO_STRING(currentProject.toRootVariableCSS()) : "";
      const current = item;
      const cssCode = filterKeyName(current ? TAG_TO_STRING(CSS_TO_STRING(this.toCSS(current))) : "");
      const keyframeCode = this.toKeyframeCSS(current);
      const nestedCssCode = current ? this.toNestedCSS(current).map((it) => {
        var cssText = it.cssText ? it.cssText : CSS_TO_STRING(it.css);
        return `${it.selector} { 
    ${filterKeyName(TAG_TO_STRING(cssText))}
    }`;
      }) : [];
      return `
<div >

${cssCode && `<div><pre title='CSS'>${cssCode}</pre></div>`}

${nestedCssCode.map((it) => {
        return `<div><pre title='CSS'>${it}</pre></div>`;
      }).join("")}

${keyframeCode && `<div><pre title='Keyframe'>${keyframeCode}</pre></div>`}

${rootVariable ? `<div>
    <label>:root</label>
    <pre>${rootVariable}</pre>
    </div>` : ""}

</div>
        `;
    }
  }
  _id = new WeakMap();
  _renderers = new WeakMap();
  class ArtBoardRender$1 extends DomRender {
    render(item) {
      var { id } = item;
      return `<div class="element-item artboard" data-id="${id}">${this.toDefString(item)}${item.layers.map((it) => {
        return this.renderer.render(it);
      }).join("")}</div>`;
    }
    toBorderCSS() {
      return {};
    }
  }
  class SVGItemRender$1 extends LayerRender {
    update(item, currentElement) {
      this.updateElementCache(item, currentElement);
      super.update(item, currentElement);
    }
    updateElementCache(item, currentElement) {
      if (item.getCache("element") !== currentElement) {
        item.addCache("element", currentElement);
        const $path = currentElement.$("path");
        item.addCache("svgElement", $path.parent().el);
        item.addCache("pathElement", $path.el);
      }
    }
    updateDefString(item, currentElement) {
      var $defs = currentElement.$("defs");
      if ($defs) {
        $defs.updateSVGDiff(`<defs>${this.toDefInnerString(item)}</defs>`);
      } else {
        var str = this.toDefString(item).trim();
        currentElement.prepend(sapa.Dom.createByHTML(str));
      }
    }
    toDefInnerString(item) {
      return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
    }
    fillId(item) {
      return this.getInnerId(item, "fill");
    }
    strokeId(item) {
      return this.getInnerId(item, "stroke");
    }
    cachedStroke(item) {
      return item.computed("stroke", (value) => {
        if (item.isBooleanItem) {
          return SVGFill.parseImage("transparent");
        } else {
          return SVGFill.parseImage(value || "black");
        }
      });
    }
    cachedFill(item) {
      return item.computed("fill", (value) => {
        if (item.isBooleanItem) {
          return SVGFill.parseImage("transparent");
        } else {
          return SVGFill.parseImage(value || "black");
        }
      });
    }
    toFillSVG(item) {
      var _a;
      const fillValue = this.cachedFill(item);
      return (_a = fillValue == null ? void 0 : fillValue.toSVGString) == null ? void 0 : _a.call(fillValue, this.fillId(item), item.contentBox);
    }
    toStrokeSVG(item) {
      var _a;
      const strokeValue = this.cachedStroke(item);
      return (_a = strokeValue == null ? void 0 : strokeValue.toSVGString) == null ? void 0 : _a.call(strokeValue, this.strokeId(item), item.contentBox);
    }
    toFillValue(item) {
      var _a;
      const fillValue = this.cachedFill(item);
      return (_a = fillValue == null ? void 0 : fillValue.toFillValue) == null ? void 0 : _a.call(fillValue, this.fillId(item));
    }
    toFillOpacityValue(item) {
      return Color__namespace.parse(item.fill || "transparent").a;
    }
    toStrokeValue(item) {
      var _a;
      const strokeValue = this.cachedStroke(item);
      return (_a = strokeValue == null ? void 0 : strokeValue.toFillValue) == null ? void 0 : _a.call(strokeValue, this.strokeId(item));
    }
    toFilterValue(item) {
      if (!item.svgfilter) {
        return "";
      }
      return `url(#${item.svgfilter})`;
    }
    toLayoutCSS() {
      return {};
    }
    toDefaultCSS(item) {
      var _a;
      return Object.assign({}, super.toDefaultCSS(item), {
        "stroke-width": item.strokeWidth,
        "stroke-linecap": item.strokeLinecap,
        "stroke-linejoin": item.strokeLinejoin,
        "stroke-dashoffset": item.strokeDashoffset,
        "fill-opacity": item.fillOpacity,
        "fill-rule": item.fillRule,
        "text-anchor": item.textAnchor,
        "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
      });
    }
    toSVGAttribute(item) {
      return this.toDefaultCSS(item);
    }
  }
  class BooleanPathRender$1 extends SVGItemRender$1 {
    toFillSVG(item) {
      const layers = item.layers;
      const op = item.booleanOperation;
      switch (op) {
        case BooleanOperation.DIFFERENCE:
          return SVGFill.parseImage(layers[1].fill || "transparent").toSVGString(this.fillId(item));
      }
      return SVGFill.parseImage(layers[0].fill || "transparent").toSVGString(this.fillId(item));
    }
    toStrokeSVG(item) {
      const layers = item.layers;
      const op = item.booleanOperation;
      switch (op) {
        case BooleanOperation.DIFFERENCE:
          return SVGFill.parseImage(layers[1].stroke || "transparent").toSVGString(this.strokeId(item));
      }
      return SVGFill.parseImage(layers[0].stroke || "black").toSVGString(this.strokeId(item));
    }
    toFillValue(item) {
      var _a, _b;
      const layers = item.layers;
      const op = item.booleanOperation;
      switch (op) {
        case BooleanOperation.DIFFERENCE:
          return SVGFill.parseImage(layers[1].fill || "transparent").toSVGString(this.fillId(item));
      }
      return (_b = (_a = SVGFill.parseImage(layers[0].fill || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.fillId(item));
    }
    toFillOpacityValue(item) {
      return Color__namespace.parse(item.fill || "transparent").a;
    }
    toStrokeValue(item) {
      var _a, _b, _c, _d;
      const layers = item.layers;
      const op = item.booleanOperation;
      switch (op) {
        case BooleanOperation.DIFFERENCE:
          return (_b = (_a = SVGFill.parseImage(layers[1].stroke || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.strokeId(item));
      }
      return (_d = (_c = SVGFill.parseImage(layers[0].stroke || "black")).toFillValue) == null ? void 0 : _d.call(_c, this.strokeId(item));
    }
    update(item, currentElement) {
      if (!currentElement)
        return;
      const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
      if ($path) {
        if (item.hasChangedField("changedChildren", "d", "boolean-operation", "width", "height")) {
          $path.setAttrNS({
            d: item.d
          });
        }
        if (item.hasChangedField("fill")) {
          $path.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $path.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $path.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
        if (item.hasChangedField("fill-rule")) {
          $path.setAttrNS({
            "fill-rule": item.fillRule || "nonezero"
          });
        }
        if (item.hasChangedField("stroke-linejoin")) {
          $path.setAttrNS({
            "stroke-linejoin": item.strokeLinejoin
          });
        }
        if (item.hasChangedField("stroke-linecap")) {
          $path.setAttrNS({
            "stroke-linecap": item.strokeLinecap
          });
        }
      }
      super.update(item, currentElement);
    }
    updateElementCache(item, currentElement) {
      if (item.getCache("element") !== currentElement) {
        item.addCache("element", currentElement);
        const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
        item.addCache("svgElement", $path.parent().el);
        item.addCache("pathElement", $path.el);
      }
    }
    render(item) {
      var { id, name, itemType } = item;
      return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  ${item.layers.map((it) => {
        return this.renderer.render(it);
      }).join("")}
  <svg xmlns="http://www.w3.org/2000/svg" class="boolean-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      data-boolean-path-id="${id}" 
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
    }
  }
  class CircleRender$1 extends LayerRender {
  }
  class ImageRender$1 extends LayerRender {
    toNestedCSS() {
      return [
        {
          selector: "img",
          cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
        }
      ];
    }
    getUrl(item) {
      var { src } = item;
      var project2 = item.project;
      return project2.getImageValueById(src) || src;
    }
    render(item) {
      var { id } = item;
      return `
          <div class='element-item image' data-id="${id}">
            ${this.toDefString(item)}
            <img src='${this.getUrl(item)}' />
          </div>`;
    }
    update(item, currentElement) {
      const $image = currentElement == null ? void 0 : currentElement.$("img");
      if ($image) {
        $image.attr("src", this.getUrl(item));
      }
      super.update(item, currentElement);
    }
  }
  class ProjectRender$1 extends DomRender {
    toRootVariableCSS(item) {
      let obj2 = {};
      item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
        var [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    }
    toCSS(item) {
      return Object.assign({}, this.toRootVariableCSS(item));
    }
    toStyle(item) {
      const keyframeString = item.toKeyframeString();
      const rootVariable = this.toRootVariableCSS(item);
      return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
    }
    toExportStyle(item) {
      const keyframeString = item.toKeyframeString();
      const rootVariable = this.toRootVariableCSS(item);
      return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
    }
    render(item) {
      return item.layers.map((it) => {
        return this.renderer.render(it);
      }).join("");
    }
    renderSVG() {
      return "";
    }
  }
  class RectRender$1 extends LayerRender {
  }
  class SVGPathRender$1 extends SVGItemRender$1 {
    update(item, currentElement) {
      if (!currentElement)
        return;
      const $path = currentElement.$("path");
      if ($path) {
        if (item.hasChangedField("width", "height", "d")) {
          $path.setAttrNS({
            d: item.d
          });
        }
        if (item.hasChangedField("fill")) {
          $path.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $path.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $path.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
        if (item.hasChangedField("fill-rule")) {
          $path.setAttrNS({
            "fill-rule": item.fillRule || "nonezero"
          });
        }
        if (item.hasChangedField("stroke-linejoin")) {
          $path.setAttrNS({
            "stroke-linejoin": item.strokeLinejoin
          });
        }
        if (item.hasChangedField("stroke-linecap")) {
          $path.setAttrNS({
            "stroke-linecap": item.strokeLinecap
          });
        }
        if (item.hasChangedField("stroke-dasharray")) {
          $path.setAttrNS({
            "stroke-dasharray": item.strokeDasharray.join(" ")
          });
        }
      }
      super.update(item, currentElement);
    }
    render(item) {
      var { id, name, itemType } = item;
      return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
      stroke-dasharray="${item.strokeDasharray.join(" ")}"
    />
  </svg>
</div>
    `;
    }
  }
  class SplineRender$1 extends SVGPathRender$1 {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        if (item.hasChangedField("points", "boundary")) {
          $path.setAttrNS({
            d: item.d
          });
        }
      }
      super.update(item, currentElement);
    }
  }
  class SVGPolygonRender$1 extends SVGItemRender$1 {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        if (item.hasChangedField("width", "height", "count")) {
          $path.setAttrNS({
            d: item.d
          });
        }
        if (item.hasChangedField("fill")) {
          $path.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $path.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $path.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
        if (item.hasChangedField("fill-rule")) {
          $path.setAttrNS({
            "fill-rule": item.fillRule || "nonezero"
          });
        }
        if (item.hasChangedField("stroke-linejoin")) {
          $path.setAttrNS({
            "stroke-linejoin": item.strokeLinejoin
          });
        }
        if (item.hasChangedField("stroke-linecap")) {
          $path.setAttrNS({
            "stroke-linecap": item.strokeLinecap
          });
        }
      }
      super.update(item, currentElement);
    }
    render(item) {
      var { id, name, itemType } = item;
      return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
    }
  }
  class SVGStarRender$1 extends SVGItemRender$1 {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        if (item.hasChangedField("width", "height", "count", "radius", "isCurve", "tension")) {
          $path.setAttrNS({
            d: item.d
          });
        }
        if (item.hasChangedField("fill")) {
          $path.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $path.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $path.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
        if (item.hasChangedField("fill-rule")) {
          $path.setAttrNS({
            "fill-rule": item.fillRule || "nonezero"
          });
        }
        if (item.hasChangedField("stroke-linejoin")) {
          $path.setAttrNS({
            "stroke-linejoin": item.strokeLinejoin
          });
        }
        if (item.hasChangedField("stroke-linecap")) {
          $path.setAttrNS({
            "stroke-linecap": item.strokeLinecap
          });
        }
      }
      super.update(item, currentElement);
    }
    render(item) {
      var { id, name, itemType } = item;
      return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
    }
  }
  class SVGTextPathRender$1 extends SVGItemRender$1 {
    update(item, currentElement) {
      var $path = currentElement.$("path.svg-path-item");
      if ($path) {
        if (item.hasChangedField("width", "height", "d")) {
          $path.attr("d", item.d);
        }
      }
      var $guidePath = currentElement.$("path.guide");
      if ($guidePath) {
        if (item.hasChangedField("width", "height", "d")) {
          $guidePath.attr("d", item.d);
        }
      }
      var $textPath = currentElement.$("textPath");
      if ($textPath) {
        if (item.hasChangedField("text")) {
          $textPath.text(item.text);
        }
        if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
          $textPath.setAttrNS({
            textLength: item.textLength,
            lengthAdjust: item.lengthAdjust,
            startOffset: item.startOffset
          });
        }
        if (item.hasChangedField("fill")) {
          $textPath.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $textPath.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $textPath.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
      }
      super.update(item, currentElement);
      item.totalLength = $path.totalLength;
    }
    toDefInnerString(item) {
      return `
        ${this.toPathSVG(item)}
        ${this.toFillSVG(item)}
        ${this.toStrokeSVG(item)}
    `;
    }
    toPathId(item) {
      return this.getInnerId(item, "path");
    }
    toPathSVG(item) {
      return `
    <path class="svg-path-item" id="${this.toPathId(item)}" d="${item.d}" fill="none" />
    `;
    }
    render(item) {
      var { id, textLength, lengthAdjust, startOffset } = item;
      const pathId = `#${this.toPathId(item)}`;
      return `
      <svg class='element-item textpath' data-id="${id}">
        ${this.toDefString(item)}
        <text class="svg-textpath-item">
          <textPath 
            xlink:href="${pathId}"
            textLength="${textLength}"
            lengthAdjust="${lengthAdjust}"
            startOffset="${startOffset}"
          >${item.text}</textPath>
          <use href="${pathId}" stroke-width="1" stroke="black" />
        </text>
        <path class="guide" d="${item.d}" stroke="rgba(0, 0, 0, 0.5)" fill="none"/>
      </svg>
    `;
    }
  }
  class SVGTextRender$1 extends SVGItemRender$1 {
    update(item, currentElement) {
      var $text = currentElement.$("text");
      if ($text) {
        if (item.hasChangedField("text")) {
          $text.text(item.text);
        }
        if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
          $text.setAttrNS({
            textLength: item.textLength,
            lengthAdjust: item.lengthAdjust,
            startOffset: item.startOffset
          });
        }
        if (item.hasChangedField("fill")) {
          $text.setAttrNS({
            fill: this.toFillValue(item)
          });
        }
        if (item.hasChangedField("stroke")) {
          $text.setAttrNS({
            stroke: this.toStrokeValue(item)
          });
        }
        if (item.hasChangedField("filter")) {
          $text.setAttrNS({
            filter: this.toFilterValue(item)
          });
        }
      }
      super.update(item, currentElement);
    }
    shapeInsideId(item) {
      return this.getInnerId(item, "shape-inside");
    }
    render(item) {
      var { id, textLength, lengthAdjust } = item;
      return `
  <svg class='element-item textpath' data-id="${id}">
    ${this.toDefString(item)}
      <text class="svg-text-item" textLength="${textLength}" lengthAdjust="${lengthAdjust}">${item.text}</text>
  </svg>`;
    }
  }
  class DomTemplateEngine {
    static compile(template, params = []) {
      return template;
    }
  }
  const EngineList = {
    dom: DomTemplateEngine
  };
  class TemplateEngine {
    static compile(engine, template, params = []) {
      const currentEngine = EngineList[engine] || EngineList["dom"];
      return currentEngine.compile(template, params);
    }
  }
  class TemplateRender$1 extends LayerRender {
    update(item, currentElement) {
      if (item.hasChangedField("x", "y", "width", "height") === false) {
        const compiledTemplate = this.compile(item);
        let $innerHTML = currentElement.$(".inner-html");
        if ($innerHTML) {
          $innerHTML.updateDiff(compiledTemplate);
        }
      }
      super.update(item, currentElement);
    }
    compile(item) {
      return TemplateEngine.compile("dom", item.template, item.params);
    }
    render(item) {
      var { id } = item;
      const compiledTemplate = this.compile(item);
      return `
      <div class='element-item template' data-id="${id}">
        ${this.toDefString(item)}
        <style id="style-${id}">
          [data-id="${id}"] .inner-html {
            width: 100%; 
            height: 100%;
            position:relative;
            display:block;
            pointer-events: none; 
          }

          [data-id="${id}"] .inner-html > * {
            width: 100%; 
            height: 100%;
          }          
        </style>
        <div class="inner-html" data-domdiff-pass="true">
          ${compiledTemplate}
        </div>
      </div>`;
    }
  }
  class TextRender$1 extends LayerRender {
    toCSS(item) {
      let css = super.toCSS(item);
      css.margin = css.margin || "0px";
      if (item.overflow !== Overflow.SCROLL) {
        if (item.content.length > 0) {
          css.height = "auto";
        }
      }
      return css;
    }
    update(item, currentElement) {
      const $textElement = currentElement == null ? void 0 : currentElement.$(`.text-content`);
      if ($textElement) {
        var { content: content2 } = item;
        $textElement.updateDiff(content2);
      }
      super.update(item, currentElement);
    }
    render(item) {
      var { id, content: content2 } = item;
      return `
            <div class='element-item text' data-id="${id}">
                ${this.toDefString(item)}
                <div class="text-content" tabIndex="-1" data-id="${id}">${content2}</div>
            </div>
        `;
    }
  }
  class VideoRender$1 extends LayerRender {
    toNestedCSS() {
      return [
        {
          selector: "video",
          cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
        }
      ];
    }
    getUrl(item) {
      var { src } = item;
      var project2 = item.project;
      return project2.getVideoValueById(src);
    }
    render(item) {
      var { id, controls, muted, poster, loop, crossorigin, autoplay } = item;
      return `
        <div class='element-item video' data-id="${id}">
            ${this.toDefString(item)}
            <video 
                controls="${controls}"
                src="${this.getUrl(item)}
                muted="${muted}"
                poster="${poster}"
                loop="${loop}"
                crossorigin="${crossorigin}"
                autoplay="${autoplay}"
            >
                Sorry, your browser doesn't support embedded videos.
            </video>
        </div>`;
    }
    update(item, currentElement) {
      const { currentTime, playbackRate, volume } = item;
      const $video = currentElement.$("video");
      if ($video) {
        $video.setProp({
          currentTime,
          playbackRate,
          volume
        });
      }
      super.update(item, currentElement);
    }
  }
  function rendererHtml(editor2) {
    const renderer = new HTMLRenderer(editor2);
    renderer.setRendererType("project", new ProjectRender$1());
    renderer.setRendererType("artboard", new ArtBoardRender$1());
    renderer.setRendererType("rect", new RectRender$1());
    renderer.setRendererType("circle", new CircleRender$1());
    renderer.setRendererType("image", new ImageRender$1());
    renderer.setRendererType("text", new TextRender$1());
    renderer.setRendererType("video", new VideoRender$1());
    renderer.setRendererType("boolean-path", new BooleanPathRender$1());
    renderer.setRendererType("svg-path", new SVGPathRender$1());
    renderer.setRendererType("polygon", new SVGPolygonRender$1());
    renderer.setRendererType("star", new SVGStarRender$1());
    renderer.setRendererType("spline", new SplineRender$1());
    renderer.setRendererType("svg-text", new SVGTextRender$1());
    renderer.setRendererType("svg-textpath", new SVGTextPathRender$1());
    renderer.setRendererType("template", new TemplateRender$1());
    editor2.registerRendererType("html", renderer);
  }
  class SVGRenderer {
    constructor(editor2) {
      this.editor = editor2;
    }
    getDefaultRendererInstance() {
      return this.editor.getRendererInstance("svg", "rect");
    }
    getRendererInstance(item) {
      return this.editor.getRendererInstance("svg", item.itemType) || this.getDefaultRendererInstance() || item;
    }
    render(item, renderer) {
      if (!item)
        return "";
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.render(item, renderer || this);
      }
    }
    toCSS(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.toCSS(item);
      }
    }
    toTransformCSS(item) {
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.toTransformCSS(item);
      }
    }
    toStyle(item, renderer) {
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.toStyle(item, renderer || this);
      }
    }
    update(item, currentElement) {
      const currentRenderer = this.getRendererInstance(item);
      if (currentRenderer) {
        return currentRenderer.update(item, currentElement);
      }
    }
    codeview(item) {
      if (!item) {
        return "";
      }
      let svgCode = this.render(item);
      svgCode = svgCode.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return `
<div class='svg-code'>
${svgCode && `<div><pre title='SVG'>${svgCode}</pre></div>`}
</div>
        `;
    }
  }
  class SVGRender extends DomRender {
    toDefaultCSS(item) {
      return {
        overflow: "visible",
        "background-color": item.backgroundColor,
        color: item.color,
        "font-size": item.fontSize,
        "font-weight": item.fontWeight,
        "font-style": item.fontStyle,
        "font-family": item.fontFamily,
        "text-align": item.textAlign,
        "text-decoration": item.textDecoration,
        "text-transform": item.textTransform,
        "letter-spacing": item.letterSpacing,
        "word-spacing": item.wordSpacing,
        "line-height": item.lineHeight,
        "text-indent": item.textIndent,
        "text-overflow": item.textOverflow,
        "text-wrap": item.textWrap,
        "z-index": item.zIndex,
        opacity: item.opacity,
        "mix-blend-mode": item.mixBlendMode,
        "transform-origin": item.transformOrigin,
        "border-radius": item.borderRadius,
        animation: item.animation,
        transition: item.transition
      };
    }
    toCSS(item) {
      const css = Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toTextShadowCSS(item), this.toBoxShadowCSS(item), this.toFilterCSS(item), this.toBackdropFilterCSS(item), this.toLayoutCSS(item));
      delete css.left;
      delete css.top;
      delete css.width;
      delete css.height;
      delete css.position;
      return css;
    }
    toSVGAttribute(item) {
      var _a;
      return __spreadProps(__spreadValues({}, this.toDefaultCSS(item)), {
        strokeWidth: item.strokeWidth,
        "fill-opacity": item.fillOpacity,
        "fill-rule": item.fillRule,
        "stroke-linecap": item.strokeLinecap,
        "stroke-linejoin": item.strokeLinejoin,
        "text-anchor": item.textAnchor,
        "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
      });
    }
    wrappedRender(item, callback) {
      const { id, x, y, width: width2, height, itemType } = item;
      return `

<svg class='svg-element-item ${itemType}'
    xmlns="http://www.w3.org/2000/svg"
    data-id="${id}"
    x="${x}"
    y="${y}"
    width="${width2}"
    height="${height}"
    viewBox="0 0 ${width2} ${height}"
    overflow="visible"
>
    ${this.toDefString(item)}
    ${sapa.isFunction(callback) && callback()}
</svg>
        `;
    }
    render(item, renderer) {
      const { width: width2, height, elementType } = item;
      const tagName = elementType || "div";
      let css = this.toCSS(item);
      return this.wrappedRender(item, () => {
        return `
<foreignObject 
    width="${width2}"
    height="${height}"
    overflow="visible"
>
    <${tagName} xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)};width:100%;height:100%;"></${tagName}>
</foreignObject>    
${item.layers.map((it) => {
          return renderer.render(it, renderer);
        }).join("")}
            `;
      });
    }
  }
  class ArtBoardRender extends SVGRender {
    toCSS(item) {
      const css = Object.assign({}, this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBackgroundImageCSS(item));
      delete css.left;
      delete css.top;
      delete css.width;
      delete css.height;
      delete css.position;
      return css;
    }
    render(item, renderer, encoding = true) {
      const { width: width2, height } = item;
      let css = this.toCSS(item);
      return `
${encoding ? `<?xml version="1.0"?>` : ""}
<svg 
    xmlns="http://www.w3.org/2000/svg"
    width="${width2}"
    height="${height}"
    viewBox="0 0 ${width2} ${height}"
    style="${CSS_TO_STRING(css)}"
>
    ${this.toDefString(item)}
    ${item.layers.map((it) => {
        return renderer.render(it, renderer);
      }).join("")}
</svg>      
        `;
    }
  }
  class SVGLayerRender extends SVGRender {
  }
  class SVGItemRender extends SVGLayerRender {
    updateDefString(item, currentElement) {
      var $defs = currentElement.$("defs");
      if ($defs) {
        $defs.html(this.toDefInnerString(item));
      } else {
        var str = this.toDefString(item).trim();
        currentElement.prepend(sapa.Dom.createByHTML(str));
      }
    }
    toDefInnerString(item) {
      return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
    }
    toDefString(item) {
      const str = this.toDefInnerString(item).trim();
      return `
            <defs>
            ${str}
            </defs>
        `;
    }
    fillId(item) {
      return this.getInnerId(item, "fill");
    }
    strokeId(item) {
      return this.getInnerId(item, "stroke");
    }
    toFillSVG(item) {
      return SVGFill.parseImage(item.fill || "transparent").toSVGString(this.fillId(item));
    }
    toStrokeSVG(item) {
      return SVGFill.parseImage(item.stroke || "black").toSVGString(this.strokeId(item));
    }
    toFillValue(item) {
      return SVGFill.parseImage(item.fill || "transparent").toFillValue(this.fillId(item));
    }
    toFillOpacityValue(item) {
      return Color__namespace.parse(item.fill || "transparent").a;
    }
    toStrokeValue(item) {
      return SVGFill.parseImage(item.stroke || "black").toFillValue(this.strokeId(item));
    }
    toFilterValue(item) {
      if (!item.svgfilter) {
        return "";
      }
      return `url(#${item.svgfilter})`;
    }
    toLayoutCSS() {
      return {};
    }
  }
  class BooleanPathRender extends SVGItemRender {
    update(item, currentElement) {
      if (!currentElement)
        return;
      const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
      if ($path) {
        $path.setAttr({
          d: item.d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        });
        item.totalLength = $path.totalLength;
      }
      this.updateDefString(item, currentElement);
    }
    render(item) {
      var { d } = item;
      return this.wrappedRender(item, () => {
        return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "boolean-path-item",
          "data-boolean-path-id": item.id,
          d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} />
    `;
      });
    }
  }
  class CircleRender extends SVGLayerRender {
  }
  class IFrameRender extends SVGLayerRender {
    update(item, currentElement) {
      let $iframe = currentElement.$("iframe");
      if ($iframe) {
        $iframe.attr("src", item.url || "about:blank");
      }
      super.update(item, currentElement);
    }
    render(item) {
      const { width: width2, height, url = "about:blank" } = item;
      let css = this.toCSS(item);
      return this.wrappedRender(item, () => {
        return `
  <foreignObject
      width="${width2}"
      height="${height}"
  >
      <iframe 
          xmlns="http://www.w3.org/1999/xhtml"
          width="100%" 
          height="100%" 
          style="border:0px;width:100%;height:100%;pointer-events:none; ${CSS_TO_STRING(css)}" 
          src="${url}"
      ></iframe>
  </foreignObject>              
          `;
      });
    }
  }
  class ImageRender extends SVGLayerRender {
    getUrl(item) {
      var { src } = item;
      var project2 = item.project;
      return project2.getImageValueById(src);
    }
    render(item) {
      const { width: width2, height } = item;
      let css = this.toCSS(item);
      return this.wrappedRender(item, () => {
        return `
            <foreignObject
                width="${width2}"
                height="${height}"
            >
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <img src='${this.getUrl(item)}' style="width:100%;height:100%; ${CSS_TO_STRING(css)}"  />
                </div>
            </foreignObject>              
          `;
      });
    }
    update(item, currentElement) {
      const $image = currentElement.$("img");
      if ($image) {
        $image.attr("src", this.getUrl(item));
      }
      super.update(item, currentElement);
    }
  }
  class ProjectRender extends SVGRender {
    render(item, renderer) {
      return item.artboards.map((it) => {
        return renderer.render(it, renderer);
      });
    }
  }
  class RectRender extends SVGLayerRender {
  }
  class SplineRender extends SVGItemRender {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        $path.setAttr({
          d: item.d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        });
      }
      this.updateDefString(item, currentElement);
    }
    render(item) {
      var { d } = item;
      return this.wrappedRender(item, () => {
        return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "spline-item",
          d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} />
    `;
      });
    }
  }
  class SVGPathRender extends SVGItemRender {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        $path.setAttr({
          d: item.d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        });
        item.totalLength = $path.totalLength;
      }
      this.updateDefString(item, currentElement);
    }
    render(item) {
      var { d } = item;
      return this.wrappedRender(item, () => {
        return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "svg-path-item",
          d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} />
    `;
      });
    }
  }
  class SVGPolygonRender extends SVGItemRender {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        $path.setAttr({
          d: item.d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        });
      }
      this.updateDefString(item, currentElement);
    }
    render(item) {
      var { d } = item;
      return this.wrappedRender(item, () => {
        return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "polygon-item",
          d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} />
    `;
      });
    }
  }
  class SVGStarRender extends SVGItemRender {
    update(item, currentElement) {
      if (!currentElement)
        return;
      var $path = currentElement.$("path");
      if ($path) {
        $path.setAttr({
          d: item.d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        });
      }
      this.updateDefString(item, currentElement);
    }
    render(item) {
      var { d } = item;
      return this.wrappedRender(item, () => {
        return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "star-item",
          d,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} />
    `;
      });
    }
  }
  class SVGTextPathRender extends SVGItemRender {
    update(item, currentElement) {
      var $path = currentElement.$("path");
      if ($path) {
        $path.attr("d", item.d);
      }
      var $textPath = currentElement.$("textPath");
      if ($textPath) {
        $textPath.text(item.text);
        $textPath.setAttr({
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item),
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust,
          startOffset: item.startOffset
        });
      }
      this.updateDefString(item, currentElement);
      item.totalLength = $path.totalLength;
    }
    toDefInnerString(item) {
      return `
      ${this.toPathSVG(item)}
      ${this.toFillSVG(item)}
      ${this.toStrokeSVG(item)}
    `;
    }
    toPathId(item) {
      return this.getInnerId(item, "path");
    }
    toPathSVG(item) {
      return `
      <path 
        class="svg-path-item"
        id="${this.toPathId(item)}"
        d="${item.d}"
        fill="none"
      />
    `;
    }
    render(item) {
      return this.wrappedRender(item, () => {
        const { textLength, lengthAdjust, startOffset } = item;
        return `
        <textPath ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          "xlink:href": `#${this.toPathId(item)}`,
          textLength,
          lengthAdjust,
          startOffset,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} >${item.text}</textPath>
      `;
      });
    }
  }
  class SVGTextRender extends SVGItemRender {
    update(item, currentElement) {
      var $text = currentElement.$("text");
      if ($text) {
        $text.text(item.text);
        $text.setAttr({
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item),
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust
        });
      }
      this.updateDefString(item, currentElement);
    }
    shapeInsideId(item) {
      return this.getInnerId(item, "shape-inside");
    }
    render(item) {
      var { textLength, lengthAdjust } = item;
      return this.wrappedRender(item, () => {
        return `
        <text ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
          class: "svg-text-item",
          textLength,
          lengthAdjust,
          filter: this.toFilterValue(item),
          fill: this.toFillValue(item),
          stroke: this.toStrokeValue(item)
        }, this.toSVGAttribute(item)), {
          style: CSS_TO_STRING(this.toCSS(item))
        }))} >${item.text}</text>
      `;
      });
    }
  }
  class TemplateRender extends SVGLayerRender {
    update(item, currentElement) {
      const compiledTemplate = this.compile(item);
      let $innerHTML = currentElement.$(".inner-html");
      if ($innerHTML) {
        $innerHTML.updateDiff(compiledTemplate);
      }
      super.update(item, currentElement);
    }
    compile(item) {
      return TemplateEngine.compile("dom", item.template, item.params);
    }
    render(item) {
      const { id, width: width2, height } = item;
      const compiledTemplate = this.compile(item);
      return this.wrappedRender(item, () => {
        return `
            <foreignObject
                width="${width2}"
                height="${height}"
            >
                <div  xmlns="http://www.w3.org/1999/xhtml" style="width: 100%;height:100%;">
                    <style id="style-${id}">
                    [data-id="${id}"] .inner-html {
                        width: 100%; 
                        height: 100%;
                        position:relative;
                        display:block;
                        pointer-events: none; 
                    }

                    [data-id="${id}"] .inner-html > * {
                        width: 100%; 
                        height: 100%;
                    }          
                    </style>
                    <div class="inner-html">
                    ${compiledTemplate}
                    </div>
                </div>
            </foreignObject>              
          `;
      });
    }
  }
  class TextRender extends SVGLayerRender {
    toCSS(item) {
      let css = super.toCSS(item);
      css.margin = css.margin || "0px";
      css.height = "auto";
      return css;
    }
    render(item) {
      const { content: content2, width: width2, height } = item;
      let css = this.toCSS(item);
      return this.wrappedRender(item, () => {
        return `
            <foreignObject width="${width2}" height="${height}">
                <p xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)}">${content2}</p>
            </foreignObject>              
          `;
      });
    }
    update(item, currentElement) {
      var { content: content2 } = item;
      currentElement.updateDiff(content2);
    }
  }
  class VideoRender extends SVGLayerRender {
    getUrl(item) {
      var { src } = item;
      var project2 = item.project;
      return project2.getVideoValueById(src);
    }
    render(item) {
      var {
        width: width2,
        height,
        controls,
        muted,
        poster,
        loop,
        crossorigin,
        autoplay
      } = item;
      let css = this.toCSS(item);
      return this.wrappedRender(item, () => {
        return `
            <foreignObject 
                width="${width2}"
                height="${height}"
                overflow="visible"
            >
                <video 
                    xmlns="http://www.w3.org/1999/xhtml"
                    controls="${controls}"
                    src="${this.getUrl(item)}"
                    muted="${muted}"
                    poster="${poster}"
                    loop="${loop}"
                    crossorigin="${crossorigin}"
                    autoplay="${autoplay}"
                    style="${CSS_TO_STRING(css)};width:100%;height:100%;"></video>
            </foreignObject>    
            `;
      });
    }
  }
  function rendererSvg(editor2) {
    editor2.registerRendererType("svg", new SVGRenderer(editor2));
    editor2.registerRenderer("svg", "project", new ProjectRender());
    editor2.registerRenderer("svg", "artboard", new ArtBoardRender());
    editor2.registerRenderer("svg", "rect", new RectRender());
    editor2.registerRenderer("svg", "circle", new CircleRender());
    editor2.registerRenderer("svg", "image", new ImageRender());
    editor2.registerRenderer("svg", "template", new TemplateRender());
    editor2.registerRenderer("svg", "iframe", new IFrameRender());
    editor2.registerRenderer("svg", "video", new VideoRender());
    editor2.registerRenderer("svg", "text", new TextRender());
    editor2.registerRenderer("svg", "boolean-path", new BooleanPathRender());
    editor2.registerRenderer("svg", "svg-path", new SVGPathRender());
    editor2.registerRenderer("svg", "polygon", new SVGPolygonRender());
    editor2.registerRenderer("svg", "star", new SVGStarRender());
    editor2.registerRenderer("svg", "spline", new SplineRender());
    editor2.registerRenderer("svg", "svg-text", new SVGTextRender());
    editor2.registerRenderer("svg", "svg-textpath", new SVGTextPathRender());
  }
  var HTMLRenderView$1 = "";
  class HTMLRenderView extends editor.EditorElement {
    initialize() {
      super.initialize();
      rendererHtml(this.$editor);
      rendererSvg(this.$editor);
      this.renderer = this.$editor.renderer("html");
    }
    initState() {
      return {
        mode: "selection",
        x: 0,
        y: 0,
        width: 1e4,
        height: 1e4,
        cachedCurrentElement: {},
        doubleClickTime: 0
      };
    }
    template() {
      return `<div class='elf--element-view' ref='$body'>
      <div class='canvas-view' 
        data-renderer-id='${this.renderer.id}' 
        ref='$view' 
        data-outline="${this.$config.get("show.outline")}"
      ></div>
      ${this.$injectManager.generate("render.view")}
    </div>`;
    }
    [sapa.BIND("$view")]() {
      const { translate: translate2, transformOrigin: origin, scale: scale2 } = this.$viewport;
      const transform2 = `translate(${translate2[0]}px, ${translate2[1]}px) scale(${scale2 || 1})`;
      const transformOrigin = `${origin[0]}px ${origin[1]}px`;
      return {
        style: {
          "transform-origin": transformOrigin,
          transform: transform2
        }
      };
    }
    [sapa.CONFIG("show.outline")]() {
      this.refs.$view.attr("data-outline", this.$config.get("show.outline"));
    }
    [sapa.CONFIG("bodyEvent")]() {
      const e = this.$config.get("bodyEvent");
      if (e.buttons === 0) {
        if (sapa.Dom.create(e.target).hasClass("elf--drag-area-view")) {
          this.$commands.emit("recoverCursor");
        }
      }
    }
    [sapa.SUBSCRIBE("refElement")](id, callback) {
      sapa.isFunction(callback) && callback(this.getElement(id));
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS)](obj2) {
      this.refreshSelectionStyleView(obj2);
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.bindData("$view");
    }
    [sapa.SUBSCRIBE("refreshAllElementBoundSize")]() {
      this.refreshAllElementBoundSize();
    }
    [sapa.SUBSCRIBE("refreshElementBoundSize")](parentObj) {
      this.refreshElementBoundSize(parentObj);
    }
    [sapa.SUBSCRIBE("updateAllCanvas")](parentLayer) {
      this.updateAllCanvas(parentLayer);
    }
    [sapa.SUBSCRIBE("refreshAllCanvas")]() {
      this.refreshAllCanvas();
    }
    [sapa.SUBSCRIBE("playTimeline", "moveTimeline")]() {
      const project2 = this.$context.selection.currentProject;
      var timeline = project2.getSelectedTimeline();
      if (timeline) {
        timeline.animations.map((it) => this.$model.get(it.id)).forEach((current) => {
          this.updateTimelineElement(current, true, false);
        });
      }
    }
    clearElementAll() {
      this.state.cachedCurrentElement = {};
    }
    clearElement(id) {
      this.state.cachedCurrentElement[id] = void 0;
    }
    getElement(id) {
      if (!this.state.cachedCurrentElement[id]) {
        this.state.cachedCurrentElement[id] = this.refs.$view.$(`[data-id="${id}"]`);
      }
      return this.state.cachedCurrentElement[id];
    }
    [sapa.FOCUSOUT("$view .element-item.text .text-content")](e) {
      e.$dt.removeAttr("contenteditable");
      e.$dt.removeClass("focused");
      this.$context.commands.emit("pop.mode.view", "TextEditorView");
      this.$context.commands.emit("recoverCursor");
    }
    [sapa.KEYUP("$view .element-item.text .text-content")](e) {
      var content2 = e.$dt.html();
      var text2 = e.$dt.text().trim();
      var id = e.$dt.parent().attr("data-id");
      var arr = [];
      this.$context.selection.items.filter((it) => it.id === id).forEach((item) => {
        item.reset({
          content: content2,
          text: text2
        });
        arr.push({ id: item.id, content: content2, text: text2 });
        this.$commands.emit("setAttribute", {
          [item.id]: {
            content: content2,
            text: text2
          }
        });
      });
      this.emit("refreshContent", arr);
    }
    checkEditMode(e) {
      this.state.hasDoubleClick = false;
      if (window.performance.now() - this.state.doubleClickTime < this.$config.get("event.doubleclick.timing")) {
        this.state.hasDoubleClick = true;
        return false;
      }
      if (this.$config.is("editing.mode", EditingMode.HAND)) {
        return false;
      }
      const code = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
      if (this.$context.keyboardManager.check(code)) {
        return false;
      }
      const $target = sapa.Dom.create(e.target);
      if ($target.hasClass("canvas-view")) {
        return false;
      }
      if (!e.shiftKey) {
        const mousePoint = this.$viewport.getWorldPosition(e);
        if (this.$context.selection.hasPoint(mousePoint)) {
          if (this.$context.selection.hasHoverItem()) {
            if (this.$context.selection.hasParent(this.$context.selection.hoverId) === false) {
              this.$context.selection.selectHoverItem();
            }
          }
          return true;
        }
        if (this.$context.selection.hasHoverItem()) {
          this.$context.selection.selectHoverItem();
          return true;
        }
      }
      const $element = $target.closest("element-item");
      if ($element) {
        if ($element.hasClass("focused")) {
          return false;
        }
        var id = $element.attr("data-id");
        if (e.altKey === false) {
          const item = this.$model.get(id);
          if (item.is("artboard") && item.hasChildren()) {
            this.$config.init("set.dragarea.mode", true);
            return true;
          }
        }
      } else {
        return false;
      }
      return true;
    }
    [sapa.DOUBLECLICK("$view")](e) {
      this.state.doubleClickTime = window.performance.now();
      const $item = sapa.Dom.create(e.target).closest("element-item");
      if ($item) {
        const id = $item.attr("data-id");
        const item = this.$model.get(id);
        if (item.is("text")) {
          const $content = $item.$(".text-content");
          $content.addClass("focused");
          $content.attr("contenteditable", "true");
          $content.focus();
          $content.select();
          this.$context.commands.emit("push.mode.view", "TextEditorView");
        } else {
          this.$context.commands.emit("doubleclick.item", e, id);
        }
      }
    }
    [sapa.CONTEXTMENU("$view") + sapa.PREVENT](e) {
      const $target = sapa.Dom.create(e.target);
      const $element = $target.closest("element-item");
      var id = $element && $element.attr("data-id");
      this.$context.selection.select(id);
      this.emit(OPEN_CONTEXT_MENU, {
        target: "context.menu.layer",
        items: [
          "-",
          {
            type: "button",
            checked: true,
            title: "yellow",
            action: () => {
              console.log("console.log", "yellow");
            }
          }
        ],
        x: e.clientX,
        y: e.clientY,
        id
      });
    }
    [sapa.POINTERSTART("$view") + sapa.IF("checkEditMode") + MOVE("calculateMovedElement") + FIRSTMOVE("calculateFirstMovedElement") + END("calculateEndedElement")](e) {
      this.initMousePoint = this.$viewport.getWorldPosition(e);
      this.$config.init("set.move.control.point", true);
      this.$config.set("editing.mode.itemType", "select");
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("startDragAreaView");
        return;
      }
      let isInSelectedArea = this.$context.selection.hasPoint(this.initMousePoint);
      const $target = sapa.Dom.create(e.target);
      if ($target.hasClass("canvas-view")) {
        this.$context.selection.select();
        this.initializeDragSelection();
        return false;
      }
      const $element = $target.closest("element-item");
      var id = $element && $element.attr("data-id");
      if (e.altKey) {
        if (isInSelectedArea)
          ;
        else {
          if (this.$context.selection.check({ id }) === false) {
            this.$context.selection.selectByGroup(id);
          }
        }
        if (this.$context.selection.isEmpty === false) {
          this.$commands.emit("history.copyLayer", "copy");
          this.emit("refreshLayerTreeView");
          this.initializeDragSelection();
        }
      } else {
        if (isInSelectedArea)
          ;
        else {
          if (e.shiftKey) {
            this.$context.selection.toggleById(id);
          } else {
            if (this.$context.selection.check({ id }) === false) {
              const current = this.$model.get(id);
              if (current && current.is("artboard") && current.hasChildren())
                ;
              else if (current.hasChildren()) {
                this.$context.selection.selectByGroup(id);
              } else {
                this.$context.selection.selectByGroup(id);
              }
            }
          }
        }
        this.initializeDragSelection();
      }
    }
    initializeDragSelection() {
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
      this.emit("startGhostToolView");
    }
    calculateFirstMovedElement() {
      this.emit("hideSelectionToolView");
      this.emit("moveFirstGhostToolView");
    }
    calculateMovedElement() {
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("moveDragAreaView");
        return;
      }
      const targetMousePoint = this.$viewport.getWorldPosition();
      this.emit("moveGhostToolView");
      if (this.$context.selection.isLayoutItem) {
        return;
      }
      const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
      this.moveTo(newDist);
      if (this.$context.selection.changeInLayoutArea(this.$viewport.applyVertexInverse(targetMousePoint))) {
        this.initMousePoint = targetMousePoint;
        this.$context.selection.reselect();
        this.$context.snapManager.clear();
        this.refreshAllCanvas();
        this.emit("refreshLayerTreeView");
      }
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
    }
    moveTo(dist2) {
      const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
        return add([], v, dist2);
      }), 3 / this.$viewport.scale);
      const localDist = add([], snap.dist, dist2);
      const result = {};
      this.$context.selection.cachedItemMatrices.forEach((it) => {
        const oldVertex = it.verties[4];
        const newVertex = add([], oldVertex, localDist);
        const newDist = subtract([], transformMat4([], newVertex, it.parentMatrixInverse), transformMat4([], oldVertex, it.parentMatrixInverse));
        if (this.$context.selection.isOne) {
          result[it.id] = {
            x: Math.round(it.x + newDist[0]),
            y: Math.round(it.y + newDist[1])
          };
        } else {
          result[it.id] = {
            x: it.x + newDist[0],
            y: it.y + newDist[1]
          };
        }
      });
      this.$context.selection.reset(result);
    }
    calculateEndedElement(dx, dy) {
      if (this.state.hasDoubleClick) {
        this.state.doubleClickTime = window.performance.now();
        return;
      }
      const targetMousePoint = this.$viewport.getWorldPosition();
      const newDist = dist(targetMousePoint, this.initMousePoint);
      this.$config.init("set.move.control.point", false);
      const hasMoved = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;
      this.emit("endGhostToolView", hasMoved);
      if (this.$config.get("set.dragarea.mode")) {
        this.emit("endDragAreaView");
        this.$config.init("set.dragarea.mode", false);
        return;
      }
      if (newDist < 1)
        ;
      else {
        this.$context.selection.reselect();
        this.$context.snapManager.clear();
        this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
        this.nextTick(() => {
          this.$commands.emit("recoverBooleanPath");
        });
      }
      this.$config.set("editing.mode.itemType", "select");
      this.$commands.emit("history.refreshSelection");
      this.emit(REFRESH_SELECTION_TOOL);
    }
    refreshSelectionStyleView(obj2) {
      let target = [];
      if (obj2) {
        if (sapa.isArray(obj2)) {
          target = obj2;
        } else {
          target = [obj2];
        }
      } else {
        target = this.$context.selection.items;
      }
      target.forEach((current) => {
        this.updateElement(current);
      });
    }
    updateElement(item) {
      if (item) {
        this.renderer.update(item, this.getElement(item.id), this.$editor);
      }
    }
    updateTimelineElement(item) {
      if (item) {
        this.renderer.update(item, this.getElement(item.id), this.$editor);
      }
    }
    refreshAllCanvas() {
      this.clearElementAll();
      const project2 = this.$context.selection.currentProject;
      const html = this.renderer.render(project2, null, this.$editor) || "";
      this.refs.$view.updateDiff(html, void 0, {
        checkPassed: (oldEl, newEl) => {
          const isPassed = oldEl.getAttribute("data-id") === newEl.getAttribute("data-id");
          return isPassed;
        }
      });
      this.updateAllCanvas(project2);
    }
    updateAllCanvas(parentLayer) {
      parentLayer == null ? void 0 : parentLayer.layers.forEach((item) => {
        this.updateElement(item, this.getElement(item.id));
        this.updateAllCanvas(item);
      });
    }
    refreshAllElementBoundSize() {
      var selectionList = this.$context.selection.items.map((it) => {
        if (it.is("artboard")) {
          return it;
        }
        return it.parent;
      });
      var list = [...new Set(selectionList)];
      if (list.length) {
        list.forEach((it) => {
          this.refreshElementBoundSize(it);
        });
      } else {
        this.$context.selection.currentProject.artboards.forEach((it) => {
          this.refreshElementBoundSize(it);
        });
      }
    }
    refreshElementRect(item) {
      var $el = this.getElement(item.id);
      if (!$el)
        return;
      let offset = $el.offsetRect();
      if (offset.width === 0 || offset.height === 0) {
        return;
      }
      item.reset(offset);
      this.refreshSelectionStyleView(item);
      if (this.$context.selection.check(item)) {
        this.emit(REFRESH_SELECTION_TOOL);
      }
    }
    refreshElementBoundSize(it) {
      if (it) {
        this.refreshElementRect(it);
        it.layers.forEach((child) => {
          this.refreshElementBoundSize(child);
        });
      }
    }
  }
  class CanvasView extends editor.EditorElement {
    components() {
      return {
        PageTools,
        DragAreaRectView,
        HTMLRenderView,
        DragAreaView
      };
    }
    initState() {
      return {
        cursor: "auto",
        cursorArgs: []
      };
    }
    afterRender() {
      this.nextTick(() => {
        this.refreshCanvasSize();
        this.$commands.emit("moveSelectionToCenter", true);
        this.refreshCursor();
      });
    }
    template() {
      return /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "elf--page-container",
        tabIndex: "-1",
        ref: "$container"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "page-view",
        ref: "$pageView"
      }, /* @__PURE__ */ sapa.createElementJsx("div", {
        class: "page-lock scrollbar",
        ref: "$lock"
      }, /* @__PURE__ */ sapa.createElementJsx(DragAreaView, {
        ref: "$dragArea"
      }), /* @__PURE__ */ sapa.createElementJsx(HTMLRenderView, {
        ref: "$htmlRenderView"
      }), /* @__PURE__ */ sapa.createElementJsx(DragAreaRectView, {
        ref: "$dragAreaRectView"
      }), this.$injectManager.generate("canvas.view", true))), sapa.createComponent("PageTools", { ref: "pageTools" }));
    }
    [sapa.BIND("$pageView")]() {
      return {
        style: {
          "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
        }
      };
    }
    checkSpace() {
      if (this.$config.is("editing.mode", EditingMode.HAND)) {
        return true;
      }
      return this.$context.keyboardManager.check(this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space));
    }
    [sapa.POINTERSTART("$lock") + sapa.IF("checkSpace") + MOVE("movePan") + END("moveEndPan")]() {
      this.startMovePan();
    }
    [sapa.CONFIG("editing.mode")]() {
      if (this.$config.is("editing.mode", EditingMode.HAND)) {
        this.startMovePan();
        this.$commands.emit("refreshCursor", "grab");
      } else {
        this.$commands.emit("recoverCursor", "auto");
      }
    }
    startMovePan() {
      this.lastDist = create$3();
    }
    movePan(dx, dy) {
      this.$commands.emit("refreshCursor", "grabbing");
      const currentDist = fromValues(dx, dy, 0);
      this.$viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$viewport.scaleMatrixInverse));
      this.lastDist = currentDist;
    }
    refreshCursor() {
      if (this.$config.is("editing.mode", EditingMode.HAND)) {
        this.$commands.emit("refreshCursor", "grab");
      } else {
        this.$commands.emit("refreshCursor", "auto");
      }
    }
    moveEndPan() {
      this.refreshCursor();
    }
    [sapa.DRAGOVER("$lock") + sapa.PREVENT]() {
    }
    [sapa.DROP("$lock") + sapa.PREVENT](e) {
      const newCenter = this.$viewport.getWorldPosition(e);
      if (e.dataTransfer.getData("text/asset")) {
        this.$commands.emit("drop.asset", {
          asset: { id: e.dataTransfer.getData("text/asset"), center: newCenter }
        });
      } else {
        const id = sapa.Dom.create(e.target).attr("data-id");
        if (id) {
          this.$commands.emit("drop.asset", {
            gradient: e.dataTransfer.getData("text/gradient"),
            pattern: e.dataTransfer.getData("text/pattern"),
            color: e.dataTransfer.getData("text/color"),
            imageUrl: e.dataTransfer.getData("image/info")
          }, id);
        } else {
          const imageUrl = e.dataTransfer.getData("image/info");
          this.$commands.emit("dropImageUrl", imageUrl);
        }
      }
    }
    [sapa.WHEEL("$lock") + sapa.PREVENT](e) {
      const [dx, dy] = sapa.normalizeWheelEvent(e);
      if (!this.state.gesture) {
        if (e.ctrlKey) {
          this.$viewport.setMousePoint(e.clientX, e.clientY);
        }
        this.emit("startGesture");
        this.state.gesture = true;
      } else {
        if (e.ctrlKey) {
          const zoomFactor = 1 - 2.5 * dy / 100;
          this.$viewport.zoom(zoomFactor);
        } else {
          const newDx = -2.5 * dx;
          const newDy = -2.5 * dy;
          this.$viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
        }
      }
      window.clearTimeout(this.state.timer);
      this.state.timer = window.setTimeout(() => {
        this.state.gesture = void 0;
        this.emit("endGesture");
      }, 200);
    }
    refreshCanvasSize() {
      this.$viewport.refreshCanvasSize(this.refs.$lock.rect());
    }
    [sapa.SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
      this.refreshCanvasSize();
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT)]() {
      this.$commands.emit("refreshCursor", "auto");
    }
  }
  var HorizontalRuler$1 = "";
  let pathString$1 = [];
  class HorizontalRuler extends editor.EditorElement {
    template() {
      return `
            <div class="elf--horizontal-ruler">
                <div class='horizontal-ruler-container' ref='$layerRuler'>
                    <svg class="lines" width="100%" width="100%" overflow="hidden">
                        <path ref="$rulerLines" d="" />
                    </svg>
                </div>                            
                <div class='horizontal-ruler-container' ref='$ruler'></div>
                <div class='horizontal-ruler-container' ref='$lines'></div>
                <div class='horizontal-ruler-container'>
                    <div class="cursor" ref="$cursor"></div>
                </div>
            </div>
        `;
    }
    afterRender() {
      this.refreshCanvasSize();
    }
    refreshCanvasSize() {
      this.state.rect = this.$el.rect();
    }
    initializeRect() {
      if (!this.state.rect || this.state.rect.width == 0) {
        this.state.rect = this.$el.rect();
      }
    }
    makeLine(pathString2, baseNumber, minX, maxX, realWidth, width2, epsilon = 3, lineWidth = 30, expect = 10) {
      let startX = minX - minX % baseNumber;
      let endX = maxX + maxX % baseNumber;
      const firstX = (startX - minX) / realWidth * width2;
      const secondX = (startX + baseNumber - minX) / realWidth * width2;
      if (Math.abs(secondX - firstX) < epsilon)
        return;
      for (var i = startX; i < endX; i += baseNumber) {
        if (i != 0 && i % expect === 0)
          continue;
        const x = Math.floor((i - minX) / realWidth * width2);
        pathString2[pathString2.length] = `M ${x} ${30 - lineWidth} L ${x} 30 `;
      }
    }
    makeLineText(baseNumber, minX, maxX, realWidth, width2, epsilon = 3) {
      const text2 = [];
      let startX = minX - minX % baseNumber;
      let endX = maxX + maxX % baseNumber;
      const firstX = (startX - minX) / realWidth * width2;
      const secondX = (startX + baseNumber - minX) / realWidth * width2;
      if (Math.abs(secondX - firstX) < epsilon)
        return;
      for (var i = startX; i < endX; i += baseNumber) {
        const x = Math.floor((i - minX) / realWidth * width2);
        text2[text2.length] = `<text x="${x}" y="${0}" dx="0" dy="6" text-anchor="middle" alignment-baseline="bottom" >${i}</text>`;
      }
      return text2.join("");
    }
    makeRulerForCurrentArtboard() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const currentArtboard = current.artboard;
      if (!currentArtboard)
        return "";
      const verties = currentArtboard.verties;
      const { minX, width: realWidth } = this.$viewport;
      const width2 = this.state.rect.width;
      const firstX = (verties[0][0] - minX) / realWidth * width2;
      const secondX = (verties[2][0] - minX) / realWidth * width2;
      return `
            M ${firstX} 20 
            L ${firstX} 30 
            L ${secondX} 30 
            L ${secondX} 20 
            Z
        `;
    }
    makeRulerForCurrent() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const verties = this.$context.selection.verties;
      const xList = verties.map((it) => it[0]);
      const currentMinX = Math.min.apply(Math, xList);
      const currentMaxX = Math.max.apply(Math, xList);
      const { minX, width: realWidth } = this.$viewport;
      const width2 = this.state.rect.width;
      const firstX = (currentMinX - minX) / realWidth * width2;
      const secondX = (currentMaxX - minX) / realWidth * width2;
      return `
            M ${firstX} 0 
            L ${firstX} 20 
            L ${secondX} 20 
            L ${secondX} 0 
            Z
        `;
    }
    makeRuler() {
      const { minX, maxX, width: realWidth } = this.$viewport;
      const width2 = this.state.rect.width;
      pathString$1 = [];
      this.makeLine(pathString$1, 1e3, minX, maxX, realWidth, width2, 10, 24, 1e4);
      this.makeLine(pathString$1, 200, minX, maxX, realWidth, width2, 10, 20, 5e3);
      this.makeLine(pathString$1, 100, minX, maxX, realWidth, width2, 10, 20, 200);
      this.makeLine(pathString$1, 50, minX, maxX, realWidth, width2, 10, 20, 100);
      this.makeLine(pathString$1, 10, minX, maxX, realWidth, width2, 10, 18, 50);
      this.makeLine(pathString$1, 5, minX, maxX, realWidth, width2, 10, 15, 10);
      this.makeLine(pathString$1, 1, minX, maxX, realWidth, width2, 10, 13, 10);
      return pathString$1.join("");
    }
    makeRulerText() {
      const { minX, maxX, width: realWidth } = this.$viewport;
      const width2 = this.state.rect.width;
      const dist2 = Math.abs(maxX - minX);
      return [
        dist2 > 3e3 ? this.makeLineText(3e3, minX, maxX, realWidth, width2, 24) : "",
        2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minX, maxX, realWidth, width2, 22) : "",
        1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
        800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
        500 < dist2 && dist2 < 800 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
        500 < dist2 && dist2 < 800 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
        200 < dist2 && dist2 < 500 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
        50 < dist2 && dist2 < 200 ? this.makeLineText(10, minX, maxX, realWidth, width2, 20) : "",
        15 < dist2 && dist2 < 50 ? this.makeLineText(5, minX, maxX, realWidth, width2, 20) : "",
        0 < dist2 && dist2 < 15 ? this.makeLineText(1, minX, maxX, realWidth, width2, 20) : ""
      ].join("");
    }
    [sapa.LOAD("$ruler") + sapa.DOMDIFF]() {
      this.initializeRect();
      return `<svg width="100%" width="100%" overflow="hidden"><path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0.5, -3)" />${this.makeRulerText()}</svg>`;
    }
    [sapa.LOAD("$lines") + sapa.DOMDIFF]() {
      this.initializeRect();
      const lines = this.$config.get("horizontal.line").map((it) => {
        const pos = this.$viewport.applyVertex([it, 0, 0]);
        return `<path d="M ${pos[0]} 0 L ${pos[0]} 30"  transform="translate(0.5, 0)" />`;
      }).join("");
      return `<svg width="100%" height="100%" class="horizontal-line" overflow="hidden">${lines}</svg>`;
    }
    [sapa.BIND("$rulerLines")]() {
      return {
        d: this.makeRulerForCurrent()
      };
    }
    makeRulerCursor() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const { minX, width: realWidth } = this.$viewport;
      this.initializeRect();
      const width2 = this.state.rect.width;
      const distX = targetMousePoint[0] - minX;
      const x = distX === 0 ? 0 : distX / realWidth * width2;
      return `M ${x - 0.5} 0 L ${x - 0.5} 20`;
    }
    [sapa.BIND("$cursor")]() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const { minX, width: realWidth } = this.$viewport;
      this.initializeRect();
      const width2 = this.state.rect.width;
      const distX = targetMousePoint[0] - minX;
      const x = distX === 0 ? 0 : distX / realWidth * width2;
      return {
        cssText: `
                --elf--horizontal-cursor-position: ${x}px;
            `
      };
    }
    [sapa.MOUSEOVER()]() {
      this.$commands.emit("refreshCursor", "ns-resize");
    }
    [sapa.POINTERSTART() + MOVE() + END()]() {
      const pos = round$1([], this.$viewport.getWorldPosition());
      this.startIndex = this.$config.push("vertical.line", pos[1]);
      this.$config.init("vertical.line.selected.index", this.startIndex);
      this.$context.snapManager.clear();
    }
    move() {
      const newPos = this.$context.snapManager.getWorldPosition();
      if (this.$viewport.minY < newPos[1] && newPos[1] < this.$viewport.maxY) {
        this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
      }
    }
    end() {
      const pos = round$1([], this.$viewport.getWorldPosition());
      if (this.$viewport.minY < pos[1] && pos[1] < this.$viewport.maxY)
        ;
      else {
        this.$config.removeIndex("vertical.line", this.startIndex);
      }
      this.startIndex = null;
      this.$commands.emit("recoverCursor");
    }
    refresh() {
      if (this.$config.get("show.ruler")) {
        this.load();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.THROTTLE(10)]() {
      if (this.$context.selection.current) {
        const current = this.$context.selection.current;
        if (current.changedRect) {
          this.refresh();
        }
      }
    }
    [sapa.SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
      this.refreshCanvasSize();
    }
    [sapa.CONFIG("onMouseMovepageContainer")]() {
      this.bindData("$cursor");
      this.bindData("$rulerLines");
    }
    [sapa.CONFIG("horizontal.line")]() {
      this.load("$lines");
    }
  }
  var PageSubEditor$1 = "";
  class PageSubEditor extends editor.EditorElement {
    template() {
      return `
      <div class='elf--page-subeditor'>
        ${this.$injectManager.generate("page.subeditor.view")}         
      </div>
    `;
    }
  }
  var VerticalRuler$1 = "";
  let pathString = [];
  class VerticalRuler extends editor.EditorElement {
    template() {
      return `
          <div class="elf--vertical-ruler">
            <div class='vertical-ruler-container' ref='$layerRuler'>
                <svg class="lines" width="100%" height="100%" overflow="hidden">
                    <path ref="$rulerLines" d=""/>
                </svg>
            </div>                                        
            <div class='vertical-ruler-container' ref='$body'></div>
            <div class='vertical-ruler-container' ref='$lines'></div>            
            <div class='vertical-ruler-container'>
                <div class="cursor" ref="$cursor"></div>
            </div>                
          </div>
        `;
    }
    afterRender() {
      this.refreshCanvasSize();
    }
    refreshCanvasSize() {
      this.state.rect = this.$el.rect();
    }
    initializeRect() {
      if (!this.state.rect || this.state.rect.width == 0) {
        this.state.rect = this.$el.rect();
      }
    }
    [sapa.MOUSEOVER()]() {
      this.$commands.emit("refreshCursor", "ew-resize");
    }
    [sapa.MOUSELEAVE()]() {
      this.$commands.emit("recoverCursor");
    }
    [sapa.POINTERSTART() + MOVE() + END()]() {
      const pos = round$1([], this.$viewport.getWorldPosition());
      this.startIndex = this.$config.push("horizontal.line", pos[0]);
      this.$config.init("horizontal.line.selected.index", this.startIndex);
      this.$context.snapManager.clear();
    }
    move() {
      const newPos = this.$context.snapManager.getWorldPosition();
      if (this.$viewport.minX < newPos[0] && newPos[0] < this.$viewport.maxX) {
        this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
      }
    }
    end() {
      const pos = round$1([], this.$viewport.getWorldPosition());
      if (this.$viewport.minX < pos[0] && pos[0] < this.$viewport.maxX)
        ;
      else {
        this.$config.removeIndex("horizontal.line", this.startIndex);
      }
      this.startIndex = null;
      this.$commands.emit("recoverCursor");
    }
    makeLine(pathString2, baseNumber, minY, maxY, realHeight, height, epsilon = 3, lineWidth = 30, expect = 10) {
      let startY = minY - minY % baseNumber;
      let endY = maxY + maxY % baseNumber;
      const firstY = (startY - minY) / realHeight * height;
      const secondY = (startY + baseNumber - minY) / realHeight * height;
      if (Math.abs(secondY - firstY) < epsilon)
        return;
      for (var i = startY; i < endY; i += baseNumber) {
        if (i != 0 && i % expect === 0)
          continue;
        const y = Math.floor((i - minY) / realHeight * height);
        pathString2[pathString2.length] = `M ${30 - lineWidth} ${y} L 30 ${y}`;
      }
    }
    makeLineText(baseNumber, minY, maxY, realHeight, height, epsilon = 3) {
      const text2 = [];
      let startY = minY - minY % baseNumber;
      let endY = maxY + maxY % baseNumber;
      const firstY = (startY - minY) / realHeight * height;
      const secondY = (startY + baseNumber - minY) / realHeight * height;
      if (Math.abs(secondY - firstY) < epsilon)
        return;
      for (var i = startY; i < endY; i += baseNumber) {
        const y = Math.floor((i - minY) / realHeight * height);
        text2[text2.length] = `<text x="${0}" y="${y}" dy="4" dominant-baseline="central" transform="rotate(-90, 1, ${y})">${i}</text>`;
      }
      return text2.join("");
    }
    makeRulerForCurrentArtboard() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const currentArtboard = current.artboard;
      if (!currentArtboard)
        return "";
      const verties = currentArtboard.verties;
      const { minY, height: realHeight } = this.$viewport;
      const height = this.state.rect.height;
      const firstY = (verties[0][1] - minY) / realHeight * height;
      const secondY = (verties[2][1] - minY) / realHeight * height;
      return `
            M 20 ${firstY}
            L 30 ${firstY}
            L 30 ${secondY}
            L 20 ${secondY}
            Z
        `;
    }
    makeRulerForCurrent() {
      const current = this.$context.selection.current;
      if (!current)
        return "";
      const { minY, height: realHeight } = this.$viewport;
      const height = this.state.rect.height;
      const verties = this.$context.selection.verties;
      const yList = verties.map((it) => it[1]);
      const currentMinY = Math.min.apply(Math, yList);
      const currentMaxY = Math.max.apply(Math, yList);
      const firstY = (currentMinY - minY) / realHeight * height;
      const secondY = (currentMaxY - minY) / realHeight * height;
      return `
            M 0 ${firstY}
            L 20 ${firstY}
            L 20 ${secondY}
            L 0 ${secondY}
            Z
        `;
    }
    makeRuler() {
      const { minY, maxY, height: realHeight } = this.$viewport;
      const height = this.state.rect.height;
      pathString = [];
      this.makeLine(pathString, 1e3, minY, maxY, realHeight, height, 10, 20, 1e4);
      this.makeLine(pathString, 200, minY, maxY, realHeight, height, 10, 16, 5e3);
      this.makeLine(pathString, 100, minY, maxY, realHeight, height, 10, 18, 200);
      this.makeLine(pathString, 50, minY, maxY, realHeight, height, 10, 18, 100);
      this.makeLine(pathString, 10, minY, maxY, realHeight, height, 10, 18, 50);
      this.makeLine(pathString, 5, minY, maxY, realHeight, height, 10, 15, 10);
      this.makeLine(pathString, 1, minY, maxY, realHeight, height, 10, 14, 5);
      return pathString.join("");
    }
    makeRulerText() {
      const { minY, maxY, height: realHeight } = this.$viewport;
      const height = this.state.rect.height;
      const dist2 = Math.abs(maxY - minY);
      return [
        dist2 > 3e3 ? this.makeLineText(3e3, minY, maxY, realHeight, height, 24) : "",
        2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minY, maxY, realHeight, height, 22) : "",
        1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minY, maxY, realHeight, height, 20) : "",
        800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minY, maxY, realHeight, height, 20) : "",
        500 < dist2 && dist2 < 800 ? this.makeLineText(100, minY, maxY, realHeight, height, 20) : "",
        500 < dist2 && dist2 < 800 ? this.makeLineText(50, minY, maxY, realHeight, height, 20) : "",
        200 < dist2 && dist2 < 500 ? this.makeLineText(50, minY, maxY, realHeight, height, 20) : "",
        50 < dist2 && dist2 < 200 ? this.makeLineText(10, minY, maxY, realHeight, height, 20) : "",
        15 < dist2 && dist2 < 50 ? this.makeLineText(5, minY, maxY, realHeight, height, 20) : "",
        0 < dist2 && dist2 < 15 ? this.makeLineText(1, minY, maxY, realHeight, height, 20) : ""
      ].join("");
    }
    [sapa.LOAD("$body") + sapa.DOMDIFF]() {
      if (!this.state.rect || this.state.rect.width == 0) {
        this.state.rect = this.$el.rect();
      }
      return `<svg width="100%" height="100%" overflow="hidden"><path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0, 0.5)" />${this.makeRulerText()}</svg>`;
    }
    [sapa.LOAD("$lines") + sapa.DOMDIFF]() {
      this.initializeRect();
      const lines = this.$config.get("vertical.line").map((it) => {
        const pos = this.$viewport.applyVertex([0, it, 0]);
        return `<path d="M 0 ${pos[1]} L 30 ${pos[1]}"  transform="translate(0, 0.5)" />`;
      }).join("");
      return `
            <svg width="100%" height="100%" class="vertical-line" overflow="hidden">${lines}</svg>
        `;
    }
    [sapa.BIND("$rulerLines")]() {
      return {
        d: this.makeRulerForCurrent()
      };
    }
    [sapa.BIND("$cursor")]() {
      const targetMousePoint = this.$viewport.getWorldPosition();
      const { minY, height: realHeight } = this.$viewport;
      this.initializeRect();
      const height = this.state.rect.height;
      const distY = targetMousePoint[1] - minY;
      const y = distY === 0 ? 0 : distY / realHeight * height;
      return {
        cssText: `
                --elf--vertical-cursor-position: ${y}px;
            `
      };
    }
    refresh() {
      if (this.$config.get("show.ruler")) {
        this.load();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_CANVAS) + sapa.THROTTLE(10)]() {
      const current = this.$context.selection.current;
      if (current && current.changedRect) {
        this.refresh();
      }
    }
    [sapa.SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
      this.refreshCanvasSize();
    }
    [sapa.CONFIG("onMouseMovepageContainer")]() {
      this.bindData("$cursor");
      this.bindData("$rulerLines");
    }
    [sapa.CONFIG("vertical.line")]() {
      this.load("$lines");
    }
  }
  var BodyPanel$1 = "";
  class BodyPanel extends editor.EditorElement {
    components() {
      return {
        CanvasView,
        VerticalRuler,
        HorizontalRuler,
        PageSubEditor
      };
    }
    template() {
      return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${sapa.createComponent("PageSubEditor", { ref: "subeditor" })}
        </div>
        <div class='editing-area' ref="$area">
          ${sapa.createComponent("HorizontalRuler", { ref: "hruler" })}
          ${sapa.createComponent("VerticalRuler", { ref: "vruler" })}
          <div class="canvas-layout">
            ${sapa.createComponent("CanvasView", { ref: "canvas" })}
          </div>

        </div>
      </div>
    `;
    }
    [sapa.BIND("$el")]() {
      return {
        class: `elf--body-panel ${this.$config.get("show.ruler") ? "ruler" : ""}`
      };
    }
    [sapa.CONFIG("show.ruler")]() {
      this.refresh();
    }
    [sapa.SUBSCRIBE("bodypanel.toggle.fullscreen")]() {
      this.refs.$el.toggleFullscreen();
    }
    [sapa.CONFIG("editor.cursor")]() {
      this.state.cursor = this.$config.get("editor.cursor");
      this.state.cursorArgs = this.$config.get("editor.cursor.args");
      this.bindData("$area");
    }
    [sapa.CONFIG("editor.cursor.args")]() {
      this.state.cursor = this.$config.get("editor.cursor");
      this.state.cursorArgs = this.$config.get("editor.cursor.args");
      this.bindData("$area");
    }
    async [sapa.BIND("$area")]() {
      const cursor = await this.$context.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
      return {
        style: {
          cursor
        }
      };
    }
  }
  var style = "";
  class DesignEditor extends editor.BlankEditor {
    initialize() {
      super.initialize();
      this.$context.pathkit.load();
    }
    afterRender() {
      super.afterRender();
      this.$commands.emit("load.json", this.opt.data);
      this.$config.init("editor.layout.elements", this.children.$layout.getLayoutElements());
    }
    getManagers() {
      return {
        snapManager: SnapManager,
        selection: SelectionManager,
        segmentSelection: SegmentSelectionManager,
        timeline: TimelineSelectionManager,
        history: HistoryManager,
        modelManager: ModelManager,
        lockManager: LockManager,
        visibleManager: VisibleManager,
        clipboard: ClipboardManager,
        pathkit: PathKitManager
      };
    }
    getPlugins() {
      return [
        ...super.getPlugins(),
        ...designEditorPlugins
      ];
    }
    getBodyPanel() {
      return /* @__PURE__ */ sapa.createElementJsx(editor.DefaultLayoutItem, {
        type: "body"
      }, /* @__PURE__ */ sapa.createElementJsx(BodyPanel, {
        ref: "$bodyPanelView"
      }));
    }
  }
  function createDesignEditor(opts) {
    return sapa.start(DesignEditor, opts);
  }
  exports2.ADD_BODY_FIRST_MOUSEMOVE = ADD_BODY_FIRST_MOUSEMOVE;
  exports2.ADD_BODY_MOUSEMOVE = ADD_BODY_MOUSEMOVE;
  exports2.ADD_BODY_MOUSEUP = ADD_BODY_MOUSEUP;
  exports2.AlignContent = AlignContent;
  exports2.AlignItems = AlignItems;
  exports2.AssetParser = AssetParser;
  exports2.BlendMode = BlendMode;
  exports2.BooleanOperation = BooleanOperation;
  exports2.BorderStyle = BorderStyle;
  exports2.BoxShadowStyle = BoxShadowStyle;
  exports2.CanvasViewToolLevel = CanvasViewToolLevel;
  exports2.ClipPathType = ClipPathType;
  exports2.ClipboardActionType = ClipboardActionType;
  exports2.ClipboardType = ClipboardType;
  exports2.Component = Component;
  exports2.Constraints = Constraints;
  exports2.ConstraintsDirection = ConstraintsDirection;
  exports2.DesignEditor = DesignEditor;
  exports2.DesignMode = DesignMode;
  exports2.DirectionNumberType = DirectionNumberType;
  exports2.DirectionType = DirectionType;
  exports2.END = END;
  exports2.END_GUESTURE = END_GUESTURE;
  exports2.EditingMode = EditingMode;
  exports2.FIRSTMOVE = FIRSTMOVE;
  exports2.FlexDirection = FlexDirection;
  exports2.FlexWrap = FlexWrap;
  exports2.FuncType = FuncType;
  exports2.GradientType = GradientType;
  exports2.IntersectEpsilonNumberType = IntersectEpsilonNumberType;
  exports2.JustifyContent = JustifyContent;
  exports2.KEYMAP_KEYDOWN = KEYMAP_KEYDOWN;
  exports2.KEYMAP_KEYUP = KEYMAP_KEYUP;
  exports2.KEY_CODE = KEY_CODE;
  exports2.KeyStringMaker = KeyStringMaker;
  exports2.Language = Language;
  exports2.Layout = Layout;
  exports2.MOVE = MOVE;
  exports2.MenuItemType = MenuItemType;
  exports2.NotifyType = NotifyType;
  exports2.OPEN_CONTEXT_MENU = OPEN_CONTEXT_MENU;
  exports2.Overflow = Overflow;
  exports2.POP_MODE_VIEW = POP_MODE_VIEW;
  exports2.PUSH_MODE_VIEW = PUSH_MODE_VIEW;
  exports2.PathGenerator = PathGenerator;
  exports2.PathParser = PathParser;
  exports2.PathSegmentType = PathSegmentType;
  exports2.PathStringManager = PathStringManager;
  exports2.Point = Point;
  exports2.PolygonParser = PolygonParser;
  exports2.REFRESH_CONTENT = REFRESH_CONTENT;
  exports2.REFRESH_SELECTION = REFRESH_SELECTION;
  exports2.REFRESH_SELECTION_TOOL = REFRESH_SELECTION_TOOL;
  exports2.RESIZE_CANVAS = RESIZE_CANVAS;
  exports2.RESIZE_WINDOW = RESIZE_WINDOW;
  exports2.RadialGradientSizeType = RadialGradientSizeType;
  exports2.RadialGradientType = RadialGradientType;
  exports2.ResizingMode = ResizingMode;
  exports2.SET_LOCALE = SET_LOCALE;
  exports2.SHOW_COMPONENT_POPUP = SHOW_COMPONENT_POPUP;
  exports2.SHOW_NOTIFY = SHOW_NOTIFY;
  exports2.START_GUESTURE = START_GUESTURE;
  exports2.SegmentManager = SegmentManager;
  exports2.SpreadMethodType = SpreadMethodType;
  exports2.StrokeLineCap = StrokeLineCap;
  exports2.StrokeLineJoin = StrokeLineJoin;
  exports2.TOGGLE_FULLSCREEN = TOGGLE_FULLSCREEN;
  exports2.TargetActionType = TargetActionType;
  exports2.TextAlign = TextAlign;
  exports2.TextClip = TextClip;
  exports2.TextDecoration = TextDecoration;
  exports2.TextTransform = TextTransform;
  exports2.TimingFunction = TimingFunction;
  exports2.TransformValue = TransformValue;
  exports2.UPDATE_CANVAS = UPDATE_CANVAS;
  exports2.UPDATE_VIEWPORT = UPDATE_VIEWPORT;
  exports2.ViewModeType = ViewModeType;
  exports2.VisibilityType = VisibilityType;
  exports2.createDesignEditor = createDesignEditor;
  Object.keys(sapa).forEach(function(k) {
    if (k !== "default" && !exports2.hasOwnProperty(k))
      Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return sapa[k];
        }
      });
  });
  Object.keys(editor).forEach(function(k) {
    if (k !== "default" && !exports2.hasOwnProperty(k))
      Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return editor[k];
        }
      });
  });
  Object.keys(Color).forEach(function(k) {
    if (k !== "default" && !exports2.hasOwnProperty(k))
      Object.defineProperty(exports2, k, {
        enumerable: true,
        get: function() {
          return Color[k];
        }
      });
  });
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
